#!/usr/bin/env python3
"""
Script for monitoring workflow runs queued in GitHub Actions.
Sends notifications to Telegram when stuck jobs are detected.
"""

import requests
import json
import os
import sys
import argparse
import subprocess
from collections import Counter, defaultdict
from typing import Dict, List, Any
from datetime import datetime, timezone
import time

def get_alert_logins() -> str:
    """
    Gets the list of logins for notifications from GH_ALERTS_TG_LOGINS environment variable.
    
    Returns:
        String with logins separated by spaces, or default login
    """
    logins = os.getenv('GH_ALERTS_TG_LOGINS')
    return logins.strip() if logins else "@KirLynx"

def get_tail_message() -> str:
    """
    Generates TAIL_MESSAGE with dynamic logins.
    
    Returns:
        String with tail message
    """
    logins = get_alert_logins()
    return f"üìä [Dashboard details](https://datalens.yandex/wkptiaeyxz7qj?tab=ka)\n\nFYI: {logins}"

# Constants
TAIL_MESSAGE = get_tail_message()

# Filtering settings
MAX_AGE_DAYS = 3  # Maximum job age in days (excludes GitHub bugs)

# Message sending settings
SEND_WHEN_ALL_GOOD = False  # Whether to send a message when all jobs are working fine

# Criteria for determining stuck jobs
# Each element: [pattern, threshold_hours, display_name]
WORKFLOW_THRESHOLDS = [
    ["PR-check", 0.5, "PR-check"],
    ["Postcommit", 3, "Postcommit"],
    # Example of adding a new type:
    # ["Nightly", 12, "Nightly-Build"]
]

def fetch_workflow_runs(status: str = "queued", per_page: int = 1000, page: int = 1) -> tuple[Dict[str, Any], str]:
    """
    Fetches workflow runs data from GitHub API.
    
    Args:
        status: Status of workflow runs (queued, in_progress, completed, etc.)
        per_page: Number of records per page
        page: Page number
    
    Returns:
        Tuple (data, error). If successful - (data, ""), if error - ({}, error_message)
    """
    url = "https://api.github.com/repos/ydb-platform/ydb/actions/runs"
    params = {
        "per_page": per_page,
        "page": page,
        "status": status
    }
    
    try:
        response = requests.get(url, params=params, timeout=30)
        
        if response.status_code == 200:
            return response.json(), ""
        else:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É –∫–∞–∫ –µ—Å—Ç—å –æ—Ç API
            try:
                error_data = response.json()
                error_message = error_data.get("message", f"HTTP {response.status_code}")
            except:
                error_message = f"HTTP {response.status_code}: {response.text}"
            
            return {}, error_message
            
    except requests.exceptions.Timeout:
        return {}, "Timeout: –ó–∞–ø—Ä–æ—Å –ø—Ä–µ–≤—ã—Å–∏–ª –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è (30 —Å–µ–∫)"
    except requests.exceptions.ConnectionError:
        return {}, "Connection error: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ API"
    except requests.exceptions.RequestException as e:
        return {}, f"Request error: {e}"
    except Exception as e:
        return {}, f"Unexpected error: {e}"

def get_effective_start_time(run: Dict[str, Any]) -> datetime:
    """
    Gets the effective start time for run (accounts for retry).
    
    Args:
        run: Workflow run object
    
    Returns:
        datetime: Effective start time
    """
    run_attempt = run.get('run_attempt', 1)
    run_started_at_str = run.get('run_started_at')
    updated_at_str = run.get('updated_at')
    created_at_str = run.get('created_at')
    
    # –î–ª—è retry jobs –∏—Å–ø–æ–ª—å–∑—É–µ–º updated_at (–≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞)
    # —Ç–∞–∫ –∫–∞–∫ API —Å status=queued –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ queued jobs
    if run_attempt > 1 and updated_at_str:
        try:
            return datetime.fromisoformat(updated_at_str.replace('Z', '+00:00'))
        except ValueError:
            pass
    
    # –î–ª—è –ø–µ—Ä–≤–æ–π –ø–æ–ø—ã—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º created_at
    if created_at_str:
        try:
            return datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))
        except ValueError:
            pass
    
    # Fallback - —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
    return datetime.now(timezone.utc)

def is_retry_job(run: Dict[str, Any]) -> bool:
    """
    Determines if the job is a retry.
    
    Args:
        run: Workflow run object
    
    Returns:
        bool: True if this is a retry job
    """
    return run.get('run_attempt', 1) > 1

def analyze_queued_workflows(workflow_runs: List[Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    """
    Analyzes workflow runs in queue and finds the oldest job for each type.
    
    Args:
        workflow_runs: List of workflow runs from API
    
    Returns:
        Dictionary with information about each workflow type
    """
    workflow_info = defaultdict(lambda: {
        'count': 0,
        'oldest_created_at': None,
        'oldest_run_id': None,
        'runs': []
    })
    
    current_time = datetime.now(timezone.utc)
    
    for run in workflow_runs:
        workflow_name = run.get('name', 'Unknown')
        run_id = run.get('id')
        
        workflow_info[workflow_name]['count'] += 1
        workflow_info[workflow_name]['runs'].append(run)
        
        # –ü–æ–ª—É—á–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ (—É—á–∏—Ç—ã–≤–∞–µ—Ç retry)
        effective_start_time = get_effective_start_time(run)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ—Ç run —Å–∞–º—ã–º —Å—Ç–∞—Ä—ã–º
        if (workflow_info[workflow_name]['oldest_created_at'] is None or 
            effective_start_time < workflow_info[workflow_name]['oldest_created_at']):
            workflow_info[workflow_name]['oldest_created_at'] = effective_start_time
            workflow_info[workflow_name]['oldest_run_id'] = run_id
    
    return dict(workflow_info)

def format_time_ago(created_at: datetime) -> str:
    """
    Formats time into a human-readable format "X minutes/hours/days ago".
    
    Args:
        created_at: Creation time
    
    Returns:
        String with time description
    """
    if created_at is None:
        return "Unknown"
    
    current_time = datetime.now(timezone.utc)
    time_diff = current_time - created_at
    
    total_seconds = time_diff.total_seconds()
    
    if total_seconds < 60:
        return f"{int(total_seconds)}s"
    elif total_seconds < 3600:
        minutes = total_seconds / 60
        return f"{minutes:.1f}m"
    elif total_seconds < 86400:
        hours = total_seconds / 3600
        return f"{hours:.1f}h"
    else:
        days = total_seconds / 86400
        return f"{days:.1f}d"

def filter_old_jobs(workflow_runs: List[Dict[str, Any]], max_age_days: int = None) -> List[Dict[str, Any]]:
    """
    Filters jobs older than max_age_days (excludes GitHub bugs).
    
    Args:
        workflow_runs: List of workflow runs in queue
        max_age_days: Maximum age in days (defaults to MAX_AGE_DAYS)
    
    Returns:
        Filtered list of workflow runs
    """
    if max_age_days is None:
        max_age_days = MAX_AGE_DAYS
    current_time = datetime.now(timezone.utc)
    max_age_seconds = max_age_days * 24 * 3600
    filtered_runs = []
    excluded_count = 0
    
    for run in workflow_runs:
        created_at_str = run.get('created_at')
        if created_at_str:
            try:
                created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))
                time_diff = current_time - created_at
                
                if time_diff.total_seconds() <= max_age_seconds:
                    filtered_runs.append(run)
                else:
                    excluded_count += 1
            except ValueError:
                # –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –≤—Ä–µ–º—è, –≤–∫–ª—é—á–∞–µ–º –≤ –æ—Ç—á–µ—Ç
                filtered_runs.append(run)
        else:
            # –ï—Å–ª–∏ –Ω–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ —Å–æ–∑–¥–∞–Ω–∏—è, –≤–∫–ª—é—á–∞–µ–º –≤ –æ—Ç—á–µ—Ç
            filtered_runs.append(run)
    
    if excluded_count > 0:
        print(f"‚ö†Ô∏è –ò—Å–∫–ª—é—á–µ–Ω–æ {excluded_count} jobs —Å—Ç–∞—Ä—à–µ {max_age_days} –¥–Ω–µ–π (–≤–µ—Ä–æ—è—Ç–Ω–æ –±–∞–≥–∏ GitHub)")
    
    return filtered_runs

def is_job_stuck_by_criteria(run, waiting_hours):
    """
    Checks if job is stuck by our criteria.
    
    Args:
        run: Workflow run object
        waiting_hours: Waiting time in hours
    
    Returns:
        bool: True if job is considered stuck
    """
    workflow_name = run.get('name', '')
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Ç–∏–ø workflow –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
        if pattern in workflow_name and waiting_hours > threshold_hours:
            return True
    
    return False

def generate_stuck_jobs_summary(stuck_jobs: List[Dict[str, Any]]) -> List[str]:
    """
    Generates brief description of stuck jobs as a list of strings, each starting with ‚ö†Ô∏è
    
    Args:
        stuck_jobs: List of stuck jobs
    
    Returns:
        List of strings with description of stuck jobs
    """
    if not stuck_jobs:
        return []
    
    stuck_counts = count_stuck_jobs_by_type(stuck_jobs)
    
    # –°–æ–±–∏—Ä–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏—è –ø–æ —Ç–∏–ø–∞–º
    descriptions = []
    for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
        count = stuck_counts.get(display_name, 0)
        if count > 0:
            job_word = "job" if count == 1 else "jobs"
            have_word = "has" if count == 1 else "have"
            hour_word = "hour" if threshold_hours == 1 else "hours"
            descriptions.append(f"‚ö†Ô∏è {display_name} {job_word} {have_word} been in the queue for more than {threshold_hours} {hour_word}! Total: {count} {job_word}.")
    
    # –î–æ–±–∞–≤–ª—è–µ–º Other –µ—Å–ª–∏ –µ—Å—Ç—å
    other_count = stuck_counts.get('Other', 0)
    if other_count > 0:
        job_word = "job" if other_count == 1 else "jobs"
        are_word = "is" if other_count == 1 else "are"
        descriptions.append(f"‚ö†Ô∏è Other {job_word} {are_word} stuck! Total: {other_count} {job_word}.")
    
    return descriptions

def count_stuck_jobs_by_type(stuck_jobs: List[Dict[str, Any]]) -> Dict[str, int]:
    """
    Counts the number of stuck jobs by types.
    
    Args:
        stuck_jobs: List of stuck jobs
    
    Returns:
        Dictionary with count of stuck jobs by types
    """
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—á–µ—Ç—á–∏–∫–∏ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    counts = {}
    for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
        counts[display_name] = 0
    counts['Other'] = 0
    
    for stuck_job in stuck_jobs:
        workflow_name = stuck_job['run'].get('name', '')
        found_type = False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Ç–∏–ø –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
            if pattern in workflow_name:
                counts[display_name] += 1
                found_type = True
                break
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∏ –æ–¥–∏–Ω —Ç–∏–ø, –¥–æ–±–∞–≤–ª—è–µ–º –≤ Other
        if not found_type:
            counts['Other'] += 1
    
    return counts

def check_for_stuck_jobs(workflow_runs: List[Dict[str, Any]], threshold_hours: int = 1) -> List[Dict[str, Any]]:
    """
    Finds "stuck" jobs by our criteria from WORKFLOW_THRESHOLDS.
    
    Args:
        workflow_runs: List of workflow runs in queue
        threshold_hours: Not used, kept for compatibility
    
    Returns:
        List of stuck jobs
    """
    stuck_jobs = []
    current_time = datetime.now(timezone.utc)
    
    for run in workflow_runs:
        # –ü–æ–ª—É—á–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ (—É—á–∏—Ç—ã–≤–∞–µ—Ç retry)
        effective_start_time = get_effective_start_time(run)
        time_diff = current_time - effective_start_time
        waiting_hours = time_diff.total_seconds() / 3600
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à–∏ –∫—Ä–∏—Ç–µ—Ä–∏–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∑–∞—Å—Ç—Ä—è–≤—à–∏—Ö jobs
        if is_job_stuck_by_criteria(run, waiting_hours):
            stuck_jobs.append({
                'run': run,
                'waiting_hours': waiting_hours
            })
    
    return stuck_jobs

def format_telegram_messages(workflow_info: Dict[str, Dict[str, Any]], stuck_jobs: List[Dict[str, Any]], total_queued: int, excluded_count: int = 0) -> List[str]:
    """
    Formats messages for sending to Telegram (splits into 2 parts).
    
    Args:
        workflow_info: Information about workflows
        stuck_jobs: List of stuck jobs
        total_queued: Total number of jobs in queue
        excluded_count: Number of excluded jobs (older than MAX_AGE_DAYS days)
    
    Returns:
        List of 2 messages for Telegram
    """
    messages = []
    
    # First message - general statistics
    message1_parts = []
    
    # Header
    if stuck_jobs:
        message1_parts.append("üö® *GITHUB ACTIONS MONITORING*")
        
        # Replace "Stuck jobs detected!" with descriptive messages about stuck jobs (one line per type)
        stuck_summary_lines = generate_stuck_jobs_summary(stuck_jobs)
        if stuck_summary_lines:
            message1_parts.extend(stuck_summary_lines)
        else:
            message1_parts.append("‚ö†Ô∏è *Stuck jobs detected!*")
    else:
        message1_parts.append("‚úÖ *GITHUB ACTIONS MONITORING*")
        message1_parts.append("All jobs in the queue are working normally")
    
    message1_parts.append("")
    
    # General statistics
    message1_parts.append(f"üìä *Statistics:*")
    message1_parts.append(f"‚Ä¢ Total in queue: {total_queued} jobs")
    
    # Statistics of stuck jobs by types
    stuck_counts = count_stuck_jobs_by_type(stuck_jobs)
    total_stuck = sum(stuck_counts.values())
    
    if total_stuck > 0:
        # Show detailed statistics by types
        for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
            if stuck_counts[display_name] > 0:
                message1_parts.append(f"‚Ä¢ Stuck {display_name} (>{threshold_hours}h): {stuck_counts[display_name]}")
        if stuck_counts['Other'] > 0:
            message1_parts.append(f"‚Ä¢ Stuck Other: {stuck_counts['Other']}")
    else:
        message1_parts.append(f"‚Ä¢ Stuck: 0")
    
    if excluded_count > 0:
        message1_parts.append(f"‚Ä¢ Excluded (>{MAX_AGE_DAYS}d): {excluded_count} jobs")
    message1_parts.append("")
    
    # Summary by workflow types
    if workflow_info:
        message1_parts.append("üìã *Workflows in queue:*")
        
        # –°–Ω–∞—á–∞–ª–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø—ã –∏–∑ WORKFLOW_THRESHOLDS
        threshold_workflows = []
        other_workflows = []
        
        for workflow_name, info in workflow_info.items():
            is_threshold_type = False
            for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
                if pattern in workflow_name:
                    threshold_workflows.append((workflow_name, info))
                    is_threshold_type = True
                    break
            if not is_threshold_type:
                other_workflows.append((workflow_name, info))
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –≥—Ä—É–ø–ø—É –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É jobs
        threshold_workflows.sort(key=lambda x: x[1]['count'], reverse=True)
        other_workflows.sort(key=lambda x: x[1]['count'], reverse=True)
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å–ø–∏—Å–∫–∏: —Å–Ω–∞—á–∞–ª–∞ threshold —Ç–∏–ø—ã, –ø–æ—Ç–æ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ
        all_workflows = threshold_workflows + other_workflows
        
        for workflow_name, info in all_workflows:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Ç–∏–ø—ã
            count = info['count']
            oldest_time = info['oldest_created_at']
            time_ago = format_time_ago(oldest_time)
            message1_parts.append(f"‚Ä¢ `{workflow_name}`: {count} jobs (oldest: {time_ago})")
    
    message1_parts.append("")
    message1_parts.append(f"üïê *Check time:* {datetime.now().strftime('%H:%M:%S UTC')}")
    
    messages.append("\n".join(message1_parts))
    
    # Second message - details about stuck jobs (only if any)
    if stuck_jobs:
        message2_parts = []
        message2_parts.append("üö® *Stuck jobs:*")
        message2_parts.append("")
        
        # Sort by waiting time (oldest first)
        stuck_jobs_sorted = sorted(stuck_jobs, key=lambda x: x['waiting_hours'], reverse=True)
        
        for i, stuck_job in enumerate(stuck_jobs_sorted[:15], 1):  # Show up to 15 jobs
            run = stuck_job['run']
            waiting_hours = stuck_job['waiting_hours']
            workflow_name = run.get('name', 'Unknown')
            run_id = run.get('id')
            run_attempt = run.get('run_attempt', 1)
            
            if waiting_hours > 24:
                waiting_str = f"{waiting_hours/24:.1f}d"
            elif waiting_hours > 1:
                waiting_str = f"{waiting_hours:.1f}h"
            else:
                waiting_str = f"{waiting_hours*60:.0f}m"
            
            # Add retry information
            retry_info = f" (retry #{run_attempt})" if run_attempt > 1 else ""
            
            github_url = f"https://github.com/ydb-platform/ydb/actions/runs/{run_id}" if run_id else "N/A"
            message2_parts.append(f"{i}. `{workflow_name}`{retry_info} - {waiting_str}")
            if run_id:
                message2_parts.append(f"   [Run {run_id}]({github_url})")
            message2_parts.append("")
        
        if len(stuck_jobs) > 15:
            message2_parts.append(f"‚Ä¢ ... and {len(stuck_jobs) - 15} more jobs")
        
        # Add dashboard link
        message2_parts.append("")
        message2_parts.append(TAIL_MESSAGE)
        
        messages.append("\n".join(message2_parts))
    
    return messages

def test_telegram_connection(bot_token: str, chat_id: str, thread_id: int = None) -> bool:
    """
    Tests connection to Telegram without sending messages.
    
    Args:
        bot_token: Telegram bot token
        chat_id: Chat ID
        thread_id: Thread ID for group messages
    
    Returns:
        True if connection is successful, False otherwise
    """
    print(f"üîç –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Telegram –¥–ª—è —á–∞—Ç–∞ {chat_id}...")
    if thread_id:
        print(f"üîç –¢–µ—Å—Ç–∏—Ä—É–µ–º thread {thread_id}...")
    
    # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    print(f"üîç Bot token: {bot_token[:10]}...{bot_token[-10:] if len(bot_token) > 20 else 'SHORT'}")
    print(f"üîç Chat ID: {chat_id}")
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º getChat –º–µ—Ç–æ–¥ –≤–º–µ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
    url = f"https://api.telegram.org/bot{bot_token}/getChat"
    data = {'chat_id': chat_id}
    
    if thread_id:
        data['message_thread_id'] = thread_id
    
    try:
        response = requests.post(url, data=data, timeout=10)
        response.raise_for_status()
        
        result = response.json()
        if result.get('ok'):
            print("‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Telegram —É—Å–ø–µ—à–Ω–æ!")
            return True
        else:
            print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å Telegram: {result.get('description', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}")
            return False
            
    except requests.exceptions.RequestException as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å Telegram: {e}")
        return False

def get_current_workflow_url() -> str:
    """
    Gets current workflow run URL from GitHub Actions environment variables.
    
    Returns:
        Current workflow run URL or empty string if variables are unavailable
    """
    github_repository = os.getenv('GITHUB_REPOSITORY', 'ydb-platform/ydb')
    github_run_id = os.getenv('GITHUB_RUN_ID')
    
    if github_run_id:
        return f"https://github.com/{github_repository}/actions/runs/{github_run_id}"
    return ""

def send_api_error_notification(bot_token: str, chat_id: str, error_message: str, thread_id: int = None) -> bool:
    """
    Sends API error notification to Telegram.
    
    Args:
        bot_token: Telegram bot token
        chat_id: Chat ID
        error_message: Error message
        thread_id: Thread ID for group messages
    
    Returns:
        True if successful, False otherwise
    """
    # –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–µ–∫—É—â–∏–π workflow run
    workflow_url = get_current_workflow_url()
    workflow_link = f"\n\nüîó [Workflow Run]({workflow_url})" if workflow_url else ""
    
    message = f"‚ö†Ô∏è *GITHUB ACTIONS MONITORING ERROR*\n\n{error_message}\n\nüïê *Time:* {datetime.now().strftime('%H:%M:%S UTC')}{workflow_link}\n\n{TAIL_MESSAGE}"
    return send_telegram_message(bot_token, chat_id, message, thread_id, "MarkdownV2")

def send_telegram_message(bot_token: str, chat_id: str, message: str, thread_id: int = None, parse_mode: str = "MarkdownV2") -> bool:
    """
    Sends message to Telegram using external script.
    
    Args:
        bot_token: Telegram bot token
        chat_id: Chat ID
        message: Message text
        thread_id: Thread ID for group messages
    
    Returns:
        True if successful, False otherwise
    """
    try:
        # –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ —Å–∫—Ä–∏–ø—Ç—É send_telegram_message.py
        script_dir = os.path.dirname(os.path.abspath(__file__))
        send_script = os.path.join(script_dir, 'send_telegram_message.py')
        
        # –í—ã–∑—ã–≤–∞–µ–º –≤–Ω–µ—à–Ω–∏–π —Å–∫—Ä–∏–ø—Ç —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º
        print(f"Chat ID: {chat_id}")
        cmd = [
            'python3', send_script,
            '--bot-token', bot_token,
            '--chat-id', chat_id,
            '--message', message,
            '--parse-mode', parse_mode
        ]
        
        # –î–æ–±–∞–≤–ª—è–µ–º thread_id –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
        if thread_id:
            cmd.extend(['--message-thread-id', str(thread_id)])
        
        result = subprocess.run(cmd, text=True, timeout=60)
        
        if result.returncode == 0:
            print("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram")
            return True
        else:
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram (–∫–æ–¥ {result.returncode})")
            return False
            
    except subprocess.TimeoutExpired:
        print("‚ùå –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ Telegram")
        return False
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Å–∫—Ä–∏–ø—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
        return False

def main():
    """Main script function."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ workflow runs –≤ –æ—á–µ—Ä–µ–¥–∏ GitHub Actions")
    parser.add_argument('--dry-run', action='store_true', 
                       help='–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏ –±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram')
    parser.add_argument('--bot-token', 
                       help='Telegram bot token (–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ TELEGRAM_BOT_TOKEN env var)')
    parser.add_argument('--chat-id', 
                       help='Telegram chat ID')
    parser.add_argument('--channel', 
                       help='Telegram channel ID (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ –¥–ª—è --chat-id)')
    parser.add_argument('--thread-id', type=int,
                       help='Telegram thread ID –¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π')
    parser.add_argument('--test-connection', action='store_true',
                       help='–¢–æ–ª—å–∫–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Telegram')
    parser.add_argument('--send-when-all-good', action='store_true',
                       help='–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–∞–∂–µ –∫–æ–≥–¥–∞ –≤—Å–µ jobs —Ä–∞–±–æ—Ç–∞—é—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ')
    parser.add_argument('--notify-on-api-errors', action='store_true',
                       help='–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö API')
    
    args = parser.parse_args()
    
    print("üîç –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ workflow runs –≤ –æ—á–µ—Ä–µ–¥–∏ GitHub Actions")
    print("=" * 60)
    
    # Get parameters from arguments or environment variables
    bot_token = args.bot_token or os.getenv('TELEGRAM_BOT_TOKEN')
    chat_id = args.channel or args.chat_id or os.getenv('TELEGRAM_CHAT_ID')
    thread_id = args.thread_id or os.getenv('TELEGRAM_THREAD_ID')
    dry_run = args.dry_run or os.getenv('DRY_RUN', 'false').lower() == 'true'
    send_when_all_good = args.send_when_all_good or os.getenv('SEND_WHEN_ALL_GOOD', 'false').lower() == 'true'
    notify_on_api_errors = args.notify_on_api_errors or os.getenv('NOTIFY_ON_API_ERRORS', 'false').lower() == 'true'
    
    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç chat_id –¥–ª—è –∫–∞–Ω–∞–ª–æ–≤ (–∫–∞–∫ –≤ parse_and_send_team_issues.py)
    if chat_id and not chat_id.startswith('-') and len(chat_id) >= 10:
        # –î–æ–±–∞–≤–ª—è–µ–º -100 –ø—Ä–µ—Ñ–∏–∫—Å –¥–ª—è supergroup
        chat_id = f"-100{chat_id}"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∂–∏–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    if args.test_connection:
        if not bot_token:
            print("‚ùå TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            print("   –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ --bot-token –∏–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_BOT_TOKEN")
            sys.exit(1)
        
        print("üîç –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Telegram...")
        if test_telegram_connection(bot_token, chat_id, thread_id):
            print("‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ!")
            sys.exit(0)
        else:
            print("‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å!")
            sys.exit(1)
    
    if dry_run:
        print("üß™ –†–ï–ñ–ò–ú DRY-RUN: –¢–æ–∫–µ–Ω—ã –Ω–µ —Ç—Ä–µ–±—É—é—Ç—Å—è, —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è")
        print("=" * 60)
    elif not bot_token:
        print("‚ùå TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        print("üí° –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π –æ—Ç–ª–∞–¥–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ --dry-run")
        sys.exit(1)
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞ "queued"
    print("üì° –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞: queued")
    data, error = fetch_workflow_runs(status="queued")
    
    if error:
        print(f"‚ùå GitHub API error: {error}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ API –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
        if notify_on_api_errors:
            if dry_run:
                # –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–µ–∫—É—â–∏–π workflow run –¥–ª—è dry-run
                workflow_url = get_current_workflow_url()
                workflow_link = f"\n\nüîó [Workflow Run]({workflow_url})" if workflow_url else ""
                
                print(f"\nüì§ DRY-RUN: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ API –¥–ª—è Telegram {chat_id}:{thread_id}")
                print("-" * 50)
                print(f"‚ö†Ô∏è *GITHUB ACTIONS MONITORING ERROR*\n\n{error}\n\nüïê *Time:* {datetime.now().strftime('%H:%M:%S UTC')}{workflow_link}\n\n{TAIL_MESSAGE}")
                print("-" * 50)
            else:
                print("üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ API –≤ Telegram...")
                if send_api_error_notification(bot_token, chat_id, error, thread_id):
                    print("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
                else:
                    print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ")
        
        sys.exit(1)
    
    queued_runs = data['workflow_runs']
    print(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(queued_runs)} workflow runs –≤ –æ—á–µ—Ä–µ–¥–∏")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –¥–∞–Ω–Ω—ã–µ
    if not queued_runs:
        print("‚úÖ –ù–µ—Ç workflow runs –≤ –æ—á–µ—Ä–µ–¥–∏")
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞
        message = "‚úÖ *GITHUB ACTIONS MONITORING*\n\nQueue is empty - all jobs are working normally! üéâ"
        
        if dry_run:
            print(f"\nüì§ DRY-RUN: –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram:{chat_id}:{thread_id}")
            print("-" * 50)
            print(message)
            print("-" * 50)
        elif send_when_all_good:
            print(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏ –≤ Telegram")
            if send_telegram_message(bot_token, chat_id, message, thread_id, "MarkdownV2"):
                print("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ")
            else:
                print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏")
        else:
            print(f"üì§ –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ - –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º")
        return
    
    # –§–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ jobs (—Å—Ç–∞—Ä—à–µ MAX_AGE_DAYS –¥–Ω–µ–π)
    filtered_runs = filter_old_jobs(queued_runs)
    excluded_count = len(queued_runs) - len(filtered_runs)
    print(f"üìä –ü–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: {len(filtered_runs)} workflow runs (–∏—Å–∫–ª—é—á–µ–Ω—ã jobs —Å—Ç–∞—Ä—à–µ {MAX_AGE_DAYS} –¥–Ω–µ–π)")
    
    if not filtered_runs:
        print("‚úÖ –ù–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö workflow runs –≤ –æ—á–µ—Ä–µ–¥–∏")
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞
        message = "‚úÖ *GITHUB ACTIONS MONITORING*\n\nQueue is empty - all jobs are working normally! üéâ"
        
        if dry_run:
            print(f"\nüì§ DRY-RUN: –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram:{chat_id}:{thread_id}")
            print("-" * 50)
            print(message)
            print("-" * 50)
        elif send_when_all_good:
            print(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏ –≤ Telegram")
            if send_telegram_message(bot_token, chat_id, message, thread_id, "MarkdownV2"):
                print("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ")
            else:
                print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏")
        else:
            print(f"üì§ –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ - –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º")
        return
    
    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
    workflow_info = analyze_queued_workflows(filtered_runs)
    total_queued = sum(info['count'] for info in workflow_info.values())
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∑–∞—Å—Ç—Ä—è–≤—à–∏–µ jobs –ø–æ –Ω–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
    stuck_jobs = check_for_stuck_jobs(filtered_runs, threshold_hours=1)
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è Telegram (–¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º)
    telegram_messages = format_telegram_messages(workflow_info, stuck_jobs, total_queued, excluded_count)
    
    # –ï—Å–ª–∏ –Ω–µ—Ç –∑–∞—Å—Ç—Ä—è–≤—à–∏—Ö jobs, –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
    if not stuck_jobs:
        if send_when_all_good:
            print(f"‚úÖ –ù–µ—Ç –∑–∞—Å—Ç—Ä—è–≤—à–∏—Ö jobs –ø–æ –Ω–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç –æ —Ö–æ—Ä–æ—à–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏")
        else:
            print(f"‚úÖ –ù–µ—Ç –∑–∞—Å—Ç—Ä—è–≤—à–∏—Ö jobs –ø–æ –Ω–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º - –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É —Å –∫—Ä–∏—Ç–µ—Ä–∏—è–º–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        criteria_parts = []
        for pattern, threshold_hours, display_name in WORKFLOW_THRESHOLDS:
            criteria_parts.append(f"{display_name} >{threshold_hours}—á")
        criteria_str = ", ".join(criteria_parts)
        print(f"   ({criteria_str})")
        print("\nüìä –¢–ï–ö–£–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:")
        print("=" * 50)
        for i, message in enumerate(telegram_messages, 1):
            print(f"\n--- –û—Ç—á–µ—Ç {i} ---")
            print(message)
        print("=" * 50)
        
        # –ï—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∫–æ–≥–¥–∞ –≤—Å–µ —Ö–æ—Ä–æ—à–æ, –≤—ã—Ö–æ–¥–∏–º
        if not send_when_all_good:
            return
    
    print(f"üö® –ù–∞–π–¥–µ–Ω–æ {len(stuck_jobs)} –∑–∞—Å—Ç—Ä—è–≤—à–∏—Ö jobs –ø–æ –Ω–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º")
    
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram –∏–ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ dry-run —Ä–µ–∂–∏–º–µ
    if dry_run:
        print(f"\nüì§ DRY-RUN: {len(telegram_messages)} —Å–æ–æ–±—â–µ–Ω–∏–µ(–π) –¥–ª—è Telegram:")
        for i, message in enumerate(telegram_messages, 1):
            print(f"\n--- –°–æ–æ–±—â–µ–Ω–∏–µ {i} ---")
            print("=" * 60)
            print(message)
            print("=" * 60)
        print("\n‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω (dry-run —Ä–µ–∂–∏–º)")
        sys.exit(0)
    else:
        print(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º {len(telegram_messages)} —Å–æ–æ–±—â–µ–Ω–∏–µ(–π) –≤ Telegram {chat_id}:{thread_id}")
        
        success_count = 0
        for i, message in enumerate(telegram_messages, 1):
            print(f"üì® –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ {i}/{len(telegram_messages)}...")
            if send_telegram_message(bot_token, chat_id, message, thread_id, "MarkdownV2"):
                success_count += 1
            else:
                print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è {i}")
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ (–∫—Ä–æ–º–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ)
            if i < len(telegram_messages):
                print("‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ 2 —Å–µ–∫—É–Ω–¥—ã –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º...")
                time.sleep(2)
        
        if success_count == len(telegram_messages):
            print("‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ")
            sys.exit(0)
        else:
            print(f"‚ö†Ô∏è –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {success_count}/{len(telegram_messages)} —Å–æ–æ–±—â–µ–Ω–∏–π")
            sys.exit(1)

if __name__ == "__main__":
    main()
