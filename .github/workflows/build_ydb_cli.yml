name: Build-YDB-CLI
run-name: Build YDB CLI

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      version-change:
        description: |
          Version part to increment:
          • PATCH (X.Y.Z → X.Y.Z+1) - for bug fixes, small improvements
          • MINOR (X.Y.Z → X.Y+1.0) - for new features, significant updates
        required: true
        type: choice
        options:
          - PATCH
          - MINOR
        default: PATCH
      commit_sha:
        description: Specific commit to use as base (optional, defaults to main)
        type: string
        default: ""
      build-linux-amd:
        type: boolean
        description: Build YDB CLI for Linux (amd64)
        default: true
      build-linux-arm:
        type: boolean
        description: Build YDB CLI for Linux (arm64)
        default: true
      build-darwin-amd:
        type: boolean
        description: Build YDB CLI for MacOS (amd64)
        default: true
      build-darwin-arm:
        type: boolean
        description: Build YDB CLI for MacOS (arm64)
        default: true
      build-windows-amd:
        type: boolean
        description: Build YDB CLI for Windows (amd64)
        default: true
defaults:
  run:
    shell: bash

jobs:
  prepare-release:
    name: Prepare release branch and update version
    runs-on: ubuntu-latest
    outputs:
      branch-name: ${{ steps.create-branch.outputs.branch-name }}
      new-version: ${{ steps.update-version.outputs.new-version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}  # TODO: change back to YDBOT_TOKEN for production
          ref: ${{ inputs.commit_sha }}
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.email github-actions@github.com  # TODO: change back to ydbot@ydb.tech for production
          git config --global user.name "GitHub Actions"  # TODO: change back to YDBot for production

      - name: Read current version
        id: read-version
        run: |
          CURRENT_VERSION=$(cat ydb/apps/ydb/version.txt)
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: update-version
        run: |
          CURRENT_VERSION="${{ steps.read-version.outputs.current-version }}"
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          if [ "${{ inputs.version-change }}" = "MAJOR" ]; then
            MAJOR=$((MAJOR+1))
            MINOR=0
            PATCH=0
          elif [ "${{ inputs.version-change }}" = "MINOR" ]; then
            MINOR=$((MINOR+1))
            PATCH=0
          elif [ "${{ inputs.version-change }}" = "PATCH" ]; then
            PATCH=$((PATCH+1))
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Create release branch
        id: create-branch
        run: |
          # Ensure we're on main before creating release branch
          git fetch origin main
          git checkout main
          git reset --hard origin/main
          
          BRANCH_NAME="release/cli-${{ steps.update-version.outputs.new-version }}"
          git checkout -b "$BRANCH_NAME"
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Created branch: $BRANCH_NAME"

      - name: Check CHANGELOG format
        run: |
          # Check if the file starts with empty line - version - empty line pattern
          HEAD_LINES=$(head -n 3 ydb/apps/ydb/CHANGELOG.md)
          FIRST_LINE=$(head -n 1 ydb/apps/ydb/CHANGELOG.md)
          SECOND_LINE=$(head -n 2 ydb/apps/ydb/CHANGELOG.md | tail -n 1)
          THIRD_LINE=$(head -n 3 ydb/apps/ydb/CHANGELOG.md | tail -n 1)

          if [[ -z "$FIRST_LINE" ]] && [[ "$SECOND_LINE" =~ ^##.*##$ ]] && [[ -z "$THIRD_LINE" ]]; then
            echo "Error: CHANGELOG already has version format at the beginning"
            exit 1
          fi

      - name: Update version file
        run: |
          echo "${{ steps.update-version.outputs.new-version }}" > ydb/apps/ydb/version.txt
          git add ydb/apps/ydb/version.txt

      - name: Update CHANGELOG
        run: |
          NEW_VERSION="${{ steps.update-version.outputs.new-version }}"
          # Create temporary file with new changelog structure
          echo "" > /tmp/changelog_header.md
          echo "## $NEW_VERSION ##" >> /tmp/changelog_header.md
          echo "" >> /tmp/changelog_header.md

          # Combine new header with existing changelog
          cat /tmp/changelog_header.md ydb/apps/ydb/CHANGELOG.md > /tmp/new_changelog.md
          mv /tmp/new_changelog.md ydb/apps/ydb/CHANGELOG.md

          git add ydb/apps/ydb/CHANGELOG.md

      - name: Commit changes
        run: |
          git commit -m "Release ${{ steps.update-version.outputs.new-version }}"

      - name: Create tag
        run: |
          TAG_NAME="CLI_${{ steps.update-version.outputs.new-version }}"
          git tag "$TAG_NAME"
          echo "Created tag: $TAG_NAME"

      - name: Push branch and tag
        run: |
          git push origin "${{ steps.create-branch.outputs.branch-name }}"
          git push origin "CLI_${{ steps.update-version.outputs.new-version }}"

  # TODO: uncomment for production - commented for fork testing
  # build-matrix:
  #     name: Build platform matrix
  #     needs: prepare-release
  #     runs-on: ubuntu-latest
  #     outputs:
  #       matrix: ${{ steps.set-matrix.outputs.matrix }}
  #     steps:
  #       - name: Create file with future platform list
  #         id: set-matrix
  #         run: |
  #           MATRIX='{"include":[]}'
  #           if [ "${{ inputs.build-linux-amd }}" == "true" ]; then
  #             MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "linux-amd", "runner": "ubuntu-latest", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-LINUX-X86_64"}]')
  #             echo "Matrix after adding linux-amd: $MATRIX"
  #           fi
  #           if [ "${{ inputs.build-linux-arm }}" == "true" ]; then
  #             MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "linux-arm", "runner": "ubuntu-latest", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-LINUX-AARCH64"}]')
  #             echo "Matrix after adding linux-arm: $MATRIX"
  #           fi
  #           if [ "${{ inputs.build-darwin-amd }}" == "true" ]; then
  #             MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "darwin-amd", "runner": "macos-13", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-DARWIN-X86_64"}]')
  #             echo "Matrix after adding darwin-amd: $MATRIX"
  #           fi
  #           if [ "${{ inputs.build-darwin-arm }}" == "true" ]; then
  #             MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "darwin-arm", "runner": "macos-13", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-DARWIN-ARM64"}]')
  #             echo "Matrix after adding darwin-arm: $MATRIX"
  #           fi
  #           if [ "${{ inputs.build-windows-amd }}" == "true" ]; then
  #             MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "windows-amd", "runner": "windows-latest", "shell": "bash", "binary": "ydb.exe", "platform": "DEFAULT-WIN-X86_64"}]')
  #             echo "Matrix after adding windows-amd: $MATRIX"
  #           fi
  #
  #           echo "Final output matrix: $MATRIX"
  #           echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
  #           MATRIX=$(echo $MATRIX | jq '.')
  #           echo "Final pretty printed matrix: $MATRIX"
  #           echo "Platform matrix: $MATRIX" >> "$GITHUB_STEP_SUMMARY"

  # build-platform-specific-binary:
  #     strategy:
  #       matrix: ${{ fromJSON(needs.build-matrix.outputs.matrix) }}
  #     name: Build ${{ matrix.os }} binary
  #     needs: [prepare-release, build-matrix]
  #     runs-on: ${{ matrix.runner }}
  #     defaults:
  #       run:
  #         shell: ${{ matrix.shell }}
  #     steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #       with:
  #         ref: ${{ needs.prepare-release.outputs.branch-name }}
  #
  #     - name: Print debug information
  #       run: |
  #         uname -a
  #         echo "YDB CLI version: $(cat ydb/apps/ydb/version.txt) (read from ydb/apps/ydb/version.txt)"
  #
  #     # Turns out it is crucial to prepare VS environment and build in one step due to env variable visibility
  #     - name: Prepare Visual Studio environment and build windows binary with ya make
  #       if: ${{ matrix.os == 'windows-amd' }}
  #       shell: cmd
  #       run: ${{ '"%ProgramFiles%\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat" -arch=amd64' }} && python ya make ydb/apps/ydb -r -DUSE_SSE4=no -o ./
  #
  #     - name: Build unix binary with ya make
  #       if: ${{ matrix.os != 'windows-amd' }}
  #       run: ./ya make ydb/apps/ydb -r -DUSE_SSE4=no --target-platform ${{ matrix.platform }}
  #
  #     - name: Upload binary to artifact
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: ${{ matrix.os }}-binary
  #         path: ydb/apps/ydb/${{ matrix.binary }}
  #         if-no-files-found: error
  #         retention-days: 1
  #
  # gather-and-push-to-s3:
  #     name: Gather built binaries and push to s3
  #     needs: [prepare-release, build-platform-specific-binary]
  #     runs-on: ubuntu-latest
  #     steps:
  #       - name: Checkout
  #         uses: actions/checkout@v4
  #         with:
  #           ref: ${{ needs.prepare-release.outputs.branch-name }}
  #       - name: Get YDB CLI version from prepare-release job
  #         id: getver
  #         run: echo "cli_version=${{ needs.prepare-release.outputs.new-version }}" >> $GITHUB_OUTPUT
  #       - name: Print YDB CLI version ${{ steps.getver.outputs.cli_version }}
  #         run: echo ${{ steps.getver.outputs.cli_version }}
  #
  #       - name: Prepare directory for linux-amd binary
  #         if: ${{ inputs.build-linux-amd }}
  #         run: mkdir -p ${{ steps.getver.outputs.cli_version }}/linux/amd64
  #       - name: Prepare directory for linux-arm binary
  #         if: ${{ inputs.build-linux-arm }}
  #         run: mkdir -p ${{ steps.getver.outputs.cli_version }}/linux/arm64
  #       - name: Prepare directory for darwin-amd binary
  #         if: ${{ inputs.build-darwin-amd }}
  #         run: mkdir -p ${{ steps.getver.outputs.cli_version }}/darwin/amd64
  #       - name: Prepare directory for darwin-arm binary
  #         if: ${{ inputs.build-darwin-arm }}
  #         run: mkdir -p ${{ steps.getver.outputs.cli_version }}/darwin/arm64
  #       - name: Prepare directory for windows-amd binary
  #         if: ${{ inputs.build-windows-amd }}
  #         run: mkdir -p ${{ steps.getver.outputs.cli_version }}/windows/amd64/unsigned
  #
  #       - name: Copy linux-amd binary
  #         if: ${{ inputs.build-linux-amd }}
  #         uses: actions/download-artifact@v4
  #         with:
  #           name: linux-amd-binary
  #           path: ${{ steps.getver.outputs.cli_version }}/linux/amd64/
  #       - name: Copy linux-arm binary
  #         if: ${{ inputs.build-linux-arm }}
  #         uses: actions/download-artifact@v4
  #         with:
  #           name: linux-arm-binary
  #           path: ${{ steps.getver.outputs.cli_version }}/linux/arm64/
  #       - name: Copy darwin amd64 binary
  #         if: ${{ inputs.build-darwin-amd }}
  #         uses: actions/download-artifact@v4
  #         with:
  #           name: darwin-amd-binary
  #           path: ${{ steps.getver.outputs.cli_version }}/darwin/amd64/
  #       - name: Copy darwin arm64 binary
  #         if: ${{ inputs.build-darwin-arm }}
  #         uses: actions/download-artifact@v4
  #         with:
  #           name: darwin-arm-binary
  #           path: ${{ steps.getver.outputs.cli_version }}/darwin/arm64/
  #       - name: Copy windows-amd binary (unsigned)
  #         if: ${{ inputs.build-windows-amd }}
  #         uses: actions/download-artifact@v4
  #         with:
  #           name: windows-amd-binary
  #           path: ${{ steps.getver.outputs.cli_version }}/windows/amd64/unsigned/
  #
  #       - name: Print resulting file hierarchy
  #         run: find ${{ steps.getver.outputs.cli_version }} | sed -e "s/[^-][^\/]*\// |/g" -e "s/|\([^ ]\)/|-\1/"
  #
  #       - name: Download s3
  #         run: wget https://github.com/s3tools/s3cmd/releases/download/v2.4.0/s3cmd-2.4.0.tar.gz
  #       - name: Unzip s3
  #         run: tar -xf s3cmd-2.4.0.tar.gz
  #       - name: Install s3
  #         run: |
  #           cd s3cmd-2.4.0
  #           sudo python3 setup.py install
  #           cd ..
  #
  #       - name: Upload to S3
  #         env:
  #           S3_HOST: "storage.yandexcloud.net"
  #           S3_BUCKET: "yandexcloud-ydb"
  #           S3_DNS_HOST_BUCKET: "%(bucket)s.storage.yandexcloud.net"
  #           S3_REGION: ru-central1
  #         run: s3cmd --access_key=${{ secrets.CLI_S3_KEY_ID }} --secret_key=${{ secrets.CLI_S3_KEY_SECRET_ID }} --host="$S3_HOST" --host-bucket="$S3_DNS_HOST_BUCKET" --region="$S3_REGION" sync --recursive ${{ steps.getver.outputs.cli_version }} "s3://$S3_BUCKET/release/"
  #
  finalize-release:
    name: Merge to main and finalize release
    needs: [prepare-release]  # TODO: add back gather-and-push-to-s3 for production
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}  # TODO: change back to YDBOT_TOKEN for production
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.email github-actions@github.com  # TODO: change back to ydbot@ydb.tech for production
          git config --global user.name "GitHub Actions"  # TODO: change back to YDBot for production

      - name: Merge release branch to main
        run: |
          # Fetch latest changes from main and release branch
          git fetch origin main
          git fetch origin "${{ needs.prepare-release.outputs.branch-name }}"
          git checkout main
          git reset --hard origin/main

          # Merge release branch
          git merge "origin/${{ needs.prepare-release.outputs.branch-name }}" --no-ff -m "Merge CLI release ${{ needs.prepare-release.outputs.new-version }}"
          git push origin main

      - name: Delete release branch
        run: |
          git push origin --delete "${{ needs.prepare-release.outputs.branch-name }}"

  cleanup-on-failure:
    name: Cleanup release branch on failure
    needs: [prepare-release, finalize-release]  # TODO: add back gather-and-push-to-s3 for production
    runs-on: ubuntu-latest
    if: failure() && needs.prepare-release.result == 'success'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}  # TODO: change back to YDBOT_TOKEN for production
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.email github-actions@github.com  # TODO: change back to ydbot@ydb.tech for production
          git config --global user.name "GitHub Actions"  # TODO: change back to YDBot for production

      - name: Delete release branch and tag
        run: |
          # Delete the branch
          git push origin --delete "${{ needs.prepare-release.outputs.branch-name }}" || echo "Branch already deleted"
 
          # Delete the tag - we're cleaning up a failed release
          git push origin --delete "CLI_${{ needs.prepare-release.outputs.new-version }}" || echo "Tag already deleted"

