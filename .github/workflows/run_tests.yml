name: Run-tests

on:
  workflow_call:
    inputs:
      test_targets:
        description: 'Paths to tests for run ,example : ydb/ ydb/tests/func/suite'
        required: true
        type: string
        default: ydb/
      test_type:
        description: 'Test type (unittest,py3test,py2test,pytest)'
        required: false
        type: string
        default: unittest,py3test,py2test,pytest
      test_size:
        description: 'Test size (small,medium,large)'
        required: false
        type: string
        default: small,medium,large
      additional_ya_make_args:
        description: 'additional args for ya make'
        required: false
        type: string
        default: ''
      build_preset:
        description: 'Build preset type'
        required: true
        type: string
      branches:
        description: 'Branches to test (JSON array or single branch)'
        required: false
        type: string
        default: '["main"]'
      branches_config_path:
        description: 'Path to JSON file with branches to test'
        required: false
        type: string
        default: ''

  workflow_dispatch:
    inputs:
      pull_number:
        description: 'Pull request number, ex: 12345'
        required: false
        default: ''
      test_targets:
        description: 'Paths to tests for run ,example : ydb/ ydb/tests/func/suite'
        required: true
        default: ydb/
      test_type:
        description: 'Test type (unittest,py3test,py2test,pytest)'
        required: false
        default: unittest,py3test,py2test,pytest
      test_size:
        description: 'Test size (small,medium,large)'
        required: false
        type: choice
        default: small,medium,large
        options:
          - small
          - medium
          - large
          - small,medium
          - small,medium,large
      additional_ya_make_args:
        description: 'additional args for ya make'
        required: false
        default: ''
      build_preset:
        description: 'Build preset type (relwithdebinfo, release-asan, release-msan, release-tsan)'
        required: true
        type: choice
        options:
          - relwithdebinfo
          - release-asan
          - release-msan
          - release-tsan
        default: relwithdebinfo
      collect_coredumps:
        type: boolean
        default: false
        description: "Collect coredumps via ulimit -c unlimited"

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      branch_array: ${{ steps.set-branches.outputs.branch_array }}
      base_branch: ${{ steps.set-branches.outputs.base_branch }}
    steps:
      - name: Checkout ${{ matrix.branch }}
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/config/stable_branches.json
            .github/scripts/tests/comment-pr.py

      - name: Set branches
        id: set-branches
        env:
          CALLED_BRANCHES: '${{ inputs.branches }}'
          BRANCHES_CONFIG_PATH: '${{ inputs.branches_config_path }}'
          PULL_REQUEST_NUMBER: '${{ inputs.pull_number }}'
          GITHUB_TOKEN: '${{ github.token }}'
        run: |
          set -e
          
          # Helper function: check if string looks like a SHA (commit hash)
          is_sha() {
            [[ $1 =~ ^[0-9a-f]{7,40}$ ]]
          }
          
          # Helper function: check if string looks like a branch name (not SHA, not pull/N)
          is_branch_name() {
            [[ -n "$1" ]] && ! is_sha "$1" && [[ $1 != pull/* ]]
          }
          
          # Helper function: get PR info from GitHub API
          get_pr_info() {
            local pr_num=$1
            curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/ydb-platform/ydb/pulls/$pr_num"
          }
          
          # Helper function: process a single branch entry
          # Returns: branch_to_test (SHA or branch name) and base_branch (if found)
          process_branch_entry() {
            local entry=$1
            local merge_sha=""
            local base_ref=""
            
            # Case 1: Entry is "pull/N" format - convert to merge commit SHA
            if [[ $entry =~ ^pull/([0-9]+)$ ]]; then
              local pr_num=${BASH_REMATCH[1]}
              echo "Processing PR: $pr_num" >&2
              
              local pr_info=$(get_pr_info "$pr_num")
              merge_sha=$(echo "$pr_info" | jq -r '.merge_commit_sha')
              base_ref=$(echo "$pr_info" | jq -r '.base.ref')
              
              if [[ -z "$merge_sha" || "$merge_sha" == "null" ]]; then
                echo "Warning: Failed to get merge commit for PR $pr_num, skipping" >&2
                return 1
              fi
              
              # Save PR info for comment step (only first PR)
              if [[ -z "$COMMIT_SHA" ]]; then
                echo "COMMIT_SHA=$merge_sha" >> $GITHUB_ENV
                echo "PR_NUMBER=$pr_num" >> $GITHUB_ENV
              fi
              
              echo "$merge_sha|$base_ref"
              return 0
            fi
            
            # Case 2: Entry is already a branch name or SHA - use as-is
            echo "$entry|"
            return 0
          }
          
          # Initialize variables
          BASE_BRANCH=""
          BRANCH_ARRAY_JSON=""
          
          # ============================================================================
          # SCENARIO 1: Direct PR number provided (workflow_dispatch with pull_number)
          # ============================================================================
          if [[ -n "$PULL_REQUEST_NUMBER" ]]; then
            echo "Scenario: Direct PR number provided: $PULL_REQUEST_NUMBER"
            
            pr_info=$(get_pr_info "$PULL_REQUEST_NUMBER")
            merge_sha=$(echo "$pr_info" | jq -r '.merge_commit_sha')
            base_ref=$(echo "$pr_info" | jq -r '.base.ref')
            
            if [[ -z "$merge_sha" || "$merge_sha" == "null" ]]; then
              echo "Error: Failed to get merge commit for PR $PULL_REQUEST_NUMBER"
              exit 1
            fi
            
            BRANCH_ARRAY_JSON="[\"$merge_sha\"]"
            BASE_BRANCH="$base_ref"
            echo "COMMIT_SHA=$merge_sha" >> $GITHUB_ENV
            echo "PR_NUMBER=$PULL_REQUEST_NUMBER" >> $GITHUB_ENV
            
          # ============================================================================
          # SCENARIO 2: Branches parameter provided (workflow_call with branches)
          # ============================================================================
          elif [[ -n "$CALLED_BRANCHES" ]]; then
            echo "Scenario: Branches parameter provided: $CALLED_BRANCHES"
            
            # Parse branches input (can be JSON array or single branch)
            if [[ $CALLED_BRANCHES == \[* ]]; then
              readarray -t branches < <(echo "$CALLED_BRANCHES" | jq -r '.[]')
            else
              branches=("$CALLED_BRANCHES")
            fi
            
            processed_branches=()
            for branch_entry in "${branches[@]}"; do
              result=$(process_branch_entry "$branch_entry") || continue
              
              branch_to_test=$(echo "$result" | cut -d'|' -f1)
              base_ref_from_pr=$(echo "$result" | cut -d'|' -f2)
              
              processed_branches+=("\"$branch_to_test\"")
              
              # Set BASE_BRANCH from PR's base.ref if available
              if [[ -z "$BASE_BRANCH" && -n "$base_ref_from_pr" && "$base_ref_from_pr" != "null" ]]; then
                BASE_BRANCH="$base_ref_from_pr"
              fi
              
              # Or use first branch name (not SHA) as base_branch
              if [[ -z "$BASE_BRANCH" ]] && is_branch_name "$branch_entry"; then
                BASE_BRANCH="$branch_entry"
              fi
            done
            
            BRANCH_ARRAY_JSON=$(IFS=, ; echo "[${processed_branches[*]}]")
            
          # ============================================================================
          # SCENARIO 3: Branches config file provided (workflow_call with branches_config_path)
          # ============================================================================
          elif [[ -n "$BRANCHES_CONFIG_PATH" ]]; then
            echo "Scenario: Branches config file provided: $BRANCHES_CONFIG_PATH"
            
            BRANCH_ARRAY_JSON=$(jq -c "." "$BRANCHES_CONFIG_PATH")
            
            # Try to extract first branch name from config (for base_branch)
            first_branch=$(jq -r '.[0] // empty' "$BRANCHES_CONFIG_PATH" 2>/dev/null || echo "")
            if [[ -n "$first_branch" ]] && is_branch_name "$first_branch"; then
              BASE_BRANCH="$first_branch"
            fi
            
          # ============================================================================
          # SCENARIO 4: No branches specified (direct workflow_dispatch)
          # ============================================================================
          else
            echo "Scenario: No branches specified, using current branch"
            
            current_ref="${{ github.ref_name }}"
            BRANCH_ARRAY_JSON="[\"$current_ref\"]"
            
            if is_branch_name "$current_ref"; then
              BASE_BRANCH="$current_ref"
            fi
          fi
          
          # ============================================================================
          # Output results
          # ============================================================================
          echo "branch_array=$BRANCH_ARRAY_JSON" >> $GITHUB_OUTPUT
          
          if [[ -n "$BASE_BRANCH" ]]; then
            echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
            echo "Using base_branch: $BASE_BRANCH"
          else
            echo "No base_branch determined (will use matrix.branch as fallback)"
          fi
          
          echo "Final branch_array: $BRANCH_ARRAY_JSON"

      - name: Install dependencies
        if: always()
        run: |
          # Check if COMMIT_SHA is set (means we have a PR to comment on)
          if [ -n "$COMMIT_SHA" ]; then
            pip install PyGithub
          else
            echo "No PR detected, skipping dependency installation"
          fi

      - name: Post run tests start comment
        if: always()
        shell: bash
        env:
          BUILD_PRESET: ${{ inputs.build_preset }}
          GITHUB_TOKEN: ${{ github.token }}
          TEST_SIZE: ${{ inputs.test_size }}
          BUILD_TARGET: ${{ inputs.test_targets }}
          COLLECT_COREDUMPS: ${{ inputs.collect_coredumps }}
        run: |
          # Check if COMMIT_SHA is set (means we have a PR to comment on)
          if [ -z "$COMMIT_SHA" ]; then
            echo "No PR detected (COMMIT_SHA is not set), skipping comment"
            exit 0
          fi
          commit_sha="$COMMIT_SHA"
          
          commit_short=$(echo "$commit_sha" | cut -c1-7)
          commit_url="https://github.com/${GITHUB_REPOSITORY}/commit/${commit_sha}"
          check_url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          
          workflow_name="${{ github.workflow }}"
          
          {
            echo "### $workflow_name started"
            echo ""
            echo "- **Build Preset:** \`$BUILD_PRESET\`"
            echo "- **Test Size:** \`$TEST_SIZE\`"
            echo "- **Test Targets:** \`$BUILD_TARGET\`"
            if [ "$COLLECT_COREDUMPS" = "true" ]; then
              echo "- **Collect Coredumps:** \`true\`"
            fi
            echo "- **Commit:** [${commit_short}](${commit_url})"
            echo "- **Workflow run:** [link](${check_url})"
            echo ""
          } | .github/scripts/tests/comment-pr.py --rewrite --no-timestamp

  run_tests:
    needs: prepare
    name: ${{ matrix.branch }}:${{ inputs.build_preset }}
    timeout-minutes: 1200
    runs-on: [ self-hosted, auto-provisioned, "${{ format('build-preset-{0}', inputs.build_preset) }}" ]
    strategy:
      fail-fast: false
      matrix:
        branch: ${{ fromJson(needs.prepare.outputs.branch_array) }}
    steps:
      - name: Set variables based on build_preset
        id: set-vars
        run: |
          if [[ "${{ inputs.build_preset }}" == "relwithdebinfo" ]]; then
            echo "threads_count=52" >> $GITHUB_ENV
            echo "timeout=1200" >> $GITHUB_ENV
          elif [[ "${{ inputs.build_preset }}" == "release-asan" ]]; then
            echo "threads_count=20" >> $GITHUB_ENV
            echo "timeout=1200" >> $GITHUB_ENV
          elif [[ "${{ inputs.build_preset }}" == "release-msan" ]]; then
            echo "threads_count=5" >> $GITHUB_ENV
            echo "timeout=1200" >> $GITHUB_ENV
          elif [[ "${{ inputs.build_preset }}" == "release-tsan" ]]; then
            echo "threads_count=18" >> $GITHUB_ENV
            echo "timeout=1200" >> $GITHUB_ENV
          else
            echo "Unknown build_preset value."
            exit 1
          fi

      - name: Checkout ${{ matrix.branch }}
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}

      - name: Setup ydb access
        uses: ./.github/actions/setup_ci_ydb_service_account_key_file_credentials
        with:
          ci_ydb_service_account_key_file_credentials: ${{ secrets.CI_YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS }}

      - name: Run YDB Tests
        id: run_tests
        timeout-minutes: ${{ fromJson(env.timeout) }}
        uses: ./.github/actions/build_and_test_ya
        with:
          build_preset: ${{ inputs.build_preset }}
          increment: false
          build_target: ${{ inputs.test_targets }}
          run_build: true
          run_tests: true
          test_retry_count: 3
          test_size: ${{ inputs.test_size }}
          test_type: ${{ inputs.test_type }}
          test_threads: ${{ fromJson(env.threads_count) }}
          custom_branch_name: ${{ needs.prepare.outputs.base_branch || matrix.branch }}
          put_build_results_to_cache: true
          collect_coredumps: ${{ inputs.collect_coredumps }}
          additional_ya_make_args: -DDEBUGINFO_LINES_ONLY ${{ inputs.additional_ya_make_args }}
          pull_number: ${{ inputs.pull_number }}
          secs: ${{ format('{{"AWS_KEY_ID":"{0}","AWS_KEY_VALUE":"{1}","REMOTE_CACHE_USERNAME":"{2}","REMOTE_CACHE_PASSWORD":"{3}","TELEGRAM_YDBOT_TOKEN":"{4}"}}',
            secrets.AWS_KEY_ID, secrets.AWS_KEY_VALUE, secrets.REMOTE_CACHE_USERNAME, secrets.REMOTE_CACHE_PASSWORD, secrets.TELEGRAM_YDBOT_TOKEN ) }}
          vars: ${{ format('{{"AWS_BUCKET":"{0}","AWS_ENDPOINT":"{1}","REMOTE_CACHE_URL":"{2}","GH_ALERTS_TG_LOGINS":"{3}","GH_ALERTS_TG_CHAT":"{4}"}}',
            vars.AWS_BUCKET, vars.AWS_ENDPOINT, vars.REMOTE_CACHE_URL_YA, vars.GH_ALERTS_TG_LOGINS, vars.GH_ALERTS_TG_CHAT ) }}

