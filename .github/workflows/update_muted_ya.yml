name: Update Muted tests

on:
  schedule:
    - cron: "0 4-21/1 * * *"  # Every 1 hours from 4:00 to 21:00 UTC
  workflow_dispatch:
    inputs:
      branches:
        description: 'Comma-separated list of branches to process (empty = use branches from config file)'
        required: false
        default: ''

env:
  BRANCHES_CONFIG_PATH: .github/config/stable_tests_branches.json
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  PR_BRANCH_PREFIX: update-muted-ya
  TITLE: "Update muted_ya.txt"
  REVIEWERS: '["ci"]'
  LABELS: "mute-unmute,not-for-changelog,ok-to-test"
  BUILD_TYPE: relwithdebinfo

jobs:
  setup:
    runs-on: [ self-hosted, auto-provisioned, build-preset-analytic-node]
    outputs:
      matrix_branches: ${{ steps.set-matrix.outputs.branches }}
    steps:
      - name: Checkout branches config
        uses: actions/checkout@v4
        with:
          ref: main
          path: config-repo
          sparse-checkout: |
            ${{ env.BRANCHES_CONFIG_PATH }}
          sparse-checkout-cone-mode: false

      - id: set-matrix
        env:
          BRANCHES_INPUT: ${{ github.event.inputs.branches }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          if [ "$EVENT_NAME" == "workflow_dispatch" ] && [ -n "$BRANCHES_INPUT" ]; then
            echo "branches=$(echo "$BRANCHES_INPUT" | jq -R -s -c 'split(",") | map(gsub("^\\s+"; "") | gsub("\\s+$"; "")) | map(select(length > 0))')" >> $GITHUB_OUTPUT
          else
            echo "branches=$(jq -c '.' config-repo/$BRANCHES_CONFIG_PATH)" >> $GITHUB_OUTPUT
          fi

      - name: Log branches to process
        run: |
          BRANCHES='${{ steps.set-matrix.outputs.branches }}'
          echo "### Branches to process" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$BRANCHES" | jq -r '.[]' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Branches to process: $(echo "$BRANCHES" | jq -r '.[]' | tr '\n' ' ')"

  collect-testowners:
    runs-on: [ self-hosted, auto-provisioned, build-preset-analytic-node]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ydb[yc] codeowners pandas

      - name: Setup ydb access
        uses: ./.github/actions/setup_ci_ydb_service_account_key_file_credentials
        with:
          ci_ydb_service_account_key_file_credentials: ${{ secrets.CI_YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS }}
    
      - name: Collect testowners
        run: python3 .github/scripts/analytics/upload_testowners.py

  update-muted-tests:
    needs: [setup, collect-testowners]
    runs-on: [ self-hosted, auto-provisioned, build-preset-analytic-node]
    strategy:
      fail-fast: false
      matrix:
        BASE_BRANCH: ${{ fromJson(needs.setup.outputs.matrix_branches) }}
    steps:
      - name: Set environment variables
        run: |
          echo "BASE_BRANCH=${{ matrix.BASE_BRANCH }}" >> $GITHUB_ENV
          PR_BRANCH="${{ env.PR_BRANCH_PREFIX }}_${{ matrix.BASE_BRANCH }}"
          echo "PR_BRANCH=${PR_BRANCH}" >> $GITHUB_ENV

      # Всегда checkout main для получения актуальных скриптов
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.YDBOT_TOKEN }}
          ref: main
          fetch-depth: 0

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ydb[yc] PyGithub codeowners pandas

      - name: Setup ydb access
        uses: ./.github/actions/setup_ci_ydb_service_account_key_file_credentials
        with:
          ci_ydb_service_account_key_file_credentials: ${{ secrets.CI_YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS }}

      # Получаем base_muted_ya.txt из целевой ветки
      - name: Get base muted_ya.txt from target branch
        run: |
          echo "Getting base muted_ya.txt from branch: ${{ env.BASE_BRANCH }}"
          git fetch origin ${{ env.BASE_BRANCH }}:refs/remotes/origin/${{ env.BASE_BRANCH }}
          git show origin/${{ env.BASE_BRANCH }}:.github/config/muted_ya.txt > base_muted_ya.txt
          echo "✓ Retrieved base muted_ya.txt from ${{ env.BASE_BRANCH }}"
    
      - name: Collect test history data
        run: python3 .github/scripts/analytics/flaky_tests_history.py --branch=${{ env.BASE_BRANCH }} --build_type=${{ env.BUILD_TYPE }}
      
      - name: Update muted tests in DB
        run: python3 .github/scripts/tests/get_muted_tests.py upload_muted_tests --branch=${{ env.BASE_BRANCH }} --build_type=${{ env.BUILD_TYPE }} --muted_ya_file=base_muted_ya.txt 
      
      - name: Update test monitor
        run: python3 .github/scripts/analytics/tests_monitor.py --branch=${{ env.BASE_BRANCH }} --build_type=${{ env.BUILD_TYPE }}

      - name: Generate new muted_ya.txt
        run: |
          .github/scripts/tests/create_new_muted_ya.py update_muted_ya \
            --branch=${{ env.BASE_BRANCH }} \
            --muted_ya_file=base_muted_ya.txt

      - name: Check if changes exist
        id: changes_check
        run: |
          # Compare base_muted_ya.txt with newly generated file
          if git diff --no-index --quiet base_muted_ya.txt mute_update/new_muted_ya.txt; then
            echo "No changes detected in muted_ya.txt"
            echo "changes=false" >> $GITHUB_ENV
          else
            echo "Changes detected in muted_ya.txt"
            echo "changes=true" >> $GITHUB_ENV
          fi

      - name: Setup git config
        if: env.changes == 'true'
        run: |
          git config user.name YDBot
          git config user.email ydbot@ydb.tech

      - name: Create PR branch and apply changes
        if: env.changes == 'true'
        run: |
          # Создаем PR ветку на основе целевой ветки
          git checkout -B ${{ env.PR_BRANCH }} origin/${{ env.BASE_BRANCH }}
          
          # Копируем новый файл в PR ветку (файл остается в рабочей директории)
          cp mute_update/new_muted_ya.txt .github/config/muted_ya.txt
          
          # Коммитим изменения
          git add .github/config/muted_ya.txt
          git commit -m "Update muted YA file for ${{ env.BASE_BRANCH }}"
          
          echo "✓ PR branch ${{ env.PR_BRANCH }} created with changes"

      - name: Collect PR description
        if: env.changes == 'true'
        run: |
          
          PR_BODY=''
          PR_BODY_FILE="pr_body_content.txt"
          
          PR_BODY+=$'# Muted tests update for ${{ env.BASE_BRANCH }}\n\n'

          if [ -s mute_update/to_delete_debug.txt ]; then
              DELETED_COUNT=$(wc -l < mute_update/to_delete_debug.txt)
              PR_BODY+=$'**Removed from mute: '"${DELETED_COUNT}**"$'\n\n'
              PR_BODY+=$'```\n'
              PR_BODY+=$(cat mute_update/to_delete_debug.txt)
              PR_BODY+=$'\n```\n\n'
          fi
          if [ -s mute_update/to_mute_debug.txt ]; then
              MUTED_COUNT=$(wc -l < mute_update/to_mute_debug.txt)
              PR_BODY+=$'**Muted flaky: '"${MUTED_COUNT}**"$'\n\n'
              PR_BODY+=$'```\n'
              PR_BODY+=$(cat mute_update/to_mute_debug.txt)
              PR_BODY+=$'\n```\n\n'

              if [ -s mute_update/to_mute.txt ]; then
                  BASE_URL="https://datalens.yandex.cloud/34xnbsom67hcq-ydb-autotests-test-history-link?branch=${{ env.BASE_BRANCH }}"
                  MAX_TESTS=50
                  TEST_COUNT=0
                  FULL_URL="${BASE_URL}"
                  while read -r test_name && [ ${TEST_COUNT} -lt ${MAX_TESTS} ]; do
                    formatted_name=$(echo "${test_name}" | sed 's/ /\//')
                    encoded_name=$(echo "${formatted_name}" \
                      | sed 's/ /%20/g' \
                      | sed 's/\//%2F/g' \
                      | sed 's/\[/%5B/g' \
                      | sed 's/\]/%5D/g' \
                      | sed 's/+/%2B/g' \
                      | sed 's/-/%2D/g')
                    FULL_URL="${FULL_URL}&full_name=${encoded_name}"
                    TEST_COUNT=$((TEST_COUNT+1))
                  done < mute_update/to_mute.txt
                  PR_BODY+=$"[View history of muted flaky tests on Dashboard](${FULL_URL})"
                  PR_BODY+=$'\n'
              fi
          fi
          if [ -s mute_update/to_unmute_debug.txt ]; then
              UNMUTED_COUNT=$(wc -l < mute_update/to_unmute_debug.txt)
              PR_BODY+=$'**Unmuted stable: '"${UNMUTED_COUNT}**"$'\n\n'
              PR_BODY+=$'```\n'
              PR_BODY+=$(cat mute_update/to_unmute_debug.txt)
              PR_BODY+=$'\n```\n\n'
          fi

          echo "$PR_BODY" > "$PR_BODY_FILE"
          echo "PR_BODY_PATH=$PR_BODY_FILE" >> $GITHUB_ENV

      - name: Upload all generated files as artifacts
        if: env.changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: muted-tests-all-files-${{ env.BASE_BRANCH }}
          path: |
            mute_update/
          retention-days: 7

      - name: Push PR branch
        if: env.changes == 'true'
        run: |
          # Retry logic for transient GitHub API timeouts
          MAX_RETRIES=5
          RETRY_DELAY=10
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_RETRIES ]; do
            echo "Attempt $ATTEMPT of $MAX_RETRIES to push branch ${{ env.PR_BRANCH }}"
            
            if git push origin ${{ env.PR_BRANCH }} --force; then
              echo "✓ Successfully pushed branch ${{ env.PR_BRANCH }}"
              exit 0
            else
              EXIT_CODE=$?
              echo "⚠️  Push failed with exit code $EXIT_CODE"
              
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "Waiting ${RETRY_DELAY} seconds before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
              else
                echo "❌ Failed to push after $MAX_RETRIES attempts"
                exit $EXIT_CODE
              fi
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Create or update PR
        if: env.changes == 'true'
        id: create_or_update_pr
        env:
          GITHUB_TOKEN: ${{ secrets.YDBOT_TOKEN }}
        run: |
          # Возвращаемся на main для доступа к скриптам
          git checkout main
          
          python .github/scripts/create_or_update_pr.py create_or_update \
            --base_branch="${{ env.BASE_BRANCH }}" \
            --branch_for_pr="${{ env.PR_BRANCH }}" \
            --title="${{ env.TITLE }} in ${{ env.BASE_BRANCH }}" \
            --body="${{ env.PR_BODY_PATH }}"
        
      - name: Prepare PR comment
        if: env.changes == 'true'
        id: comment_pr
        run: |
          # Читаем содержимое PR body
          PR_BODY_CONTENT=$(cat pr_body_content.txt)
          WORKFLOW_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          COMPLETE_BODY=$(cat << EOF
          Collected in workflow [#${{ github.run_number }}](${WORKFLOW_URL}) for ${{ env.BASE_BRANCH }}

          ${PR_BODY_CONTENT}
          EOF
          )
          
          echo "$COMPLETE_BODY" > pr_comment_final.txt
          echo "PR_COMMENT_FILE=pr_comment_final.txt" >> $GITHUB_OUTPUT

      - name: Add comment, reviewers and labels
        if: env.changes == 'true'
        uses: actions/github-script@v7
        env:
          LABELS: ${{ env.LABELS }}
          REVIEWERS: ${{ env.REVIEWERS }}
        with:
          github-token: ${{ secrets.YDBOT_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Читаем комментарий из файла
            const commentFile = '${{ steps.comment_pr.outputs.PR_COMMENT_FILE }}';
            const commentBody = fs.readFileSync(commentFile, 'utf8');
            
            // Добавляем комментарий
            await github.rest.issues.createComment({
              issue_number: ${{ steps.create_or_update_pr.outputs.pr_number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
            
            // Добавляем лейблы
            const labelsToAdd = process.env.LABELS.split(',');
            await github.rest.issues.addLabels({
              ...context.repo,
              issue_number: ${{ steps.create_or_update_pr.outputs.pr_number }},
              labels: labelsToAdd
            });
            
            // Добавляем ревьюеров
            const reviewers = JSON.parse(process.env.REVIEWERS);
            await github.rest.pulls.requestReviewers({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ steps.create_or_update_pr.outputs.pr_number }},
              team_reviewers: reviewers
            });
          
      - name: Enable auto-merge (squash)
        if: env.changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.YDBOT_TOKEN }}
          script: |
            const pr = ${{ steps.create_or_update_pr.outputs.pr_number }};
            
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr
            });
            
            const mutation = `
              mutation EnableAutoMerge {
                enablePullRequestAutoMerge(input: {
                  pullRequestId: "${pullRequest.node_id}",
                  mergeMethod: SQUASH
                }) {
                  clientMutationId
                }
              }
            `;
            
            try {
              await github.graphql(mutation);
              console.log("Auto-merge with squash successfully enabled");
            } catch (error) {
              console.error("Failed to enable auto-merge with squash:", error);
            }

