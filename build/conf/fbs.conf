FLATC=${tool:"contrib/tools/flatc"}

# tag:fbs
FLATC_FLAGS_VALUE=

### @usage: FLATC_FLAGS(flags...)
###
### Add flags to flatc command line
macro FLATC_FLAGS(FLAGS...) {
    SET_APPEND(FLATC_FLAGS_VALUE $FLAGS)
}

# tag:fbs
_PY_FBS_DEPS=contrib/python/flatbuffers

# tag:fbs tag:internal
### @usage: FBS_TO_PYSRC(output_base_name fbs_files...) # internal
###
### Create a tar archive of .py files generated by flatc for Python. Output tar
### archive will have .fbs.pysrc extension. This .fbs.pysrc extension is specially
### processed when --add-flatbuf-result flag is specified on the command line
### for 'ya make ...' (tar archive is extracted to output directory).
macro FBS_TO_PYSRC(OUT_NAME, IN_FBS_FILES...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $FLATC --python --python-typing --gen-mutable ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR} ${input:IN_FBS_FILES} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --exts .py --input $BINDIR --output ${output;noauto;tared:OUT_NAME.py3.fbs.pysrc} ${kv;hide:"p FP"} ${kv;hide:"pc light-green"} ${kv;hide:"tared_kind nodir"} ${hide:FBS_FAKEID}
}

macro FBS_TO_PY2SRC(OUT_NAME, IN_FBS_FILES...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} ${tool:"contrib/deprecated/flatc"} --python --gen-mutable ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR} ${input:IN_FBS_FILES} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --exts .py --input $BINDIR --output ${output;noauto;tared:OUT_NAME.py2.fbs.pysrc} ${kv;hide:"p FP"} ${kv;hide:"pc light-green"} ${kv;hide:"tared_kind nodir"} ${hide:FBS_FAKEID}
}

# tag:fbs tag:go-specific
# Implicit dependencies of generated code for Go
_GO_FLATC_IMPORTS=\
    ${GOSTD}/bytes \
    ${GOSTD}/strconv \
    vendor/github.com/google/flatbuffers/go

# tag:fbs tag:cpp-specific
macro _CPP_FLATC_CMD(SRC, SRCFLAGS...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $YMAKE_PYTHON3 ${input:"build/scripts/cpp_flatc_wrapper.py"} ${tool:"contrib/tools/flatc"} --no-warnings --cpp --keep-prefix --gen-mutable --schema -b --yandex-maps-iter --gen-object-api --filename-suffix .fbs ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${output;main;norel:SRC.h} ${output;hide;norel:SRC.cpp} ${input:SRC} ${output;hide;noext;norel:SRC.iter.fbs.h} ${output;noauto;hide;noext;norel:SRC.bfbs} ${kv;hide:"p FL"} ${kv;hide:"pc light-green"} ${hide:FBS_FAKEID}
    .SEM=target_fbs_source PRIVATE ${input:SRC} ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} ${output;hide;norel:SRC.h} ${output;hide;norel:SRC.cpp} ${output;hide;noext;norel:SRC.iter.fbs.h} ${output;noauto;hide;noext;norel:SRC.bfbs} ${hide;tool:"contrib/tools/flatc/bin"} && set_global_flags FBS_CPP_FLAGS --no-warnings --cpp --keep-prefix --gen-mutable --schema -b --yandex-maps-iter --gen-object-api --filename-suffix .fbs ${input;hide:"build/scripts/cpp_flatc_wrapper.py"}
    .PEERDIR=contrib/libs/flatbuffers
}

# tag:fbs tag:cpp-specific
macro _CPP_FLATC64_CMD(SRC, SRCFLAGS...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $YMAKE_PYTHON3 ${input:"build/scripts/cpp_flatc_wrapper.py"} ${tool:"contrib/tools/flatc64"} --no-warnings --cpp --keep-prefix --gen-mutable --schema -b --filename-suffix .fbs64 ${FLATC_FLAGS_VALUE} -I ${ARCADIA_ROOT} -I ${ARCADIA_BUILD_ROOT} -o ${output;main;norel:SRC.h} ${output;hide;norel:SRC.cpp} ${input:SRC} ${output;noauto;hide;noext;norel:SRC.bfbs64} ${kv;hide:"p FL64"} ${kv;hide:"pc light-green"} ${hide:FBS_FAKEID}
    .PEERDIR=contrib/libs/flatbuffers64
}

# tag:fbs tag:go-specific tag:internal
### @usage: _GO_FLATC_CMD(fbs_file flags...) # internal
###
### Create a tar archive of .go files generated by flatc for Go. Output tar archive
### will have .fbs.gosrc extension. This .fbs.gosrc is specially processed when
### --add-protobuf-result flag is specified on the command line for 'ya make ...'
### (tar archive is extracted to output directory).
macro _GO_FLATC_CMD(SRC, PACKAGE_NAME) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $FLATC --go --gen-mutable --go-namespace ${PACKAGE_NAME} ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR}/_generated ${input:SRC} && $YMAKE_PYTHON3 ${input:"build/scripts/postprocess_go_fbs.py"} --arcadia-prefix ${GO_ARCADIA_PROJECT_PREFIX} --input-dir ${BINDIR} --map $_FBS_NAMESPACE_MAP_GLOBAL && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --flat --input ${BINDIR}/_generated --output ${output;noext;tared:SRC.fbs.gosrc} --exts .go ${kv;hide:"p FG"} ${kv;hide:"pc light-green"} ${kv;hide:"tared_kind nodir"} ${hide:FBS_FAKEID}
    .PEERDIR=${_GO_FLATC_IMPORTS}
}

# tag:fbs tag:java-specific tag:internal
### @usage: _JAVA_FLATC_CMD(fbs_file) # internal
###
### Create a tar archive of .java files generated by flatc for Java. Output tar
### acrchive will have .fbs.jsrc extension. Files with .fbs.jsrc extension will
### be added to results when --add-flatbuf-result flag is specified on the command
### line for 'ya make ...'
macro _JAVA_FLATC_CMD(SRC, SRCFLAGS...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $FLATC --java --gen-mutable ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR} ${input:SRC} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --input $BINDIR --output ${output;nopath;noext:SRC.fbs.jsrc} --exts .java ${kv;hide:"p FJ"} ${kv;hide:"pc light-green"} ${hide:FBS_FAKEID}
    .PEERDIR=contrib/java/com/google/flatbuffers/flatbuffers-java/${JAVA_FLATBUFFERS_VERSION}
}

# tag:fbs
_FBS_NAMESPACE_MAP_GLOBAL=

# tag:fbs
macro _FBS_NAMESPACE_IMPL(NAMESPACE, PATH, DUMMY...) {
    SET_APPEND(_FBS_NAMESPACE_MAP_GLOBAL ${NAMESPACE}=${PATH})
}

# tag:fbs
macro FBS_NAMESPACE(NAMESPACE, PATH...) {
    _FBS_NAMESPACE_IMPL($NAMESPACE $PATH $MODDIR)
}

# tag:fbs
### @usage: FBS_LIBRARY()
###
### Build some variant of Flatbuffers library.
###
### The particular variant is selected based on where PEERDIR to FBS_LIBRARY
### comes from.
###
### Now supported 5 variants: C++, Java, Python 2.x, Python 3.x and Go.
### When PEERDIR comes from module for particular language appropriate variant
### is selected.
###
### Notes: FBS_NAMESPACE must be specified in all dependent FBS_LIBRARY modules
###        if build of Go code is requested.
multimodule FBS_LIBRARY {
    module CPP_FBS: LIBRARY {
        ENABLE(CPP_FBS)
        ENABLE(GEN_FBS)
        SET(PEERDIR_TAGS CPP_FBS)
    }

    module GO_FBS: GO_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        ENABLE(GO_FBS)
        SET(PEERDIR_TAGS GO GO_FBS)
    }

    module JAVA_FBS: EXTERNAL_JAVA_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        ENABLE(JAVA_FBS)
        SET(PEERDIR_TAGS JAVA_FBS)
    }

    module PY2_FBS: PY2_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        .ALIASES=SRCS=PY_SRCS
        ENABLE(PY2_FBS)
        SET(PEERDIR_TAGS PY2 PY2_FBS)
        # Can not use NO_LINT(), because is not allowed outside of contrib directory
        SET(_NO_LINT_VALUE none_internal)
    }

    module PY3_FBS: PY3_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        .ALIASES=SRCS=PY_SRCS
        ENABLE(PY3_FBS)
        SET(PEERDIR_TAGS PY3 PY3_FBS)
        # Can not use NO_LINT(), because is not allowed outside of contrib directory
        SET(_NO_LINT_VALUE none_internal)
        OBJ_SUF=.py3
    }
}

macro FBS_CMD(SRC, SRCFLAGS...) {
    .CMD=$_FBS_CMDLINE
    .SEM=$_FBS_CMDLINE
}

# tag:proto tag:fbs
### @usage: PROTO2FBS(InputProto)
###
### Produce flatbuf schema out of protobuf description.
macro PROTO2FBS(File) {
    .CMD=${cwd:BINDIR} $FLATC -I . -I ${ARCADIA_ROOT} --proto ${input:File} ${output;hide;norel;noext:File.fbs} ${kv;hide:"p FBS"} ${kv;hide:"pc yellow"} && $MOVE_FILE ${BINDIR}/${nopath;noext:File.fbs} ${output;norel;noext:File.fbs}
}

_CPP_FLATC_CMDLINE=$_CPP_FLATC_CMD($SRC $SRCFLAGS)
_CPP_FLATC64_CMDLINE=$_CPP_FLATC64_CMD($SRC $SRCFLAGS)
_JAVA_FLATC_CMDLINE=$_JAVA_FLATC_CMD($SRC $SRCFLAGS)
