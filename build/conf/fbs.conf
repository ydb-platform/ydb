FLATC=contrib/libs/flatbuffers/flatc
FLATC64=contrib/libs/flatbuffers64/flatc

# tag:fbs
FLATC_FLAGS_VALUE=

### @usage: FLATC_FLAGS(flags...)
###
### Add flags to flatc command line
macro FLATC_FLAGS(FLAGS...) {
    SET_APPEND(FLATC_FLAGS_VALUE $FLAGS)
}

# tag:fbs
_PY_FBS_DEPS=contrib/python/flatbuffers

# tag:fbs tag:internal
### @usage: FBS_TO_PYSRC(output_base_name fbs_files...) # internal
###
### Create a tar archive of .py files generated by flatc for Python. Output tar
### archive will have .fbs.pysrc extension. This .fbs.pysrc extension is specially
### processed when --add-flatbuf-result flag is specified on the command line
### for 'ya make ...' (tar archive is extracted to output directory).
macro FBS_TO_PYSRC(OUT_NAME, IN_FBS_FILES...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} ${tool:FLATC} --python --no-warnings --python-typing --gen-mutable ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR} ${input:IN_FBS_FILES} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --exts .py --input $BINDIR --output ${tared;noauto;output;suf=.py3.fbs.pysrc:OUT_NAME} ${hide;kv:"p FP"} ${hide;kv:"pc light-green"} ${hide;kv:"tared_kind nodir"} ${hide:FBS_FAKEID}
    .STRUCT_CMD=yes
}

macro FBS_TO_PY2SRC(OUT_NAME, IN_FBS_FILES...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} ${tool:"contrib/deprecated/flatc"} --python --gen-mutable ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR} ${input:IN_FBS_FILES} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --exts .py --input $BINDIR --output ${tared;noauto;output;suf=.py2.fbs.pysrc:OUT_NAME} ${hide;kv:"p FP"} ${hide;kv:"pc light-green"} ${hide;kv:"tared_kind nodir"} ${hide:FBS_FAKEID}
    .STRUCT_CMD=yes
}

# tag:fbs tag:go-specific
# Implicit dependencies of generated code for Go
_GO_FLATC_IMPORTS=\
    ${GOSTD}/bytes \
    ${GOSTD}/strconv \
    vendor/github.com/google/flatbuffers/go

# tag:fbs tag:cpp-specific
macro _CPP_FLATC_CMD(SRC, SRCFLAGS...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $YMAKE_PYTHON3 ${input:"build/scripts/cpp_flatc_wrapper.py"} ${tool:FLATC} --no-warnings --cpp --keep-prefix --gen-mutable --schema -b --yandex-maps-iter --gen-object-api --filename-suffix .fbs ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${main;norel;output;suf=.h:SRC} ${hide;norel;output;suf=.cpp:SRC} ${input:SRC} ${hide;norel;output;suf=.iter.fbs.h;noext:SRC} ${hide;noauto;norel;output;suf=.bfbs;noext:SRC} ${hide;kv:"p FL"} ${hide;kv:"pc light-green"} ${hide:FBS_FAKEID}
    .SEM=target_macroses-ITEM && target_macroses-macro target_fbs_source && target_macroses-args PRIVATE ${input:SRC} ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} ${hide;norel;output;suf=.h:SRC} ${hide;norel;output;suf=.cpp:SRC} ${hide;norel;output;suf=.iter.fbs.h;noext:SRC} ${hide;noauto;norel;output;suf=.bfbs;noext:SRC} ${hide;tool:FLATC} && platform_vars-FBS_CPP_FLAGS "--no-warnings --cpp --keep-prefix --gen-mutable --schema -b --yandex-maps-iter --gen-object-api --filename-suffix .fbs" ${hide;input:"build/scripts/cpp_flatc_wrapper.py"}
    .PEERDIR=contrib/libs/flatbuffers
}

# tag:fbs tag:cpp-specific
macro _CPP_FLATC64_CMD(SRC, SRCFLAGS...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $YMAKE_PYTHON3 ${input:"build/scripts/cpp_flatc_wrapper.py"} ${tool:FLATC64} --no-warnings --cpp --keep-prefix --gen-mutable --schema -b --filename-suffix .fbs64 ${FLATC_FLAGS_VALUE} -I ${ARCADIA_ROOT} -I ${ARCADIA_BUILD_ROOT} -o ${main;norel;output;suf=.h:SRC} ${hide;norel;output;suf=.cpp:SRC} ${input:SRC} ${hide;noauto;norel;output;suf=.bfbs64;noext:SRC} ${hide;kv:"p FL64"} ${hide;kv:"pc light-green"} ${hide:FBS_FAKEID}
    .PEERDIR=contrib/libs/flatbuffers64
}

# tag:fbs tag:go-specific tag:internal
### @usage: _GO_FLATC_CMD(fbs_file flags...) # internal
###
### Create a tar archive of .go files generated by flatc for Go. Output tar archive
### will have .fbs.gosrc extension. This .fbs.gosrc is specially processed when
### --add-protobuf-result flag is specified on the command line for 'ya make ...'
### (tar archive is extracted to output directory).
macro _GO_FLATC_CMD(SRC, PACKAGE_NAME) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} ${tool:FLATC} --go --gen-mutable --go-namespace ${PACKAGE_NAME} ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR}/_generated ${input:SRC} && $YMAKE_PYTHON3 ${input:"build/scripts/postprocess_go_fbs.py"} --arcadia-prefix ${GO_ARCADIA_PROJECT_PREFIX} --input-dir ${BINDIR} --map $_FBS_NAMESPACE_MAP_GLOBAL && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --flat --input ${BINDIR}/_generated --output ${tared;output;suf=.fbs.gosrc;noext:SRC} --exts .go ${hide;kv:"p FG"} ${hide;kv:"pc light-green"} ${hide;kv:"tared_kind nodir"} ${hide:FBS_FAKEID}
    .STRUCT_CMD=yes
    .PEERDIR=${_GO_FLATC_IMPORTS}
}

# tag:fbs tag:java-specific tag:internal
### @usage: _JAVA_FLATC_CMD(fbs_file) # internal
###
### Create a tar archive of .java files generated by flatc for Java. Output tar
### acrchive will have .fbs.jsrc extension. Files with .fbs.jsrc extension will
### be added to results when --add-flatbuf-result flag is specified on the command
### line for 'ya make ...'
macro _JAVA_FLATC_CMD(SRC, SRCFLAGS...) {
    .CMD=${cwd:ARCADIA_BUILD_ROOT} ${tool:FLATC} --java --gen-mutable ${FLATC_FLAGS_VALUE} ${pre=-I :_FLATC__INCLUDE} -o ${BINDIR} ${input:SRC} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_sources.py"} --input $BINDIR --output ${output;suf=.fbs.jsrc;nopath;noext:SRC} --exts .java ${hide;kv:"p FJ"} ${hide;kv:"pc light-green"} ${hide:FBS_FAKEID}
    .PEERDIR=contrib/java/com/google/flatbuffers/flatbuffers-java/${JAVA_FLATBUFFERS_VERSION}
}

# tag:fbs
_FBS_NAMESPACE_MAP_GLOBAL=

# tag:fbs
macro _FBS_NAMESPACE_IMPL(NAMESPACE, PATH, DUMMY...) {
    SET_APPEND(_FBS_NAMESPACE_MAP_GLOBAL ${NAMESPACE}=${PATH})
}

# tag:fbs
macro FBS_NAMESPACE(NAMESPACE, PATH...) {
    _FBS_NAMESPACE_IMPL($NAMESPACE $PATH $MODDIR)
}

# tag:fbs
### @usage: FBS_LIBRARY()
###
### Build some variant of Flatbuffers library.
###
### The particular variant is selected based on where PEERDIR to FBS_LIBRARY
### comes from.
###
### Now supported 5 variants: C++, Java, Python 2.x, Python 3.x and Go.
### When PEERDIR comes from module for particular language appropriate variant
### is selected.
###
### Notes: FBS_NAMESPACE must be specified in all dependent FBS_LIBRARY modules
###        if build of Go code is requested.
multimodule FBS_LIBRARY {
    module CPP_FBS: LIBRARY {
        ENABLE(CPP_FBS)
        ENABLE(GEN_FBS)
        SET(PEERDIR_TAGS CPP_FBS)
    }

    module GO_FBS: GO_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        ENABLE(GO_FBS)
        SET(PEERDIR_TAGS GO GO_FBS)
    }

    module JAVA_FBS: JAR_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        ENABLE(JAVA_FBS)
        SET(PEERDIR_TAGS JAVA_FBS)
    }

    module PY2_FBS: PY2_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        .ALIASES=SRCS=PY_SRCS
        .INCLUDE_TAG=no
        ENABLE(PY2_FBS)
        SET(PEERDIR_TAGS PY2 PY2_FBS)
        # Can not use NO_LINT(), because is not allowed outside of contrib directory
        SET(_NO_LINT_VALUE none_internal)
    }

    module PY3_FBS: PY3_LIBRARY {
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
        .ALIASES=SRCS=PY_SRCS
        ENABLE(PY3_FBS)
        SET(PEERDIR_TAGS PY3 PY3_FBS)
        # Can not use NO_LINT(), because is not allowed outside of contrib directory
        SET(_NO_LINT_VALUE none_internal)
        OBJ_SUF=.py3
    }
}

macro FBS_CMD(SRC, SRCFLAGS...) {
    .CMD=$_FBS_CMDLINE
    .SEM=$_FBS_CMDLINE
}

# tag:proto tag:fbs
### @usage: PROTO2FBS(InputProto)
###
### Produce flatbuf schema out of protobuf description.
macro PROTO2FBS(File) {
    .CMD=${cwd:BINDIR} ${tool:FLATC} -I . -I ${ARCADIA_ROOT} --proto ${input:File} ${hide;norel;output;suf=.fbs;noext:File} ${hide;kv:"p FBS"} ${hide;kv:"pc yellow"} && $MOVE_FILE ${BINDIR}/${suf=.fbs;nopath;noext:File} ${norel;output;suf=.fbs;noext:File}
    .STRUCT_CMD=yes
}

_CPP_FLATC_CMDLINE=$_CPP_FLATC_CMD($SRC $SRCFLAGS)
_CPP_FLATC64_CMDLINE=$_CPP_FLATC64_CMD($SRC $SRCFLAGS)
_JAVA_FLATC_CMDLINE=$_JAVA_FLATC_CMD($SRC $SRCFLAGS)
