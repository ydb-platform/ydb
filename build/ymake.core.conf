# !!! DISCLAIMER! PLEASE DON'T IGNORE !!!
# The FAKEID value is huge hammer. It affects UIDs of all nodes in build graph including, but not limited to
# any resource fetch (think java contrib), build on any language (C++, Python, Java, Go), any code generation.
# Any build after this change will pay the price:
# - Local builds and Sandbox builds will reload all resources from Sandbox and cached data from YT (if ready).
# - Distributed (YT) cache warmup will take significant time to catch up and will need to recache everything.
# - Autocheck will rebuild and recache everything.
# Use this with extreme care and only change if it is ultimately needed. Consider more specific XXX_FAKEIDs below instead.
FAKEID=314159265358

SANDBOX_FAKEID=${FAKEID}.7600000
CPP_FAKEID=2023-06-06
GO_FAKEID=11100371
ANDROID_FAKEID=2023-05-17
CLANG_TIDY_FAKEID=2023-06-06
CYTHON_FAKE_ID=10784829
JAVA_FAKEID=10849009

# Change of this value will invalidate some parts of configure cache
# but will not affect builds anyhow (except tests referring build/ directory)
JSON_CACHE_FAKE_ID=11215402

CURDIR=.
MODDIR=.
BINDIR=bin:/
SRCDIR=
YMAKE=ymake
ECHO=echo
INCLUDE_EXTS=.h .hh .hpp .rli .cuh .inc .i .ipp .ixx .ya_exposed
CPP_EXT=.cpp
OBJ_SUF=
CFLAGS=
EXTRA_C_FLAGS=
SFLAGS=
FORCE_COVERAGE_ENABLED=
FORCE_COVERAGE_DISABLED=

AUTOCHECK_BALANCING_OPTIONS=
SO_OUTPUTS=no

MODULE_PREFIX=
MODULE_SUFFIX=

@import "${CONF_ROOT}/conf/settings.conf"
@import "${CONF_ROOT}/conf/opensource.conf"
@import "${CONF_ROOT}/conf/rules.conf"
@import "${CONF_ROOT}/conf/sysincl.conf"
@import "${CONF_ROOT}/conf/license.conf"
@import "${CONF_ROOT}/conf/ts/ts.conf"
@import "${CONF_ROOT}/conf/docs.conf"
@import "${CONF_ROOT}/conf/swig.conf"
@import "${CONF_ROOT}/conf/perl.conf"
@import "${CONF_ROOT}/conf/proto.conf"
@import "${CONF_ROOT}/conf/fbs.conf"

@import "${CONF_ROOT}/conf/project_specific/other.conf"
@import "${CONF_ROOT}/conf/project_specific/uservices.conf"
@import "${CONF_ROOT}/conf/project_specific/yt.conf"

USE_GLOBAL_CMD=no
when ($OS_WINDOWS != "yes") {
    USE_GLOBAL_CMD=yes
}

when ($USE_PYTHON) {
    C_DEFINES+= -DUSE_PYTHON
}

__COMMA__=${comma:""}

ARCADIA_TEST_ROOT=../arcadia_tests_data/
DEFAULT_REQUIREMENTS=network:restricted cpu:1 ram:32

FAIL_PY2=no

_PREBUILT_TOOLS_ROOT=build/prebuilt
_TOOL_PROTOC_GEN_GO=vendor/github.com/golang/protobuf/protoc-gen-go
_TOOL_PROTOC_GEN_GO_V2=vendor/google.golang.org/protobuf/cmd/protoc-gen-go
_TOOL_PROTOC_GEN_GO_GRPC_V2=vendor/google.golang.org/grpc/cmd/protoc-gen-go-grpc
_TOOL_RESCOMPILER=tools/rescompiler
_TOOL_RESCOMPRESSOR=tools/rescompressor
_TOOL_RORESCOMPILER=tools/rorescompiler

when ($DISABLE_SEPARATE_AUX_CPP != "yes") {
    SEPARATE_AUX_CPP=yes
}

when ($HOST_ARCH_X86_64 == "yes") {
    when ($HOST_OS_DARWIN == "yes" || $HOST_OS_LINUX == "yes" || $HOST_OS_WINDOWS == "yes") {
        VALID_HOST_PLATFORM_FOR_COMMON_PREBUILT_TOOLS=yes

        when ($USE_PREBUILT_TOOLS == "yes" && $ARCH_X86_64 == "yes") {
            _TOOL_PROTOC_GEN_GO=${_PREBUILT_TOOLS_ROOT}/vendor/github.com/golang/protobuf/protoc-gen-go
        }
    }
}

FAIL_MODULE_CMD=$YMAKE_PYTHON3 ${input:"build/scripts/fail_module_cmd.py"} $TARGET ${kv;hide:"p ER"} ${kv;hide:"pc red"}
DEFAULT_TIDY_CONFIG=build/config/tests/clang_tidy/config.yaml
PROJECT_TIDY_CONFIG=build/config/tests/clang_tidy/config.yaml
TIDY=
TIDY_ENABLED=
when($TIDY == "yes") {
    TIDY_ENABLED=yes
}

when ($TIDY_ENABLED == "yes") {
    when ($TIDY_EXPORT_FIXES=="") {
        TIDY_EXPORT_FIXES="no"
    }

    CLANG_TIDY_ARGS=${hide:CLANG_TIDY_FAKEID} $YMAKE_PYTHON ${input:"build/scripts/clang_tidy.py"} "--ymake-python" $YMAKE_PYTHON "--clang-tidy-bin" "$(CLANG_TIDY_BIN)/bin/clang-tidy" "--config-validation-script" ${input:"build/tests/config/clang_tidy/tidy_config_validation.py"} "--testing-src" ${input:SRC} "--source-root" $(SOURCE_ROOT) "--build-root" $(BUILD_ROOT) "--tidy-json" ${output;noauto;suf=${COMPILE_OUT_SUFFIX}${OBJ_CROSS_SUF}.tidyjson:SRC} "--export-fixes" $TIDY_EXPORT_FIXES
    CLANG_TIDY_ARGS+="--default-config-file" ${input:DEFAULT_TIDY_CONFIG}
    CLANG_TIDY_ARGS+="--project-config-file" ${input:PROJECT_TIDY_CONFIG}
    when ($TIDY_CHECKS) {
        CLANG_TIDY_ARGS+="--checks=$TIDY_CHECKS"
    }

    when ($TIDY_HEADER_FILTER) {
        CLANG_TIDY_ARGS+="--header-filter=$TIDY_HEADER_FILTER"
    }

    TIDY_VALUE=USE_CONDITIONAL_SRCS
}
otherwise {
    CLANG_TIDY_ARGS=
    TIDY_VALUE=
}

# tag:codenav
when ($CODENAVIGATION && $NOCODENAVIGATION != "yes") {
    PY_PROGRAM_LINK_EXE=$LINK_EXE ${kv;hide:"pyndex $TARGET"}
    YNDEXER_ARGS=$YMAKE_PYTHON ${input:"build/scripts/yndexer.py"} $CPPYNDEXER_RESOURCE_GLOBAL/yndexer 1500 $(SOURCE_ROOT) $ARCADIA_BUILD_ROOT ${input:SRC}
    YNDEXER_OUTPUT=${output;noauto;suf=${OBJ_CROSS_SUF}${COMPILE_OUT_SUFFIX}.ydx.pb2:SRC}
}
otherwise {
    PY_PROGRAM_LINK_EXE=$LINK_EXE
    YNDEXER_ARGS=
    YNDEXER_OUTPUT=
}

when ($RETRY == "yes") {
    RETRY_ARGS=$YMAKE_PYTHON ${input:"build/scripts/wrapcc.py"}
}
otherwise {
    RETRY_ARGS=
}

COVERAGE_FLAGS=
EXTRA_OUTPUT=
when ($CLANG == "yes" || $GCC == "yes") {
    when ($BUILD_TYPE == "COVERAGE" || $GCOV_COVERAGE) {
        COVERAGE_FLAGS=-fprofile-arcs -ftest-coverage
        EXTRA_OUTPUT=${output;noauto;hide;suf=${COMPILE_OUT_SUFFIX}${_CROSS_SUFFIX}.gcno:SRC}
    }
}

when ($OS_CYGWIN == "yes") {
    CFLAGS+=-D_LDBL_EQ_DBL=1 -U__STRICT_ANSI__
    USE_ASMLIB=no
    FSTACK=
}

CFLAGS+=$COVERAGE_FLAGS
LDFLAGS+=$COVERAGE_FLAGS

CHECKFLAG=
NO_MAPREDUCE=

when ($NO_MAPREDUCE ==  "yes") {
    C_DEFINES+=-DNO_MAPREDUCE
}

when ($OS_ANDROID == "yes") {
    PIE=yes
}

when ($CLANG && $OS_DARWIN && $SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
    SO_OUTPUTS=yes
}

when ($OS_NONE == "yes" || $MAPSMOBI_BUILD_TARGET == "yes" && $OS_LINUX != "yes") {
    USE_STL_SYSTEM=yes
}

# USE_INTERNAL_STL is an internal flag (set on by default) but may be used externally to
# select system standard C++ library when USE_INTERNAL_STL=no is set.
#
# USE_STL_SYSTEM=yes is a regular way to select system standard C++ library.
#
when ($USE_STL_SYSTEM == "yes") {
    USE_INTERNAL_STL=no
}

when ($USE_INTERNAL_STL == "no") {
    USE_STL_SYSTEM=yes
}
otherwise {
    USE_INTERNAL_STL=yes
    # TODO: Extract to conf/sysincl.conf
    # This trigger doesn't work for module level since SYSINCL is processed at
    # configuration stage (This means that NO_RUNTIME() macro called in ya.make
    # won't affect SYSINCL and the only way to make this trigger work correctly
    # is to define configuration variable NORUNTIME (-DNORUNTIME) on the command
    # line when `ya make ...` is invoked.
    when ($NORUNTIME != "yes") {
        SYSINCL+=build/sysincl/stl-to-libcxx.yml
        when ($MUSL == "yes") {
            SYSINCL+=build/sysincl/libc-musl-libcxx.yml
        }
    }
}

# tag:linux-specific
when ($OS_LINUX && $OS_SDK == "ubuntu-14" && $MUSL != "yes") {
    USE_UBUNTU_COMPATIBILITY=yes
}

USE_ARCADIA_PYTHON=yes
USE_ARCADIA_LIBM=no
USE_EAT_MY_DATA=no

HAVE_MKL=
when ($HAVE_MKL == "") {
    when ($OS_LINUX && $ARCH_X86_64 && !$SANITIZER_TYPE) {
        HAVE_MKL=yes
    }
    otherwise {
        HAVE_MKL=no
    }
}

SFDL_TMP_OUT= ${output;tmp:SRC.tmp}

# tag:tool-specific
ARCH_TOOL=${tool:"tools/archiver"}

# tag:tool-specific
FML_TOOL=${tool:"tools/relev_fml_codegen"}
FML_UNUSED_TOOL=${tool:"tools/relev_fml_unused"}
LUA_TOOL=${tool:"tools/lua"}
ENUM_PARSER_TOOL=${tool:"tools/enum_parser/enum_parser"}

FATAL_ERROR_MODULE=no
FATAL_ERROR_MESSAGE=

ANTLR_PYTHON=Python2

### @usage: NO_LTO()
###
### Disable any lto (link-time optimizations) for the module.
### This will compile module source files as usual (without LTO) but will not prevent lto-enabled
### linking of entire program if global settings say so.
macro NO_LTO() {
    DISABLE(USE_LTO)
    DISABLE(USE_THINLTO)
}

# tag:allocator
DEFAULT_ALLOCATOR=LF

# tag:allocator
when ($OS_ANDROID == "yes" || $MSVC == "yes" || $ARCH_TYPE_32 == "yes" || $ARCH_AARCH64 == "yes") {
    DEFAULT_ALLOCATOR=J
}

# tag:allocator
when ($OS_CYGWIN == "yes" || $ARCH_PPC64LE == "yes") {
    DEFAULT_ALLOCATOR=SYSTEM
}

# tag:allocator
when ($OS_DARWIN == "yes") {
    DEFAULT_ALLOCATOR=SYSTEM
}

# tag:allocator
when ($OS_LINUX == "yes") {
    when ($GCC) {
        # tcmalloc broken build
    }
    elsewhen ($SANDBOXING) {
        # broken
    }
    elsewhen ($ARCH_X86_64) {
        DEFAULT_ALLOCATOR=TCMALLOC_TC
    }
}

# tag:allocator
when ($SANITIZER_TYPE) {
    when ($SANITIZER_TYPE != "no") {
        DEFAULT_ALLOCATOR=SYSTEM
    }
}

# tag:allocator
when ($ARCH_XTENSA == "yes") {
    DEFAULT_ALLOCATOR=FAKE
}

# tag:internal
### @usage: CHECK_CONFIG_H(<conf_header>) # internal
###
### This internal macro adds checking code for configuration header in external (contrib) library.
### The check is needed to avoid conflicts on certain types and functions available in arcadia.
###
### @see https://a.yandex-team.ru/arc/trunk/arcadia/build/scripts/check_config_h.py for exact details
macro CHECK_CONFIG_H(Conf) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/check_config_h.py"} ${input;rootrel:Conf} ${output;nopath;noext:Conf.config.cpp} ${kv;hide:"p CH"} ${kv;hide:"pc yellow"}
    OUTPUT_INCLUDES=$Conf
}

REQUIRED_TRANSITIVE_PEERS=
### @usage REQUIRES(dirs...)
###
### Specify list of dirs which this module must depend on indirectly.
###
### This macro can be used if module depends on the directories specified but they can't be listed
### as direct PEERDIR dependencies (due to public include order or link order issues).
macro REQUIRES(DIRS[]) {
    SET_APPEND(REQUIRED_TRANSITIVE_PEERS $DIRS)
}

CHECK_DEPENDENT_DIRS_TYPES=
CHECK_DEPENDENT_DIRS_RESTRICTIONS=
### @usage CHECK_DEPENDENT_DIRS(DENY|ALLOW_ONLY ([ALL|PEERDIRS|GLOB] dir)...)
###
### Specify project transitive dependencies constraints.
###
### @params:
###  1. DENY: current module can not depend on module from any specified directory neither directly nor transitively.
###  2. ALLOW_ONLY: current module can not depend on module from a dir not specified in the directory list neither directly nor transitively.
###  3. ALL: directory constraints following after this modifier are applied to both transitive PEERDIR dependencies and tool dependencies.
###  4. PEERDIRS: directory constraints following after this modifier are applied to transitive PEERDIR dependencies only.
###  5. GLOB: next directory constraint is an ANT glob pattern.
###  6. EXCEPT: next constraint is an exception for the rest of other rules.
###
### Directory constraints added before either ALL or PEERDIRS modifier is used are treated as ALL directory constraints.
###
### Note: Can be used multiple times on the same module all specified constraints will be checked.
### All macro invocation for the same module must use same constraints type (DENY or ALLOW_ONLY)
macro CHECK_DEPENDENT_DIRS(TYPE, ALL?"UNUSED":"", PEERDIRS?"PEERDIRS":"ALL", RESTRICTIONS...) {
    SET_APPEND(CHECK_DEPENDENT_DIRS_RESTRICTIONS $PEERDIRS $RESTRICTIONS)
    SET_APPEND(CHECK_DEPENDENT_DIRS_TYPES $TYPE)
}

macro _RESOURCE_SEM(INPUTS[], KEYS[]) {
    SET(RESOURCE_OUTPUT ${hash:INPUTS}.cpp)
    .SEM=resources ${output;global:RESOURCE_OUTPUT} INPUTS ${input:INPUTS} KEYS $KEYS ${tool;hide:"tools/rescompiler/bin"}
}

# tag:built-in
### @usage: RESOURCE([FORCE_TEXT ][Src Key]* [- Key=Value]*) # built-in
### Add data (resources, random files, strings) to the program)
### The common usage is to place Src file into binary. The Key is used to access it using library/cpp/resource or library/python/resource.
### Alternative syntax with '- Key=Value' allows placing Value string as resource data into binary and make it accessible by Key.
###
### This is a simpler but less flexible option than ARCHIVE(), because in the case of ARCHIVE(), you have to use the data explicitly,
### and in the case of RESOURCE(), the data will fall through SRCS() or SRCS(GLOBAL) to binary linking.
###
### Use the FORCE_TEXT parameter to explicitly mark all Src files as text files: they will not be parsed unless used elsewhere.
###
### @example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a2ispolzujjtekomanduresource
###
### @example:
###
###     LIBRARY()
###         OWNER(user1)
###
###         RESOURCE(
###             path/to/file1 /key/in/program/1
###             path/to/file2 /key2
###         )
###     END()
###
macro RESOURCE(Args...) {
    PEERDIR(library/cpp/resource)
}

# tag:sanitize
RUN_NO_SANITIZE=$YMAKE_PYTHON ${input:"build/scripts/run_tool.py"} --

# tag:sanitize
when ($IS_CROSS_SANITIZE) {
    RUN_NO_SANITIZE=
}

YIELD=$YMAKE_PYTHON ${input:"build/scripts/yield_line.py"} -- ${BINDIR}/__args
XARGS=$YMAKE_PYTHON ${input:"build/scripts/xargs.py"} -- ${BINDIR}/__args

WRITER_PY=$YMAKE_PYTHON ${input:"build/scripts/writer.py"} ${input;hide:"build/scripts/process_command_files.py"}
FS_TOOLS=$YMAKE_PYTHON ${input:"build/scripts/fs_tools.py"} ${input;hide:"build/scripts/process_command_files.py"}
FIX_MSVC_OUTPUT=${YMAKE_PYTHON} ${input:"build/scripts/fix_msvc_output.py"} ${input;hide:"build/scripts/process_command_files.py"}
_PROCESS_WHOLE_ARCHIVE_SCRIPT=${input;hide:"build/scripts/process_command_files.py"} ${input;hide:"build/scripts/process_whole_archive_option.py"}

COPY_CMD=$FS_TOOLS copy
LINK_OR_COPY_CMD=$FS_TOOLS link_or_copy
REMOVE_FILE=$FS_TOOLS remove
MOVE_FILE=$FS_TOOLS rename

# tag:allocator tag:windows-specific
MSVC_DYNAMICBASE=/DYNAMICBASE
when ($ALLOCATOR == "LF") {
    MSVC_DYNAMICBASE=/DYNAMICBASE:NO
}

# tag:sanitize
SANITIZER_CFLAGS=

# variables must be defined for all module types to make generate_mf.py work
NEED_PLATFORM_PEERDIRS=yes
PEERDIR_TEST_TOOL=yes

### @usage: _BARE_UNIT  # internal
###
### The base of all modules describing default bare minimum for all modules.
### To avoid surprises, all buildable modules are better to be inherited from it or its descendants.
module _BARE_UNIT {
    .EXTS=.*
    .CMD=TOUCH_UNIT
    .IGNORED=GO_PROTO_PLUGIN
    .NODE_TYPE=Bundle
    .PEERDIR_POLICY=as_include
    .RESTRICTED=GRPC USE_SKIFF INDUCED_DEPS FUZZ_DICTS FUZZ_OPTS PACK EXPLICIT_OUTPUTS DOCS_DIR DOCS_CONFIG DOCS_VARS YT_SPEC USE_CXX USE_UTIL WHOLE_ARCHIVE PRIMARY_OUTPUT SECONDARY_OUTPUT DEPENDENCY_MANAGEMENT EXCLUDE NO_DOCTESTS EMBED_JAVA_VCS_INFO RESOURCE_FILES PACK_GLOBALS_IN_LIBRARY _EXPOSE GLOBAL_DEPS LIST_PROTO
    .FINAL_TARGET=no

    PEERDIR_TAGS=__EMPTY__
    PEERDIR+=$YMAKE_PYTHON3_PEERDIR

    when ($FATAL_ERROR_MESSAGE && $FATAL_ERROR_MODULE != "yes") {
        PEERDIR+=build/conf_fatal_error
    }

    DEFAULT(MODULE_VERSION)
    DEFAULT(MODULE_PREFIX)
    DEFAULT(MODULE_SUFFIX)
}

### @usage: GEN_LIBRARY()
###
### Definition of a module that brings generated artefacts. This module can PEERDIRed
### from any module. The resulted module is empty and cleaned up during construction
### of the build graph.
###
### NOTE! SRCS macro is not supported for this library.
module GEN_LIBRARY: _BARE_UNIT {
    .PROXY=yes
    .RESTRICTED=SRCS SRC
    .SEM=IGNORED

    # ENABLE(_FAKE_MODULE)
    SET(MODULE_SUFFIX .pkg.fake)
}

### @usage: _BASE_UNIT  # internal
###
### The base of all LIBRARY/PROGRAM modules describing common logic for all modules.
### To avoid surprises, all buildable modules are better to be inherited from it or its descendants.
module _BASE_UNIT: _BARE_UNIT {
    .GLOBAL=_FBS_NAMESPACE_MAP

    PEERDIR_TAGS=CPP_PROTO CPP_FBS H_IDL PY2 PY2_NATIVE YQL_UDF_STATIC __EMPTY__ DLL_LIB

    CPP_PROTO_CMDLINE=${cwd;rootdir;input:File} $PROTOC -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT/$PROTO_NAMESPACE ${pre=-I=:_PROTO__INCLUDE} -I=$ARCADIA_BUILD_ROOT -I=$PROTOBUF_PATH --cpp_out=${CPP_PROTO_PLUGINS}$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE $_PROTOC_FLAGS $PROTOC_STYLEGUIDE_OUT $PROTOC_PLUGIN_STYLEGUIDE ${input;rootrel:File}
    CPP_PROTO_OUTS+=${output;hide;norel;nopath;noext:File.pb.cc} ${output;main;hide;norel;nopath;noext:File.pb.h}
    CPP_PROTO_OUTS_SEM+=${output;main;hide;norel;nopath;noext:File.pb.h}
    CPP_EV_OUTS+=${output;hide;norel:File.pb.cc} ${output;hide;norel:File.pb.h}
    CPP_EV_OUTS_SEM+=${output;hide;norel:File.pb.h}

    when ($SWIG_LANG == "perl") {
        _SWIG_CMD=$_SWIG_PERL_CMD
        _SWIG_ADDINCLS=$_SWIG_PERL_ADDINCLS
        _SWIG_PEERDIR=$_SWIG_PERL_PEERDIR
    }
    elsewhen ($SWIG_LANG == "python") {
        _SWIG_CMD=$_SWIG_PYTHON_CMD
        _SWIG_ADDINCLS=$_SWIG_PYTHON_ADDINCLS
        _SWIG_PEERDIR=$_SWIG_PYTHON_PEERDIR
    }
    elsewhen ($SWIG_LANG == "jni_cpp") {
        _SWIG_CMD=$_SWIG_JNI_CPP_CMD
        _SWIG_ADDINCLS=$_SWIG_JNI_ADDINCLS
        _SWIG_PEERDIR=$_SWIG_JNI_PEERDIR
    }
    elsewhen ($SWIG_LANG == "java") {
        _SWIG_CMD=$_SWIG_JNI_CMD
        _SWIG_ADDINCLS=$_SWIG_JNI_ADDINCLS
        _SWIG_PEERDIR=$_SWIG_JNI_PEERDIR
    }

    when ($PY_PROTOS_FOR == "yes") {
        MACRO_ALIAS(EVLOG_CMD _PY_EVLOG_CMD)
        MACRO_ALIAS(PROTO_CMD _PY_PROTO_CMD)
    }
    otherwise {
        MACRO_ALIAS(EVLOG_CMD _CPP_EVLOG_CMD)
        MACRO_ALIAS(FBS_CMD _CPP_FLATC_CMD)
        when ($BUILD_PROTO_AS_EVLOG == "yes") {
            MACRO_ALIAS(PROTO_CMD _CPP_PROTO_EVLOG_CMD)
        }
        otherwise {
            MACRO_ALIAS(PROTO_CMD _CPP_PROTO_CMD)
        }
        when ($USE_VANILLA_PROTOC == "yes") {
            PROTOC=${tool:"contrib/tools/protoc_std"}
            PROTOC_STYLEGUIDE_OUT=
            PROTOC_PLUGIN_STYLEGUIDE=
            PROTOBUF_PATH=${ARCADIA_ROOT}/contrib/libs/protobuf_std
            MACRO_ALIAS(PROTO_CMD _CPP_VANILLA_PROTO_CMD)
        }
        when ($PROTOC_TRANSITIVE_HEADERS == "no") {
            CPP_PROTO_PLUGINS=transitive_pb_h=false:${CPP_PROTO_PLUGINS}
        }
    }

    SANITIZER_DEFINED=no

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        CFLAGS+=-fsanitize=$SANITIZER_TYPE -D${SANITIZER_TYPE}_sanitizer_enabled $SANITIZER_CFLAGS -fno-omit-frame-pointer
        LDFLAGS+=-fsanitize=$SANITIZER_TYPE
        SANITIZER_DEFINED=yes

        when ($CLANG) {
            CFLAGS+=-fsanitize-blacklist=${input:"build/sanitize-blacklist.txt"} -fno-sanitize-link-runtime
            LDFLAGS+=-fsanitize-blacklist=${input:"build/sanitize-blacklist.txt"} -fno-sanitize-link-runtime
        }
    }

    when ($SANITIZE_COVERAGE && $SANITIZE_COVERAGE != "no") {
        CFLAGS+=-fsanitize-coverage=$SANITIZE_COVERAGE
        LDFLAGS+=-fsanitize-coverage=$SANITIZE_COVERAGE
    }

    POPULATE_CPP_COVERAGE_FLAGS()

    when ($NLG_COVERAGE && $NLG_COVERAGE != "no") {
        CFLAGS+=-DNLG_COVERAGE
    }

    when ($GCC) {
        select ($SANITIZER_TYPE) {
            "address" ? {
                LDFLAGS+=-static-libasan
            }
            "undefined" ? {
                LDFLAGS+=-static-libubsan
            }
            "thread" ? {
                PIE=yes
                LDFLAGS+=-static-libtsan
            }
        }
    }

    when ($HARDENING == "yes") {
        when ($CLANG) {
            CFLAGS+=-fstack-protector-all -D_hardening_enabled_
            LDFLAGS+=-z relro -z now -z noexecstack
            PIE=yes
        }
    }

    when ($USE_LTO == "yes") {
        when ($GCC) {
            CFLAGS+=-flto -fno-fat-lto-objects
            LDFLAGS+=-flto
            NO_LTO_CFLAGS=-fno-lto
        }
        when ($CLANG) {
            CFLAGS+=-flto
            LDFLAGS+=-flto
            NO_LTO_CFLAGS=-fno-lto
        }
    }

    when ($USE_THINLTO == "yes") {
        when ($GCC) {
            CFLAGS+=-flto=thin
            LDFLAGS+=-flto=thin
            NO_LTO_CFLAGS=-fno-lto
        }
        when ($CLANG) {
            CFLAGS+=-flto=thin
            LDFLAGS+=-flto=thin
            NO_LTO_CFLAGS=-fno-lto
        }
    }


    when ($CLANG) {
        when ($PGO_ADD == "yes") {
            CFLAGS+=-fprofile-instr-generate
            LDFLAGS+=-fprofile-instr-generate
        }
        when ($PGO_PATH) {
            CFLAGS+=-fprofile-instr-use=$PGO_PATH -Wno-profile-instr-unprofiled -Wno-profile-instr-out-of-date
            LDFLAGS+=-fprofile-instr-use=$PGO_PATH
        }
    }

    when ($COMPILER_PLATFORM && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=$COMPILER_PLATFORM
    }

    when ($OS_LINUX && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=contrib/libs/linux-headers
    }

    # Adding PEERDIR from trigger doesn't always work. In this case it
    # cause troubles in contrib/libs/libc_compat/ubuntu_14 under musl
    # Workaround this issue by setting variable with PEERDIR in trigger
    # and then adding PEERDIR to it's value    unconditionally.
    when ($USE_UBUNTU_COMPATIBILITY == "yes" && $NEED_PLATFORM_PEERDIRS == "yes") {
        _UBUNTU_COMPAT_PEERDIR=contrib/libs/libc_compat/ubuntu_14
    }
    otherwise {
        _UBUNTU_COMPAT_PEERDIR=
    }
    PEERDIR+=$_UBUNTU_COMPAT_PEERDIR

    when ($NORUNTIME != "yes") {
        PEERDIR+=contrib/libs/cxxsupp
        when ($MAPSMOBI_BUILD_TARGET == "yes") {
            PEERDIR+=build/platform/mapkit
        }
    }

    when ($NOUTIL != "yes") {
        PEERDIR+=util
    }

    when ($MUSL == "yes") {
        CFLAGS += -D_musl_
        LINK_DYN_LIB_FLAGS += --musl
        LINK_SCRIPT_EXE_FLAGS += --musl
        PEERDIR+=contrib/libs/musl/include
    }

    # g++ has proxy C-headers which are incompatible with libc++ proxy C-headers.
    # The same problem exists for clang toolchain. On the other hand, the problem
    # doesn't affect cl since it has united C/C++ library and doesn't need
    # proxy C-headers.
    # Disable all C++ headers including proxy C-headers when we use libc++.
    when ($USE_INTERNAL_STL == "yes" && $MSVC != "yes") {
        CXXFLAGS += -nostdinc++
    }
    otherwise {
        CFLAGS += -DUSE_STL_SYSTEM
    }

    when ($CODENAVIGATION && $NOCODENAVIGATION != "yes") {
        PEERDIR += build/external_resources/codenavigation
    }

    when ($CYTHON_COVERAGE && $CYTHON_COVERAGE == "yes") {
        CFLAGS+=-DCYTHON_TRACE=1 -DCYTHON_TRACE_NOGIL=1
    }

    DEFAULT(USE_SSE4 yes)

    when ($NOSSE != "yes") {
       CFLAGS+=$SSE_CFLAGS
       C_DEFINES+=$SSE_DEFINES
       when ($USE_SSE4 == "yes") {
           CFLAGS+=$SSE4_CFLAGS
           C_DEFINES+=$SSE4_DEFINES
       }
    }
    elsewhen ($MSVC != "yes") {
        CFLAGS += -mno-sse
    }

    POPULATE_CPP_COVERAGE_FLAGS()
    _REGISTER_NO_CHECK_IMPORTS()

    DEFAULT(PACKAGE_PREFIX_ARGS)

    DEFAULT(SWIG_LANG python)
    DEFAULT(GP_FLAGS -CtTLANSI-C -Dk* -c)

    when ($NEED_BINUTILS_PEERDIR && $BINUTILS_USED && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=build/platform/binutils
    }
}

_LINKER_ID=
# GCC does not support -fuse-ld with an executable path,
# only -fuse-ld=gold or -fuse-ld=lld.
when ($_LINKER_ID != "" && $_DEFAULT_LINKER_ID != "" && $CLANG == "yes" && $NEED_PLATFORM_PEERDIRS == "yes") {
    when ($_LINKER_ID in [ "gold", "lld" ]) {
        PEERDIR+=build/platform/${_LINKER_ID}
    }
}

macro _USE_LINKER_IMPL(LINKER_ID...) {
    SET(_LINKER_ID $LINKER_ID)
}

macro _USE_LINKER() {
    _USE_LINKER_IMPL($_DEFAULT_LINKER_ID)
}

### @usage: USE_LINKER_GOLD()
### Use gold linker for a program. This doesn't work in libraries
macro USE_LINKER_GOLD() {
    _USE_LINKER_IMPL(gold)
}

COMMON_LINK_SETTINGS=
LINK_ADDITIONAL_SECTIONS=
LINK_ADDITIONAL_SECTIONS_COMMAND=

when ($COMMON_LINK_SETTINGS == "yes") {
    when ($_LINKER_ID == "lld" && ($OS_LINUX == "yes" || $OS_ANDROID == "yes")) {
         LDFLAGS += -Wl,--gdb-index
    }

    when ($EMBED_LINKER_CREF == "yes") {
        LDFLAGS+=-Wl,--cref ${tmp;stdout;pre=$MODULE_PREFIX;suf=.ldcref:REALPRJNAME} -Wl,--no-demangle
        LINK_ADDITIONAL_SECTIONS+=--add-section=.ya.linker_cref=${tmp;pre=$MODULE_PREFIX;suf=.ldcref:REALPRJNAME}
    }
    elsewhen ($DUMP_LINKER_CREF == "yes") {
        LDFLAGS+=-Wl,--cref ${output;stdout;pre=$MODULE_PREFIX;suf=.ldcref:REALPRJNAME} -Wl,--no-demangle
    }

    when ($EMBED_LINKER_MAP == "yes") {
        LDFLAGS+=-Wl,-Map=${tmp;pre=$MODULE_PREFIX;suf=.map.$_LINKER_ID:REALPRJNAME}
        LINK_ADDITIONAL_SECTIONS+=--add-section=.ya.linker_map.${_LINKER_ID}=${tmp;pre=$MODULE_PREFIX;suf=.map.$_LINKER_ID:REALPRJNAME}
    }
    elsewhen ($DUMP_LINKER_MAP == "yes") {
        LDFLAGS+=-Wl,-Map=${output;rootrel;pre=$MODULE_PREFIX;suf=.map.$_LINKER_ID:REALPRJNAME}
    }

    when ($USE_MKL == "yes") {
        NOPLATFORM=yes
    }

    when (($USE_EAT_MY_DATA == "yes") && ($WIN32 != "yes") && ($DARWIN != "yes") && ($OS_ANDROID != "yes") && ($OS_IOS != "yes")) {
        PEERDIR+=contrib/libs/libeatmydata
        # We can not use LICENSE_RESTRICTION_EXCEPTIONS() macro inside a trigger.
        # Duplicate its implementation here
        MODULE_LICENSES_RESTRICTION_EXCEPTIONS+=contrib/libs/libeatmydata
    }

    when ($USE_ARCADIA_LIBM == "yes") {
        PEERDIR+=contrib/libs/libm
    }
    when ($USE_ARCADIA_LIBM == "no") {
        C_SYSTEM_LIBRARIES+=-lm
    }

    when (($MUSL != "yes" && $WITH_VALGRIND == "yes") || $SANITIZER_DEFINED == "yes") {
        when ($ALLOCATOR in [ "TCMALLOC", "TCMALLOC_SMALL_BUT_SLOW", "TCMALLOC_NUMA_256K", "TCMALLOC_NUMA_LARGE_PAGES", "TCMALLOC_256K", "TCMALLOC_TC", "GOOGLE", "J", "LF", "LF_YT", "LF_DBG", "B", "BM", "C", "LOCKLESS", "YT", "MIM", "HU", "PROFILED_HU" ]) {
            PEERDIR+=library/cpp/malloc/system
        }
    }
    otherwise {
        select ($ALLOCATOR) {
            "MIM" ? {
                PEERDIR+=library/cpp/malloc/mimalloc
            }
            "HU" ? {
                PEERDIR+=library/cpp/malloc/hu
            }
            "PROFILED_HU" ? {
                PEERDIR+=library/cpp/malloc/profiled_hu
            }
            "TCMALLOC_256K" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc
            }
            "TCMALLOC_SMALL_BUT_SLOW" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/small_but_slow
            }
            "TCMALLOC_NUMA_256K" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/numa_256k
            }
            "TCMALLOC_NUMA_LARGE_PAGES" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/numa_large_pages
            }
            "TCMALLOC" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/default
            }
            "TCMALLOC_TC" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/no_percpu_cache
            }
            "GOOGLE" ? {
                PEERDIR+=library/cpp/malloc/galloc
            }
            "J" ? {
                when ($WIN32 == "yes") {
                    PEERDIR+=library/cpp/malloc/system
                }
                otherwise {
                    PEERDIR+=library/cpp/malloc/jemalloc
                }
            }
            "LF" ? {
                PEERDIR+=library/cpp/lfalloc
            }
            "LF_YT" ? {
                PEERDIR+=library/cpp/lfalloc/yt
            }
            "LF_DBG" ? {
                PEERDIR+=library/cpp/lfalloc/dbg
            }
            "B" ? {
                PEERDIR+=library/cpp/balloc
            }
            "BM" ? {
                PEERDIR+=library/cpp/balloc_market
            }
            "C" ? {
                PEERDIR+=library/cpp/malloc/calloc
            }
            "LOCKLESS" ? {
                PEERDIR+=library/cpp/malloc/lockless
            }
            "YT" ? {
                PEERDIR+=library/cpp/ytalloc/impl
            }
        }
    }

    when ($ALLOCATOR == "SYSTEM") {
        PEERDIR+=library/cpp/malloc/system
    }
    when ($WERROR != "no") {
        when ($WERROR_MODE == "all" || ($WERROR_MODE == "compiler_specific" && $WERROR == "yes")) {
            C_WARNING_OPTS += $WERROR_FLAG
        }
    }

    when ($ICC == "yes") {
        PEERDIR+=contrib/libs/intel/core
    }
    when ($WITH_VALGRIND == "yes") {
        PEERDIR+=contrib/libs/valgrind
        # https://st.yandex-team.ru/DTCC-122
        CFLAGS+=-fdebug-default-version=4
    }
}

when ($EMBED_LINKER_MAP == "yes" || $EMBED_LINKER_CREF == "yes") {
    LINK_ADDITIONAL_SECTIONS_COMMAND+= \
        $OBJCOPY_TOOL $LINK_ADDITIONAL_SECTIONS $TARGET
}

_SO_EXT_FILTER=${ext=.so:PEERS} ${hide;late_out;nopath;ext=.so;pre=$BINDIR/:PEERS}
when ($OS_WINDOWS == "yes") {
    _SO_EXT_FILTER=${ext=.dll:PEERS} ${hide;late_out;nopath;ext=.dll;pre=$BINDIR/:PEERS}
}
elsewhen ($OS_DARWIN == "yes" || $OS_IOS == "yes") {
    _SO_EXT_FILTER=${ext=.dylib:PEERS} ${hide;late_out;nopath;ext=.dylib;pre=$BINDIR/:PEERS}
}

LINK_OR_COPY_SO_CMD=
RPATH_GLOBAL=
when ($SO_OUTPUTS == "yes") {
    LINK_OR_COPY_SO_CMD=$FS_TOOLS link_or_copy_to_dir --no-check $_SO_EXT_FILTER ${BINDIR}
    LDFLAGS+=$RPATH_GLOBAL
}

# tag:restricted tag:DLL
### $usage: WITH_DYNAMIC_LIBS() # restricted
###
### Include dynamic libraries as extra PROGRAM/DLL outputs
macro WITH_DYNAMIC_LIBS() {
    ENABLE(SO_OUTPUTS)
}

# tag:internal
### $usage: REAL_LINK_EXE_IMPL(peers...) # internal
macro REAL_LINK_EXE_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$REAL_LINK_EXE_CMDLINE && $LINK_OR_COPY_SO_CMD
}

# tag:internal
### $usage: REAL_LINK_EXEC_DYN_LIB_IMPL(peers...) # internal
macro REAL_LINK_EXEC_DYN_LIB_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$REAL_LINK_EXEC_DYN_LIB_CMDLINE
}

# tag:internal
### $usage: REAL_LINK_DYN_LIB_IMPL(peers...) # internal
macro REAL_LINK_DYN_LIB_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$REAL_LINK_DYN_LIB_CMDLINE && $LINK_OR_COPY_SO_CMD
}

# tag:internal
### $usage: LINK_EXE_IMPL(peers...) # internal
macro LINK_EXE_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$LINK_EXE_CMDLINE && $LINK_OR_COPY_SO_CMD
}

# tag:internal
### $usage: LINK_EXEC_DYN_LIB_IMPL(peers...) # internal
macro LINK_EXEC_DYN_LIB_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$LINK_EXEC_DYN_LIB_CMDLINE
}

# tag:internal
### @usage: _LINK_UNIT  # internal
###
### The base of all linkable modules: programs, DLLs etc. Describes common linking logic.
module _LINK_UNIT: _BASE_UNIT {
    .EXTS=.o .obj .supp .tidyjson .ld
    .CMD=LINK_EXE
    .ALLOWED=EXTRALIBS OBJADDE_GLOBAL RESOURCE_FILES
    .NODE_TYPE=Program
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes
    .DEFAULT_NAME_GENERATOR=DirName
    .ARGS_PARSER=Base

    DEFAULT(ALLOCATOR $DEFAULT_ALLOCATOR)
    _USE_LINKER()

    #link with libunwind manually
    when ($DARWIN == "yes" && $NOPLATFORM != "yes") {
        PEERDIR += contrib/libs/cxxsupp
    }

    when ($USE_LIBCXXRT == "yes") {
        PEERDIR += contrib/libs/cxxsupp/libcxxrt
    }

    when ($USE_DYNAMIC_CUDA == "yes") {
        LINK_DYN_LIB_FLAGS += --dynamic-cuda
        LINK_SCRIPT_EXE_FLAGS += --dynamic-cuda
    }

    ENABLE(COMMON_LINK_SETTINGS)
    CHECK_PROVIDES()
}

MODULE_TYPE=UNKNOWN

macro ADD_CLANG_TIDY() {
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME clang_tidy)
    when ($TIDY_ENABLED == "yes") {
        _MAKEFILE_INCLUDE_LIKE_DEPS+=${ARCADIA_ROOT}/build/yandex_specific/config/clang_tidy/tidy_project_map.json
        _MAKEFILE_INCLUDE_LIKE_DEPS+=${ARCADIA_ROOT}/build/yandex_specific/config/clang_tidy/tidy_default_map.json
    }
}

# tag:internal
### @usage: _BASE_PROGRAM  # internal
###
### The base of all programs. It adds dependencies to make final artefact complete and runnable.
module _BASE_PROGRAM: _LINK_UNIT {
    .SYMLINK_POLICY=EXE
    .ALLOWED=INDUCED_DEPS WHOLE_ARCHIVE
    .GLOBAL=LDFLAGS _WHOLE_ARCHIVE_LIBS_VALUE RPATH
    SET(MODULE_TYPE PROGRAM)
    SET(MODULE_LANG CPP)
    FORCE_COVERAGE_ENABLED=yes

    when ($OS_IOS == "yes") {
        EXTS+=.ios.interface
    }

    when ($WIN32 == "yes" || $OS_CYGWIN == "yes") {
        MODULE_SUFFIX=.exe
    }

    when ($TIDY_ENABLED == "yes") {
        MODULE_SUFFIX=.tidyjson
    }

    when ($MSVC != "yes" && $NOPLATFORM != "yes" && $WITH_VALGRIND != "yes" && $USE_ASMLIB != "no" && $MIC_ARCH != "yes" && $PIC != "yes" && $PIE != "yes") {
        when ($OS_LINUX == "yes" && $ARCH_X86_64 == "yes" && $MUSL != "yes" && $SANITIZER_DEFINED != "yes" && $USE_THINLTO != "yes") {
            PEERDIR+=contrib/libs/glibcasm
        }
        otherwise {
            PEERDIR+=contrib/libs/asmlib
        }
    }

    when ($MUSL == "yes") {
        when ($MUSL_LITE == "yes") {
            PEERDIR += contrib/libs/musl
        }
        otherwise {
            PEERDIR += contrib/libs/musl/full
        }
    }

    DEFAULT(CPU_CHECK yes)
    when ($USE_SSE4 != "yes" || $NOUTIL == "yes" || $ALLOCATOR == "FAKE") {
        CPU_CHECK = no
    }

    when ($CPU_CHECK == "yes") {
        PEERDIR += library/cpp/cpuid_check
    }

    when ($USE_ARC_PROFILE == "yes" && $NOUTIL != "yes") {
        PEERDIR += library/cpp/execprofile/autostart
    }

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        PEERDIR += contrib/libs/cxxsupp/libsan
        when ($CLANG) {
            select ($TARGET_PLATFORM) {
                "LINUX" ? {
                    PEERDIR += library/cpp/sanitizer/${SANITIZER_TYPE}/static
                }
                "DARWIN" ? {
                    # Memory sanitizer is not supported for darwin platform.
                    # https://clang.llvm.org/docs/MemorySanitizer.html#supported-platforms
                    when ($SANITIZER_TYPE != "memory") {
                        PEERDIR += library/cpp/sanitizer/${SANITIZER_TYPE}/dynamic
                    }
                }
                default ? {
                    FATAL_ERROR_MESSAGE+=Unsupported platform for sanitizer
                }
            }
        }
    }

    when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no") {
        PEERDIR+=library/cpp/testing/dump_clang_coverage
    }

    when ($IDE_MSVS == "yes") {
        PEERDIR+=build/scripts/c_templates
    }

    when ($_CUSTOM_LINK_STEP_SCRIPT) {
        LINK_SCRIPT_EXE_FLAGS+=--python=$YMAKE_PYTHON --custom-step=${input:_CUSTOM_LINK_STEP_SCRIPT}
    }
}

VCS_INFO_SEM=vcs_info ${input;hide:"build/scripts/vcs_info.py"} ${input;hide:"build/scripts/c_templates/svn_interface.c"} ${input;hide:"build/scripts/c_templates/svnversion.h"}
CPP_PROGRAM_SEM=add_executable $MODDIR $CMAKE_TARGET_NAME ${hide:TARGET} ${hide:AUTO_INPUT} $CMAKE_TARGET_ARTEFACT_RENAME_RULES \
                && ${VCS_INFO_SEM} \
                && target_link_options PRIVATE $LDFLAGS_GLOBAL_RAW $LDFLAGS $OBJADDE_LIB $OBJADDE \
                && target_include_directories PRIVATE $_C__INCLUDE_OWNED \
                && target_compile_options PRIVATE $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
                && target_compile_options PRIVATE $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW
### @usage: PROGRAM([progname])
###
### Regular program module.
### If name is not specified it will be generated from the name of the containing project directory.
module PROGRAM: _BASE_PROGRAM {
    .SEM=CPP_PROGRAM_SEM

    ADD_YTEST($MODULE_PREFIX$REALPRJNAME coverage.extractor)
    ADD_CLANG_TIDY()
}

### @usage: EXPORTS_SCRIPT(exports_file)
###
### Specify exports script within PROGRAM, DLL and DLL-derived modules.
### This accepts 2 kind of files: .exports with <lang symbol> pairs and JSON-line .symlist files.
### The other option use EXPORTS parameter of the DLL module itself.
###
### @see: [DLL](#module_DLL)
macro EXPORTS_SCRIPT(Arg) {
    SET(EXPORTS_FILE $Arg)
}

### @usage: NO_EXPORT_DYNAMIC_SYMBOLS()
###
### Disable exporting all non-hidden symbols as dynamic when linking a PROGRAM.
macro NO_EXPORT_DYNAMIC_SYMBOLS() {
    ENABLE(NO_EXPORT_DYNAMIC_SYMBOLS)
}

### @usage: EXPORT_ALL_DYNAMIC_SYMBOLS()
###
### Export all non-hidden symbols as dynamic when linking a PROGRAM.
macro EXPORT_ALL_DYNAMIC_SYMBOLS() {
    # Dummy: default behaviour
    ENABLE(EXPORT_ALL_DYNAMIC_SYMBOLS)
}

### @usage: USE_DYNAMIC_CUDA()
###
### Enable linking of PROGRAM with dynamic CUDA. By default CUDA uses static linking
macro USE_DYNAMIC_CUDA() {
    LDFLAGS(-Wl,-rpath,$ORIGIN)
    ENABLE(USE_DYNAMIC_CUDA)
}

### @usage: CUSTOM_LINK_STEP_SCRIPT(name)
###
### Specifies name of a script for custom link step. The scripts
### should be placed in the build/scripts directory and are subject to
### review by devtools@.
macro CUSTOM_LINK_STEP_SCRIPT(Name) {
    SET(_CUSTOM_LINK_STEP_SCRIPT build/scripts/$Name)
}

### @usage: _BASE_UNITTEST  # internal
###
### Module with base logic for all unit-test modules: it makes code runnable as unit-test by Arcadia testing machinery.
module _BASE_UNITTEST: _BASE_PROGRAM {
    .FINAL_TARGET=no
    .NODE_TYPE=Program
    .ALLOWED=YT_SPEC
    when ($UT_SKIP_EXCEPTIONS == "yes") {
        C_DEFINES+=-DUT_SKIP_EXCEPTIONS
    }
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
}

_TEST_SPLIT_FACTOR_SEM=1
_TEST_TIMEOUT_SEM=
_TEST_PARTITION_SEM=
UNITTEST_SEM=$CPP_PROGRAM_SEM \
    && set_property TARGET $REALPRJNAME PROPERTY SPLIT_FACTOR $_TEST_SPLIT_FACTOR_SEM \
    $_TEST_PARTITION_SEM \
    && add_yunittest NAME $REALPRJNAME TEST_TARGET $REALPRJNAME TEST_ARG --print-before-suite --print-before-test --fork-tests --print-times --show-fails \
    && set_yunittest_property TEST $REALPRJNAME PROPERTY LABELS $TEST_SIZE_NAME $FILTER_ONLY_TEST_TAGS \
    && add_ytest_requirements $REALPRJNAME $DEFAULT_REQUIREMENTS $TEST_REQUIREMENTS_VALUE \
    $_TEST_TIMEOUT_SEM

# tag:test
### @usage: UNITTEST([name])
###
### Unit test module based on library/cpp/testing/unittest.
### It is recommended not to specify the name.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#opisanievya.make1
module UNITTEST: _BASE_UNITTEST {
    .SEM=UNITTEST_SEM
    .DEFAULT_NAME_GENERATOR=FullPath
    .ARGS_PARSER=Base
    PEERDIR(library/cpp/testing/unittest_main)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME unittest.py)

    when ($TEST_FORK_MODE != "none") {
        when ($TEST_SPLIT_FACTOR) {
            _TEST_SPLIT_FACTOR_SEM=$TEST_SPLIT_FACTOR
        }
        otherwise {
            _TEST_SPLIT_FACTOR_SEM=10
        }
        when ($TEST_PARTITION == "MODULO") {
            _TEST_PARTITION_SEM=&& set_property TARGET $REALPRJNAME PROPERTY SPLIT_TYPE $TEST_PARTITION \
        }
    }
    when ($TEST_TIMEOUT) {
        _TEST_TIMEOUT_SEM=&& set_yunittest_property TEST $REALPRJNAME PROPERTY TIMEOUT $TEST_TIMEOUT
    }
}

# tag:yt-specific tag:test
### @usage: YT_UNITTEST([name])
###
### YT Unit test module based on library/cpp/testing/unittest with NYT::Initialize hook
module YT_UNITTEST: _BASE_UNITTEST {
    PEERDIR(library/cpp/testing/unittest_main mapreduce/yt/tests/yt_initialize_hook)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME unittest.py)
}

# tag:test
### @usage: UNITTEST_WITH_CUSTOM_ENTRY_POINT([name])
###
### Generic unit test module.
module UNITTEST_WITH_CUSTOM_ENTRY_POINT: _BASE_UNITTEST {
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME unittest.py)
}

GTEST_SEM=$CPP_PROGRAM_SEM \
    && add_test NAME $REALPRJNAME COMMAND $REALPRJNAME \
    && set_property TEST $REALPRJNAME PROPERTY LABELS $TEST_SIZE_NAME $FILTER_ONLY_TEST_TAGS \
    && add_test_requirements $REALPRJNAME $DEFAULT_REQUIREMENTS $TEST_REQUIREMENTS_VALUE \
    $_TEST_TIMEOUT_SEM

# tag:cpp-specific tag:test
### @usage: GTEST([name])
###
### Unit test module based on library/cpp/testing/gtest.
### It is recommended not to specify the name.
###
### Documentation: https://docs.yandex-team.ru/arcadia-cpp/cpp_test
module GTEST: _BASE_UNITTEST {
    .SEM=GTEST_SEM
    .DEFAULT_NAME_GENERATOR=FullPath
    .ARGS_PARSER=Base
    PEERDIR(library/cpp/testing/gtest library/cpp/testing/gtest_main)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME gunittest)

    when ($TEST_TIMEOUT) {
        _TEST_TIMEOUT_SEM=&& set_property TEST $REALPRJNAME PROPERTY TIMEOUT $TEST_TIMEOUT
    }
}

USE_AFL=no

# tag:fuzzing
### @usage: FUZZ()
###
### In order to start using Fuzzing in Arcadia, you need to create a FUZZ module with the implementation of the function LLVMFuzzerTestOneInput().
### This module should be reachable by RECURSE from /autocheck project in order for the corpus to be regularly updated.
### AFL and Libfuzzer are supported in Arcadia via a single interface, but the automatic fuzzing still works only through Libfuzzer.
###
### Example: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/re2/re2/fuzzing/re2_fuzzer.cc?rev=2919463#L58
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
module FUZZ: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .ALLOWED=FUZZ_DICTS FUZZ_OPTS

    SET(LIBFUZZER_PATH contrib/libs/libfuzzer)
    when ($USE_AFL == "no") {
        PEERDIR+=$LIBFUZZER_PATH
    }
    when ($USE_AFL == "yes") {
        PEERDIR+=$LIBFUZZER_PATH/afl
    }

    when (!$SANITIZER_TYPE || $SANITIZER_TYPE == "no") {
        PEERDIR+=devtools/nofuzz
    }

    ADD_YTEST($MODULE_PREFIX$REALPRJNAME fuzz.test)
}

# tag:ios-specific
PACK_IOS_CMD=
when ($OS_IOS && $BUILD_IOS_APP) {
    PACK_IOS_CMD=$YMAKE_PYTHON ${input:"build/scripts/pack_ios.py"} --binary $TARGET --target $TARGET --temp-dir $BINDIR $PEERS
}

LINK_BOOSTTEST_CMD=
BOOST_TEST_TYPE_STRING=

when ($BOOSTTEST_IS_FAT_OBJECT) {
    LINK_BOOSTTEST_CMD=$LINK_RECURSIVE_LIBRARY
    BOOST_TEST_TYPE_STRING=no.test
}
otherwise {
    LINK_BOOSTTEST_CMD=$LINK_EXE
    BOOST_TEST_TYPE_STRING=boost.test
}

# tag:deprecated
### @usage: BOOSTTEST([name]) #deprecated
###
### Test module based on boost/test/unit_test.hpp.
### As with entire boost library usage of this technology is deprecated in Arcadia and restricted with configuration error in most of projects.
### No new module of this type should be introduced unless it is explicitly approved by C++ committee.
module BOOSTTEST: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .CMD=LINK_BOOSTTEST_CMD
    PEERDIR(library/cpp/testing/boost_test)
    when ($BOOSTTEST_IS_FAT_OBJECT) {
        MODULE_SUFFIX=.a
    }
    elsewhen ($OS_IOS && $BUILD_IOS_APP) {
        PEERDIR+=devtools/boosttest_ios_wrapper/library
        MODULE_SUFFIX=.ios.tar
    }
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME $BOOST_TEST_TYPE_STRING)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
}

# tag:deprecated
### @usage BOOSTTEST_WITH_MAIN([name]) #deprecated
###
### Same as BOOSTTEST (see above), but comes with builtin int main(argc, argv) implementation
module BOOSTTEST_WITH_MAIN: BOOSTTEST {
    PEERDIR(library/cpp/testing/boost_test_main)
}

FUZZ_DICTS_VALUE=
### @usage: FUZZ_DICTS(path1 [path2...])
###
### Allows you to specify dictionaries, relative to the root of Arcadia, which will be used in Fuzzing.
### Libfuzzer and AFL use a single syntax for dictionary descriptions.
### Should only be used in FUZZ modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
macro FUZZ_DICTS(Data...) {
    SET_APPEND(FUZZ_DICTS_VALUE $Data)
}

FUZZ_OPTS_VALUE=
### @usage: FUZZ_OPTS(opt1 [Opt2...])
###
### Overrides or adds options to the corpus mining and fuzzer run.
### Currently supported only Libfuzzer, so you should use the options for it.
### Should only be used in FUZZ modules.
###
### @example:
###
###     FUZZ_OPTS (
###         -max_len=1024
###         -rss_limit_mb=8192
###     )
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
macro FUZZ_OPTS(Data...) {
    SET_APPEND(FUZZ_OPTS_VALUE $Data)
}

# tag:yt-specific tag:test
TEST_YT_SPEC_VALUE=
### @usage: YT_SPEC(path1 [path2...])
###
### Allows you to specify json-files with YT task and operation specs,
### which will be used to run test node in the YT.
### Test must be marked with ya:yt tag.
### Files must be relative to the root of Arcadia.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro YT_SPEC(Data...) {
    SET_APPEND(TEST_YT_SPEC_VALUE $Data)
}

# tag:test
TEST_SRCS_VALUE=
### @usage: TEST_SRCS(Files...)
###
### In PY2TEST, PY3TEST and PY*_LIBRARY modules used as PY_SRCS macro and additionally used to mine test cases to be executed by testing framework.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynapytest
macro TEST_SRCS(Tests...) {
    SET_APPEND(TEST_SRCS_VALUE $Tests)
}

macro DISABLE_DATA_VALIDATION() {
    DISABLE(VALIDATE_DATA)
}

# tag:test
TEST_DATA_VALUE=
### @usage: DATA([path...])
###
### Specifies the path to the data necessary test.
### Valid values are: arcadia/<path> , arcadia_tests_data/<path> and sbr://<resource_id>.
### In the latter case resource will be brought to the working directory of the test before it is started
###
### Used only inside TEST modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#dannyeizrepozitorija
macro DATA(Data...) {
    SET_APPEND(TEST_DATA_VALUE $Data)
    ADD_CHECK(check.data $Data)
}

# tag:test
### @usage: DATA_FILES([path...])
###
### Specifies the path to the arcadia source data necessary test.
### Used only inside TEST modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#dannyeizrepozitorija
macro DATA_FILES(Paths...) {
    SET_APPEND(TEST_DATA_VALUE ${pre=arcadia/:Paths})
    _DATA_FILES($Paths)
}

# tag:test
### @usage: EXPLICIT_DATA()
###
### Disables implicit macro DATA(<module_path>).
ADD_SRCDIR_TO_TEST_DATA=yes
macro EXPLICIT_DATA() {
    SET(ADD_SRCDIR_TO_TEST_DATA no)
}

# tag:test
TEST_TAGS_VALUE=
### @usage: TAG ([tag...])
###
### Each test can have one or more tags used to filter tests list for running.
### There are also special tags affecting test behaviour, for example ya:external, sb:ssd.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#obshhieponjatija
macro TAG(Tags...) {
    SET_APPEND(TEST_TAGS_VALUE $Tags)
}

# tag:test
TEST_REQUIREMENTS_VALUE=
### @usage: REQUIREMENTS([cpu:<count>] [disk_usage:<size>] [ram:<size>] [ram_disk:<size>] [container:<id>] [network:<restricted|full>] [dns:dns64])
###
### Allows you to specify the requirements of the test.
###
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
macro REQUIREMENTS(Tags...) {
    SET_APPEND(TEST_REQUIREMENTS_VALUE $Tags)
}

# tag:test
TEST_ENV_VALUE=
### @usage: ENV(key[=value])
###
### Sets env variable key to value (gets value from system env by default).
macro ENV(Data...) {
    SET_APPEND(TEST_ENV_VALUE ${quo:Data})
}

### @usage: CONFTEST_LOAD_POLICY_LOCAL()
###
### Loads conftest.py files in a way that pytest does it
macro CONFTEST_LOAD_POLICY_LOCAL() {
    SET_APPEND(TEST_ENV_VALUE "CONFTEST_LOAD_POLICY=LOCAL")
}

# tag:test
TEST_RECIPES_VALUE=
### @usage: USE_RECIPE(path [arg1 arg2...])
###
### Provides prepared environment via recipe for test.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/recipes
macro USE_RECIPE(Data...) {
    SET_APPEND(TEST_RECIPES_VALUE $Data)
    SET_APPEND(TEST_RECIPES_VALUE "USE_RECIPE_DELIM")
}

# tag:python-specific tag:test
TEST_PYTHON_PATH_VALUE=

# tag:python-specific tag:test
### @usage: PYTHON_PATH(Path)
###
### Set path to Python that will be used to runs scripts in tests
macro PYTHON_PATH(Path) {
    SET(TEST_PYTHON_PATH_VALUE $Path)
}

# tag:test
SKIP_TEST_VALUE=
### @usage: SKIP_TEST(Reason)
###
### Skip the suite defined by test module. Provide a reason to be output in test execution report.
macro SKIP_TEST(Reason...) {
    SET(SKIP_TEST_VALUE $Reason)
}

# tag:test
LINT_LEVEL_VALUE=extended
_NO_LINT_VALUE=
### @usage: NO_LINT([ktlint])
###
### Do not check for style files included in PY_SRCS, TEST_SRCS, JAVA_SRCS.
### Ktlint can be disabled using NO_LINT(ktlint) explicitly.
macro NO_LINT(ktlint?"ktlint":"none") {
    SET(_NO_LINT_VALUE ${ktlint})
}

### @usage: LINT(<none|base|strict>)
###
### Set linting level for sources of the module
macro LINT(level) {
    SET(LINT_LEVEL_VALUE $level)
}

# tag:cpp-specific tag:test
module CPP_STYLE_TEST_14: PY3TEST_BIN {
    DEPENDS(contrib/libs/clang14/tools/clang-format)
    PEERDIR+=library/python/cpp_test
}

macro STYLE(Globs...) {
    _GLOB(STYLE_SRCS_GLOB ${pre=${ARCADIA_ROOT}:Globs})
    _STYLE(${STYLE_SRCS_GLOB})
}

# tag:cpp-specific tag:deprecated tag:test
### @usage: GTEST_UGLY([name])
###
### Deprecated, do not use in new projects. Use GTEST instead.
###
### The test module based on gtest (contrib/libs/gtest contrib/libs/gmock).
### Use public documentation on gtest for details.
###
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module GTEST_UGLY: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    PEERDIR(contrib/restricted/googletest/googlemock contrib/restricted/googletest/googletest)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME gtest)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
}

# tag:test
### @usage: EXECTEST()
###
### Module definition of generic test that executes a binary.
### Use macro RUN to specify binary to run.
###
### @example:
###
###     EXECTEST()
###         OWNER(g:yatool)
###
###         RUN(
###             cat input.txt
###         )
###         DATA(
###             arcadia/devtools/ya/test/tests/exectest/data
###         )
###         DEPENDS(
###             devtools/dummy_arcadia/cat
###         )
###         TEST_CWD(devtools/ya/test/tests/exectest/data)
###     END()
###
### More examples: https://wiki.yandex-team.ru/yatool/test/#exec-testy
###
### @see: [RUN()](#macro_RUN)
module EXECTEST: _BARE_UNIT {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .ALLOWED=YT_SPEC
    .RESTRICTED=FORK_TEST_FILES
    .DEFAULT_NAME_GENERATOR=FullPath
    .ARGS_PARSER=Base
    SET(MODULE_SUFFIX .pkg.fake)
    SETUP_EXECTEST()
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
}

# tag:cpp-specific tag:test
### @usage: Y_BENCHMARK([benchmarkname])
###
### Benchmark test based on the library/cpp/testing/benchmark.
###
### For more details see: https://wiki.yandex-team.ru/yatool/test/#zapuskbenchmark
module Y_BENCHMARK: PROGRAM {
    .SEM=CPP_PROGRAM_SEM
    PEERDIR(library/cpp/testing/benchmark/main)
}

GBENCH_SEM=$CPP_PROGRAM_SEM \
    && add_test NAME $REALPRJNAME COMMAND $REALPRJNAME \
    && set_property TEST $REALPRJNAME PROPERTY LABELS SMALL $FILTER_ONLY_TEST_TAGS \
    && add_test_requirements $REALPRJNAME $DEFAULT_REQUIREMENTS $TEST_REQUIREMENTS_VALUE \
    $_TEST_TIMEOUT_SEM

# tag:cpp-specific tag:test
### @usage: G_BENCHMARK([benchmarkname])
###
### Benchmark test based on the google benchmark.
###
### For more details see: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/benchmark/README.md
module G_BENCHMARK: _BASE_PROGRAM {
    .SEM=GBENCH_SEM
    PEERDIR(library/cpp/testing/gbenchmark)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME g_benchmark)
}

# tag:test
TEST_ROOT=$(TESTS_DATA_ROOT)
RESULT_MAX_FILE=0
STRIP_FILES=--dont-strip-files
VERIFY_RESULTS=--verify-results
ADDITIONAL_PATH=

# set for tests variables to fill it by YA_DEV or YA
YA_ROOT=ya
when ($YA_DEV == "yes") {
    YA_ROOT=ya-dev
}

# tag:test
### @usage: UNITTEST_FOR(path/to/lib)
###
### Convenience extension of UNITTEST module.
### The UNINTTEST module with additional SRCDIR + ADDINCL + PEERDIR on path/to/lib.
### path/to/lib is the path to the directory with the LIBRARY project.
###
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module UNITTEST_FOR: UNITTEST {
    .SEM=UNITTEST_SEM
    PEERDIR(ADDINCL $UNITTEST_DIR)
    SRCDIR($UNITTEST_DIR)
}

### @usage: _LIBRARY # internal
###
### Base module definition for all libraries.
### Contains basic logic like module properties, default variable values etc.
### All libraries similar to C++-libraries should be inherited from it.
module _LIBRARY: _BASE_UNIT {
    .CMD=LINK_LIB
    .NODE_TYPE=Library
    .PEERDIR_POLICY=as_include
    .EXTS=.o .obj .a .mf .supp .tidyjson .ld .lib
    .ALLOWED=GRPC USE_SKIFF EXTRALIBS OBJADDE_GLOBAL RESOURCE_FILES
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS USER_CONLYFLAGS LDFLAGS SRCS _WHOLE_ARCHIVE_LIBS_VALUE RPATH
    .RESTRICTED=ALLOCATOR SIZE TAG DATA TEST_DATA DEPENDS FORK_TESTS FORK_SUBTESTS SPLIT_FACTOR TEST_CWD RUN TIMEOUT SPLIT_DWARF
    .FINAL_TARGET=no
    .GLOBAL_CMD=GLOBAL_LINK_LIB
    .GLOBAL_EXTS=.o .obj .tidyjson

    GLOBAL_SUFFIX=.global$MODULE_SUFFIX
    #TODO: Remove this hack (really we do not need add fake src at all)
    ENABLE(NEED_ADD_FAKE_SRC)
    _REQUIRE_EXPLICIT_LICENSE(contrib/deprecated contrib/libs contrib/restricted contrib/python)
    CHECK_CONTRIB_CREDITS(contrib/clickhouse contrib/libs contrib/deprecated EXCEPT contrib/deprecated/python)

    when ($USE_MKL == "yes") {
        NOPLATFORM=yes
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.lib
    }
    otherwise {
        when ($TIDY_ENABLED == "yes") {
            MODULE_PREFIX=
            MODULE_SUFFIX=.tidyjson
        }
        otherwise {
            MODULE_PREFIX=lib
            MODULE_SUFFIX=.a
        }
    }

    when ($WERROR != "no") {
        when ($WERROR_MODE == "all" || ($WERROR_MODE == "compiler_specific" && $WERROR == "yes")) {
            C_WARNING_OPTS += $WERROR_FLAG
        }
    }

    when ($WITH_VALGRIND == "yes") {
        PEERDIR+=contrib/libs/valgrind
        # https://st.yandex-team.ru/DTCC-1227
        CFLAGS+=-fdebug-default-version=4
    }

    when ($USE_ARCADIA_LIBM == "yes") {
        PEERDIR+=contrib/libs/libm
    }
}

CPP_LIBRARY_INDUCED_SEM_PROPERTY=consumer_link_library
CPP_LIBRARY_SEM=add_library ${MODDIR} $CMAKE_TARGET_NAME ${hide:TARGET} ${hide:AUTO_INPUT} $CMAKE_TARGET_ARTEFACT_RENAME_RULES \
                && library_fake_marker FAKE_MODULE ${FAKE_MODULE} \
                && ${CPP_LIBRARY_INDUCED_SEM_PROPERTY} PUBLIC $CMAKE_LINK_TARGET \
                && target_include_directories PUBLIC $_C__INCLUDE_GLOBAL \
                && target_include_directories PRIVATE $_C__INCLUDE_OWNED \
                && target_compile_options PRIVATE $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
                && target_compile_options PUBLIC $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW \
                && target_link_options INTERFACE $LDFLAGS_GLOBAL_RAW \
                && add_language C && add_language CXX
CPP_OBJ_LIBRARY_SEM=add_global_library_for ${MODDIR} ${suf=.global:CMAKE_TARGET_NAME} $CMAKE_TARGET_NAME ${hide:GLOBAL_TARGET} ${hide:AUTO_INPUT} \
                && target_include_directories PUBLIC $_C__INCLUDE_GLOBAL \
                && target_include_directories PRIVATE $_C__INCLUDE_OWNED \
                && target_compile_options PRIVATE $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
                && target_compile_options PUBLIC $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW

CMAKE_FIND_PKG=
CMAKE_LINK_TARGET=$REALPRJNAME
CMAKE_FIND_PKG_COMP=
CONAN_REQUIRE=
CONAN_OPTS_SEM=

### @usage: LIBRARY()
###
### The regular static library module.
###
### The LIBRARY() is intermediate module, so when built directly it won't build its dependencies.
### It transitively provides its PEERDIRs to ultimate final target, where all LIBRARY() modules are built and linked together.
###
### This is C++ library, and it selects peers from multimodules accordingly.
###
### It makes little sense to mention LIBRARY in DEPENDS or BUNDLE, package and deploy it since it is not a standalone entity.
### In order to use library in tests PEERDIR it to link into tests.
### If you think you need to distribute static library please contact devtools@ for assistance.
module LIBRARY: _LIBRARY {
    .GLOBAL=_AARS _PROGUARD_RULES
    .SEM=CPP_LIBRARY_SEM
    .GLOBAL_SEM=CPP_OBJ_LIBRARY_SEM
    .DEFAULT_NAME_GENERATOR=ThreeDirNames
    .ARGS_PARSER=Base

    when ($CMAKE_PACKAGE_COMPONENT != "") {
        CMAKE_FIND_PKG_COMP=COMPONENTS $CMAKE_PACKAGE_COMPONENT
    }
    when ($CMAKE_PACKAGE != "") {
        CMAKE_FIND_PKG=find_package $CMAKE_PACKAGE $CMAKE_FIND_PKG_COMP
        CPP_LIBRARY_SEM=$CMAKE_FIND_PKG && ${CPP_LIBRARY_INDUCED_SEM_PROPERTY} PUBLIC $CMAKE_LINK_TARGET $CONAN_REQUIRE $CONAN_OPTS_SEM && IGNORED
    }
    when ($CONAN_REFERENCE != "") {
        CONAN_REQUIRE=&& conan_require $CONAN_REFERENCE
        CPP_LIBRARY_SEM=$CMAKE_FIND_PKG && ${CPP_LIBRARY_INDUCED_SEM_PROPERTY} PUBLIC $CMAKE_LINK_TARGET $CONAN_REQUIRE $CONAN_OPTS_SEM && IGNORED
    }
    when ($CONAN_PKG_OPTS != "") {
        CONAN_OPTS_SEM=&& conan_options $CONAN_PKG_OPTS
    }
    when ($OPENSOURCE_EXPORT == "no") {
        CPP_LIBRARY_SEM=IGNORED
    }
    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no" && $SANITIZE_HEADERS && $SANITIZE_HEADERS != "no") {
        PEERDIR += library/cpp/sanitizer/include
    }

    when ($HAS_CPP_PROTOBUF_PEERS == "yes") {
        PEERDIR+=$CPP_PROTOBUF_PEERS
    }
    SET(MODULE_TYPE LIBRARY)
    SET(MODULE_LANG CPP)

    ADD_CLANG_TIDY()
}

# tag:internal
### @usage: _BARE_MODULE() # internal
###
### Remove unwanted dependencies for "empty" library module
macro _BARE_MODULE() {
    SET(NEED_PLATFORM_PEERDIRS no)
    SET(PEERDIR_TEST_TOOL no)
    DISABLE(WITH_VALGRIND)
    NO_CODENAVIGATION()
    NO_PLATFORM()
    NO_RUNTIME()
    NO_UTIL()
    NO_CLANG_TIDY()
}

# tag:internal
### @usage: _BARE_LINK_MODULE() # internal
###
### Remove unwanted dependencies for "empty" link module
macro _BARE_LINK_MODULE() {
    _BARE_MODULE()
    DISABLE(COMMON_LINK_SETTINGS)
    ALLOCATOR(FAKE)
}

# tag:internal
### @usage: _CONDITIONAL_SRCS([USE_CONDITIONAL_SRCS] Files...) # internal
###
### Adds Files... to SRCS if first word is `USE_CONDITIONAL_SRCS`
### To be used with some variable which is set to `USE_CONDITIONAL_SRCS` under condition
macro _CONDITIONAL_SRCS(USE_CONDITIONAL_SRCS[], DYMMY...) {
    SRCS($USE_CONDITIONAL_SRCS)
}

# XXX: dirty hack for correct LDFLAGS passing
RESOURCES_LIBRARY_LINK=$TOUCH_UNIT
RESOURCES_LIBRARY_SEM=IGNORED

### @usage: RESOURCES_LIBRARY()
###
### Definition of a module that brings its content from external source (Sandbox) via DECLARE_EXTERNAL_RESOURCE macro.
### This can participate in PEERDIRs of others as library but it cannot have own sources and PEERDIRs.
###
### @see: [DECLARE_EXTERNAL_RESOURCE()](#macro_DECLARE_EXTERNAL_RESOURCE)
module RESOURCES_LIBRARY: _BARE_UNIT {
    .CMD=RESOURCES_LIBRARY_LINK
    .SEM=RESOURCES_LIBRARY_SEM
    .ALLOWED=DECLARE_EXTERNAL_RESOURCE EXTRALIBS OBJADDE_GLOBAL
    .RESTRICTED=ALLOCATOR SIZE TAG DATA TEST_DATA DEPENDS FORK_TESTS FORK_SUBTESTS SPLIT_FACTOR TEST_CWD RUN TIMEOUT SRC SRCS PEERDIR SPLIT_DWARF
    .NODE_TYPE=Library
    .PEERDIR_POLICY=as_include
    .EXTS=.o .obj .a .mf .supp .tidyjson .ld .lib
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS USER_CONLYFLAGS LDFLAGS _WHOLE_ARCHIVE_LIBS_VALUE RPATH

    when ($CMAKE_PACKAGE_COMPONENT != "") {
        CMAKE_FIND_PKG_COMP=COMPONENTS $CMAKE_PACKAGE_COMPONENT
    }
    when ($CMAKE_PACKAGE != "") {
        CMAKE_FIND_PKG=find_package $CMAKE_PACKAGE $CMAKE_FIND_PKG_COMP
        RESOURCES_LIBRARY_SEM=$CMAKE_FIND_PKG && ${CPP_LIBRARY_INDUCED_SEM_PROPERTY} PUBLIC $CMAKE_LINK_TARGET $CONAN_REQUIRE $CONAN_OPTS_SEM && IGNORED
    }
    when ($CONAN_REFERENCE != "") {
        CONAN_REQUIRE=&& conan_require $CONAN_REFERENCE
        RESOURCES_LIBRARY_SEM=$CMAKE_FIND_PKG && ${CPP_LIBRARY_INDUCED_SEM_PROPERTY} PUBLIC $CMAKE_LINK_TARGET $CONAN_REQUIRE $CONAN_OPTS_SEM && IGNORED
    }
    when ($CONAN_PKG_OPTS != "") {
        CONAN_OPTS_SEM=&& conan_options $CONAN_PKG_OPTS
    }

    MODULE_SUFFIX=.pkg.fake
    ENABLE(NEED_ADD_FAKE_SRC)
    WITHOUT_LICENSE_TEXTS()
}

FAT_OBJECT_SEM=add_fat_object ${MODDIR} ${CMAKE_TARGET_NAME} ${hide:TARGET} ${hide:AUTO_INPUT} ${CMAKE_TARGET_ARTEFACT_RENAME_RULES} \
    && target_include_directories PRIVATE $_C__INCLUDE_OWNED \
    && target_compile_options PRIVATE $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
    && set_global_flags FAT_OBJECT_PREFIX ${MODULE_PREFIX} \
    && set_global_flags FAT_OBJECT_SUFFIX ${MODULE_SUFFIX}

### Do not turn visibility=hidden symbos into static symbos of partially linked object file
###
### Note: This variable do not have any effect on platforms other than MacOS and iOS.
KEEP_FAT_OBJECT_SYMBOLS=no

### @usage: FAT_OBJECT()
###
### The "fat" object module. It will contain all its transitive dependencies reachable by PEERDIRs:
### static libraries, local (from own SRCS) and global (from peers') object files.
###
### Designed for use in XCode projects for iOS.
module FAT_OBJECT: LIBRARY {
    .ALLOWED=PACK_GLOBALS_IN_LIBRARY
    .CMD=LINK_FAT_OBJECT
    .SEM=FAT_OBJECT_SEM
    .PEERDIR_POLICY=as_build_from

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.lib
    }
    otherwise {
        MODULE_SUFFIX=.a
    }

    when (($OS_DARWIN == "yes" || $OS_IOS == "yes") && $KEEP_FAT_OBJECT_SYMBOLS == "yes") {
        LDFLAGS_GLOBAL += -keep_private_externs
    }

    # FIXME: This is weird legacy
    when ($OS_ANDROID == "yes") {
        MODULE_PREFIX=lib
    }
    otherwise {
        MODULE_PREFIX=
    }

    _USE_LINKER()

    # This module requires at least one .o which is not subject to removal so just add _fake_src.cpp as SRCS
    # ymake's handling of NEED_ADD_FAKE_SRC may insert arbitrary command, not necessarily compilation
    DISABLE(NEED_ADD_FAKE_SRC)
    SRCS(build/scripts/_fake_src.cpp)
}

RECURSIVE_LIBRARY_SEM=add_recursive_library ${MODDIR} ${CMAKE_TARGET_NAME} ${hide:TARGET} ${hide:AUTO_INPUT} ${CMAKE_TARGET_ARTEFACT_RENAME_RULES} \
    && target_include_directories PUBLIC $_C__INCLUDE_GLOBAL \
    && target_include_directories PRIVATE $_C__INCLUDE_OWNED \
    && target_compile_options PRIVATE $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
    && target_compile_options PUBLIC $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW \
    && target_link_options INTERFACE $LDFLAGS_GLOBAL_RAW

### @usage: RECURSIVE_LIBRARY()
###
### The recursive ("fat") library module. It will contain all its transitive dependencies reachable by PEERDIRs:
### from static libraries, local (from own SRCS) and global (from peers') object files.
###
### Designed for use in XCode projects for iOS.
module RECURSIVE_LIBRARY: LIBRARY {
    .CMD=LINK_RECURSIVE_LIBRARY
    .SEM=RECURSIVE_LIBRARY_SEM
    .PEERDIR_POLICY=as_build_from

    # This module requires at least one .o which is not subject to removal so just add _fake_src.cpp as SRCS
    # ymake's handling of NEED_ADD_FAKE_SRC may insert arbitrary command, not necessarily compilation
    DISABLE(NEED_ADD_FAKE_SRC)
    SRCS(build/scripts/_fake_src.cpp)
}

_SONAME=
_EXPORT_SCRIPT_SEM=
_CLEAN_TEXTREL=
macro _ADD_DYNLYB_SEM(Libname) {
    .SEM=add_shared_library ${MODDIR} ${Libname} ${hide:TARGET} ${hide:AUTO_INPUT} && target_include_directories PUBLIC $_C__INCLUDE_GLOBAL && target_include_directories PRIVATE $_C__INCLUDE_OWNED && target_compile_options PRIVATE $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS && target_compile_options PUBLIC $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW && target_link_options PRIVATE $LDFLAGS_GLOBAL_RAW $LDFLAGS $OBJADDE_LIB $OBJADDE && ${VCS_INFO_SEM} $_EXPORT_SCRIPT_SEM
}
CPP_DYN_LIBRARY_SEM=$_ADD_DYNLYB_SEM($CMAKE_TARGET_NAME) $CMAKE_TARGET_ARTEFACT_RENAME_RULES

macro CLEAN_TEXTREL() {
    SET(_CLEAN_TEXTREL yes)
}
### @usage: DLL_UNIT # internal
###
### Base module for all dynamically linked libraries as final artifacts.
### Contains all general logic for such kind of modules. Supports versioning and export files.
### Cannot participate in linking to programs, intended to be used as final artifact (packaged and deployed).
module DLL_UNIT: _LINK_UNIT {
    .CMD=LINK_DYN_LIB
    .SEM=CPP_DYN_LIBRARY_SEM
    .NODE_TYPE=Library
    .SYMLINK_POLICY=SO
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS USER_CONLYFLAGS LDFLAGS _WHOLE_ARCHIVE_LIBS_VALUE RPATH
    .ALLOWED=WHOLE_ARCHIVE
    .DEFAULT_NAME_GENERATOR=TwoDirNames
    .ARGS_PARSER=DLL
    DYNAMIC_LINK=yes
    ALLOCATOR(FAKE)
    SET(MODULE_TYPE DLL)
    SET(MODULE_TAG DLL)
    SET(MODULE_LANG CPP)
    ADD_CLANG_TIDY()

    when ($EXPORTS_FILE) {
        _EXPORT_SCRIPT_SEM=&& use_export_script ${input:EXPORTS_FILE}
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.dll
    }
    elsewhen ($DARWIN == "yes" || $OS_IOS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dylib
    }
    elsewhen ($TIDY_ENABLED == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.tidyjson
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.so
    }

    # This by now replicates ymake's behavior. We'll get rid of SONAME setting in ymake and fix this code altogether
    SONAME=${pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX:REALPRJNAME}
    when ($MODULE_VERSION) {
       LINK_DYN_LIB_FLAGS=--soname ${output;pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX$MODULE_VERSION:REALPRJNAME}
    }
    _SONAME=$SONAME$MODULE_VERSION

    when ($LINUX == "yes") {
        # '-z notext' is needed for linking mkl into shared libraries
        when ($_CLEAN_TEXTREL != "yes") {
            LDFLAGS += -Wl,-z,notext
        }
    }

    when ($OS_LINUX == "yes" && $ARCH_X86_64 == "yes") {
        when ($_NO_FIX_ELF != "yes") {
            LINK_DYN_LIB_FLAGS+=--fix-elf ${tool:"tools/fix_elf"}
        }
    }

    when ($DARWIN == "yes") {
        LDFLAGS += -undefined dynamic_lookup
    }

    when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no") {
        PEERDIR+=library/cpp/testing/dump_clang_coverage
    }

    when ($IDE_MSVS == "yes") {
        PEERDIR+=build/scripts/c_templates
    }

    when ($_CUSTOM_LINK_STEP_SCRIPT) {
        LINK_DYN_LIB_FLAGS+=--python=$YMAKE_PYTHON --custom-step=${input:_CUSTOM_LINK_STEP_SCRIPT}
    }
}

# tag:r-specific
### @usage: R_MODULE(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
###
### The external module for R language.
### 1. major_ver and minor_ver must be integers.
### 2. The resulting .so will have the prefix "lib".
### 3. Processing EXPORTS and PREFIX is the same as for DLL module
### This is native DLL, so it will select C++ version from PROTO_LIBRARY.
module R_MODULE: DLL_UNIT {
    .SEM=CPP_DYN_LIBRARY_SEM
    when ($DARWIN == "yes") {
        LDFLAGS+=-flat_namespace -dynamiclib
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dll
    }

    ADDINCL(contrib/libs/r-lang)
}

### @usage: DYNAMIC_LIBRARY_FROM(Paths)
###
### Use specified libraries as sources of DLL
macro DYNAMIC_LIBRARY_FROM(Path...) {
    PEERDIR($Path)
    WHOLE_ARCHIVE($Path)
}

### @usage: DLL(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
###
### Dynamic library module definition.
### 1. major_ver and minor_ver must be integers.
### 2. EXPORTS allows you to explicitly specify the list of exported functions. This accepts 2 kind of files: .exports with <lang symbol> pairs and JSON-line .symlist files
### 3. PREFIX allows you to change the prefix of the output file (default DLL has the prefix "lib").
###
### DLL cannot participate in linking to programs but can be used from Java or as final artifact (packaged and deployed).
module DLL: DLL_UNIT {
    .SEM=CPP_DYN_LIBRARY_SEM
    SET(MAKE_ONLY_SHARED_LIB yes)
    when ($OS_WINDOWS) {
        MODULE_SUFFIX=.dll
    }

    # TODO: Make it possible to use this syntax
    # DEFAULT(DLL_FOR_DIR no)
    ### FIXME: XXX
    ###when ($DLL_FOR_DIR != "no") {
    ###    SRCDIR($DLL_FOR_DIR)
    ###    ADDINCL($DLL_FOR_DIR)
    ###}
}

### DLL_TOOL is a DLL that can be used as a LD_PRELOAD tool.
module DLL_TOOL: DLL {
    .SEM=CPP_DYN_LIBRARY_SEM
    # ymake resolves only program nodes as tools.
    .NODE_TYPE=Program
}

### @usage: SO_PROGRAM(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
###
### Executable dynamic library module definition.
### 1. major_ver and minor_ver must be integers.
### 2. EXPORTS allows you to explicitly specify the list of exported functions. This accepts 2 kind of files: .exports with <lang symbol> pairs and JSON-line .symlist files
### 3. PREFIX allows you to change the prefix of the output file.
module SO_PROGRAM: DLL {
    .CMD=LINK_EXEC_DYN_LIB
    SET(MODULE_TYPE PROGRAM)

    MODULE_PREFIX=
    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.exe
    }
    otherwise {
        MODULE_SUFFIX=
    }
}

DLL_PROXY_CMD_MF=$GENERATE_MF && $COPY_CMD $AUTO_INPUT $TARGET

# tag:internal
### @usage: DEV_DLL_PROXY() # internal
###
### The use of this module is strictly prohibited!!!
### This is a temporary and project-specific solution.
module DEV_DLL_PROXY: _BARE_UNIT {
    .NODE_TYPE=Library
    .EXTS=.so .dll .dylib .mf
    .CMD=DLL_PROXY_CMD_MF
    DYNAMIC_LINK=yes

    when ($OS_WINDOWS == "yes") {
        MODULE_SUFFIX=.dll
    }
    elsewhen ($DARWIN == "yes" || $OS_IOS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dylib$MODULE_VERSION
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.so$MODULE_VERSION
    }
}

# tag:internal
### @usage: DLL_PROXY() # internal
###
### The use of this module is strictly prohibited!!!
### This is a temporary and project-specific solution.
module DLL_PROXY: DEV_DLL_PROXY {
    .EXTS=.so .dylib .lib .mf
    .PROXY=yes
    .PEERDIR_POLICY=as_build_from
    SET(PEERDIR_TAGS DLL __EMPTY__)

    when ($OS_WINDOWS == "yes") {
        MODULE_SUFFIX=.lib
    }
}

# tag:internal
### @usage: DYNAMIC_DEPS(Path...) # internal, temporary
###
### Enlist paths to all DYNAMIC_LIBRARY dependencies of the DYNAMIC_LIBRARY
### This it needed to transfer their outputs through the library to PROGRAM
### or dependent DLL/DYNAMIC_LIBRARY.
###
### Note: this is temporary solution until support of `super-global` variables come
###       which will enable transfer of some properties though final targets like DLLs.
macro DYNAMIC_DEPS(Path...) {
     # PEERDIR as macro completely ignored in place where this macro applies
     SET_APPEND(PEERDIR $Path)
}

# tag:internal
### @usage: DYNAMIC_LIBRARY() # internal
###
### The use of this module is strictly prohibited except LGPL-related opensourcing
### This provides linkable DLL module which brings its results to programs and tests
### for seamless testing and packaging
multimodule DYNAMIC_LIBRARY {
    module DLL_BIN: DLL {
        .PROXY=yes
        .IGNORED=PROVIDES
        SET(MODULE_TAG DLL)
    }
    module DLL_LIB: _DLL_COMPATIBLE_LIBRARY {
        .CMD=TOUCH_UNIT_MF
        .PEERDIRSELF=DLL_BIN
        .IGNORED=SRCS PEERDIR RUN_PROGRAM PYTHON DYNAMIC_LIBRARY_FROM GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER USE_PYTHON2 USE_PYTHON3
        .ALLOWED=DYNAMIC_DEPS

        SET(PEERDIR_TAGS DLL_LIB __EMPTY__)

        _BARE_MODULE()
        DYNAMIC_LINK=yes
        MODULE_SUFFIX=.pkg.fake
        PEERDIR+=build/platform/local_so

        when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no" && $SANITIZE_HEADERS && $SANITIZE_HEADERS != "no") {
            PEERDIR += library/cpp/sanitizer/include
        }

        # disable credits generation for static library
        SET(CREDITS_FLAGS)
    }
}

### @usage: GLOBAL_SRCS(filenames...)
###
### Make all source files listed as GLOBAL.
### Call to GLOBAL_SRCS macro is equivalent to call to SRCS macro when each source file is marked with GLOBAL keyword.
### Arcadia root relative or project dir relative paths are supported for filenames arguments. GLOBAL keyword is not
### recognized for GLOBAL_SRCS in contrast to SRCS macro.
###
### @example:
### Consider the file to ya.make:
###
###     LIBRARY()
###         GLOBAL_SRCS(foo.cpp bar.cpp)
###     END()
###
### @see: [SRCS()](#macro_SRCS)
macro GLOBAL_SRCS(Files...) {
    SRCS(${pre=GLOBAL :Files})
}

### @usage: ALL_SRCS([GLOBAL] filenames...)
###
### Make all source files listed as GLOBAL or not depending on the keyword GLOBAL
### Call to ALL_SRCS macro is equivalent to call to GLOBAL_SRCS macro when GLOBAL keyword is specified
### as the first argument and is equivalent to call to SRCS macro otherwise.
###
### @example:
###
###     LIBRARY()
###         SET(MAKE_IT_GLOBAL GLOBAL)
###         ALL_SRCS(${MAKE_IT_GLOBAL} foo.cpp bar.cpp)
###     END()
###
### @see: [GLOBAL_SRCS()](#macro_GLOBAL_SRCS), [SRCS()](#macro_SRCS)
macro ALL_SRCS(GLOBAL?"GLOBAL":"", Files...) {
    SRCS(${pre=$GLOBAL :Files})
}

### @usage: _DLL_COMPATIBLE_LIBRARY # internal
###
### Base module to place DLLs into multimodules back to back with libraries.
### In order to function properly all modules in multimodule shall have the
### same set of arguments. So this module is just library that accepts but
### ignores all DLL arguments.
module _DLL_COMPATIBLE_LIBRARY: LIBRARY {
    .DEFAULT_NAME_GENERATOR=TwoDirNames
    .ARGS_PARSER=DLL
}

@import "${CONF_ROOT}/conf/project_specific/yql_udf.conf"

# as SRCS in packages use macro BUNDLE_SRCS!

PACKED_PACKAGE_ARGS=
PACKED_PACKAGE_EXT=
### @usage: PACK(archive_type)
###
### When placed inside the PACKAGE module, packs the build results tree to the archive with specified extension. Currently supported extensions are `tar` and `tar.gz`
###
### Is not allowed other module types than PACKAGE().
###
### @see: [PACKAGE()](#module_PACKAGE)
macro PACK(Ext) {
    SET(PACKED_PACKAGE_EXT $Ext)
}

PACKAGE_STRICT_VALUE=
macro PACKAGE_STRICT() {
    SET(PACKAGE_STRICT_VALUE yes)
}

### @usage: PACKAGE(name)
###
### Module collects what is described directly inside it, builds and collects all its transitively available PEERDIRs.
### As a result, build directory of the project gets the structure of the accessible part of Arcadia, where the build result of each PEERDIR is placed to relevant Arcadia subpath.
### The data can be optionally packed if macro PACK() is used.
###
### Is only used together with the macros FILES(), PEERDIR(), COPY(), FROM_SANDBOX(), RUN_PROGRAM or BUNDLE(). Don't use SRCS inside a PACKAGE.
###
### Documentation: https://wiki.yandex-team.ru/yatool/large-data/
###
### @see: [PACK()](#macro_PACK)
multimodule PACKAGE {
    module PACKAGE_FINAL: _BASE_UNIT {
        .CMD=TOUCH_PACKAGE_MF
        .ALIASES=SRCS=FILES
        .ALLOWED=PACK
        .PEERDIRSELF=PACKAGE_UNION
        .USE_PEERS_LATE_OUTS=yes
        .PEERDIR_POLICY=as_build_from
        .FINAL_TARGET=yes
        SET(PEERDIR_TAGS CPP_PROTO CPP_FBS PY2 PY3 PY2_NATIVE YQL_UDF_SHARED __EMPTY__ DOCSBOOK JAR_RUNNABLE PY3_BIN PY3TEST_PROGRAM DLL GO_PROGRAM PACKAGE_UNION)

        SET(MODULE_SUFFIX .final.pkg.fake)
        SET(DONT_RESOLVE_INCLUDES yes)
        NO_PLATFORM()
        when ($PACKED_PACKAGE_EXT) {
            PACKED_PACKAGE_ARGS+=--dest-arch ${output;pre=$MODULE_PREFIX;suf=.$PACKED_PACKAGE_EXT:REALPRJNAME}
        }
        SET(NEED_PLATFORM_PEERDIRS no)
    }
    module PACKAGE_UNION: UNION {
        .CMD=UNION_CMD
        .FINAL_TARGET=no
        .ALLOWED=PACK
        .IGNORED=VCS_INFO_FILE

        SET(MODULE_SUFFIX .pkg.fake)
        SET(PEERDIR_TAGS CPP_PROTO CPP_FBS PY2 PY3 PY2_NATIVE YQL_UDF_SHARED __EMPTY__ DOCSBOOK JAR_RUNNABLE PY3_BIN PY3TEST_PROGRAM DLL GO_PROGRAM PACKAGE_UNION)

        DISABLE(START_TARGET)
    }
}

TOUCH_GROUP=$TOUCH_PACKAGE ${kv;hide:"p CI"}

### @usage: CI_GROUP()
###
### Module collects what is described directly inside it transitively by PEERDIRs.
### No particular layout of built artifacts is implied. This module is needed primarily for CI dependency analysis and may not trigger builds at all.
###
### Is only used together with the macro PEERDIR() and FILES(). Don't use SRCS inside CI_GROUP().
module CI_GROUP: _BARE_UNIT  {
    .CMD=TOUCH_GROUP
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes
    .RESTRICTED=SRCS
    .USE_PEERS_LATE_OUTS=yes
    MODULE_SUFFIX=.ci.pkg.fake
    PEERDIR_TAGS=CPP_PROTO PY3 PY3_NATIVE PY3_BIN PY3TEST_PROGRAM YQL_UDF_SHARED __EMPTY__ DOCSBOOK JAR_RUNNABLE DLL
}

# tag:generic tag:internal
TOUCH_UNIT_MF=$TOUCH_UNIT && $GENERATE_MF

### @usage: UNION(name)
###
### Collection of PEERDIR dependencies, files and artifacts.
### UNION doesn't build its peers, just provides those to modules depending on it.
### When specified in DEPENDS() macro the UNION is transitively closed, building all its peers and providing those by own paths (without adding this module path like PACKAGE does).
###
### Is only used together with the macros like FILES(), PEERDIR(), COPY(), FROM_SANDBOX(), RUN_PROGRAM or BUNDLE(). Don't use SRCS inside a UNION.
###
### Documentation: https://wiki.yandex-team.ru/yatool/large-data/
module UNION: _BASE_UNIT {
    .CMD=UNION_CMD_MF
    .FINAL_TARGET=no
    .ALIASES=SRCS=FILES
    .ALLOWED=EXPLICIT_OUTPUTS
    .IGNORED=VCS_INFO_FILE
    NO_PLATFORM()
    SET(MODULE_SUFFIX .pkg.fake)
    SET(DONT_RESOLVE_INCLUDES yes)
    SET(NEED_PLATFORM_PEERDIRS no)
    PEERDIR_TAGS=CPP_PROTO CPP_FBS PY2 PY2_NATIVE YQL_UDF_SHARED __EMPTY__ DOCSBOOK JAR_RUNNABLE PY3_BIN DLL PACKAGE_UNION

    UNION_OUTS=${hide;late_out:AUTO_INPUT}
    when ($_UNION_EXPLICIT_OUTPUTS) {
        UNION_OUTS=$_EXPAND_INS_OUTS($_UNION_EXPLICIT_OUTPUTS)
   }
}

# tag:internal
### @usage: _SET_FIRST_VALUE(name args...) # internal
###
### This macro sets the value of `name` variable to the value of next argument
macro _SET_FIRST_VALUE(NAME, VALUE, OTHER...) {
    SET($NAME $VALUE)
}

# tag:internal
### @usage: _SRCS_NO_GLOBAL(files...) # internal
###
### Proxy macro to SRCS macro which filters out GLOBAL keyword from the list of source files.
### Useful for modules like EXTERNAL_JAVA_LIBRARY, where GLOBAL keyword cannot be applied properly.
### Note: this macro changes order of source files.
macro _SRCS_NO_GLOBAL(GLOBAL[], FILES...) {
    SRCS($GLOBAL $FILES)
}

@import "${CONF_ROOT}/conf/java.conf"
@import "${CONF_ROOT}/conf/python.conf"

TEST_CWD_VALUE=
### @usage: TEST_CWD(path)
###
### Defines working directory for test runs. Often used in conjunction with DATA() macro.
### Is only used inside of the TEST modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro TEST_CWD(Arg) {
    SET(TEST_CWD_VALUE $Arg)
}

# tag:sandbox-specific
### @usage: SANDBOX_TASK([Name])
###
### Multimodule describing Sandbox task (Python code that can be executed by Sandbox system).
###
### When being a final target, this multimodule builds Sandbox binary task. It may PEERDIR other SANDBOX_TASKs as libraries.
### The final artifact is provided when SANDBOX_TASK is referred to by DEPENDS and BUNDLE macros.
### As PEERDIR target, it works like regular PY2_LIBRARY with predefined dependencies on Sandbox SDK to allow code reuse among SANDBOX_TASKs.
###
### Currently Sandbox supports only Python 2.x, so both variants will be compatible only with Python 2.x modules
### and will select multimodule variants accordingly.
###
### Documentation: https://wiki.yandex-team.ru/sandbox/tasks/binary
multimodule SANDBOX_TASK {
    module SB_TASK_BIN: _PY2_PROGRAM {
        PY_MAIN(sandbox.taskbox.binary)
        PEERDIR(sandbox/bin sandbox/sdk2 sandbox/sandboxsdk sandbox/taskbox/worker)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE api.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE kernel.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE library.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE sky*)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
        when ($FAIL_PY2 == "yes") {
            _OK=no
        }
        elsewhen ($OPENSOURCE != "yes") {
            PEERDIR+=build/rules/py2_deprecation
        }

        ASSERT(_OK You are using deprecated Python2-only code (SANDBOX_TASK). Please consider rewriting to 2/3-compatible code.)
    }
    module PY2: PY2_LIBRARY {
        PEERDIR(sandbox/sdk2 sandbox/sandboxsdk)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
}

# tag:sandbox-specific
multimodule SANDBOX_PY23_3_TASK {
    module SB_TASK_BIN: PY3_PROGRAM_BIN {
        .IGNORED=RUN_ANTLR4_PYTHON
        PY_MAIN(sandbox.taskbox.binary)
        PEERDIR(sandbox/bin sandbox/sdk2 sandbox/taskbox/worker)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE api.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE kernel.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE library.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE sky*)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
    module PY2: PY2_LIBRARY {
        .RESTRICTED=RUN_ANTLR4_PYTHON
        PEERDIR(sandbox/sdk2 sandbox/sandboxsdk)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
        OBJ_SUF=.py2
    }
    module PY3: PY3_LIBRARY {
        .RESTRICTED=RUN_ANTLR4_PYTHON
        when ($MSVC == "yes" || $CYGWIN == "yes") {
            MODULE_PREFIX=py3
        }
        otherwise {
             MODULE_PREFIX=libpy3
        }
        OBJ_SUF=.py3
        RUN_CYTHON_SCRIPT_H=$YMAKE_PYTHON $CYTHON_SCRIPT
        PEERDIR(sandbox/sdk2)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
}

# tag:sandbox-specific
multimodule SANDBOX_PY23_TASK {
    module SB_TASK_BIN: _PY2_PROGRAM {
        .RESTRICTED=RUN_ANTLR4_PYTHON
        PY_MAIN(sandbox.taskbox.binary)
        PEERDIR(sandbox/bin sandbox/sdk2 sandbox/sandboxsdk sandbox/taskbox/worker)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE api.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE kernel.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE library.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE sky*)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
    module PY2: PY2_LIBRARY {
        .RESTRICTED=RUN_ANTLR4_PYTHON
        PEERDIR(sandbox/sdk2 sandbox/sandboxsdk)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
        OBJ_SUF=.py2
    }
    module PY3: PY3_LIBRARY {
        .RESTRICTED=RUN_ANTLR4_PYTHON
        OBJ_SUF=.py3
        RUN_CYTHON_SCRIPT_H=$YMAKE_PYTHON $CYTHON_SCRIPT
        PEERDIR(sandbox/sdk2)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
}

# tag:sandbox-specific
### @usage: SANDBOX_PY3_TASK([Name])
###
### Multimodule describing Sandbox task (Python3 code that can be executed by Sandbox system).
###
### When being a final target, this multimodule builds Sandbox binary task. It may PEERDIR other SANDBOX_PY3_TASKs as libraries.
### The final artifact is provided when SANDBOX_PY3_TASK is referred to by DEPENDS and BUNDLE macros.
### As PEERDIR target, it works like regular PY3_LIBRARY with predefined dependencies on Sandbox SDK to allow code reuse among SANDBOX_PY3_TASKs.
###
### Currently Sandbox supports Python 3.x only in binary tasks, both variants will be compatible only with Python 3.x and py23 libraries
### and will select multimodule variants accordingly.
###
### Documentation: https://wiki.yandex-team.ru/sandbox/tasks/binary
multimodule SANDBOX_PY3_TASK {
    module SB_TASK_BIN: PY3_PROGRAM_BIN {
        .IGNORED=RUN_ANTLR4_PYTHON
        PY_MAIN(sandbox.taskbox.binary)
        PEERDIR(sandbox/bin sandbox/sdk2 sandbox/taskbox/worker)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE api.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE kernel.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE library.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE sky*)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
    module PY3: PY3_LIBRARY {
        PEERDIR(sandbox/sdk2)
        REGISTER_SANDBOX_IMPORT(${MODDIR})
    }
}

# tag:allocator
### @usage: ALLOCATOR(Alloc)  # Default: LF
###
### Set memory allocator implementation for the PROGRAM()/DLL() module.
### This may only be specified for programs and dlls, use in other modules leads to configuration errors.
###
### Available allocators are: "LF", "LF_YT", "LF_DBG", "YT", "J", "B", "BM", "C", "TCMALLOC", "GOOGLE", "LOCKLESS", "SYSTEM", "FAKE", "MIM", "HU", "PROFILED_HU".
###   - LF - lfalloc (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/lfalloc)
###   - LF_YT -  Allocator selection for YT (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/lfalloc/yt/ya.make)
###   - LF_DBG -  Debug allocator selection (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/lfalloc/dbg/ya.make)
###   - YT - The YTAlloc allocator (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/ytalloc/impl/ya.make)
###   - J - The JEMalloc allocator (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/jemalloc)
###   - B - The balloc allocator named Pyotr Popov and Anton Samokhvalov
###       - Discussion: https://ironpeter.at.yandex-team.ru/replies.xml?item_no=126
###       - Code: https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/balloc
###   - BM - The balloc for market (agri@ commits from july 2018 till November 2018 saved)
###   - C - Like B, but can be disabled for each thread to LF or SYSTEM one (B can be disabled only to SYSTEM)
###   - MIM -  Microsoft's mimalloc (actual version) (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/mimalloc)
###   - TCMALLOC -  Google TCMalloc (actual version) (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/tcmalloc)
###   - GOOGLE -  Google TCMalloc (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/galloc)
###   - LOCKLESS - Allocator based upon lockless queues (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/lockless)
###   - SYSTEM - Use target system allocator
###   - FAKE - Don't link with any allocator
###   - HU - Huge page allocator by @gulin.
###   - PROFILED_HU - patched HU. It is a bit slower but has metrics of memory consumption.
###
### More about allocators in Arcadia: https://wiki.yandex-team.ru/arcadia/allocators/
macro ALLOCATOR(Alloc) {
    SET(ALLOCATOR $Alloc)

    when ($ALLOCATOR in [ "LF", "LF_YT", "LF_DBG", "YT", "J", "B", "BM", "C", "TCMALLOC", "TCMALLOC_SMALL_BUT_SLOW", "TCMALLOC_NUMA_256K", "TCMALLOC_NUMA_LARGE_PAGES", "TCMALLOC_256K", "TCMALLOC_TC", "GOOGLE", "LOCKLESS", "SYSTEM", "FAKE", "MIM", "HU", "PROFILED_HU" ]) {
    }
    otherwise {
        PEERDIR+=___configure_error___unknown_allocator_type___$ALLOCATOR
    }
}

when ($MIC_ARCH == "yes") {
    CFLAGS+=-mmic
    LDFLAGS+=-mmic
}
when ($USE_OPENMP == "yes") {
    PEERDIR+=contrib/libs/openmp
}

when ($STRIP == "yes" && $NO_STRIP != "yes") {
    STRIP_FLAG=$LD_STRIP_FLAG
    DWARF_COMMAND=
    GO_LINK_FLAGS_VALUE+=-s
}

when ($NO_LINKER_DCE != "yes") {
    DCE_FLAG=$LD_DCE_FLAG
}

when ($BT_MINSIZEREL == "yes" || $LINKER_ICF == "yes") {
    ICF_FLAG=$LD_ICF_FLAG
}

OBJCOPY_TOOL=$OBJCOPY_TOOL_VENDOR
OBJDUMP_TOOL=$OBJDUMP_TOOL_VENDOR
STRIP_TOOL=$STRIP_TOOL_VENDOR
NEED_BINUTILS_PEERDIR=
BINUTILS_USED=

when (!$OBJCOPY_TOOL_VENDOR) {
    OBJCOPY_TOOL=$BINUTILS_ROOT_RESOURCE_GLOBAL/bin/objcopy
    NEED_BINUTILS_PEERDIR=yes
}
when (!$OBJDUMP_TOOL_VENDOR) {
    OBJDUMP_TOOL=$BINUTILS_ROOT_RESOURCE_GLOBAL/bin/objdump
    NEED_BINUTILS_PEERDIR=yes
}
when (!$STRIP_TOOL_VENDOR) {
    STRIP_TOOL=$BINUTILS_ROOT_RESOURCE_GLOBAL/bin/strip
    NEED_BINUTILS_PEERDIR=yes
}

SPLIT_DWARF_VALUE=no
NO_SPLIT_DWARF=no

when ($OS_DARWIN || $OS_IOS || $OS_IOSSIM) {
    SPLIT_DWARF_VALUE=yes
}

when ($STRIP_DEBUG_INFO) {
    SPLIT_DWARF_VALUE=yes
    NO_SPLIT_DWARF=no
}

### @usage: SPLIT_DWARF()
###
### Emit debug info for the PROGRAM/DLL as a separate file <module_name>.debug.
### NB: It does not help you to save process RSS but can add problems (see e.g. BEGEMOT-2147).
macro SPLIT_DWARF() {
    SET(SPLIT_DWARF_VALUE yes)
}

### @usage: NO_SPLIT_DWARF()
###
### Do NOT emit debug info for the PROGRAM/DLL as a separate file.
### On macOS this also means do NOT generate dSym files (faster linkage)
macro NO_SPLIT_DWARF() {
    SET(SPLIT_DWARF_VALUE no)
}

SPLIT_DWARF_OUTPUT=${output;tobindir;pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX.debug:REALPRJNAME}
when ($SPLIT_DWARF_VALUE == "yes" && $NO_SPLIT_DWARF != "yes" && $NO_DEBUGINFO != "yes" && $HOST_OS_LINUX == "yes" && $TARGET_PLATFORM == "LINUX") {
    DWARF_COMMAND+= \
        $OBJCOPY_TOOL --only-keep-debug $TARGET $SPLIT_DWARF_OUTPUT && \
        $STRIP_TOOL --strip-debug $TARGET && \
        $OBJCOPY_TOOL --remove-section=.gnu_debuglink --add-gnu-debuglink $SPLIT_DWARF_OUTPUT $TARGET
    BINUTILS_USED=yes
}

### @usage: EXTRALIBS_STATIC(Libs...)
###
### Add the specified external static libraries to the program link
macro EXTRALIBS_STATIC(Args...) {
    LDFLAGS(-Wl,-Bstatic ${Args} -Wl,-Bdynamic)
}

### @usage ADD_COMPILABLE_TRANSLATE(Dict Name Options...)
###
### Generate translation dictionary code to transdict.LOWER(Name).cpp that will than be compiled into library
macro ADD_COMPILABLE_TRANSLATE(Dict, Name, MakeTransDictOptions...) {
     __translatename_lower=${tolower:Name}
     __translate_dict=${BINDIR}/transdict.${__translatename_lower}.cpp
     RUN_PROGRAM(dict/tools/maketransdict -i ${Dict} ${MakeTransDictOptions} ${Name} STDOUT_NOAUTO ${__translate_dict} IN ${Dict})
}

### @usage ADD_COMPILABLE_TRANSLIT(TranslitTable NGrams Name Options...)
###
### Generate transliteration dictionary code
### This will emit both translit, untranslit and ngrams table codes those will be than further compiled into library
macro ADD_COMPILABLE_TRANSLIT(TranslitTable, NGrams, Name, Options...) {
     __translitname_lower=${tolower:Name}
     __translit_table=${BINDIR}/translit_trie_${__translitname_lower}.cpp
     __untranslit_table=${BINDIR}/untranslit_trie_${__translitname_lower}.cpp
     __ngrams_table=${BINDIR}/ngr_arr_${__translitname_lower}.cpp
     __gentrie_dir=dict/tools/make_untranslit_trie

     RUN_PROGRAM(${__gentrie_dir} -i ${TranslitTable} ${Options} ${__translitname_lower} IN ${TranslitTable} STDOUT ${__untranslit_table})
     RUN_PROGRAM(${__gentrie_dir} -i ${TranslitTable} -n ${Options} ${__translitname_lower} IN ${TranslitTable} STDOUT ${__translit_table})
     RUN_PROGRAM(dict/tools/make_ngrams -i ${NGrams} ${Options} ${__translitname_lower} IN ${NGrams} STDOUT ${__ngrams_table})
}

macro _COPY_FILE_IMPL(FILE, AUTO_DST="", NOAUTO_DST="", OUTPUT_INCLUDES[], INDUCED_DEPS[], OUTPUT_INCLUDES_INP[]) {
    .CMD=$COPY_CMD ${input:FILE} ${output:AUTO_DST} ${output;noauto:NOAUTO_DST} ${output_include;hide:OUTPUT_INCLUDES} ${output_include;from_input;hide:OUTPUT_INCLUDES_INP} $INDUCED_DEPS ${kv;hide:"p CP"} ${kv;hide:"pc light-cyan"}
    .SEM=copy_file ${input:FILE} ${output:AUTO_DST} ${output;noauto:NOAUTO_DST}
}

### @usage: COPY_FILE(File Destination [AUTO] [OUTPUT_INCLUDES Deps...])
###
### Copy file to build root. It is possible to change both location and the name.
###
### Parameters:
### - File - Source file name.
### - Destination - Output file name.
### - AUTO - Consider copied file for further processing automatically.
### - OUTPUT_INCLUDES output_includes... - Output file dependencies.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type)
###                           and set of dependencies
###
### The file will be just copied if AUTO boolean parameter is not specified. You should explicitly
### mention it in SRCS under new name (or specify AUTO boolean parameter) for further processing.
macro COPY_FILE(File, Destination, AUTO?"AUTO_DST":"NOAUTO_DST", OUTPUT_INCLUDES[], INDUCED_DEPS[]) {
    .CMD=$_COPY_FILE_IMPL($File $AUTO $Destination OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS)
    .SEM=$_COPY_FILE_IMPL($File $AUTO $Destination)
}

### @usage: COPY_FILE_WITH_CONTEXT(FILE DEST [AUTO] [OUTPUT_INCLUDES DEPS...])
###
### Copy file to build root the same way as it is done for COPY_FILE, but also
### propagates the context of the source file.
macro COPY_FILE_WITH_CONTEXT(FILE, DEST, AUTO?"AUTO_DST":"NOAUTO_DST", OUTPUT_INCLUDES[], INDUCED_DEPS[]) {
    .CMD=$_COPY_FILE_IMPL($FILE $AUTO $DEST OUTPUT_INCLUDES_INP $FILE OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS)
}

### This is to join $ALL_RES_ and $EXT
macro _ARF_HELPER(Args...) {
     RESOURCE_FILES($Args)
}

### @usage ALL_RESOURCE_FILES(Ext [PREFIX {prefix}] [STRIP {strip}] Dirs...)
###
### This macro collects all files with extension `Ext` and
### Passes them to `RESOURCE_FILES` macro as relative to current directory
###
### `PREFIX` and `STRIP` have the same meaning as in `ROURCES_FILES`, both are applied over moddir-relative paths
###
### Note: This macro can be used multiple times per ya.make, but only once for each Ext value
### Note: Wildcards are not allowed neither as Ext nor in Dirs
macro ALL_RESOURCE_FILES(EXT, PREFIX="", STRIP="", DIRS...) {
     _GLOB(ALL_RES_$EXT ${suf=/*.$EXT:DIRS})
     _ARF_HELPER(${pre=PREFIX :PREFIX} STRIP ${ARCADIA_ROOT}/${MODDIR}/${STRIP} ${pre=$ALL_RES_:EXT})
}

macro _BUNDLE_TARGET(Target, Destination) {
    .CMD=$MOVE_FILE ${result:Target} ${output;noauto:Destination} ${kv;hide:"p BN"} ${kv;hide:"pc light-cyan"} $VCS_INFO_DISABLE_CACHE__NO_UID__
}

### @usage: TIMEOUT(TIMEOUT)
###
### Sets a timeout on test execution
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro TIMEOUT(Time) {
    SET(TEST_TIMEOUT $Time)
}

SBR_UID_EXT=""
# tag:test
### @usage: VALIDATE_DATA_RESTART(ext)
###
### Change uid for resource validation tests. May be useful when sandbox resource ttl is changed, but test status is cached in CI.
### You can change ext to change test's uid. For example VALIDATE_DATA_RESTART(X), where is X is current revision.
macro VALIDATE_DATA_RESTART(Ext) {
    SET(SBR_UID_EXT $Ext)
}

# tag:test
TEST_FORK_MODE=none
TEST_PARTITION=SEQUENTIAL

# tag:test
### @usage: FORK_TESTS()
###
### Splits a test run on chunks by test classes.
### The number of chunks can be overridden using the macro SPLIT_FACTOR.
###
### Allows to run tests in parallel. Supported in UNITTEST, JTEST/JUNIT5 and PY2TEST/PY3TEST modules.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_TESTS(MODE...) {
    SET(TEST_FORK_MODE tests)
    SET(TEST_PARTITION $MODE)
}

# tag:test
### @usage: FORK_SUBTESTS()
###
### Splits the test run in chunks on subtests.
### The number of chunks can be overridden using the macro SPLIT_FACTOR.
###
### Allows to run tests in parallel. Supported in UNITTEST, JTEST/JUNIT5 and PY2TEST/PY3TEST modules.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_SUBTESTS(MODE...) {
    SET(TEST_FORK_MODE subtests)
    SET(TEST_PARTITION $MODE)
}

# tag:test
### @usage: SPLIT_FACTOR(x)
###
### Sets the number of chunks for parallel run tests when used in test module with FORK_TESTS() or FORK_SUBTESTS().
### If none of those is specified this macro implies FORK_TESTS().
###
### Supports C++ ut and PyTest.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro SPLIT_FACTOR(Factor) {
    SET(TEST_SPLIT_FACTOR $Factor)
}

# tag:test
FORK_TEST_FILES_MODE=
### @usage: FORK_TEST_FILES()
###
### Only for PY2TEST and PY3TEST: splits a file executable with the tests on chunks in the files listed in TEST_SRCS
### Compatible with FORK_(SUB)TESTS.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_TEST_FILES() {
    SET(FORK_TEST_FILES_MODE on)
}

# tag:test
TEST_SIZE_NAME=SMALL
### @usage: SIZE(SMALL/MEDIUM/LARGE)
###
### Set the 'size' for the test. Each 'size' has own set of resrtictions, SMALL bein the most restricted and LARGE being the list.
### See documentation on test system for more details.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro SIZE(Type) {
    SET(TEST_SIZE_NAME $Type)
}

### @usage: JOIN_SRCS(Out Src...)
###
### Join set of sources into single file named Out and send it for further processing.
### This macro doesn't place all file into Out, it emits #include<Src>... Use the for C++ source files only.
### You should specify file name with the extension as Out. Further processing will be done according this extension.
macro JOIN_SRCS(Out, Src...) {
    .CMD=$YMAKE_PYTHON3 ${input:"build/scripts/gen_join_srcs.py"} ${input;hide:"build/scripts/process_command_files.py"} ${output:Out} --ya-start-command-file ${input;rootrel:Src} --ya-end-command-file ${output_include;from_input;hide:Src} ${kv;hide:"p JS"} ${kv;hide:"pc magenta"}
    .SEM=target_joined_source $Out ${input:Src} ${output;hide;suf=.o:Out} ${input;hide:"build/scripts/gen_join_srcs.py"} ${input;hide:"build/scripts/process_command_files.py"}
    _CONDITIONAL_SRCS($TIDY_VALUE $Src)
}

### @usage: JOIN_SRCS_GLOBAL(Out Src...)
###
### Join set of sources into single file named Out and send it for further processing as if it were listed as SRCS(GLOBAL Out).
### This macro doesn't place all file into Out, it emits #include<Src>... Use the for C++ source files only.
### You should specify file name with the extension as Out. Further processing will be done according to this extension.
macro JOIN_SRCS_GLOBAL(Out, Src...) {
    .CMD=$YMAKE_PYTHON3 ${input:"build/scripts/gen_join_srcs.py"} ${input;hide:"build/scripts/process_command_files.py"} ${output;noauto:Out} --ya-start-command-file ${input;rootrel:Src} --ya-end-command-file ${output_include;from_input;hide:Src} ${kv;hide:"p JS"} ${kv;hide:"pc magenta"}
    SRCS(GLOBAL $Out)
}

### @usage: FLAT_JOIN_SRCS_GLOBAL(Out Src...)
###
### Join set of sources into single file named Out and send it for further processing as if it were listed as SRCS(GLOBAL Out).
### This macro places all files into single file, so will work with any sources.
### You should specify file name with the extension as Out. Further processing will be done according to this extension.
macro FLAT_JOIN_SRCS_GLOBAL(Out, Src...) {
    .CMD=$FS_TOOLS cat ${output;noauto:Out} --ya-start-command-file ${input:Src} --ya-end-command-file ${output_include;from_input;hide:Src} ${kv;hide:"p JS"} ${kv;hide:"pc magenta"}
    SRCS(GLOBAL $Out)
}

# tag:cpu
PIC_CFLAGS=
SSE2_CFLAGS=
SSE3_CFLAGS=
SSSE3_CFLAGS=
SSE41_CFLAGS=
SSE42_CFLAGS=
POPCNT_CFLAGS=
PCLMUL_CFLAGS=
CX16_FLAGS=
AVX_CFLAGS=
AVX2_CFLAGS=
AVX512_CFLAGS=
AMX_CFLAGS=

# tag:cpu
SSE_DEFINES=
SSE_CFLAGS=
SSE4_DEFINES=
SSE4_CFLAGS=
XOP_CFLAGS=

NO_LTO_CFLAGS=

# tag:cpu
when (($ARCH_X86_64 || $ARCH_I386) && $DISABLE_INSTRUCTION_SETS != "yes") {
    when ($CLANG || $CLANG_CL || $GCC) {
        PIC_CFLAGS=-fPIC
        SSE2_CFLAGS=-msse2
        SSE3_CFLAGS=-msse3
        SSSE3_CFLAGS=-mssse3
        SSE41_CFLAGS=-msse4.1
        SSE42_CFLAGS=-msse4.2
        XOP_CFLAGS=-mxop
        POPCNT_CFLAGS=-mpopcnt
        PCLMUL_CFLAGS=-mpclmul
        AVX_CFLAGS=-mavx

        # On Intel BMI1, BMI2 and FMA3 instruction sets come together with AVX-2 extension starting with Broadwell / Haswell.
        # See:
        # https://en.wikipedia.org/wiki/FMA_instruction_set
        # https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
        #
        # AMD implemented FMA3 in Piledriver architecture over AVX (that is, prior to AVX-2 which was introduced in Zen).
        # BMI2 implementation was released by AMD along with AVX-2 support.
        # See:
        # https://en.wikipedia.org/wiki/Template:AMD_x86_CPU_features
        #
        # Due to the above, it looks safe to enable all three extensions whenever AVX-2 is enabled.
        AVX2_CFLAGS=-mavx2 -mfma -mbmi -mbmi2

        # All Intel CPUS with AVX-512 have these instructions except for the Knights Landing / Knights Mill
        # (these are Xeon Phi)
        # See:
        # https://en.wikichip.org/wiki/x86/avx-512
        AVX512_CFLAGS=-mavx512f -mavx512cd -mavx512bw -mavx512dq -mavx512vl

        # AMX stands Advanced Matrix Extension supported by modern Intel architectures
        # See:
        # https://en.wikipedia.org/wiki/Advanced_Matrix_Extensions
        # https://en.wikichip.org/wiki/x86/amx
        AMX_CFLAGS=-mamx-tile -mamx-int8 ${AVX512_CFLAGS}

        when ($ARCH_X86_64 && $OS_ANDROID != "yes") {
            CX16_FLAGS=-mcx16
        }
        SSE_DEFINES=-DSSE_ENABLED=1 -DSSE3_ENABLED=1 -DSSSE3_ENABLED=1
        SSE4_DEFINES=-DSSE41_ENABLED=1 -DSSE42_ENABLED=1 -DPOPCNT_ENABLED=1 -DCX16_ENABLED=1
    }
    elsewhen ($MSVC) {
        SSE2_CFLAGS=/D__SSE2__=1
        SSE3_CFLAGS=/D__SSE3__=1
        SSSE3_CFLAGS=/D__SSSE3__=1
        SSE41_CFLAGS=/D__SSE4_1__=1
        SSE42_CFLAGS=/D__SSE4_2__=1
        POPCNT_CFLAGS=/D__POPCNT__=1
        PCLMUL_CFLAGS=/D__PCLMUL__=1
        AVX_CFLAGS=/arch:AVX /DAVX_ENABLED=1
        AVX2_CFLAGS=/arch:AVX2 /DAVX2_ENABLED=1
        AVX512_CFLAGS=/arch:AVX512 /DAVX512_ENABLED=1
        SSE_DEFINES=/DSSE_ENABLED=1 /DSSE3_ENABLED=1 /DSSSE3_ENABLED=1
        SSE4_DEFINES=/DSSE41_ENABLED=1 /DSSE42_ENABLED=1 /DPOPCNT_ENABLED=1 /DCX16_ENABLED=1
    }
    SSE_CFLAGS=$SSE2_CFLAGS $SSE3_CFLAGS $SSSE3_CFLAGS
    SSE4_CFLAGS=$SSE41_CFLAGS $SSE42_CFLAGS $POPCNT_CFLAGS $CX16_FLAGS
    when ($ARCH_I386 && $OS_ANDROID == "yes") {
        USE_SSE4=no
    }
}
otherwise {
    USE_SSE4=no
    CPU_CHECK=no
}

# tag:cpu
when ($NOSSE == "yes") {
    USE_SSE4=no
}

# tag:cpu
### @usage: NO_SSE4()
###
### Compile module without SSE4
macro NO_SSE4() {
    SET(USE_SSE4 no)
}

# tag:cpu
### @usage: NO_CPU_CHECK()
###
### Compile module without startup CPU features check
macro NO_CPU_CHECK() {
    SET(CPU_CHECK no)
}

### @usage: ADDINCLSELF()
###
### The macro adds the -I<project source path> flag to the source compilation flags of the current project.
macro ADDINCLSELF(FOR="") {
    when($FOR) {
        ADDINCL+=FOR $FOR ${MODDIR}
    }
    otherwise {
        ADDINCL+=${MODDIR}
    }
}

COMPILE_OUT_SUFFIX=
_COMPILE_OUTPUTS=${output;suf=${COMPILE_OUT_SUFFIX}${OBJECT_SUF}:SRC}
_COMPILE_TIME_TRACE_OUTPUTS=${output;noauto;suf=${COMPILE_OUT_SUFFIX}${OBJECT_SUF}.time_trace.json:SRC}

macro SET_COMPILE_OUTPUTS_MODIFIERS(NOREL?";norel":"") {
    SET(_COMPILE_OUTPUTS \${output;suf=\${OBJECT_SUF}$NOREL:SRC})
    SET(_COMPILE_TIME_TRACE_OUTPUTS \${output;noauto;suf=\${OBJECT_SUF}.time_trace.json$NOREL:SRC})
}

# tag:internal
### @usage: _ADD_EXTRA_FLAGS_IMPL([GENERATE] Args...) # internal
### Generate prefix = " && set_property SOURCE ${input:SRC} APPEND PROPERTY COMPILE_OPTIONS " before $Args when GENERATE
### is specified in the list of actual arguments
macro _ADD_EXTRA_FLAGS_IMPL(GENERATE?" && set_property SOURCE ${input:SRC} APPEND PROPERTY COMPILE_OPTIONS ":"", Args...) {
    .SEM=$GENERATE $Args
}

# tag:internal
### @usage: _ADD_EXTRA_FLAGS([GENERATE] Args...) # internal
### Generate prefix = " && set_property SOURCE ${input:SRC} APPEND PROPERTY COMPILE_OPTIONS " if Args is not empty
macro _ADD_EXTRA_FLAGS(COMPILE_OUT_SUFFIX="", Args...) {
    .SEM=$_ADD_EXTRA_FLAGS_IMPL(${pre=GENERATE :Args})
}

_EMPTY_CMD=

# tag:src-processing tag:internal
### @usage: _SRC(Ext Src Flags) # internal
###
### Basic building block of extension-based command dispatching
### To enable specific extension processing define _SRC() macro with fixed first argument (Ext).
### Internal logic will apply this macro to all files with this Ext listed in SRC/SRCS macros or outputs
### of other commands (except ones marked as noauto)
macro _SRC(EXT, SRC, SRCFLAGS...) {
    # Generic macro definition for _SRC (just a placeholder, it does nothing)
}

# tag:src-processing
macro _SRC("swg", SRC, SRCFLAGS...) {
    .CMD=${_SWIG_CMD}
    .ADDINCL=${_SWIG_ADDINCLS}
    .PEERDIR=${_SWIG_PEERDIR}
    .SEM=conan_require_tool swig/4.0.2 && conan_import '"bin, *swig* -> ./bin"' ${input;hide:SRC} ${_SWIG_SEM_TO_MODULE_LINK}
}

RODATA_SYMBOL_PREFIX=
when ($DARWIN == "yes" || $IOS == "yes" || ($WINDOWS == "yes" && $ARCH_TYPE_32 == "yes")) {
    RODATA_SYMBOL_PREFIX=_
}

RODATA_ELF_FLAGS=
when($LINUX  == "yes" || $ANDROID == "yes") {
    RODATA_ELF_FLAGS=--elf
}

RODATA_COMPILE=$YMAKE_PYTHON3 ${input:"build/scripts/rodata2asm.py"} $RODATA_ELF_FLAGS ${RODATA_SYMBOL_PREFIX}${noext;nopath:SRC} ${input:SRC} ${tmp;suf=.asm:SRC} ${hide:OBJECT_SUF} && $_SRC_yasm_helper(${tmp;suf=.asm:SRC})
when (($ARCH_AARCH64 || $ARCH_ARM || $ARCH_PPC64LE || $ARCH_RISCV32) == "yes") {
    RODATA_COMPILE=$YMAKE_PYTHON3 ${input:"build/scripts/rodata2cpp.py"} ${noext;nopath:SRC} ${input:SRC} ${output;suf=.cpp:SRC}
}

# tag:src-processing
macro _SRC("rodata", SRC, SRCFLAGS...) {
    .CMD=$RODATA_COMPILE ${hide;kv:"p RD"} ${hide;kv:"pc light-green"}
    .SEM=target_rodata_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} ${input;hide:"build/scripts/rodata2cpp.py"}
}

# tag:src-processing
macro _SRC("S", SRC, SRCFLAGS...) {
    .CMD=$C_COMPILER $C_FLAGS_PLATFORM $CFLAGS $SFLAGS $SRCFLAGS -c -o ${output:SRC.o} ${input:SRC} ${pre=-I:_C__INCLUDE}
    .SEM=target_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS) && add_language ASM
}

# tag:src-processing
macro _SRC("s", SRC, SRCFLAGS...) {
    .CMD=$_SRC(S, $SRC $SRCFLAGS)
}

# tag:src-processing
macro _SRC("s79", SRC, SRCFLAGS...) {
    .CMD=$_SRC(S, $SRC $SRCFLAGS -x assembler-with-cpp)
}

# tag:src-processing
macro _SRC("mm", SRC, SRCFLAGS...) {
    .CMD=$C_COMPILER $C_FLAGS_PLATFORM -x objective-c++ -fobjc-arc -fobjc-abi-version=2 -c -o ${output:SRC.o} ${input:SRC} $CXXFLAGS ${pre=-I:_C__INCLUDE} ${SRCFLAGS} ${kv;hide:"p CC"} ${kv;hide:"pc light-green"} $TOOLCHAIN_ENV
}

# tag:src-processing
macro _SRC("fml", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL $CHECKFLAG -b -o ${output:SRC.inc} -T ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("fml2", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL $CHECKFLAG -b -o ${output;nopath;noext:SRC.fml.inc} -2 -O ${output;nopath;noext:SRC.fml.cpp} -T ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("fml3", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL $CHECKFLAG -b -o ${output;nopath;noext:SRC.fml.inc} -3 -O ${output;nopath;noext:SRC.fml.cpp} -L ${input;nopath;noext:SRC.list} -P ${nopath;noext:SRC} -T ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("sfdl", SRC, SRCFLAGS...) {
    .CMD=$CXX_COMPILER $C_FLAGS_PLATFORM $CXXFLAGS $SFDL_FLAG ${SRCFLAGS} ${input:SRC} && ${tool:"tools/calcstaticopt"} -i ${tmp:SRC.tmp} -a $ARCADIA_ROOT ${output;stdout;nopath;noext;defext=.inc:SRC} ${kv;hide:"p SF"} ${kv;hide:"pc yellow"} $TOOLCHAIN_ENV
}

macro _XS_SRCS(SRC, TYPEMAPS[], SRCFLAGS...) {
    .CMD=$PERL_LD_LIBRARY_PATH $PERL $PERL_INCLUDE ${suf=/ExtUtils/xsubpp:PERL_PRIVLIB} -typemap ${suf=/ExtUtils/typemap:PERL_PRIVLIB} $PERLSUFFIX $XSUBPPFLAGS ${pre=-typemap :TYPEMAPS} ${input;hide:TYPEMAPS} ${SRCFLAGS} ${input:SRC} ${PERLOUTPUT} ${kv;hide:"p XS"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("xs", SRC, SRCFLAGS...) {
    .CMD=$_XS_SRCS($SRC TYPEMAPS $_XSTYPEMAPS $SRCFLAGS)
}

# tag:src-processing
macro _SRC("gperf", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/gperf"} $GP_FLAGS ${SRCFLAGS} ${pre=-Nin_;suf=_set;nopath;noallext:SRC} ${input:SRC} ${output;stdout;nopath;noext;defext=.gperf.cpp:SRC} ${kv;hide:"p GP"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("rl", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel5/ragel"} $RAGEL_FLAGS ${SRCFLAGS} -o ${tmp:SRC.tmp} ${input:SRC} && $RUN_NO_SANITIZE ${tool:"contrib/tools/ragel5/rlgen-cd"} $RLGEN_FLAGS -o ${output;nopath;noext;defext=.rl5.cpp:SRC} ${tmp:SRC.tmp} ${kv;hide:"p R5"} ${kv;hide:"pc yellow"}
}

macro _SRC("xsyn", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"library/cpp/xml/parslib/xsyn2ragel.py"} ${input:SRC} ${input:"library/cpp/xml/parslib/xmlpars.xh"} dontuse ${output;stdout;suf=.h.rl5:SRC} ${kv;hide:"p XN"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("rl5", SRC, SRCFLAGS...) {
    .CMD=$_SRC(rl $SRC $SRCFLAGS)
}

# tag:src-processing
macro _SRC("asp", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"tools/html2cpp"} ${input:SRC} ${output:SRC.cpp} ${kv;hide:"p HT"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("rl6", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel6"} $RAGEL6_FLAGS ${SRCFLAGS} -L -I${ARCADIA_ROOT} -o ${output;nopath;noext;defext=.rl6.cpp:SRC} ${input:SRC} ${kv;hide:"p R6"} ${kv;hide:"pc yellow"}
    .SEM=target_ragel_lexers PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $RAGEL6_FLAGS ${SRCFLAGS} && set_global_flags RAGEL_FLAGS -L -I $S/ && conan_require_tool ragel/6.10 && conan_import '"bin, ragel* -> ./bin"' ${input;hide:"build/scripts/run_tool.py"}
}

# tag:src-processing
macro _SRC("pln", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL -b -o ${output;pre=pln.;nopath;noext:SRC.cpp} -f ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("xsyn", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"library/cpp/xml/parslib/xsyn2ragel.py"} ${input:SRC} ${input:"library/cpp/xml/parslib/xmlpars.xh"} dontuse ${output;stdout:SRC.h.rl5} ${kv;hide:"p XN"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("ev", SRC, SRCFLAGS...) {
    .CMD=$EVLOG_CMD($SRC)
    .SEM=$EVLOG_CMD($SRC)
}

# tag:src-processing
macro _SRC("proto", SRC, SRCFLAGS...) {
    .CMD=$PROTO_CMD($SRC)
    .SEM=$PROTO_CMD($SRC)
}

# tag:src-processing
macro _SRC("gztproto", SRC, SRCFLAGS...) {
    # _PROTO__INCLUDE is before ARCADIA_ROOT in includes because in gazetteer we don't use builtins now and paths' canonization (resolving) depends on order of roots.
    # descriptor.proto must be resolved as google/protobuf/descriptor.proto
    .CMD=${tool:"dict/gazetteer/converter"} -I$PROTOBUF_PATH ${pre="-I":_PROTO__INCLUDE} -I$ARCADIA_ROOT ${SRCFLAGS} ${input:SRC} ${output;nopath;noext;norel:SRC.proto} ${kv;hide:"p GZ"} ${kv;hide:"pc yellow"}
    .PEERDIR=kernel/gazetteer/proto
}

# tag:src-processing
macro _SRC("cfgproto", SRC, SRCFLAGS...) {
    .CMD=$_CPP_CFGPROTO_CMD($SRC)
}

# tag:src-processing
macro _SRC("pyx", SRC, SRCFLAGS...) {
    # Copy-paste from BUILDWITH_CYTHON
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:SRC} -o ${output;tobindir;suf=${OBJ_SUF}.cpp:SRC} $CYTHON_OUTPUT_INCLUDES ${SRCFLAGS} ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    .SEM=target_cython_sources PRIVATE ${input:Src} ${output;hide;tobindir:Src.fake.o} && target_cython_options $CYTHON_OPTIONS --cplus ${SRCFLAGS} ${CYTHON_CPP_OUTPUT_INCLUDES} && target_cython_include_directories $_CYTHON__INCLUDE && set_python_type_for_cython $PYTHON_TYPE_FOR_CYTHON
    .ADDINCL=FOR cython contrib/tools/cython/Cython/Includes
}

# tag:src-processing
macro _SRC("in", SRC, SRCFLAGS...) {
   .CMD=$CONFIGURE_FILE(${SRC} ${nopath;noext:SRC})
   .SEM=$CONFIGURE_FILE(${SRC} ${nopath;noext:SRC})
}

macro MANUAL_GENERATION(Outs...) {
    .SEM=IGNORED ${output;hide;noauto:Outs}
}

# tag:src-processing
macro _SRC("sc", SRC, SRCFLAGS...) {
    .CMD=${tool:"tools/domschemec"} --in ${input:SRC} --out ${output;norel:SRC.h} ${output_include;hide:"util/generic/strbuf.h"} ${output_include;hide:"array"} ${output_include;hide:"util/generic/string.h"} ${output_include;hide:"util/generic/vector.h"} ${output_include;hide:"util/string/cast.h"} ${SRCFLAGS} ${kv;hide:"p SC"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("ssqls", SRC, SRCFLAGS...) {
    .CMD=${tool:"metrika/core/tools/ssqls"} ${input;notransformbuilddir:SRC} -S $ARCADIA_ROOT -B $ARCADIA_BUILD_ROOT $SRCFLAGS ${output;noext;hide:SRC.cpp} ${output;noext;hide:SRC.h} ${kv;hide:"p SS"} ${kv;hide:"pc yellow"}
}

# tag:src-processing
macro _SRC("f", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/f2c.py"} -t ${tool:"contrib/tools/f2c"} -c ${input:SRC} -o ${output:SRC.c} ${output_include;hide:"f2c.h"} ${kv;hide:"p FT"} ${kv;hide:"pc light-green"}
    .PEERDIR=contrib/libs/libf2c
    .ADDINCL=contrib/libs/libf2c
}

# tag:src-processing
macro _SRC("cpp", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp($SRC $SRCFLAGS)
    .SEM=target_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS)
}

# tag:src-processing
macro _SRC("cxx", SRC, SRCFLAGS...) {
    .CMD=$_SRC(cpp $SRC $SRCFLAGS)
}

# tag:src-processing
macro _SRC("cc", SRC, SRCFLAGS...) {
    .CMD=$_SRC(cpp $SRC $SRCFLAGS)
    .SEM=target_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS)
}

# tag:src-processing
macro _SRC("auxcpp", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp($SRC $_FORCE_CPP_FLAGS $SRCFLAGS)
    .SEM=target_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($_FORCE_CPP_FLAGS $SRCFLAGS)
}

# tag:src-processing
macro _SRC("C", SRC, SRCFLAGS...) {
    .CMD=$_SRC(cpp $SRC $SRCFLAGS)
}

# tag:src-processing
macro _SRC("c", SRC, SRCFLAGS...) {
    .CMD=$_SRC_c($SRC $SRCFLAGS)
    .SEM=target_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS $USER_CONLYFLAGS $USER_CONLYFLAGS_GLOBAL)
}

# tag:src-processing
macro _SRC("m", SRC, SRCFLAGS...) {
    .CMD=$_SRC(c $SRC $SRCFLAGS)
}

# tag:src-processing
macro _SRC("masm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_masm($SRC $SRCFLAGS)
}

YASM_SEM=target_yasm_source PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $YASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS ${pre=-P :PREINCLUDES} ${input;hide:"build/scripts/run_tool.py"} \
         && set_global_flags YASM_FLAGS -f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} $_YASM_PLATFORM_FLAGS_VALUE -D ${pre=_;suf=_:HARDWARE_TYPE} -D_YASM_ $ASM_PREFIX_VALUE $_YASM_PREDEFINED_FLAGS_VALUE \
         && add_language ASM \
         && conan_require_tool yasm/1.3.0 && conan_import '"bin, *yasm* -> ./bin"' && conan_import '"bin, ytasm* -> ./bin"'
ASM_SEM=target_yasm_source PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} $YASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS ${input;hide:"build/scripts/run_tool.py"} \
        && set_global_flags YASM_FLAGS -f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} $_YASM_PLATFORM_FLAGS_VALUE -D ${pre=_;suf=_:HARDWARE_TYPE} -D_YASM_ $ASM_PREFIX_VALUE $_YASM_PREDEFINED_FLAGS_VALUE \
        && add_language ASM \
        && conan_require_tool yasm/1.3.0 && conan_import '"bin, *yasm* -> ./bin"' && conan_import '"bin, ytasm* -> ./bin"'
# tag:src-processing
macro _SRC("yasm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_yasm($SRC $SRCFLAGS PREINCLUDES $YASM_PREINCLUDES_VALUE)
    .SEM=$YASM_SEM
}

# tag:src-processing
macro _SRC("asm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_ASM($SRC $SRCFLAGS PREINCLUDES $YASM_PREINCLUDES_VALUE)
    .SEM=$ASM_SEM
}

# tag:src-processing
macro _SRC("lua", SRC, SRCFLAGS...) {
    .CMD=${cwd:LUAJIT_PATH} ${tool:"contrib/libs/luajit/compiler"} -b -g ${input:SRC} ${SRCFLAGS} ${global;output;suf=.o:SRC} ${kv;hide:"p LJ"} ${kv;hide:"pc light-cyan"}
    .PEERDIR=$LUAJIT_PATH
}

NVCC_CFLAGS=
when ($IDE_MSVS_CALL == "yes") {
    # This is to avoid issues with .pdb from MSVC calling nvcc calling cl
    NVCC_CFLAGS+=/Fd$(TEMP)
}

NVCC_STD_VER=14
when ($MSVC == "yes") {
    NVCC_STD=/std:c++${NVCC_STD_VER}
}
otherwise {
    NVCC_STD=-std=c++${NVCC_STD_VER}
}

# tag:src-processing
macro _SRC("cu", SRC, SRCFLAGS...) {
    .CMD=$_SRC_CU_CMD
    .SEM=target_cuda_sources PRIVATE ${input:SRC} ${output;hide;suf=${OBJ_SUF}.o:SRC} && set_global_flags CMAKE_CUDA_STANDARD ${NVCC_STD_VER} && target_cuda_flags $CUDA_NVCC_FLAGS && target_cuda_cflags $USER_CXXFLAGS $SRCFLAGS $_SEM_EXTRA_CXX_FLAGS
    .PEERDIR=$_SRC_CU_PEERDIR
}

# tag:src-processing
macro _SRC("fbs", SRC, SRCFLAGS...) {
    .CMD=$FBS_CMD($SRC, $SRCFLAGS)
    .SEM=$FBS_CMD($SRC, $SRCFLAGS)
}

# tag:src-processing
macro _SRC("fbs64", SRC, SRCFLAGS...) {
    .CMD=$_CPP_FLATC64_CMD($SRC, $SRCFLAGS)
}

# tag:src-processing
macro _SRC("pysrc", SRC, SRCFLAGS...) {
    .CMD=$_SRC_PYSRC($SRC, $SRCFLAGS)
}

# tag:src-processing
# This triggers configure error in attempt to add `ya.make` to SRCS macro or apply automatic processing by extension from codegen
macro _SRC("make", SRC, SRCFLAGS...) {
    .CMD=
}

@import "${CONF_ROOT}/conf/bison_lex.conf"

# tag:src-processing
macro _SRC_py2src(SRC, SRCFLAGS...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON3 ${input:"build/scripts/compile_pysrc.py"} --input ${input:SRC} --output ${output;noext;suf=.py2_raw.cpp:SRC} --rescompiler ${tool:"tools/rescompiler"} py2 --python $(PYTHON)/python --py_compile ${input:"build/scripts/py_compile.py"} ${kv;hide:"p P2"} ${kv;hide:"pc light-green"}
}

# tag:src-processing
macro _SRC_py3src(SRC, SRCFLAGS...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON3 ${input:"build/scripts/compile_pysrc.py"} --input ${input:SRC} --output ${output;noext;suf=.py3_raw.cpp:SRC} --rescompiler ${tool:"tools/rescompiler"} py3 --pycc ${tool:"contrib/tools/python3/pycc"} ${kv;hide:"p P3"} ${kv;hide:"pc light-green"}
}

# tag:src-processing python-specific
when ($PYTHON3 == "yes") {
    MACRO_ALIAS(_SRC_PYSRC _SRC_py3src)
}
otherwise {
    MACRO_ALIAS(_SRC_PYSRC _SRC_py2src)
}

# tag:src-processing
macro _SRC_c_nodeps(SRC, OUTFILE, INC...) {
     .CMD=$_SRC_C_NODEPS_CMD
}

# Custom flags for generated cpp-files. To support another generator:
# - insert additional file extension before .cpp into generated cpp-file name
# - update _LANG_CFLAGS_FILTER variable. Don't forget to add ' SKIP ' after flag list
#
# ragel5 and ragel6 generated terrible code which makes use of goto's in switch statements.
# This triggers -Werror-implicit-fallthrough due to `unannotated fall-through between switch labels`.
#
# cython generated code also fails to pass this diagnostics due to `fallthrough annotation in unreachable code`.
# We use cython==0.29.26 at the time. This issue might be fixed in further versions.
#
# flags -fno-profile-instr-generate -fno-coverage-mapping needed to always disable coverage for .pyx, .rl5, .rl6
# generated sources
## tag:src-processing
when ($CLANG == "yes") {
    _LANG_CFLAGS_FILTER=\
        ${pre=-Wno-implicit-fallthrough -fno-profile-instr-generate -fno-coverage-mapping SKIP ;ext=.rl5:SRC} \
        ${pre=-Wno-implicit-fallthrough -fno-profile-instr-generate -fno-coverage-mapping SKIP ;ext=.rl6:SRC} \
        ${pre=-Wno-implicit-fallthrough -fno-profile-instr-generate -fno-coverage-mapping SKIP ;ext=.pyx:SRC}
}
otherwise {
    _LANG_CFLAGS_FILTER=\
        ${pre=-Wno-implicit-fallthrough SKIP ;ext=.rl5:SRC} \
        ${pre=-Wno-implicit-fallthrough SKIP ;ext=.rl6:SRC} \
        ${pre=-Wno-implicit-fallthrough SKIP ;ext=.pyx:SRC}
}

# tag:src-processing
# Magic macro for removing file name from result (file name is passed as unused SKIP parameter)
macro _FILTER_EXTS(SKIP="", FLAGS...) {
    .CMD=$FLAGS
}

# tag:src-processing
macro _LANG_CFLAGS(SRC) {
    .CMD=$_FILTER_EXTS($_LANG_CFLAGS_FILTER)
}

# tag:src-processing
# ymake bug workaround: variables followed a macros call in .CMD are not substituted and are placed in result as is
# Pack macro call into a variable and use it in _SRC_CPP_CMD instead of macro call
_LANG_CFLAGS_VALUE=
when ($CLANG == "yes" || $CLANG_CL == "yes" || $GCC == "yes") {
    _LANG_CFLAGS_VALUE=$_LANG_CFLAGS(${noext:SRC})
}

# Allows to add single compilation unit name to the node's 'kv' section.
# This is used by the coverage machinery to instrument only the necessary sources
# when --coverage-prefix-filter <rootrelpath> is specified. For more info see DEVTOOLSSUPPORT-16891
SCU_NAME_KV=
when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no" && $USE_SCU_VALUE == "yes") {
    SCU_NAME_KV=${hide;kv:"scu_name $KV_VAL"}
}

macro _ADD_SCU_NAME(KV_VAL) {
    .CMD=$SCU_NAME_KV
}

# tag:src-processing
macro _SRC_cpp(SRC, COMPILE_OUT_SUFFIX="", SRCFLAGS...) {
    .CMD=$_SRC_CPP_CMD $_ADD_SCU_NAME(${input:SRC})
}

# tag:src-processing
macro _SRC_c(SRC, COMPILE_OUT_SUFFIX="", SRCFLAGS...) {
    .CMD=$_SRC_C_CMD $_ADD_SCU_NAME(${input:SRC})
}

# tag:src-processing
macro _SRC_m(SRC, SRCFLAGS...) {
    .CMD=$_SRC_M_CMD
}

# tag:src-processing
macro _SRC_masm(SRC, SRCFLAGS...) {
    .CMD=$_SRC_MASM_CMD
}

# tag:lua-specific
### @usage: COMPILE_LUA(Src, [NAME <import_name>])
###
### Compile LUA source file to object code using LUA 2.0
### Optionally override import name which is by default reflects Src name
macro COMPILE_LUA(Src, NAME="") {
    .CMD=$_SRC(lua, $Src, ${pre=-n :NAME})
}

# tag:lua-specific
### @usage: _SRC_lua_21(SRC [SRCFLAGS...]) # internal
###
### Compile LUA source file to object code using LUA 2.1
macro _SRC_lua_21(SRC, SRCFLAGS...) {
    .CMD=${cwd:LUAJIT_21_PATH} ${tool:"contrib/libs/luajit_21/compiler"} -b -g ${input:SRC} ${SRCFLAGS} ${global;output;suf=.o:SRC} ${kv;hide:"p LJ"} ${kv;hide:"pc light-cyan"}
    .PEERDIR=$LUAJIT_21_PATH
}

# tag:lua-specific
### @usage: COMPILE_LUA_21(Src, [NAME <import_name>])
###
### Compile LUA source file to object code using LUA 2.1
### Optionally override import name which is by default reflects Src name
macro COMPILE_LUA_21(Src, NAME="") {
    .CMD=$_SRC_lua_21($Src, ${pre=-n :NAME})
}

GETTEXT_KEEP_PATH=no
_MO_OUTPUT=
when ($GETTEXT_KEEP_PATH == "yes") {
    _MO_OUTPUT=${output;noauto;norel;noext:SRC.mo}
}
otherwise {
    _MO_OUTPUT=${output;noauto;nopath;noext;tobindir:SRC.mo}
}

# tag:src-processing
macro _SRC("po", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"contrib/tools/python/src/Tools/i18n/msgfmt.py"} -o $_MO_OUTPUT ${input:SRC}
}

# tag:ydl-specific
YDL_FLAGS= --force-color -I ${ARCADIA_ROOT}
YDL_DESC_FLAGS=

# tag:src-processing tag:ydl-specific
macro _SRC("ydl", SRC, SRCFLAGS...) {
    .CMD=${tool:"statbox/ydl/compiler/tooling/ydl/bin"} c $YDL_FLAGS --cpp-output-header ${output;suf=.h:SRC} --cpp-output-source ${output;suf=.cpp:SRC} ${input:SRC} ${output_include;hide:"statbox/ydl/runtime/cpp/gen_support/standard_includes.h"} ${kv;hide:"p YDL"} ${kv;hide:"pc yellow"}
    .PEERDIR+=statbox/ydl/runtime/cpp
}

# tag:ydl-specific
### @usage BUILD_YDL_DESC(Input Symbol Output)
###
### Generate a descriptor for a Symbol located in a ydl module Input, and put it to the file Output.
###
### @example:
###
###     PACKAGE()
###         BUILD_YDL_DESC(../types.ydl Event Event.ydld)
###     END()
###
### This will parse file ../types.ydl, generate a descriptor for a symbol Event defined in the said file, and put the descriptor to the Event.ydld.
macro BUILD_YDL_DESC(Input, Symbol, Output) {
    .CMD=${tool:"statbox/ydl/compiler/tooling/ydl/bin"} ti $YDL_FLAGS $YDL_DESC_FLAGS -o ${output;noauto:Output} ${input:Input} ${Symbol} ${kv;hide:"p YDL"} ${kv;hide:"pc yellow"}
}

# tag:ydl-specific
### @usage: YDL_DESC_USE_BINARY()
###
### Used in conjunction with BUILD_YDL_DESC. When enabled, all generated descriptors are binary.
###
### @example:
###
###     PACKAGE()
###         YDL_DESC_USE_BINARY()
###         BUILD_YDL_DESC(../types.ydl Event Event.ydld)
###     END()
###
### This will generate descriptor Event.ydld in a binary format.
macro YDL_DESC_USE_BINARY() {
    YDL_DESC_FLAGS_BINARY= --binary
    SET_APPEND(YDL_DESC_FLAGS $YDL_DESC_FLAGS_BINARY)
}

### @usage SRC(File Flags...)
###
### Compile single file with extra Flags.
### Compilation is driven by the last extension of the File and Flags are specific to corresponding compilation command
macro SRC(FILE, FLAGS...) {
    _SRC(${lastext:FILE} $FILE $FLAGS)
}

### @usage: SRCS(<[GLOBAL] File> ...)
###
### Source files of the project. Files are built according to their extension and put int module output or fed to ultimate PROGRAM/DLL depending on GLOBAL presence.
### Arcadia Paths from the root and is relative to the project's LIST are supported
###
### GLOBAL marks next file as direct input to link phase of the program/shared library project built into. This prevents symbols of the file to be excluded by linker as unused.
### The scope of the GLOBAL keyword is the following file (that is, in the case of SRCS(GLOBAL foo.cpp bar.cpp) global will be only foo.cpp)
###
### @example:
###
###     LIBRARY(test_global)
###         SRCS(GLOBAL foo.cpp)
###     END()
###
### This will produce foo.o and feed it to any PROGRAM/DLL module transitively depending on test_global library. The library itself will be empty and won't produce .a file.
macro SRCS(FILES...) {
    foreach (FILE : $FILES) {
        _SRC(${lastext:FILE} $FILE)
    }
}

# tag:c-specific
macro _SRC_C_CUSTOM_FLAGS(SRC, COMPILE_OUT_SUFFIX, CUSTOM_FLAGS...) {
    .CMD=$_SRC_c($SRC COMPILE_OUT_SUFFIX ${COMPILE_OUT_SUFFIX} ${CUSTOM_FLAGS})
    .SEM=target_sources_custom $COMPILE_OUT_SUFFIX SRCS ${input:SRC} ${hide;output;suf=${COMPILE_OUT_SUFFIX}.o:SRC} CUSTOM_FLAGS $CUSTOM_FLAGS $USER_CONLYFLAGS $USER_CONLYFLAGS_GLOBAL
}

macro _SRC_CPP_CUSTOM_FLAGS(SRC, COMPILE_OUT_SUFFIX, CUSTOM_FLAGS...) {
    .CMD=$_SRC_cpp($SRC COMPILE_OUT_SUFFIX ${COMPILE_OUT_SUFFIX} ${CUSTOM_FLAGS})
    .SEM=target_sources_custom $COMPILE_OUT_SUFFIX SRCS ${input:SRC} ${hide;output;suf=${COMPILE_OUT_SUFFIX}.o:SRC} CUSTOM_FLAGS $CUSTOM_FLAGS
}


# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Defenition of generic macro. Report an error that the File with Ext is not
### supported by macro MacroName if no appropriate macro specialization is found.
macro _SRC_CUSTOM_C_CPP(EXT, MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    MESSAGE(FATAL_ERROR macro [[alt1]]$MACRO_NAME[[rst]] does not support files with [[imp]].$EXT[[rst]] extension)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single C file (with .c extension)
macro _SRC_CUSTOM_C_CPP("c", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_C_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .cpp extension)
macro _SRC_CUSTOM_C_CPP("cpp", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .cxx extension)
macro _SRC_CUSTOM_C_CPP("cxx", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .cc extension)
macro _SRC_CUSTOM_C_CPP("cc", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .C extension)
macro _SRC_CUSTOM_C_CPP("C", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_SSE2(File Flags...)
###
### Compile a single C/C++ file with SSE2 and additional Flags
macro SRC_C_SSE2(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE2 $FILE .sse2 $SSE2_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_SSE3(File Flags...)
###
### Compile a single C/C++ file with SSE3 and additional Flags
macro SRC_C_SSE3(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE3 $FILE .sse3 $SSE3_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_SSSE3(File Flags...)
###
### Compile a single C/C++ file with SSSE3 and additional Flags
macro SRC_C_SSSE3(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSSE3 $FILE .ssse3 $SSSE3_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_SSE4(File Flags...)
###
### Compile a single C/C++ file with SSE4 and additional Flags
macro SRC_C_SSE4(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE4 $FILE .sse4 $SSE4_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_SSE41(File Flags...)
###
### Compile a single C/C++ file with SSE4.1 and additional Flags
macro SRC_C_SSE41(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE41 $FILE .sse41 $SSE41_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_AVX(File Flags...)
###
### Compile a single C/C++ file with AVX and additional Flags
macro SRC_C_AVX(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AVX $FILE .avx $AVX_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_AVX2(File Flags...)
###
### Compile a single C/C++ file with AVX2 and additional Flags
macro SRC_C_AVX2(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AVX2 $FILE .avx2 $AVX2_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_AVX512(File Flags...)
###
### Compile a single C/C++ file with AVX512 and additional Flags
macro SRC_C_AVX512(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AVX512 $FILE .avx512 $AVX512_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_AVX512(File Flags...)
###
### Compile a single C/C++ file with AVX512 and additional Flags
macro SRC_C_AMX(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AMX $FILE .amx $AMX_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_XOP(File Flags...)
###
### Compile a single C/C++ file with (an AMD-specific instruction set,
### see https://en.wikipedia.org/wiki/XOP_instruction_set) and additional Flags
macro SRC_C_XOP(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_XOP $FILE .xop $XOP_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @uasge SRC_C_PCLMUL(File Flags...)
###
### Compile a single C/C++ file with PCLMUL and additional Flags
macro SRC_C_PCLMUL(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_PCLMUL $FILE .pclmul $PCLMUL_CFLAGS $FLAGS )
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Defenition of generic macro. Report an error that the File with Ext is not
### supported by macro MacroName if no appropriate macro specialization is found.
macro _SRC_STRICT_C_CPP(EXT, MACRO_NAME, FILE, FLAGS...) {
    MESSAGE(FATAL_ERROR macro [[alt1]]$MACRO_NAME[[rst]] does not support files with [[imp]].$EXT[[rst]] extension)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single C file (with .c extension)
macro _SRC_STRICT_C_CPP("c", MACRO_NAME, FILE, FLAGS...) {
    _SRC(c $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .cpp extension)
macro _SRC_STRICT_C_CPP("cpp", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .cxx extension)
macro _SRC_STRICT_C_CPP("cxx", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .cc extension)
macro _SRC_STRICT_C_CPP("cc", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .C extension)
macro _SRC_STRICT_C_CPP("C", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @uasge SRC_C_PIC(File Flags...)
###
### Compile a single C/C++ file with -fPIC and additional Flags
macro SRC_C_PIC(FILE, FLAGS...) {
    _SRC_STRICT_C_CPP(${lastext:FILE} SRC_C_PIC $FILE $PIC_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @uasge SRC_C_NO_LTO(File Flags...)
###
### Compile a single C/C++ file with link-time-optimization disabling and additional Flags
macro SRC_C_NO_LTO(FILE, FLAGS...) {
    _SRC_STRICT_C_CPP(${lastext:FILE} SRC_C_NO_LTO $FILE $NO_LTO_CFLAGS $FLAGS)
}

# tag:python-processing tag:cython
# TODO: use it in [.pyx] cmd
### @usage: BUILDWITH_CYTHON_CPP(Src Options...)
###
### Generates .cpp file from .pyx.
macro BUILDWITH_CYTHON_CPP(Src, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} -o ${output;tobindir;suf=${OBJ_SUF}.cpp:Src} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    .SEM=target_cython_sources PRIVATE ${input:Src} ${output;hide;tobindir:Src.fake.o} && target_cython_options $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} && target_cython_include_directories $_CYTHON__INCLUDE && set_python_type_for_cython $PYTHON_TYPE_FOR_CYTHON
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_CPP_DEP(Src Dep Options...) # internal
###
### Generates .cpp file from .pyx and attach extra input Dep.
### If Dep changes the .cpp file will be re-generated.
macro _BUILDWITH_CYTHON_CPP_DEP(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${input;hide:Dep} -o ${output;tobindir;suf=${OBJ_SUF}.cpp:Src} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    .SEM=target_cython_sources PRIVATE ${input:Src} ${input;hide:Dep} ${output;hide;tobindir:Src.fake.o} && target_cython_options $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} && target_cython_include_directories $_CYTHON__INCLUDE && set_python_type_for_cython $PYTHON_TYPE_FOR_CYTHON
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_CPP_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_CPP without .pyx infix and with cdef public .h file.
macro _BUILDWITH_CYTHON_CPP_H(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT_H $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${input;hide:Dep} -o ${output;noext;tobindir:Src.cpp} ${output;hide;addincl;noext;tobindir:Src.h} ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}


# tag:python-processing tag:cython
### @usage: BUILDWITH_CYTHON_C(Src Options...)
###
### Generates .c file from .pyx.
macro BUILDWITH_CYTHON_C(Src, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} -o ${output;tobindir;suf=${OBJ_SUF}.c:Src} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    .SEM=target_cython_sources PRIVATE ${input:Src} ${output;hide;tobindir:Src.fake.o} && target_cython_options $CYTHON_OPTIONS ${Options} ${CYTHON_OUTPUT_INCLUDES} && target_cython_include_directories $_CYTHON__INCLUDE && set_python_type_for_cython $PYTHON_TYPE_FOR_CYTHON
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_C_DEP(Src Dep Options...) # internal
###
### Generates .c file from .pyx and attach extra input Dep.
### If Dep changes the .c file will be re-generated.
macro _BUILDWITH_CYTHON_C_DEP(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${input;hide:Dep} -o ${output;tobindir;suf=${OBJ_SUF}.c:Src} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    .SEM=target_cython_sources PRIVATE ${input:Src} ${input;hide:Dep} ${output;hide;tobindir:Src.fake.o} && target_cython_options $CYTHON_OPTIONS ${Options} ${CYTHON_OUTPUT_INCLUDES} && target_cython_include_directories $_CYTHON__INCLUDE && set_python_type_for_cython $PYTHON_TYPE_FOR_CYTHON
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_C_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_C without .pyx infix and with cdef public .h file.
macro _BUILDWITH_CYTHON_C_H(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT_H $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${input;hide:Dep} -o ${output;noext;tobindir:Src.c} ${output;hide;addincl;noext;tobindir:Src.h} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_C_API_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_C_H with cdef api _api.h file.
macro _BUILDWITH_CYTHON_C_API_H(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT_H $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${input;hide:Dep} -o ${output;noext;tobindir:Src.c} ${output;hide;addincl;noext;tobindir:Src.h} ${output;hide;addincl;noext;defext=_api.h;tobindir:Src} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(FOR cython contrib/tools/cython/Cython/Includes)
}

### @usage: BUILDWITH_RAGEL6(Src Options...)
###
### Compile .rl file using Ragel6.
macro BUILDWITH_RAGEL6(Src, Options...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel6"} $RAGEL6_FLAGS ${Options} -I${ARCADIA_ROOT} -o ${output;nopath;noext;defext=.rl6.cpp:Src} ${input:Src} ${kv;hide:"p R6"} ${kv;hide:"pc yellow"}
}

# tag:python-processing tag:internal
# TODO: use it in [.pyx] cmd
### @usage: _PY_REGISTER() # internal
###
### Register Python 2.x module in internal resource file system. Arcadia Python 2.x importer will be retrieve these on import directive.
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY_REGISTER(Func) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_py_reg.py"} $Func ${output;noauto:Func.reg.cpp} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Func.reg.cpp)
}

# tag:python-processing tag:internal
### @usage: _PY3_REGISTER() # internal
###
### Register Python 3.x module in internal resource file system. Arcadia Python 3.x importer will be retrieve these on import directive
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY3_REGISTER(Func) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_py3_reg.py"} $Func ${output;noauto:Func.reg3.cpp} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Func.reg3.cpp)
}

# tag:python-processing tag:internal
### @usage: _PY_COMPILE_BYTECODE(SrcX Src) # internal
###
### Compile Python 2.x .py source file into Arcadia binary form suitable for PY2_PROGRAM
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY_COMPILE_BYTECODE(SrcX, Src, Dst) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/py_compile.py"} $SrcX ${input:Src} ${output;noauto:Dst.yapyc} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
}

# tag:python-processing tag:internal
### @usage: _PY3_COMPILE_BYTECODE(SrcX Src) # internal
###
### Compile Python 3.x .py source file into Arcadia binary form suitable for PY3_PROGRAM
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY3_COMPILE_BYTECODE(SrcX, Src, Dst) {
    .CMD=${env:"PYTHONHASHSEED=0"} ${tool:"contrib/tools/python3/pycc"} $SrcX ${input:Src} ${output;noauto:Dst.yapyc3} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
}

macro _ARCHIVE_SEM_HELPER(FLAGS[], OUT, Files...) {
    .SEM=add_custom_command OUTPUT ${OUT} DEPENDS $ARCH_TOOL ${join= :Files} COMMAND $ARCH_TOOL $FLAGS ${join=\: :Files}: -o ${OUT}
}

### @usage: ARCHIVE_ASM(NAME archive_name files...)
###
### Similar to the macro ARCHIVE, but:
### 1. works faster and it is better to use for large files.
### 2. Different syntax (see examples in codesearch or users/pg/tests/archive_test)
macro ARCHIVE_ASM(NAME="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q $DONTCOMPRESS ${input;join=\: :Files}: -o ${output;suf=$OBJ_SUF.rodata:NAME} ${kv;hide:"p AR"} ${kv;hide:"pc light-cyan"}
    .SEM=$_ARCHIVE_SEM_HELPER(${output;suf=$OBJ_SUF.rodata:NAME} ${input:Files} FLAGS -q $DONTCOMPRESS)
}

# tag:yweb-specific
macro PIRE_INLINE_CMD(SRC) {
   .CMD=${tool:"library/cpp/regex/pire/inline"} -o ${output:SRC} ${input:SRC} ${output_include;hide:SRC} ${kv;hide:"p PI"} ${kv;hide:"pc yellow"}
}

# tag:yweb-specific
macro PIRE_INLINE(FILES...) {
    foreach (FILE : $FILES) {
        PIRE_INLINE_CMD($FILE)
    }
}

### @usage: ARCHIVE(archive_name [DONT_COMPRESS] files...)
###
### Add arbitrary data to a modules. Unlike RESOURCE macro the result should be futher processed by othet macros in the module.
###
### Example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a1ispolzujjtekomanduarchive
macro ARCHIVE(NAME="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q -x $DONTCOMPRESS ${input;join=\: :Files}: -o ${output;addincl;noauto:NAME} ${kv;hide:"p AR"} ${kv;hide:"pc light-red"}
    .SEM=$_ARCHIVE_SEM_HELPER(${output;addincl;noauto:NAME} ${input:Files} FLAGS -q -x $DONTCOMPRESS) && target_sources PRIVATE $BINDIR/$NAME
}

### @usage: ARCHIVE_BY_KEYS(archive_name key [DONT_COMPRESS] files...)
###
### Add arbitrary data to a module be accessible by specified key.
### Unlike RESOURCE macro the result should be futher processed by othet macros in the module.
###
### Example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a1ispolzujjtekomanduarchive
macro ARCHIVE_BY_KEYS(NAME="", KEYS="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q -x $DONTCOMPRESS ${input:Files} -k $KEYS -o ${output;addincl;noauto:NAME} ${kv;hide:"p AR"} ${kv;hide:"pc light-red"}
}

#scripts

#special commands
BUILDVERSION_SCRIPT=build/scripts/build_info_gen.py
SVNVERSION_JAVA_MARKER=output-java-class
SVNVERSION_GO_MARKER=output-go
VCS_C_OBJ=$BINDIR/__vcs_version__.c$OBJECT_SUF
VCS_C_OBJ_RR=$MODDIR/__vcs_version__.c$OBJECT_SUF
VCS_C=$BINDIR/__vcs_version__.c
VCS_GO=$BINDIR/__vcs_version__.go
VCS_JAVA=$BINDIR/__vcs_version__.mf
VCS_INFO_DISABLE_CACHE__NO_UID__=
YASM_DEBUG_INFO_DISABLE_CACHE__NO_UID__=
CL_DEBUG_INFO_DISABLE_CACHE__NO_UID__=
CL_MACRO_INFO_DISABLE_CACHE__NO_UID__=
YASM_DEBUG_INFO=
CL_DEBUG_INFO=
CL_MACRO_INFO=
when ($FORCE_VCS_INFO_UPDATE == "yes") {
    VCS_INFO_DISABLE_CACHE__NO_UID__=${hide;kv:"disable_cache"}
}
### Works for pyton too.
GENERATE_VCS_C_INFO_NODEP=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} $(VCS)/vcs.json $VCS_C ${input:"build/scripts/c_templates/svn_interface.c"} $VCS_INFO_DISABLE_CACHE__NO_UID__ && $_SRC_c_nodeps($VCS_C, $VCS_C_OBJ, $(SOURCE_ROOT))
GENERATE_VCS_GO_INFO_NODEP=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-go $(VCS)/vcs.json $VCS_GO $VCS_INFO_DISABLE_CACHE__NO_UID__
GENERATE_VCS_JAVA_INFO_NODEP=$YMAKE_PYTHON ${input:"build/scripts/vcs_info.py"} output-java $(VCS)/vcs.json $VCS_JAVA $VCS_INFO_DISABLE_CACHE__NO_UID__
macro UPDATE_VCS_JAVA_INFO_NODEP(Jar) {
    .CMD=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-java $(VCS)/vcs.json $VCS_JAVA $Jar $VCS_INFO_DISABLE_CACHE__NO_UID__
}

VCS_INFO_FILE=

### @usage VCS_INFO_FILE([FILE out_file])
###
### Enable saving vcs info as a json-file into PACKAGE
###
### Info is saved to 'vcs_info.json' by default.
### Use FILE parameter if you want another name.
###
### Note: macro can be used only once per module
macro VCS_INFO_FILE(FILE="vcs_info.json") {
    SET(VCS_INFO_FILE $FILE)
}

ADD_VCS_INFO_FILE_CMD=
when ($VCS_INFO_FILE) {
    ADD_VCS_INFO_FILE_CMD=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-json $(VCS)/vcs.json ${output:VCS_INFO_FILE} $VCS_INFO_DISABLE_CACHE__NO_UID__
}

### @usage: CREATE_BUILDINFO_FOR(GenHdr)
###
### Creates header file to access some information about build specified via configuration variables.
### Unlike CREATE_SVNVERSION_FOR() it doesn't take revion information from VCS, it uses revision and SandboxTaskId passed via -D options to ya make
macro CREATE_BUILDINFO_FOR(GenHdr) {
    .CMD=$YIELD $CXX_COMPILER && $YIELD $CXXFLAGS && $XARGS $YMAKE_PYTHON3 ${input:BUILDVERSION_SCRIPT} ${output:GenHdr} ${kv;hide:"p BI"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"} $SVN_DEPENDS_CACHE__NO_UID__
    .SEM=$RUN_PYTHON3($BUILDVERSION_SCRIPT $GenHdr \\\"${CMAKE_CXX_COMPILER}\\\" \\\"${CMAKE_CXX_FLAGS}\\\" OUT $GenHdr)
}

DECIMAL_MD5_SCRIPT=build/scripts/decimal_md5.py
DECIMAL_MD5_FIXED=

### @usage: DECIMAL_MD5_LOWER_32_BITS(<fileName> [FUNCNAME funcName] [inputs...])
###
### Generates .cpp file <fileName> with one defined function 'const char* <funcName>() { return "<calculated_md5_hash>"; }'.
### <calculated_md5_hash> will be md5 hash for all inputs passed to this macro.
macro DECIMAL_MD5_LOWER_32_BITS(File, FUNCNAME="", Opts...) {
    .CMD=$YMAKE_PYTHON ${input:DECIMAL_MD5_SCRIPT} --fixed-output=${DECIMAL_MD5_FIXED} --func-name=${FUNCNAME} --lower-bits 32 --source-root=$ARCADIA_ROOT ${input;context=TEXT:Opts} ${output;stdout:File} ${kv;hide:"p SV"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"}
}

# tag:internal
### @usage $CFG_VARS # internal
###
### Mark commands that embed Configuration variables into files
macro CFG_VARS() {
    .GEN_FROM_FILE=yes
}

### @usage: CONFIGURE_FILE(from to)
###
### Copy file with the replacement of configuration variables in form of @ANY_CONF_VAR@ with their values.
### The values are collected during configure stage, while replacement itself happens during build stage.
### Used implicitly for .in-files processing.
macro CONFIGURE_FILE(Src, Dst) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/configure_file.py"} ${input:Src} ${output;addincl:Dst} $CFG_VARS ${kv;hide:"p CF"} ${kv;hide:"pc yellow"}
    .SEM=set_vars ${CFG_VARS} && configure_file $S/${input;rootrel:Src} $B/${output;addincl;rootrel:Dst}
}

### @usage: BASE_CODEGEN(tool_path prefix)
###
### Generator ${prefix}.cpp + ${prefix}.h files based on ${prefix}.in.
macro BASE_CODEGEN(Tool, Prefix, Opts...) {
    .CMD=${tool:Tool} ${input:Prefix.in} ${output;nopath;noauto:Prefix.cpp} ${output;nopath:Prefix.h} $Opts ${kv;hide:"p BC"} ${kv;hide:"pc yellow"}
}

# tag:internal
### @usage: _SPLIT_CODEGEN_BASE(tool prefix OUTS[] OUTPUT_INCLUDES[]) # internal
###
### Generator of a certain number .the. cpp file + one header .h file from .in.
### This is the call of the generator. Python macro SPLIT_CODEGEN() is defined in order to properly fill command outputs from OUT_NUM argument.
macro _SPLIT_CODEGEN_BASE(Tool, Prefix, OUT[], OPTS[], OUTPUT_INCLUDES[]) {
    .CMD=${tool:Tool} ${input:Prefix.in} ${output;hide:OUT} ${output;nopath;noauto:Prefix.cpp} ${output;nopath:Prefix.h} $OPTS ${output_include;hide:OUTPUT_INCLUDES} ${kv;hide:"p SC"} ${kv;hide:"pc yellow"}
}

STRUCT_CODEGEN_OUTPUT_INCLUDES=${output_include;hide:"util/generic/singleton.h"} \
${output_include;hide:"util/generic/strbuf.h"} \
${output_include;hide:"util/generic/vector.h"} \
${output_include;hide:"util/generic/ptr.h"} \
${output_include;hide:"util/generic/yexception.h"} \
${output_include;hide:"kernel/struct_codegen/reflection/reflection.h"} \
${output_include;hide:"kernel/struct_codegen/reflection/floats.h"}

### @usage: STRUCT_CODEGEN(Prefix)
### A special case BASE_CODEGEN, in which the kernel/struct_codegen/codegen_tool tool is used.
macro STRUCT_CODEGEN(Prefix) {
    .CMD=$BASE_CODEGEN(kernel/struct_codegen/codegen_tool, $Prefix, $STRUCT_CODEGEN_OUTPUT_INCLUDES)
    .PEERDIR=kernel/struct_codegen/metadata kernel/struct_codegen/reflection
}

### @usage: DUMPERF_CODEGEN(Prefix)
### A special case BASE_CODEGEN, in which the extsearch/images/robot/tools/dumperf/codegen tool is used
macro DUMPERF_CODEGEN(Prefix) {
    .CMD=$BASE_CODEGEN(extsearch/images/robot/tools/dumperf/codegen, $Prefix, ${output_include;hide:"extsearch/images/kernel/erf/erf_format.h"})
}

# tag:flags
### @usage: LDFLAGS(LinkerFlags...)
###
### Add flags to the link command line of executable or shared library/dll.
### Note: LDFLAGS are always global. When set in the LIBRARY module they will affect all programs/dlls/tests the library is linked into.
### Note: remember about the incompatibility of flags for gcc and cl.
macro LDFLAGS(Flags...) {
    SET_APPEND(LDFLAGS_GLOBAL $Flags)
}

# tag:flags
### @usage: CFLAGS([GLOBAL compiler_flag]* compiler_flags)
###
### Add the specified flags to the compilation command of C and C++ files.
### @params: GLOBAL - Propagates these flags to dependent projects
### Note: remember about the incompatibility flags for clang and cl (to set flags specifically for cl.exe use MSVC_FLAGS).
macro CFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CFLAGS $Flags)
}

# tag:flags
### @usage: MASMFLAGS(compiler flags)
### Add the specified flags to the compilation command of .masm files.
macro MASMFLAGS(Flags...) {
   SET_APPEND(MASMFLAGS $Flags)
}

# tag:flags
### @usage: CONLYFLAGS([GLOBAL compiler_flag]* compiler_flags)
### Add the specified flags to the compilation command of .c (but not .cpp) files.
### @params: GLOBAL - Distributes these flags on dependent projects
macro CONLYFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CONLYFLAGS $Flags)
}

# tag:flags
### @usage: CXXFLAGS(compiler_flags)
### Add the specified flags to the compilation command of .cpp (but not .c) files.
macro CXXFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CXXFLAGS $Flags)
}

# tag:flags
### @usage: CUDA_NVCC_FLAGS(compiler flags)
### Add the specified flags to the compile line .cu-files.
macro CUDA_NVCC_FLAGS(Flags...) {
   SET_APPEND(CUDA_NVCC_FLAGS $Flags)
}

# tag:flags
### @usage: NVCC_DEVICE_LINK(file.cu...)
### Run nvcc --device-link on objects compiled from srcs with --device-c.
### This generates a stub object devlink.o that supplies missing pieces for the
### host linker to link relocatable device objects into the final executable.
macro NVCC_DEVICE_LINK(Srcs...) {
    .CMD=$NVCC $NVCC_FLAGS -o ${output;suf=${OBJ_SUF}${NVCC_OBJ_EXT}:"devlink"} -dlink ${input;suf=${OBJ_SUF}${NVCC_OBJ_EXT}:Srcs} ${kv;hide:"p DL"} ${kv;hide:"pc light-blue"}
}

# tag:flags
### @usage: CYTHON_FLAGS(compiler_flags)
### Add the specified flags to the compilation command of .pyx files.
macro CYTHON_FLAGS(Flags...) {
   SET_APPEND(CYTHON_OPTIONS $Flags)
}

### @usage: STRIP()
### Strip debug info from a PROGRAM, DLL or TEST.
### This macro doesn't work in LIBRARY's, UNION's and PACKAGE's.
macro STRIP() {
    ENABLE(STRIP)
}

### @usage: NO_OPTIMIZE()
### Build code without any optimizations (-O0 mode).
macro NO_OPTIMIZE() {
    ENABLE(NO_OPTIMIZE)
}

#TODO(YMAKE-91) read proper compile flags instead of sending explicit flags to semgraph directly
_SEM_EXTRA_CXX_FLAGS=

### @usage: NO_COMPILER_WARNINGS()
### Disable all compiler warnings in the module.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro NO_COMPILER_WARNINGS() {
    ENABLE(NO_COMPILER_WARNINGS)
    SET(_SEM_EXTRA_CXX_FLAGS "$<IF:$<CXX_COMPILER_ID:MSVC>,,-Wno-everything>")
}

### @usage: WERROR()
### Consider warnings as errors in the current module.
### In the bright future will be removed, since WERROR is the default.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro WERROR() {
    ENABLE(WERROR)
}

### @usage: NO_WERROR()
### Override WERROR() behavior
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro NO_WERROR() {
    DISABLE(WERROR)
}

### @usage: NO_WSHADOW()
### Disable C++ shadowing warnings.
macro NO_WSHADOW() {
    ENABLE(NO_WSHADOW)
}

# tag:internal
### @usage: NO_PLATFORM_RESOURCES() # internal
### Exclude dependency on platform resources libraries.
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro NO_PLATFORM_RESOURCES() {
    ENABLE(NOPLATFORM_RESOURCES)
}

# tag:internal tag:codenav
### @usage: NO_CODENAVIGATION() # internal
### Disable codenaviagtion for a module. Needed to avoid PEERDIR loops in codenavigation support.
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro NO_CODENAVIGATION() {
    ENABLE(NOCODENAVIGATION)
}

### @usage: NO_UTIL()
### Build module without dependency on util.
### Note: use this with care. Util most likely will be linked into executable anyway,
### so using util headers/functions/classes may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_UTIL() {
    ENABLE(NOUTIL)
}

### @usage: NO_RUNTIME()
###
### This macro:
### 1. Sets the ENABLE(NOUTIL) + DISABLE(USE_INTERNAL_STL);
### 2. If the project that contains the macro NO_RUNTIME(), peerdir-it project does not contain NO_RUNTIME() => Warning.
### Note: use this with care. Arcadia STL most likely will be linked into executable anyway, so using STL headers/functions/classes
### may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_RUNTIME() {
    SET(USE_ARCADIA_LIBM no)
    NO_UTIL()
    ENABLE(NORUNTIME)
}

### @usage: NO_LIBC()
###
### Exclude dependencies on C++ and C runtimes (including util, musl and libeatmydata).
### Note: use this with care. libc most likely will be linked into executable anyway,
### so using libc headers/functions may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_LIBC() {
    NO_RUNTIME()
    DISABLE(MUSL)
}

### @usage: NO_PLATFORM()
###
### Exclude dependencies on C++ and C runtimes (including util, musl and libeatmydata) and set NO_PLATFORM variable for special processing.
### Note: use this with care. libc most likely will be linked into executable anyway,
### so using libc headers/functions may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_PLATFORM() {
    NO_LIBC()
    ENABLE(NOPLATFORM)
}

# tag:cpp-specific
### @usage: USE_CXX()
###
### Add dependency on C++ runtime
### Note: This macro is inteneded for use in _GO_BASE_UNIT like module when the module is built without C++ runtime by default
macro USE_CXX() {
    DISABLE(NORUNTIME)
}

### @usage: USE_UTIL()
###
### Add dependency on util and C++ runtime
### Note: This macro is intended for use in _GO_BASE_UNIT like module when the module is build without util by default
macro USE_UTIL() {
    USE_CXX()
    DISABLE(NOUTIL)
}

### @usage: USE_NASM()
###
### Build only .asm files with nasm toolchain instead of yasm
### Add to ya.make file ADDINCL(asm ...) with all folders where .asm files include smth
macro USE_NASM() {
    ENABLE(USE_NASM_ASSEMBLER)
    PEERDIR(build/external_resources/nasm)
}

# tag:deprecated
### @usage: NO_JOIN_SRC() # deprecated, does-nothing
### This macro currently does nothing. This is default behavior which cannot be overridden at module level.
macro NO_JOIN_SRC() {
    ENABLE(UNUSED_MACRO)
}

# tag:sanitize
### @usage: NO_SANITIZE()
###
### Disable all sanitizers for the module.
macro NO_SANITIZE() {
    DISABLE(SANITIZER_TYPE)
}

# tag:coverage tag:sanitize
### @usage: NO_SANITIZE_COVERAGE()
###
### Disable lightweight coverage (-fsanitize-coverage) for the module.
### Sanitize coverage is commonly used with fuzzing.
### It might be useful to disable it for libraries that should never
### be the main targets for fuzzing, like libfuzzer library itself.
### Sanitize coverage instrumentation is enabled by the --sanitize-coverage option.
macro NO_SANITIZE_COVERAGE() {
    DISABLE(SANITIZE_COVERAGE)
}

# tag:coverage
### @usage: NO_CLANG_COVERAGE()
###
### Disable heavyweight clang coverage for the module. Clang coverage instrumentation is enabled by the --clang-coverage option.
macro NO_CLANG_COVERAGE() {
    DISABLE(CLANG_COVERAGE)
}

macro NO_CLANG_TIDY() {
    DISABLE(TIDY_ENABLED)
}


# tag:lua-specific
LUAJIT_PATH=${ARCADIA_ROOT}/contrib/libs/luajit
macro _LUAJIT_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_PATH} ${tool:"contrib/libs/luajit/compiler"} -b -g ${input:Src} ${output;noauto:OUT} ${kv;hide:"p LJ"} ${kv;hide:"pc light-cyan"}
}

# tag:lua-specific
LUAJIT_21_PATH=${ARCADIA_ROOT}/contrib/libs/luajit_21
macro _LUAJIT_21_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_21_PATH} ${tool:"contrib/libs/luajit_21/compiler"} -b -g ${input:Src} ${output;noauto:OUT} ${kv;hide:"p LJ"} ${kv;hide:"pc light-cyan"}
}

macro _MX_BIN_TO_INFO(Src) {
    .CMD=${tool:"tools/mx_bin2info"} ${input:Src} ${output;nopath;noext;noauto:Src.info} ${kv;hide:"p MX"} ${kv;hide:"pc yellow"}
}

MX_GEN_TABLE_INCLS=${output_include;hide:"yabs_mx_calc_table.h"} \
${output_include;hide:"kernel/matrixnet/mn_sse.h"} \
${output_include;hide:"library/cpp/archive/yarchive.h"} \
${output_include;hide:"util/memory/blob.h"} \
${output_include;hide:"util/generic/hash.h"} \
${output_include;hide:"util/generic/ptr.h"} \
${output_include;hide:"util/generic/singleton.h"}

macro _MX_GEN_TABLE(Srcs...) {
   .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_mx_table.py"} $Srcs ${output;stdout:"mx_tables.cpp"} $MX_GEN_TABLE_INCLS ${kv;hide:"p MX"} ${kv;hide:"pc yellow"}
   PEERDIR(kernel/matrixnet)
   PEERDIR(library/cpp/archive)
}

RELEV_FML_CODEGEN_INCLS=${output_include;hide:"kernel/relevfml/relev_fml.h"} ${output_include;hide:"library/cpp/sse/sse.h"}

### @usage: GENERATE_ENUM_SERIALIZATION(File.h)
###
### Create serialization support for enumeration members defined in the header (String <-> Enum conversions) and compile it into the module.
###
### Documentation: https://wiki.yandex-team.ru/yatool/HowToWriteYaMakeFiles/
macro GENERATE_ENUM_SERIALIZATION(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --include-path ${input;rootrel:File} --output ${output;suf=_serialized.cpp:File} ${output_include;from_input;hide:File} ${output_include;hide:"util/generic/serialized_enum.h"} ${kv;hide:"p EN"} ${kv;hide:"pc yellow"}
    .SEM=generate_enum_serilization ${input:File} ${output;hide;suf=_serialized.o:File} INCLUDE_HEADERS ${input;rootrel:File} ${tool;hide:"tools/enum_parser/enum_parser"}
    PEERDIR(tools/enum_parser/enum_serialization_runtime)
}

### @usage: GENERATE_ENUM_SERIALIZATION_WITH_HEADER(File.h)
###
### Create serialization support for enumeration members defined in the header (String <-> Enum conversions) and compile it into the module
### Provide access to serialization functions via generated header File_serialized.h
###
### Documentation: https://wiki.yandex-team.ru/yatool/HowToWriteYaMakeFiles/
macro GENERATE_ENUM_SERIALIZATION_WITH_HEADER(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --include-path ${input;rootrel:File} --output ${output;suf=_serialized.cpp:File} --header ${output;suf=_serialized.h:File} ${output_include;from_input;hide:File} ${kv;hide:"p EN"} ${kv;hide:"pc yellow"}
    .SEM=generate_enum_serilization ${input:File} ${output;hide;suf=_serialized.o:File} GEN_HEADER ${output;suf=_serialized.h:File} INCLUDE_HEADERS ${input;rootrel:File} ${tool;hide:"tools/enum_parser/enum_parser"}
    PEERDIR(tools/enum_parser/enum_serialization_runtime)
}

### @usage: DEB_VERSION(File)
###
### Creates a header file DebianVersion.h define the DEBIAN_VERSION taken from the File.
macro DEB_VERSION(File) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/mkver.py"} ${input:File} ${output;stdout:"DebianVersion.h"} ${kv;hide:"p CL"} ${kv;hide:"pc yellow"}
}

BUILD_MN_SCRIPT=build/scripts/build_mn.py

# tag:matrixnet
### @usage: BUILD_MN([CHECK] [PTR] [MULTI] mninfo mnname) # matrixnet
###
### Generate MatrixNet data and access code using single command.
### Alternative macro BUILD_MNS() works faster and better for large files.
macro BUILD_MN(MnInfo, MnName, CHECK?"fml_tool=$FML_UNUSED_TOOL CHECK":"", MULTI?, PTR?, RANKING_SUFFIX="") {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnF $ARCADIA_ROOT $ARCH_TOOL ${input:MnInfo} $MnName ranking_suffix=$RANKING_SUFFIX ${output;pre=mn.:MnName.cpp} ${output;hide;pre=MN_External_;suf=.rodata:MnName} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} $CHECK $MULTI $PTR ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

macro _BUILD_MNS_FILE(Input, Name, Output, Suffix, Check, Fml_tool, AsmDataName) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnsFilesF $ARCADIA_ROOT $BINDIR $ARCH_TOOL fml_tool=$Fml_tool $Name ranking_suffix=$Suffix ${input:Input} ${output;hide:Output} ${output;hide;pre=MN_External_;suf=.rodata:AsmDataName} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

MNS_OUTPUT=mnmodels

macro _BUILD_MNS_CPP(NAME="", CHECK?, RANKING_SUFFIX="", Files...) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnsCppF $NAME ranking_suffix=$RANKING_SUFFIX ${input:MNS_OUTPUT.h} ${output:MNS_OUTPUT.cpp} ${input:Files} ${output_include;hide:MNS_OUTPUT.h} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

macro _BUILD_MNS_HEADER(NAME="", CHECK?, RANKING_SUFFIX="", Files...) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnsHeaderF $NAME ranking_suffix=$RANKING_SUFFIX ${output:MNS_OUTPUT.h} ${input:Files} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} ${output_include;hide:"kernel/matrixnet/mn_multi_categ.h"} ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

# TODO: support foreach_in and keywords simultaneous usage (look at BUILD_MNS_FILES)

# tag:matrixnet
### @usage: BUILD_MNS([CHECK] NAME listname mninfos...) # matrixnet
###
### Generate MatrixNet data and access code using separate commands for support code, interface and data.
### Faster version of BUILD_MN() macro for large files.
macro BUILD_MNS(Files...) {
    _BUILD_MNS_HEADER($Files)
    _BUILD_MNS_CPP($Files)
    _BUILD_MNS_FILES($Files)
}

### @usage: COMPILE_NLG(nlg_config.json, [TRANSLATIONS_JSON translations.json], Src...)
###
### Generate and compile .nlg templates (Jinja2-based) and interface for megamind runtime in localized mode.
###
### Alice-specific macro
macro COMPILE_NLG(NLG_CONFIG_JSON, TRANSLATIONS_JSON="", Src...) {
    when ($TRANSLATIONS_JSON) {
        TRANSLATIONS_JSON_ARG=--translations-json
    }
    otherwise {
        TRANSLATIONS_JSON_ARG=
    }
    PEERDIR(alice/nlg/library/nlg_project_runtime)
    RUN_PROGRAM(alice/nlg/tools/codegen compile-cpp --import-dir ${ARCADIA_ROOT} --out-dir ${ARCADIA_BUILD_ROOT} --include-prefix ${MODDIR} --nlg-config-json ${NLG_CONFIG_JSON} ${TRANSLATIONS_JSON_ARG} ${TRANSLATIONS_JSON} ${Src} IN ${TRANSLATIONS_JSON} ${NLG_CONFIG_JSON} ${Src} OUT_NOAUTO nlg_renderer_factory.cpp nlg_renderer_factory.h register.cpp translations.cpp translations.h localizable_phrases.pb.txt ${suf=.cpp:Src} ${suf=.h:Src} ${suf=.pb.txt:Src})
    SRCS(GLOBAL register.cpp nlg_renderer_factory.cpp translations.cpp ${suf=.cpp:Src})
}

### @usage: NEED_CHECK()
###
### Commits to the project marked with this macro will be blocked by pre-commit check and then will be
### automatically merged to trunk only if there is no new broken build targets in check results.
### The use of this macro is disabled by default.
macro NEED_CHECK(Flags...) {
    # TODO: FIXME
    ENABLE(UNUSED_MACRO)
}

### @usage: NO_NEED_CHECK()
###
### Commits to the project marked with this macro will not be affected by higher-level NEED_CHECK macro.
macro NO_NEED_CHECK(Flags...) {
    ENABLE(UNUSED_MACRO)
}

# tag:deprecated
### @usage: NEED_REVIEW() # deprecated
###
### Mark the project as needing review.
### Reviewers are listed in the macro OWNER. The use of this macro is disabled by default.
### Details can be found here: https://clubs.at.yandex-team.ru/arcadia/6104
macro NEED_REVIEW(Flags...) {
    # TODO: FIXME
    ENABLE(UNUSED_MACRO)
}

### @usage: VERSION(Args...)
###
### Specify version of a module. Currently unused by build system, only informative.
macro VERSION(Flags...) {
    ENABLE(UNUSED_MACRO)
}

DATAWORK_SCHEEME_EXPORT_FLAGS=

when ($UNIX == "yes") {
    SCHEEME2_CFLAGS= -E -x c++
}

when ($WIN32 == "yes") {
    SCHEEME2_CFLAGS= /E /TP
}

SCHEEME2_STRUCT_INFO_FLAGS=-f "const static ui32 RecordSig" -u "RecordSig" --gcc44_no_typename --no_complex_overloaded_func_export
### @usage: GEN_SCHEEME2(scheeme_name from_file dependent_files...)
###
### Generates a C++ description for structure(contains the field RecordSig) in the specified file (and connected).
###
### 1. ${scheeme_name}.inc - the name of the generated file.
### 2. Use an environment variable - DATAWORK_SCHEEME_EXPORT_FLAGS that allows to specify flags to tools/structparser
###
### @example:
###
###     SET(DATAWORK_SCHEEME_EXPORT_FLAGS --final_only -m "::")
###
### all options are passed to structparser (in this example --final_only - do not export heirs with public base that contains the required field,,- m "::" only from the root namespace)
### sets in extra option
###
### @example:
###
###     SET(EXTRACT_STRUCT_INFO_FLAGS -f \"const static ui32 RecordSig\"
###         -u \"RecordSig\" -n${scheeme_name}SchemeInfo ----gcc44_no_typename no_complex_overloaded_func_export
###         ${DATAWORK_SCHEEME_EXPORT_FLAGS})
###
### for compatibility with C++ compiler and the external environment.
### See tools/structparser for more details.
macro GEN_SCHEEME2(ScheemeName, FromFile) {
    .CMD=$CXX_COMPILER $C_FLAGS_PLATFORM -c ${tmp;stdout:FromFile.cph} $SCHEEME2_CFLAGS ${input:FromFile} ${pre=-I:_C__INCLUDE} $CXXFLAGS -Wno-error && ${tool:"tools/structparser"} -o ${output:ScheemeName.inc} -n N${ScheemeName}SchemeInfo $SCHEEME2_STRUCT_INFO_FLAGS $DATAWORK_SCHEEME_EXPORT_FLAGS ${tmp:FromFile.cph} ${output;stdout;noauto:ScheemeName.inc.log} ${kv;hide:"p SH"} ${kv;hide:"pc yellow"}
}

### @usage: SYMLINK(from to)
### Add symlink
macro SYMLINK(From, To) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/symlink.py"} ${input;dirallowed:From} ${output;noauto:To} ${kv;hide:"p LN"} ${kv;hide:"pc light-cyan"}
}

# tag:internal
### @usage: _TARGET_SOURCES_FOR_HEADERS_IMPL([GENERATE] Args...) # internal
### Generate prefix " && target_sources PRIVATE " before $Args when GENERATE is specified in the list of actual arguments
macro _TARGET_SOURCES_FOR_HEADERS_IMPL(GENERATE?" && target_sources PRIVATE ":"", Args...) {
    .SEM=$GENERATE ${output;ext=.h:Args} ${output;ext=.hh:Args} ${output;ext=.hpp:Args} ${output;ext=.inc:Args} ${output;ext=.i:Args}
}

# tag:internal
### @usage: _TARGET_SOURCES_FOR_HEADERS(Args...) # internal
### Generate prefix " && target_sources PRIVATE " before $Args if Args is not empty
macro _TARGET_SOURCES_FOR_HEADERS(Args...) {
    .SEM=$_TARGET_SOURCES_FOR_HEADERS_IMPL(${pre=GENERATE :Args})
}

# tag:internal
### @usage: _TARGET_SOURCES_FOR_HEADERS_IMPL([GENERATE] Args...) # internal
### Generate prefix " ${CMAKE_COMMAND} -E env " before $Args when GENERATE is specified in the list of actual arguments
macro _SET_ENV_FOR_CUSTOM_COMMAND_IMPL(GENERATE?" ${CMAKE_COMMAND} -E env ":"", Args...) {
    .SEM=$GENERATE ${pre= :Args}
}

# tag:internal
### @usage: _SET_ENV_FOR_CUSTOM_COMMAND(Args...) # internal
### Generate prefix " ${CMAKE_COMMAND} -E env " before $Args if Args is not empty
macro _SET_ENV_FOR_CUSTOM_COMMAND(Args...) {
    .SEM=$_SET_ENV_FOR_CUSTOM_COMMAND_IMPL(${pre=GENERATE :Args})
}


macro _FMT_INDUCED_DEPS(For, Deps...) {
    .CMD=${induced_deps=$For;hide:Deps}
}

### @usage: PREPARE_INDUCED_DEPS(VAR Type Files...)
###
### Format value for `INDUCED_DEPS` param in certain macros and assign to `VAR`
### This tells that files of Type resulted from code generation macros (not neccessarily directly,
### but in processing chain of generated files) should have extra dependencies from list of Files...
###
### Prominent example here is Cython: one can generate .pyx file that may depend on .pxd and have cimpot from
### certain .h. The former is dependency for .pyx itself, while the latter is dependency for .pyx.cpp
### resulted from Cython-processing of generated pyx. The code ganeration will look like:
### ```
### PREPARE_INDUCED_DEPS(PYX_DEPS pyx imported.pxd)
### PREPARE_INDUCED_DEPS(CPP_DEPS cpp cdefed.h)
### RUN_PYTHON3(generate_pyx.py genereted.pyx OUT generated.pyx INDUCED_DEPS $PYX_DEPS $CPP_DEPS)
### ```
###
### The VAR will basically contain pair of `Type:[Files...]` in a form suitable for passing
### as an element of array parameter. This is needed because language of ya.make doesn't support
### Dict params right now and so it is impossible to directly pass something
### like `{Type1:[Files2...], Type2:[Files2...]}`
###
macro PREPARE_INDUCED_DEPS(VAR, For, Deps...) {
    SET($VAR \$_FMT_INDUCED_DEPS($For $Deps))
}

### @usage: RUN_PROGRAM(tool_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a program from arcadia.
### These macros are similar: RUN_PROGRAM, RUN_LUA, PYTHON.
###
### Parameters:
### - tool_path - Path to the directory of the tool.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
### Note that Tool is always built for the host platform, so be careful to provide that tool can be built for all Arcadia major host platforms (Linux, MacOS and Windows).
macro RUN_PROGRAM(Tool, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} ${tool:Tool} $Args ${input;hide:IN} ${input;context=TEXT;hide:IN_NOPARSE} ${input;hide:IN_DEPS} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p PR"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    .SEM=add_custom_command $_SET_ENV_FOR_CUSTOM_COMMAND($ENV) OUTPUT ${output:OUT} ${output;noauto:OUT_NOAUTO} ${output:STDOUT} ${output;noauto:STDOUT_NOAUTO} DEPENDS ${input:IN} ${input;context=TEXT:IN_NOPARSE} ${tool:Tool} ${tool:TOOL} ${pre=WORKING_DIRECTORY :CWD} COMMAND ${tool:Tool} $Args ${pre=> :STDOUT} ${pre=> :STDOUT_NOAUTO} $_TARGET_SOURCES_FOR_HEADERS($OUT $OUT_NOAUTO $STDOUT $STDOUT_NOAUTO)
}

# tag:lua-specific
### @usage: RUN_LUA(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a lua script.
### These macros are similar: RUN_PROGRAM, RUN_LUA, PYTHON.
###
### Parameters:
### - script_path - Path to the script.3
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro RUN_LUA(ScriptPath, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $LUA_TOOL ${input:ScriptPath} $Args ${input;hide:IN} ${input;context=TEXT;hide:IN_NOPARSE} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p LU"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
}

# tag:python-specific
### @usage: PYTHON(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a python script with $(PYTHON)/python built from devtools/huge_python.
### These macros are similar: RUN_PROGRAM, RUN_LUA, PYTHON.
###
### Parameters:
### - script_path - Path to the script.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro PYTHON(ScriptPath, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $YMAKE_PYTHON ${input:ScriptPath} $Args ${input;hide:IN} ${input;context=TEXT;hide:IN_NOPARSE} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    .SEM=find_package Python2 && add_custom_command $_SET_ENV_FOR_CUSTOM_COMMAND($ENV) OUTPUT ${output:OUT} ${output;noauto:OUT_NOAUTO} ${output:STDOUT} ${output;noauto:STDOUT_NOAUTO} DEPENDS ${input:IN} ${input;context=TEXT:IN_NOPARSE} ${input:ScriptPath} ${tool:TOOL} ${pre=WORKING_DIRECTORY :CWD} COMMAND Python2::Interpreter ${input:ScriptPath} $Args ${pre=> :STDOUT} ${pre=> :STDOUT_NOAUTO} $_TARGET_SOURCES_FOR_HEADERS($OUT $OUT_NOAUTO $STDOUT $STDOUT_NOAUTO)
}

# tag:python-specific
### @usage: RUN_PYTHON3(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a python script with prebuilt python3 interpretor built from devtools/huge_python3.
### These macros are similar: RUN_PROGRAM, RUN_LUA, PYTHON.
###
### Parameters:
### - script_path - Path to the script.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro RUN_PYTHON3(ScriptPath, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $YMAKE_PYTHON3 ${input:ScriptPath} $Args ${input;hide:IN} ${input;context=TEXT;hide:IN_NOPARSE} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    .SEM=find_package Python3 && add_custom_command $_SET_ENV_FOR_CUSTOM_COMMAND($ENV) OUTPUT ${output:OUT} ${output;noauto:OUT_NOAUTO} ${output:STDOUT} ${output;noauto:STDOUT_NOAUTO} DEPENDS ${input:IN} ${input;context=TEXT:IN_NOPARSE} ${input:ScriptPath} ${tool:TOOL} ${pre=WORKING_DIRECTORY :CWD} COMMAND Python3::Interpreter ${input:ScriptPath} $Args ${pre=> :STDOUT} ${pre=> :STDOUT_NOAUTO} $_TARGET_SOURCES_FOR_HEADERS($OUT $OUT_NOAUTO $STDOUT $STDOUT_NOAUTO)
}

# tag:java-specific
macro _RUN_JAVA(IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], TOOL[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], HIDE_OUTPUT?"stderr2stdout":"stdout2stderr", Args...) {
    PEERDIR(build/platform/java/jdk $JDK_RESOURCE_PEERDIR)
    .CMD=${cwd:CWD} ${env:ENV} $YMAKE_PYTHON ${input;pre=build/scripts/:HIDE_OUTPUT.py} $JDK_RESOURCE/bin/java $Args ${tool;hide:TOOL} ${input;hide:IN} ${input;context=TEXT;hide:IN_NOPARSE} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p JV"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"}
}

### @usage: FROM_SANDBOX([FILE] resource_id [AUTOUPDATED script] [RENAME <resource files>] OUT_[NOAUTO] <output files> [EXECUTABLE] [OUTPUT_INCLUDES <include files>] [INDUCED_DEPS $VARs...])
###
### Download the resource from the Sandbox, unpack (if not explicitly specified word FILE) and add OUT files to the build. EXECUTABLE makes them executable.
### You may specify extra dependencies that output files bring using OUTPUT_INCLUDES or INDUCED_DEPS. The change of these may e.g. lead to recompilation of .cpp files extracted from resource.
### If there is no default processing for OUT files or you need process them specially use OUT_NOAUTO instead of OUT.
###
### It is disallowed to specify directory as OUT/OUT_NOAUTO since all outputs of commands shall be known to build system.
###
### RENAME renames files to the corresponding OUT and OUT_NOAUTO outputs:
### FROM_SANDBOX(resource_id RENAME in_file1 in_file2 OUT out_file1 out_file2 out_file3)
### FROM_SANDBOX(resource_id RENAME in_file1 OUT out_file1 RENAME in_file2 OUT out_file2)
### FROM_SANDBOX(FILE resource_id RENAME resource_file OUT out_name)
###
### RENAME RESOURCE allows to rename the resource without specifying its file name.
###
### OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                         In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### If AUTOUPDATED is specified than macro will be regularly updated according to autoupdate script. The dedicated Sandbox task scans the arcadia and
### changes resource_ids in such macros if newer resource of specified type is available. Note that the task seeks AUTOUPDATED in specific position,
### so you shall place it immediately after resource_id.
macro FROM_SANDBOX(Id, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], FILE?"--copy-to-dir":"--untar-to", AUTOUPDATED="", PREFIX=".", RENAME[], EXECUTABLE?"--executable":"", SBR="sbr:") {
    .CMD=${hide:SANDBOX_FAKEID} ${cwd:BINDIR} ${resource;pre=$SBR:Id} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_sandbox.py"} --resource-file $(RESOURCE_ROOT)/sbr/$Id/resource --resource-id $Id $FILE $PREFIX ${pre=--rename :RENAME} $EXECUTABLE -- $OUT $OUT_NOAUTO ${input;hide:"build/scripts/fetch_from.py"} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${requirements;hide:"network:full"} ${kv;hide:"p SB"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    ADD_CHECK(check.resource $Id)
}

### @usage: FROM_MDS([FILE] key [RENAME <resource files>] OUT_[NOAUTO] <output files> [EXECUTABLE] [OUTPUT_INCLUDES <include files>] [INDUCED_DEPS $VARs...])
###
### Download resource from MDS with the specified key and process like [FROM_SANDBOX()](#macro_FROM_SANDBOX).
macro FROM_MDS(Key, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], FILE?"--copy-to-dir":"--untar-to", PREFIX=".", RENAME[], EXECUTABLE?"--executable":"") {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_mds.py"} --key $Key $FILE $PREFIX ${pre=--rename :RENAME} $EXECUTABLE -- $OUT $OUT_NOAUTO ${input;hide:"build/scripts/fetch_from.py"} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${requirements;hide:"network:full"} ${kv;hide:"p MD"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    ADD_CHECK(check.mds $Key)
}

# tag:internal
### @usage: _FROM_EXTERNAL(ExtFile [AUTOUPDATED script] [RENAME <resource files>] OUT_[NOAUTO] <output files> [EXECUTABLE])  #internal
###
### Use resource described as .external file as [FROM_SANDBOX()](#macro_FROM_SANDBOX)/[FROM_MDS()](#macro_FROM_MDS).
macro _FROM_EXTERNAL(File, OutFile, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], AUTOUPDATED="", PREFIX=".", RENAME[], EXECUTABLE?"--executable":"", EXT="ext:") {
    .CMD=${hide:SANDBOX_FAKEID} ${cwd:BINDIR} ${resource;pre=$EXT;suf=.external:OutFile} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_external.py"} --external-file ${input:File} --resource-file $(RESOURCE_ROOT)/ext/$OutFile --copy-to-dir $PREFIX ${pre=--rename :RENAME} $EXECUTABLE -- $OUT $OUT_NOAUTO ${input;hide:"build/scripts/fetch_from.py"} ${input;hide:"build/scripts/fetch_from_sandbox.py"} ${input;hide:"build/scripts/fetch_from_mds.py"} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${requirements;hide:"network:full"} ${kv;hide:"p XT"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}

#FIXME: add '${resource;pre=$EXT:OutFile}' when support of the scheme is added to executors
#FIXME: add 'ADD_CHECK(check.external $File)' when proper testing is implemented
}

### @usage LARGE_FILES([AUTOUPDATED]  Files...)
###
### Use large file ether from working copy or from remote storage via placeholder <File>.external
### If <File> is present locally (and not a symlink!) it will be copied to build directory.
### Otherwise macro will try to locate <File>.external, parse it retrieve ot during build phase.
macro LARGE_FILES(AUTOUPDATED?, Files...) {
    # This is needed to correctly switch between remote and local modes
    _GLOB($LF $Files)
}

### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT_[NOAUTO] <output files> [EXECUTABLE] [OUTPUT_INCLUDES <include files>] [INDUCED_DEPS $VARs...])
###
### Process file archive as [FROM_SANDBOX()](#macro_FROM_SANDBOX).
macro FROM_ARCHIVE(Src, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], PREFIX=".", RENAME[], EXECUTABLE?"--executable":"") {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_archive.py"} "--archive" ${input:Src} "--file-name" ${suf=-:Src} "--untar-to" $PREFIX ${pre=--rename :RENAME} $EXECUTABLE -- $OUT $OUT_NOAUTO ${input;hide:"build/scripts/fetch_from.py"} ${output_include;hide:OUTPUT_INCLUDES} $INDUCED_DEPS ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${kv;hide:"p FA"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
}

when ($MSVC == "yes") {
    C_AS_CXX_FLAGS=/TP /std:c++17
}
otherwise {
    C_AS_CXX_FLAGS=-x c++ -std=c++17
}

# tag:cpp-specific
### @usage: COMPILE_C_AS_CXX()
###
### Compile .c files as .cpp ones within a module.
macro COMPILE_C_AS_CXX() {
    SET(EXTRA_C_FLAGS $C_AS_CXX_FLAGS)
}

### @usage: NO_DEBUG_INFO()
###
### Compile files without debug info collection.
macro NO_DEBUG_INFO() {
    SET(NO_DEBUGINFO yes)
}

### @usage: CTEMPLATE_VARNAMES(File)
###
### Generate File.varnames.h using contrib/libs/ctemplate/make_tpl_varnames_h
###
### Documentation: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/ctemplate/README.md
macro CTEMPLATE_VARNAMES(File) {
    .CMD=${tool:"contrib/libs/ctemplate/make_tpl_varnames_h"} -f ${output;addincl;nopath;noallext:File.varnames.h} ${input:File}
}

LLVM_OPTS=
CLANG_BC_ROOT=${CLANG11_RESOURCE_GLOBAL}

macro USE_LLVM_BC12() {
    SET(CLANG_BC_ROOT ${CLANG12_RESOURCE_GLOBAL})
}

CLANG_DEFAULT_ROOT=${CLANG_RESOURCE_GLOBAL}
CLANG_C_COMPILER_BIN=${CLANG_RESOURCE_GLOBAL}/bin/clang
CLANG_CPP_COMPILER_BIN=${CLANG_RESOURCE_GLOBAL}/bin/clang++

CLANG_EMIT_EXTRA_OPTS=

when ($OS_WINDOWS == "yes") {
   # we can't use c++latest for clang14 now
   # so we set c++20 for it
   # for clang11 (actual clang for CLANG_EMIT_AST_CXX and LLVM_COMPILE_* macroses) /std:c++20 provokes "unused-command-line-argument" error
   # !do not forget to change this flag when updating build/platform/clang
   CLANG_EMIT_EXTRA_OPTS+=/std:c++latest
}

when ($OS_ANDROID == "yes") {
    # We use clang shipped with android-ndk which has different layout
    CLANG_DEFAULT_ROOT=$CLANG_ANDROID_RESOURCE_GLOBAL
    when ($HOST_OS_DARWIN) {
        CLANG_C_COMPILER_BIN=${CLANG_ANDROID_RESOURCE_GLOBAL}/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang
        CLANG_CPP_COMPILER_BIN=${CLANG_ANDROID_RESOURCE_GLOBAL}/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang++
    }
    otherwise {
        CLANG_C_COMPILER_BIN=${CLANG_ANDROID_RESOURCE_GLOBAL}/toolchains/llvm/prebuilt/linux-x86_64/bin/clang
        CLANG_CPP_COMPILER_BIN=${CLANG_ANDROID_RESOURCE_GLOBAL}/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++
    }
}

### @usage: CLANG_EMIT_AST_CXX(Input Output Opts...)
###
### Emit Clang AST from .cpp file. CXXFLAGS and LLVM_OPTS are passed in, while CFLAGS and C_FLAGS_PLATFORM are not.
### Note: Output name is used as is, no extension added.
macro CLANG_EMIT_AST_CXX(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_CPP_COMPILER_BIN} ${pre=-I:_C__INCLUDE} $CXXFLAGS $C_FLAGS_PLATFORM $LLVM_OPTS -emit-ast -c ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p ST"} ${kv;hide:"pc light-green"}
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_COMPILE_CXX(Input Output Opts...)
###
### Emit LLVM bytecode from .cpp file. BC_CXXFLAGS, LLVM_OPTS and C_FLAGS_PLATFORM are passed in, while CFLAGS are not.
### Note: Output name is used as is, no extension added.
macro LLVM_COMPILE_CXX(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_BC_ROOT}/bin/clang++ ${pre=-I:_C__INCLUDE} $BC_CXXFLAGS $C_FLAGS_PLATFORM -Wno-unknown-warning-option $LLVM_OPTS ${NO_LTO_CFLAGS} -emit-llvm -c ${input:Input} -o ${output;noauto:Output} $Opts $CLANG_EMIT_EXTRA_OPTS ${kv;hide:"p BC"} ${kv;hide:"pc light-green"}
    .SEM=llvm_compile_cxx ${input:Input} ${output;noauto:Output} ${"${CLANGPLUSPLUS}"} -Wno-unknown-warning-option $LLVM_OPTS ${NO_LTO_CFLAGS} -emit-llvm ${Opts}
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_COMPILE_C(Input Output Opts...)
###
### Emit LLVM bytecode from .c file. BC_CFLAGS, LLVM_OPTS and C_FLAGS_PLATFORM are passed in, while CFLAGS are not.
### Note: Output name is used as is, no extension added.
macro LLVM_COMPILE_C(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_BC_ROOT}/bin/clang ${pre=-I:_C__INCLUDE} $BC_CFLAGS $C_FLAGS_PLATFORM $LLVM_OPTS ${NO_LTO_CFLAGS} -emit-llvm -c ${input:Input} -o ${output;noauto:Output} $Opts $CLANG_EMIT_EXTRA_OPTS ${kv;hide:"p BC"} ${kv;hide:"pc light-green"}
    .SEM=llvm_compile_c ${input:Input} ${output;noauto:Output} ${"${CLANGC}"} -Wno-unknown-warning-option $LLVM_OPTS ${NO_LTO_CFLAGS} -emit-llvm ${Opts}
    PEERDIR(build/platform/clang)
}

### @usage: BPF(Input Output Opts...)
###
### Emit eBPF bytecode from .c file.
### Note: Output name is used as is, no extension added.
macro BPF(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_C_COMPILER_BIN} ${pre=-I:_C__INCLUDE} $C_FLAGS_PLATFORM -target bpf -c ${input:Input} -o ${output;noauto:Output} $Opts $CLANG_EMIT_EXTRA_OPTS ${kv;hide:"p BP"} ${kv;hide:"pc light-green"}
    PEERDIR(build/platform/clang)
}

LD_BINARY_NAME=ld
when($OS_LINUX) {
    LD_BINARY_NAME=ld.lld
}

### @usage: BPF_STATIC(Input Output Opts...)
###
### Emit eBPF bytecode from .c file.
### Note: Output name is used as is, no extension added.
macro BPF_STATIC(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_C_COMPILER_BIN} ${pre=-I:_C__INCLUDE} $C_FLAGS_PLATFORM -target bpf -c ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p BP"} ${kv;hide:"pc light-green"} && ${cwd:BINDIR} $LLD_ROOT_RESOURCE_GLOBAL/$LD_BINARY_NAME -r -b binary -m elf_x86_64 -o ${output;noauto;suf=.bpf.o:Input} ${noauto;nopath:Output}
    PEERDIR(build/platform/clang build/platform/lld)
}

### @usage: LLVM_COMPILE_LL(Input Output Opts...)
###
### Compile LLVM bytecode to object representation.
### Note: Output name is used as is, no extension added.
macro LLVM_COMPILE_LL(Input, Output, Opts...) {
    .CMD=${CLANG_BC_ROOT}/bin/llvm-as ${input:Input} -o ${output;noauto:Output} ${kv;hide:"p BC"} ${kv;hide:"pc light-green"}
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_LINK(Output Inputs...)
###
### Call llvm-link on set of Inputs to produce Output.
### Note: Unlike many other macros output argument goes first. Output name is used as is, no extension added.
macro LLVM_LINK(Output, Inputs...) {
    .CMD=${CLANG_BC_ROOT}/bin/llvm-link ${input:Inputs} -o ${output;noauto:Output} ${kv;hide:"p LD"} ${kv;hide:"pc light-red"}
    .SEM=add_custom_command OUTPUT ${output;noauto:Output} DEPENDS ${input:Inputs} COMMAND ${LLVMLINK} ${input:Inputs} -o ${output;noauto:Output}
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_OPT(Input Output Opts...)
###
### Call llvm-opt with set of Opts on Input to produce Output.
### Note: Output name is used as is, no extension added.
macro LLVM_OPT(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/llvm_opt_wrapper.py"} ${CLANG_BC_ROOT}/bin/opt ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p OP"} ${kv;hide:"pc yellow"}
    .SEM=add_custom_command OUTPUT ${output;noauto:Output} DEPENDS ${input:Input} COMMAND ${LLVMOPT} ${input:Input} -o ${output;noauto:Output} $Opts
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_LLC(Src Opts...)
###
### Call llvm-llc with set of Opts on Src to produce object file.
###
### Note: Output name is calculated as concatenation of Src name and platform specific object file extension.
macro LLVM_LLC(Src, Opts...) {
    .CMD=${tool:"contrib/libs/llvm14/tools/llc"} ${input:Src} --filetype obj -o ${output;suf=$OBJECT_SUF;noauto:Src} $Opts ${kv;hide:"p LC"} ${kv;hide:"pc yellow"}
    .SEM=add_custom_command OUTPUT ${output;suf=$OBJECT_SUF;noauto:Src} DEPENDS ${input:Src} COMMAND ${LLVMLLC} --filetype obj ${input:Src} -o ${output;suf=$OBJECT_SUF;noauto:Src} $Opts
    PEERDIR(build/platform/clang)
}

when ($NO_DEBUGINFO == "yes") {
    DEBUG_INFO_FLAGS=
}

when ($CLANG && $DEBUGINFO_LINES_ONLY == "yes" && $NO_DEBUGINFO != "yes") {
    DEBUG_INFO_FLAGS=-gline-tables-only
}

# TODO: configurable tar and touch
PACK_TGZ=${cwd:ARCADIA_BUILD_ROOT} tar -czf ${rootrel:OUTPUT} ${rootrel:INPUT} ${kv;hide:"p AR"} ${kv;hide:"pc light-red"}

#  tag:internal
### @usage TOUCH(Outputs...) # internal
### Just introduce outputs
macro TOUCH(Outputs...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${output:Outputs}
}

TOUCH_UNIT=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${kv;hide:"p UN"} ${kv;hide:"pc light-cyan"} $TARGET
FAKE_PACKAGE_CMD=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${kv;hide:"pc light-red"} $TARGET
COPY_PACKAGE_CMD=$YMAKE_PYTHON ${input:"build/scripts/copy_to_dir.py"} --dest-dir $BINDIR --build-root $ARCADIA_BUILD_ROOT $PACKED_PACKAGE_ARGS $SRCS_GLOBAL $PEERS_LATE_OUTS ${skip_by_ext=.pkg.fake:PEERS} ${hide;late_out:AUTO_INPUT} ${hide;late_out;to_namespace=$BINDIR/:SRCS_GLOBAL} ${hide;late_out;to_namespace=$BINDIR/:PEERS_LATE_OUTS} ${hide;late_out;skip_by_ext=.pkg.fake;to_namespace=$BINDIR/:PEERS} ${kv;hide:"package PACKAGE"}
TOUCH_PACKAGE=$FAKE_PACKAGE_CMD $VCS_INFO_DISABLE_CACHE__NO_UID__ && $COPY_PACKAGE_CMD
_P_PK=${kv;hide:"p PK"}
TOUCH_PACKAGE_MF=$GENERATE_MF && $TOUCH_PACKAGE $_P_PK && $ADD_VCS_INFO_FILE_CMD

# Note: we don't use touch.py in the command below to avoid introduction of undesired input
UNION_CMD=$YMAKE_PYTHON -c open(\'$TARGET\',\'w\').close() ${kv;hide:"p UN"} ${kv;hide:"package UNION"} ${kv;hide:"pc light-cyan"} $UNION_OUTS $VCS_INFO_DISABLE_CACHE__NO_UID__
UNION_CMD_MF=$UNION_CMD && $GENERATE_MF

macro _EXPAND_INS_OUTS(FILES{input}[]) {
    .CMD=${input;hide:FILES} ${late_out;hide:INPUT}
}

_UNION_EXPLICIT_OUTPUTS=

### @usage: EXPLICIT_OUTPUTS(Files...)
###
### Let UNION has only explicitly specified outputs listed in this macro
### The list of files shall contain results of commands in this UNION.
### Only these files will be outputs of the UNION. This allows to eliminate
### intermediate files being result of the UNION
macro EXPLICIT_OUTPUTS(Files...) {
     SET_APPEND(_UNION_EXPLICIT_OUTPUTS ${Files})
}

NO_CHECK_IMPORTS_FOR_VALUE=None
### @usage: NO_CHECK_IMPORTS([patterns])
###
### Do not run checks on imports of Python modules.
### Optional parameter mask patterns describes the names of the modules that do not need to check.
macro NO_CHECK_IMPORTS(Masks...) {
    SET(NO_CHECK_IMPORTS_FOR_VALUE $Masks)
}


# tag:yasm-specific
_YASM_FMT_VALUE=
_YASM_PLATFORM_FLAGS_VALUE=
_YASM_PREDEFINED_FLAGS_VALUE=
when ($OS_DARWIN || $OS_IOS) {
    _YASM_FMT_VALUE=macho
    _YASM_PLATFORM_FLAGS_VALUE=-D DARWIN -D UNIX
}
elsewhen ($OS_WINDOWS && $ARCH_X86_64) {
    _YASM_FMT_VALUE=win
    _YASM_PLATFORM_FLAGS_VALUE=-D WIN64
}
elsewhen ($OS_WINDOWS && $ARCH_I386) {
    _YASM_FMT_VALUE=win
    _YASM_PLATFORM_FLAGS_VALUE=-D WIN32
}
otherwise {
    _YASM_FMT_VALUE=elf
    _YASM_PLATFORM_FLAGS_VALUE=-D UNIX
    _YASM_PREDEFINED_FLAGS_VALUE=-g dwarf2
}

when ($ASM_PREFIX) {
    ASM_PREFIX_VALUE=--prefix=$ASM_PREFIX
}
otherwise {
    ASM_PREFIX_VALUE=
}

# tag:yasm-specific
YASM_FLAGS=
YASM_PREINCLUDES_VALUE=

# tag:yasm-specific
macro _SRC_yasm_helper(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=${tool:"contrib/tools/yasm"} -f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} $_YASM_PLATFORM_FLAGS_VALUE $YASM_DEBUG_INFO $YASM_DEBUG_INFO_DISABLE_CACHE__NO_UID__ -D ${pre=_;suf=_:HARDWARE_TYPE} -D_YASM_ $ASM_PREFIX_VALUE $_YASM_PREDEFINED_FLAGS_VALUE $YASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS -o ${output;noext;suf=${OBJECT_SUF}:SRC} ${pre=-P :PREINCLUDES} ${input;hide:PREINCLUDES} ${SRC} ${kv;hide:"p AS"} ${kv;hide:"pc light-green"}
}

# tag:yasm-specific
macro _SRC_yasm(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=$_SRC_yasm_helper(${input:SRC}, $SRCFLAGS, PREINCLUDES $PREINCLUDES)
}

# tag:nasm-specific
NASM_FLAGS=

# tag:nasm-specific
macro _SRC_nasm_helper(SRC, SRCFLAGS...) {
    .CMD=${NASM_RESOURCE_GLOBAL}/bin/nasm -f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} -D ${pre=_;suf=_:HARDWARE_TYPE} $NASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS -o ${output;noext;suf=${OBJECT_SUF}:SRC} ${SRC}
}

# tag:nasm-specific
macro _SRC_nasm(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=$_SRC_nasm_helper(${input:SRC}, $SRCFLAGS)
}

# tag:src-processing
when ($USE_NASM_ASSEMBLER == "yes") {
    MACRO_ALIAS(_SRC_ASM _SRC_nasm)
}
otherwise {
    MACRO_ALIAS(_SRC_ASM _SRC_yasm)
}

### @usage: ASM_PREINCLUDE(AsmFiles...)
###
### Supply additional .asm files to all assembler calls within a module
macro ASM_PREINCLUDE(PREINCLUDES...) {
    SET_APPEND(YASM_PREINCLUDES_VALUE $PREINCLUDES)
}

### @usage: RUN_ANTLR(Args...)
###
### Macro to invoke ANTLR3 generator (general case)
macro RUN_ANTLR(IN[], IN_NOPARSE[], OUT[], OUT_NOAUTO[], OUTPUT_INCLUDES[], INDUCED_DEPS[], CWD="", Args...) {
    PEERDIR(build/external_resources/antlr3 build/platform/java/jdk $JDK_RESOURCE_PEERDIR)
    .CMD=$_RUN_JAVA(-jar $ANTLR3_RESOURCE_GLOBAL/antlr-3.5.2-complete-no-st3.jar $Args IN $IN IN_NOPARSE $IN_NOPARSE OUT $OUT OUT_NOAUTO $OUT_NOAUTO OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS ${pre=CWD :CWD})
    .SEM=run_antlr OUTPUT ${output:OUT} ${output;noauto:OUT_NOAUTO} DEPENDS ${input:IN} ${pre=WORKING_DIRECTORY :CWD} ANTLER_ARGS $Args
}

### @usage: RUN_ANTLR4(Args...)
###
### Macro to invoke ANTLR4 generator (general case)
macro RUN_ANTLR4(IN[], IN_NOPARSE[], OUT[], OUT_NOAUTO[], OUTPUT_INCLUDES[], INDUCED_DEPS[], CWD="", Args...) {
    _RUN_JAVA(-jar ${input:"contrib/java/antlr/antlr4/antlr.jar"} $Args IN $IN IN_NOPARSE $IN_NOPARSE OUT $OUT OUT_NOAUTO $OUT_NOAUTO OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS ${pre=CWD :CWD})
}

_ANTLR4_LISTENER_GRAMMAR=-listener
_ANTLR4_LISTENER_PARSER=-listener
_ANTLR4_LISTENER__ANTLR4_EMPTY=-no-listener
_ANTLR4_VISITOR_GRAMMAR=-visitor
_ANTLR4_VISITOR_PARSER=-visitor
_ANTLR4_VISITOR__ANTLR4_EMPTY=-no-visitor

### @usage: RUN_ANTLR4_CPP_SPLIT(LEXER, PARSER, OUTPUT_INCLUDES, LISTENER, VISITOR, Args...)
###
### Macro to invoke ANTLR4 generator for separate lexer and parser grammars (Cpp)
macro RUN_ANTLR4_CPP_SPLIT(LEXER, PARSER, OUTPUT_INCLUDES[], LISTENER?"PARSER":"_ANTLR4_EMPTY", VISITOR?"PARSER":"_ANTLR4_EMPTY", _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${LEXER} ${PARSER} -Dlanguage=Cpp -o ${BINDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${LEXER} ${PARSER} OUT ${noext;suf=.cpp:LEXER} ${noext;suf=.h:LEXER} ${noext;suf=.cpp:PARSER} ${noext;suf=.h:PARSER} ${noext;suf=Listener.h:$LISTENER} ${noext;suf=BaseListener.h:$LISTENER} ${noext;suf=Visitor.h:$VISITOR} ${noext;suf=BaseVisitor.h:$VISITOR} OUTPUT_INCLUDES ${ARCADIA_ROOT}/contrib/libs/antlr4_cpp_runtime/src/antlr4-runtime.h ${OUTPUT_INCLUDES})
    PEERDIR(contrib/libs/antlr4_cpp_runtime)
}

### @usage: RUN_ANTLR4_CPP(GRAMMAR, OUTPUT_INCLUDES, LISTENER, VISITOR, Args...)
###
### Macro to invoke ANTLR4 generator for combined lexer+parser grammars (Cpp)
macro RUN_ANTLR4_CPP(GRAMMAR, OUTPUT_INCLUDES[], LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${GRAMMAR} -Dlanguage=Cpp -o ${BINDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${GRAMMAR} OUT ${noext;suf=Lexer.cpp:GRAMMAR} ${noext;suf=Lexer.h:GRAMMAR} ${noext;suf=Parser.cpp:GRAMMAR} ${noext;suf=Parser.h:GRAMMAR} ${noext;suf=Listener.h:$LISTENER} ${noext;suf=BaseListener.h:$LISTENER} ${noext;suf=Visitor.h:$VISITOR} ${noext;suf=BaseVisitor.h:$VISITOR} OUTPUT_INCLUDES ${ARCADIA_ROOT}/contrib/libs/antlr4_cpp_runtime/src/antlr4-runtime.h ${OUTPUT_INCLUDES})
    PEERDIR(contrib/libs/antlr4_cpp_runtime)
}

### @usage: RUN_ANTLR4_GO(GRAMMAR, DEPS <extra_go_deps>, LISTENER, VISITOR, Args...)
###
### Macro to invoke ANTLR4 generator (Go)
macro RUN_ANTLR4_GO(GRAMMAR, DEPS[], LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${GRAMMAR} -Dlanguage=Go -o ${BINDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${GRAMMAR} OUT ${noext;tolower;suf=_lexer.go:GRAMMAR} ${noext;tolower;suf=_parser.go:GRAMMAR} ${noext;tolower;suf=_listener.go:$LISTENER} ${noext;tolower;suf=_base_listener.go:$LISTENER} ${noext;tolower;suf=_visitor.go:$VISITOR} ${noext;tolower;suf=_base_visitor.go:$VISITOR})
    PEERDIR(${GOSTD}/fmt ${GOSTD}/reflect ${GOSTD}/strconv ${GOSTD}/sync ${GOSTD}/unicode vendor/github.com/antlr/antlr4/runtime/Go/antlr/v4 $DEPS)
}

### @usage: RUN_ANTLR4_PYTHON(Grammar [LISTENER] [VISITOR] [SUBDIR] [EXTRA_OUTS Outs...] Args...)
###
### `LISTENER` - emit grammar listener
### `VISITOR` -  emit grammar visitor
### `SUBDIR` - place generated files to specified subdirectory of BINDIR
### `EXTRA_OUTS` - list extra outputs produced by Antlr (e.g. .interp and .token files) if they are needed. If `SUBDIR` is specied it will affect these as well. Use file names only.
###
### Macro to invoke ANTLR4 generator (Python). The Python3 will be used for PY3_LIBRARY/PY3_PROGRAM/PY3TEST, Python2 will be used in all other cases.
macro RUN_ANTLR4_PYTHON(GRAMMAR, LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", SUBDIR=".", EXTRA_OUTS[], _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${GRAMMAR} -Dlanguage=$ANTLR_PYTHON -o ${BINDIR}/${SUBDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${GRAMMAR} OUT_NOAUTO ${nopath;noext;pre=${SUBDIR}/;suf=Lexer.py:GRAMMAR} ${nopath;noext;pre=${SUBDIR}/;suf=Parser.py:GRAMMAR} ${nopath;noext;pre=${SUBDIR}/;suf=Listener.py:$LISTENER} ${nopath;noext;pre=${SUBDIR}/;suf=Visitor.py:$VISITOR} ${pre=${SUBDIR}/:EXTRA_OUTS})
    PEERDIR(contrib/python/antlr4)
}

# tag:cpp-specific
macro CPP_ADDINCL(Dirs...) {
    ADDINCL($Dirs)
}

# tag:internal
_WHOLE_ARCHIVE_PEERS_VALUE=
### @usage: WHOLE_ARCHIVE(dirnames...) # internal
macro WHOLE_ARCHIVE(PEERS...) {
    SET_APPEND(_WHOLE_ARCHIVE_PEERS_VALUE ${PEERS})
    REQUIRES(${PEERS})
}

ANDROID_SDK_ROOT=${ANDROID_SDK_RESOURCE_GLOBAL}/android_sdk

macro TASKLET() {
    PEERDIR(tasklet/api)

    # CPP
    CPP_PROTO_PLUGIN(tasklet_cpp tasklet/v1/gen/cpp .tasklet.h)

    # Python
    PY_PROTO_PLUGIN2(tasklet_py _tasklet.py _sbtask.py tasklet/v1/gen/python DEPS tasklet/v1/domain/sandbox tasklet/v1/runtime sandbox/sdk2)
}

TASKLET_REG_INCLUDES= \
    ${output_include;hide:"tasklet/v1/runtime/lib/cpp_wrapper.h"} \
    ${output_include;hide:"tasklet/v1/runtime/lib/go_wrapper.h"} \
    ${output_include;hide:"tasklet/v1/runtime/lib/py_wrapper.h"} \
    ${output_include;hide:"tasklet/v1/runtime/lib/js_wrapper.h"} \
    ${output_include;hide:"tasklet/v1/runtime/lib/registry.h"}

macro TASKLET_REG(Name, Lang, Impl, Includes...) {
    PEERDIR(tasklet/v1/domain sandbox/bin sandbox/taskbox/worker)

    when($Lang == "js") {
        # JS runtime links the Node.js from contrib as a library, which is a bit heavy,
        # so we do it, only if any JS tasklets are linked into the target
        PEERDIR+=tasklet/v1/runtime/js
    }

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_tasklet_reg.py"} $Name -l $Lang -i $Impl ${output;noauto:Name.task.cpp} $Includes ${output_include;hide:Includes} $TASKLET_REG_INCLUDES ${kv;hide:"p TT"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Name.task.cpp)
}

# TEMPORARY METHOD FOR EXTENDED REGISTRY SETUP
# NOT COMPLETE
macro TASKLET_REG_EXT(Name, Lang, Impl, Wrapper, Includes...) {
    PEERDIR(tasklet/v1/domain sandbox/bin sandbox/taskbox/worker)

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_tasklet_reg.py"} $Name -l $Lang -i $Impl -w $Wrapper ${output;noauto:Name.task.cpp} $Includes ${output_include;hide:Includes} $TASKLET_REG_INCLUDES ${kv;hide:"p TT"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Name.task.cpp)
}

# tag:cpp-specific
_CPP_PROTO_MODULE_PREFIX=
_CPP_PROTO_MODULE_SUFFIX=
when ($MSVC == "yes" || $CYGWIN == "yes") {
    _CPP_PROTO_MODULE_PREFIX=
    _CPP_PROTO_MODULE_SUFFIX=.lib
}
otherwise {
    _CPP_PROTO_MODULE_PREFIX=lib
    _CPP_PROTO_MODULE_SUFFIX=.a
}

### @usage: _EXPOSE(OutputsToExport...)
###
### Allows to mark outputs of macro command as unused in the current module but intended
### to be used in modules consuming current via PEERDIR.
###
### TODO(DEVTOOLS-9000) proper implementation needed
macro _EXPOSE(Args...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${output;suf=$_HASH_HELPER($Args).ya_exposed:"empty_"} ${input;hide:Args}
}

# tag:internal
### @usage: _PROXY_LIBRARY() # internal
###
### The use of this module is strictly prohibited!!!
module _PROXY_LIBRARY: LIBRARY {
    .EXTS=.a .lib
    .PEERDIR_POLICY=as_build_from
    .PROXY=yes
    .FINAL_TARGET=yes
    DISABLE(NEED_ADD_FAKE_SRC)

    NO_UTIL()
    NO_RUNTIME()
}

# tag:maps-specific
@import "${CONF_ROOT}/conf/project_specific/maps/asrc.conf"
@import "${CONF_ROOT}/conf/project_specific/maps/aar.conf"
@import "${CONF_ROOT}/conf/project_specific/maps/sproto.conf"
@import "${CONF_ROOT}/conf/project_specific/maps/mapkit.conf"

_PRIMARY_OUTPUT_VALUE=

# tag:internal
### @usage: PRIMARY_OUTPUT_VALUE(Output) # internal
###
### The use of this module is strictly prohibited!!!
macro PRIMARY_OUTPUT(OUTPUT) {
    SET(_PRIMARY_OUTPUT_VALUE $OUTPUT)
}

_DLL_PROXY_LIBRARY_CMD=$GENERATE_MF && $COPY_CMD $_PRIMARY_OUTPUT_VALUE ${input;hide:_PRIMARY_OUTPUT_VALUE} ${TARGET}

# tag:internal
### @usage: DLL_PROXY_LIBRARY() # internal
###
### The use of this module is strictly prohibited!!!
module DLL_PROXY_LIBRARY: _PROXY_LIBRARY {
    .ALLOWED=PRIMARY_OUTPUT
    .CMD=_DLL_PROXY_LIBRARY_CMD
}

_PREBUILT_PROGRAM_CMD=$GENERATE_MF && $COPY_CMD $_PRIMARY_OUTPUT_VALUE ${TARGET} ${kv;hide:"p ld"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"}

# tag:internal
### @usage: PREBUILT_PROGRAM([programname]) # internal
###
### Program module which uses a prebuilt prgram as its output.
module PREBUILT_PROGRAM: _LINK_UNIT {
    .CMD=_PREBUILT_PROGRAM_CMD
    .SYMLINK_POLICY=EXE
    .ALLOWED=INDUCED_DEPS PRIMARY_OUTPUT
    .RESTRICTED=SRCS

    _BARE_LINK_MODULE()

    SET(MODULE_TYPE PROGRAM)

    when ($WIN32 == "yes" || $OS_CYGWIN == "yes") {
        MODULE_SUFFIX=.exe
    }
}

### @usage COLLECT_JINJA_TEMPLATES(varname path)
###
### This macro collects all jinja and yaml files in the directory specified by second argument and
### stores result in the variable with mane specified by first parameter.
macro COLLECT_JINJA_TEMPLATES(VAR, DIR) {
    _GLOB($VAR ${DIR}/**/*.jinja ${DIR}/**/*.yaml)
}

@import "${CONF_ROOT}/conf/go.conf"

# Conflict between protobuf-java and protobuf-javalite ¯\_(ツ)_/¯
# both libraries are required by grpc
JAVA_IGNORE_CLASSPATH_CLASH_DEFAULE_VALUE=\
    com.google.protobuf.AbstractMessageLite \
    com.google.protobuf.AbstractMessageLite$Builder \
    com.google.protobuf.AbstractMessageLite$Builder$LimitedInputStream \
    com.google.protobuf.AbstractMessageLite$InternalOneOfEnum \
    com.google.protobuf.AbstractParser \
    com.google.protobuf.AbstractProtobufList \
    com.google.protobuf.AllocatedBuffer \
    com.google.protobuf.AllocatedBuffer$1 \
    com.google.protobuf.AllocatedBuffer$2 \
    com.google.protobuf.Android \
    com.google.protobuf.Any \
    com.google.protobuf.Any$1 \
    com.google.protobuf.Any$Builder \
    com.google.protobuf.AnyOrBuilder \
    com.google.protobuf.AnyProto \
    com.google.protobuf.Api \
    com.google.protobuf.Api$1 \
    com.google.protobuf.Api$Builder \
    com.google.protobuf.ApiOrBuilder \
    com.google.protobuf.ApiProto \
    com.google.protobuf.ArrayDecoders \
    com.google.protobuf.ArrayDecoders$1 \
    com.google.protobuf.ArrayDecoders$Registers \
    com.google.protobuf.BinaryReader \
    com.google.protobuf.BinaryReader$1 \
    com.google.protobuf.BinaryReader$SafeHeapReader \
    com.google.protobuf.BinaryWriter \
    com.google.protobuf.BinaryWriter$1 \
    com.google.protobuf.BinaryWriter$SafeDirectWriter \
    com.google.protobuf.BinaryWriter$SafeHeapWriter \
    com.google.protobuf.BinaryWriter$UnsafeDirectWriter \
    com.google.protobuf.BinaryWriter$UnsafeHeapWriter \
    com.google.protobuf.BooleanArrayList \
    com.google.protobuf.BoolValue \
    com.google.protobuf.BoolValue$1 \
    com.google.protobuf.BoolValue$Builder \
    com.google.protobuf.BoolValueOrBuilder \
    com.google.protobuf.BufferAllocator \
    com.google.protobuf.BufferAllocator$1 \
    com.google.protobuf.ByteBufferWriter \
    com.google.protobuf.ByteOutput \
    com.google.protobuf.ByteString \
    com.google.protobuf.ByteString$1 \
    com.google.protobuf.ByteString$2 \
    com.google.protobuf.ByteString$AbstractByteIterator \
    com.google.protobuf.ByteString$ArraysByteArrayCopier \
    com.google.protobuf.ByteString$BoundedByteString \
    com.google.protobuf.ByteString$ByteArrayCopier \
    com.google.protobuf.ByteString$ByteIterator \
    com.google.protobuf.ByteString$CodedBuilder \
    com.google.protobuf.ByteString$LeafByteString \
    com.google.protobuf.ByteString$LiteralByteString \
    com.google.protobuf.ByteString$Output \
    com.google.protobuf.ByteString$SystemByteArrayCopier \
    com.google.protobuf.BytesValue \
    com.google.protobuf.BytesValue$1 \
    com.google.protobuf.BytesValue$Builder \
    com.google.protobuf.BytesValueOrBuilder \
    com.google.protobuf.CanIgnoreReturnValue \
    com.google.protobuf.CheckReturnValue \
    com.google.protobuf.CodedInputStream \
    com.google.protobuf.CodedInputStream$1 \
    com.google.protobuf.CodedInputStream$ArrayDecoder \
    com.google.protobuf.CodedInputStream$IterableDirectByteBufferDecoder \
    com.google.protobuf.CodedInputStream$StreamDecoder \
    com.google.protobuf.CodedInputStream$StreamDecoder$RefillCallback \
    com.google.protobuf.CodedInputStream$StreamDecoder$SkippedDataSink \
    com.google.protobuf.CodedInputStream$UnsafeDirectNioDecoder \
    com.google.protobuf.CodedInputStreamReader \
    com.google.protobuf.CodedInputStreamReader$1 \
    com.google.protobuf.CodedOutputStream \
    com.google.protobuf.CodedOutputStream$1 \
    com.google.protobuf.CodedOutputStream$AbstractBufferedEncoder \
    com.google.protobuf.CodedOutputStream$ArrayEncoder \
    com.google.protobuf.CodedOutputStream$ByteOutputEncoder \
    com.google.protobuf.CodedOutputStream$HeapNioEncoder \
    com.google.protobuf.CodedOutputStream$OutOfSpaceException \
    com.google.protobuf.CodedOutputStream$OutputStreamEncoder \
    com.google.protobuf.CodedOutputStream$SafeDirectNioEncoder \
    com.google.protobuf.CodedOutputStream$UnsafeDirectNioEncoder \
    com.google.protobuf.CodedOutputStreamWriter \
    com.google.protobuf.CodedOutputStreamWriter$1 \
    com.google.protobuf.DoubleArrayList \
    com.google.protobuf.DoubleValue \
    com.google.protobuf.DoubleValue$1 \
    com.google.protobuf.DoubleValue$Builder \
    com.google.protobuf.DoubleValueOrBuilder \
    com.google.protobuf.Duration \
    com.google.protobuf.Duration$1 \
    com.google.protobuf.Duration$Builder \
    com.google.protobuf.DurationOrBuilder \
    com.google.protobuf.DurationProto \
    com.google.protobuf.Empty \
    com.google.protobuf.Empty$1 \
    com.google.protobuf.Empty$Builder \
    com.google.protobuf.EmptyOrBuilder \
    com.google.protobuf.EmptyProto \
    com.google.protobuf.Enum \
    com.google.protobuf.Enum$1 \
    com.google.protobuf.Enum$Builder \
    com.google.protobuf.EnumOrBuilder \
    com.google.protobuf.EnumValue \
    com.google.protobuf.EnumValue$1 \
    com.google.protobuf.EnumValue$Builder \
    com.google.protobuf.EnumValueOrBuilder \
    com.google.protobuf.ExperimentalApi \
    com.google.protobuf.ExtensionLite \
    com.google.protobuf.ExtensionRegistryFactory \
    com.google.protobuf.ExtensionRegistryLite \
    com.google.protobuf.ExtensionRegistryLite$ExtensionClassHolder \
    com.google.protobuf.ExtensionRegistryLite$ObjectIntPair \
    com.google.protobuf.ExtensionSchema \
    com.google.protobuf.ExtensionSchemaLite \
    com.google.protobuf.ExtensionSchemaLite$1 \
    com.google.protobuf.ExtensionSchemas \
    com.google.protobuf.Field \
    com.google.protobuf.Field$1 \
    com.google.protobuf.Field$Builder \
    com.google.protobuf.Field$Cardinality \
    com.google.protobuf.Field$Cardinality$1 \
    com.google.protobuf.Field$Kind \
    com.google.protobuf.Field$Kind$1 \
    com.google.protobuf.FieldInfo \
    com.google.protobuf.FieldInfo$1 \
    com.google.protobuf.FieldInfo$Builder \
    com.google.protobuf.FieldMask \
    com.google.protobuf.FieldMask$1 \
    com.google.protobuf.FieldMask$Builder \
    com.google.protobuf.FieldMaskOrBuilder \
    com.google.protobuf.FieldMaskProto \
    com.google.protobuf.FieldOrBuilder \
    com.google.protobuf.FieldSet \
    com.google.protobuf.FieldSet$1 \
    com.google.protobuf.FieldSet$Builder \
    com.google.protobuf.FieldSet$FieldDescriptorLite \
    com.google.protobuf.FieldType \
    com.google.protobuf.FieldType$1 \
    com.google.protobuf.FieldType$Collection \
    com.google.protobuf.FloatArrayList \
    com.google.protobuf.FloatValue \
    com.google.protobuf.FloatValue$1 \
    com.google.protobuf.FloatValue$Builder \
    com.google.protobuf.FloatValueOrBuilder \
    com.google.protobuf.GeneratedMessageInfoFactory \
    com.google.protobuf.GeneratedMessageLite \
    com.google.protobuf.GeneratedMessageLite$1 \
    com.google.protobuf.GeneratedMessageLite$Builder \
    com.google.protobuf.GeneratedMessageLite$DefaultInstanceBasedParser \
    com.google.protobuf.GeneratedMessageLite$ExtendableBuilder \
    com.google.protobuf.GeneratedMessageLite$ExtendableMessage \
    com.google.protobuf.GeneratedMessageLite$ExtendableMessage$ExtensionWriter \
    com.google.protobuf.GeneratedMessageLite$ExtendableMessageOrBuilder \
    com.google.protobuf.GeneratedMessageLite$ExtensionDescriptor \
    com.google.protobuf.GeneratedMessageLite$GeneratedExtension \
    com.google.protobuf.GeneratedMessageLite$MethodToInvoke \
    com.google.protobuf.GeneratedMessageLite$SerializedForm \
    com.google.protobuf.Int32Value \
    com.google.protobuf.Int32Value$1 \
    com.google.protobuf.Int32Value$Builder \
    com.google.protobuf.Int32ValueOrBuilder \
    com.google.protobuf.Int64Value \
    com.google.protobuf.Int64Value$1 \
    com.google.protobuf.Int64Value$Builder \
    com.google.protobuf.Int64ValueOrBuilder \
    com.google.protobuf.IntArrayList \
    com.google.protobuf.Internal \
    com.google.protobuf.Internal$BooleanList \
    com.google.protobuf.Internal$DoubleList \
    com.google.protobuf.Internal$EnumLite \
    com.google.protobuf.Internal$EnumLiteMap \
    com.google.protobuf.Internal$EnumVerifier \
    com.google.protobuf.Internal$FloatList \
    com.google.protobuf.Internal$IntList \
    com.google.protobuf.Internal$ListAdapter \
    com.google.protobuf.Internal$ListAdapter$Converter \
    com.google.protobuf.Internal$LongList \
    com.google.protobuf.Internal$MapAdapter \
    com.google.protobuf.Internal$MapAdapter$1 \
    com.google.protobuf.Internal$MapAdapter$Converter \
    com.google.protobuf.Internal$MapAdapter$EntryAdapter \
    com.google.protobuf.Internal$MapAdapter$IteratorAdapter \
    com.google.protobuf.Internal$MapAdapter$SetAdapter \
    com.google.protobuf.Internal$ProtobufList \
    com.google.protobuf.InvalidProtocolBufferException \
    com.google.protobuf.InvalidProtocolBufferException$InvalidWireTypeException \
    com.google.protobuf.IterableByteBufferInputStream \
    com.google.protobuf.JavaType \
    com.google.protobuf.LazyField \
    com.google.protobuf.LazyField$1 \
    com.google.protobuf.LazyField$LazyEntry \
    com.google.protobuf.LazyField$LazyIterator \
    com.google.protobuf.LazyFieldLite \
    com.google.protobuf.LazyStringArrayList \
    com.google.protobuf.LazyStringArrayList$ByteArrayListView \
    com.google.protobuf.LazyStringArrayList$ByteStringListView \
    com.google.protobuf.LazyStringList \
    com.google.protobuf.ListFieldSchema \
    com.google.protobuf.ListFieldSchema$1 \
    com.google.protobuf.ListFieldSchema$ListFieldSchemaFull \
    com.google.protobuf.ListFieldSchema$ListFieldSchemaLite \
    com.google.protobuf.ListValue \
    com.google.protobuf.ListValue$1 \
    com.google.protobuf.ListValue$Builder \
    com.google.protobuf.ListValueOrBuilder \
    com.google.protobuf.LongArrayList \
    com.google.protobuf.ManifestSchemaFactory \
    com.google.protobuf.ManifestSchemaFactory$1 \
    com.google.protobuf.ManifestSchemaFactory$CompositeMessageInfoFactory \
    com.google.protobuf.MapEntryLite \
    com.google.protobuf.MapEntryLite$1 \
    com.google.protobuf.MapEntryLite$Metadata \
    com.google.protobuf.MapFieldLite \
    com.google.protobuf.MapFieldSchema \
    com.google.protobuf.MapFieldSchemaLite \
    com.google.protobuf.MapFieldSchemas \
    com.google.protobuf.MessageInfo \
    com.google.protobuf.MessageInfoFactory \
    com.google.protobuf.MessageLite \
    com.google.protobuf.MessageLite$Builder \
    com.google.protobuf.MessageLiteOrBuilder \
    com.google.protobuf.MessageLiteToString \
    com.google.protobuf.MessageSchema \
    com.google.protobuf.MessageSchema$1 \
    com.google.protobuf.MessageSetSchema \
    com.google.protobuf.Method \
    com.google.protobuf.Method$1 \
    com.google.protobuf.Method$Builder \
    com.google.protobuf.MethodOrBuilder \
    com.google.protobuf.Mixin \
    com.google.protobuf.Mixin$1 \
    com.google.protobuf.Mixin$Builder \
    com.google.protobuf.MixinOrBuilder \
    com.google.protobuf.MutabilityOracle \
    com.google.protobuf.MutabilityOracle$1 \
    com.google.protobuf.NewInstanceSchema \
    com.google.protobuf.NewInstanceSchemaLite \
    com.google.protobuf.NewInstanceSchemas \
    com.google.protobuf.NioByteString \
    com.google.protobuf.NioByteString$1 \
    com.google.protobuf.NullValue \
    com.google.protobuf.NullValue$1 \
    com.google.protobuf.OneofInfo \
    com.google.protobuf.Option \
    com.google.protobuf.Option$1 \
    com.google.protobuf.Option$Builder \
    com.google.protobuf.OptionOrBuilder \
    com.google.protobuf.Parser \
    com.google.protobuf.PrimitiveNonBoxingCollection \
    com.google.protobuf.Protobuf \
    com.google.protobuf.ProtobufArrayList \
    com.google.protobuf.ProtobufLists \
    com.google.protobuf.ProtocolStringList \
    com.google.protobuf.ProtoSyntax \
    com.google.protobuf.RawMessageInfo \
    com.google.protobuf.Reader \
    com.google.protobuf.RopeByteString \
    com.google.protobuf.RopeByteString$1 \
    com.google.protobuf.RopeByteString$Balancer \
    com.google.protobuf.RopeByteString$PieceIterator \
    com.google.protobuf.RopeByteString$RopeInputStream \
    com.google.protobuf.Schema \
    com.google.protobuf.SchemaFactory \
    com.google.protobuf.SchemaUtil \
    com.google.protobuf.SmallSortedMap \
    com.google.protobuf.SmallSortedMap$1 \
    com.google.protobuf.SmallSortedMap$DescendingEntryIterator \
    com.google.protobuf.SmallSortedMap$DescendingEntrySet \
    com.google.protobuf.SmallSortedMap$EmptySet \
    com.google.protobuf.SmallSortedMap$EmptySet$1 \
    com.google.protobuf.SmallSortedMap$EmptySet$2 \
    com.google.protobuf.SmallSortedMap$Entry \
    com.google.protobuf.SmallSortedMap$EntryIterator \
    com.google.protobuf.SmallSortedMap$EntrySet \
    com.google.protobuf.SourceContext \
    com.google.protobuf.SourceContext$1 \
    com.google.protobuf.SourceContext$Builder \
    com.google.protobuf.SourceContextOrBuilder \
    com.google.protobuf.SourceContextProto \
    com.google.protobuf.StringValue \
    com.google.protobuf.StringValue$1 \
    com.google.protobuf.StringValue$Builder \
    com.google.protobuf.StringValueOrBuilder \
    com.google.protobuf.Struct \
    com.google.protobuf.Struct$1 \
    com.google.protobuf.Struct$Builder \
    com.google.protobuf.Struct$FieldsDefaultEntryHolder \
    com.google.protobuf.StructOrBuilder \
    com.google.protobuf.StructProto \
    com.google.protobuf.StructuralMessageInfo \
    com.google.protobuf.StructuralMessageInfo$Builder \
    com.google.protobuf.Syntax \
    com.google.protobuf.Syntax$1 \
    com.google.protobuf.TextFormatEscaper \
    com.google.protobuf.TextFormatEscaper$1 \
    com.google.protobuf.TextFormatEscaper$2 \
    com.google.protobuf.TextFormatEscaper$ByteSequence \
    com.google.protobuf.Timestamp \
    com.google.protobuf.Timestamp$1 \
    com.google.protobuf.Timestamp$Builder \
    com.google.protobuf.TimestampOrBuilder \
    com.google.protobuf.TimestampProto \
    com.google.protobuf.Type \
    com.google.protobuf.Type$1 \
    com.google.protobuf.Type$Builder \
    com.google.protobuf.TypeOrBuilder \
    com.google.protobuf.TypeProto \
    com.google.protobuf.UInt32Value \
    com.google.protobuf.UInt32Value$1 \
    com.google.protobuf.UInt32Value$Builder \
    com.google.protobuf.UInt32ValueOrBuilder \
    com.google.protobuf.UInt64Value \
    com.google.protobuf.UInt64Value$1 \
    com.google.protobuf.UInt64Value$Builder \
    com.google.protobuf.UInt64ValueOrBuilder \
    com.google.protobuf.UninitializedMessageException \
    com.google.protobuf.UnknownFieldSchema \
    com.google.protobuf.UnknownFieldSetLite \
    com.google.protobuf.UnknownFieldSetLiteSchema \
    com.google.protobuf.UnmodifiableLazyStringList \
    com.google.protobuf.UnmodifiableLazyStringList$1 \
    com.google.protobuf.UnmodifiableLazyStringList$2 \
    com.google.protobuf.UnsafeByteOperations \
    com.google.protobuf.UnsafeUtil \
    com.google.protobuf.UnsafeUtil$1 \
    com.google.protobuf.UnsafeUtil$Android32MemoryAccessor \
    com.google.protobuf.UnsafeUtil$Android64MemoryAccessor \
    com.google.protobuf.UnsafeUtil$JvmMemoryAccessor \
    com.google.protobuf.UnsafeUtil$MemoryAccessor \
    com.google.protobuf.Utf8 \
    com.google.protobuf.Utf8$DecodeUtil \
    com.google.protobuf.Utf8$Processor \
    com.google.protobuf.Utf8$SafeProcessor \
    com.google.protobuf.Utf8$UnpairedSurrogateException \
    com.google.protobuf.Utf8$UnsafeProcessor \
    com.google.protobuf.Value \
    com.google.protobuf.Value$1 \
    com.google.protobuf.Value$Builder \
    com.google.protobuf.Value$KindCase \
    com.google.protobuf.ValueOrBuilder \
    com.google.protobuf.WireFormat \
    com.google.protobuf.WireFormat$1 \
    com.google.protobuf.WireFormat$FieldType \
    com.google.protobuf.WireFormat$FieldType$1 \
    com.google.protobuf.WireFormat$FieldType$2 \
    com.google.protobuf.WireFormat$FieldType$3 \
    com.google.protobuf.WireFormat$FieldType$4 \
    com.google.protobuf.WireFormat$JavaType \
    com.google.protobuf.WireFormat$Utf8Validation \
    com.google.protobuf.WireFormat$Utf8Validation$1 \
    com.google.protobuf.WireFormat$Utf8Validation$2 \
    com.google.protobuf.WireFormat$Utf8Validation$3 \
    com.google.protobuf.WrappersProto \
    com.google.protobuf.Writer \
    com.google.protobuf.Writer$FieldOrder

# tag:java-specific
JAVA_IGNORE_CLASSPATH_CLASH_VALUE=$JAVA_IGNORE_CLASSPATH_CLASH_DEFAULE_VALUE

### @usage: JAVA_IGNORE_CLASSPATH_CLASH_FOR([classes])
### Ignore classpath clash test fails for classes
macro JAVA_IGNORE_CLASSPATH_CLASH_FOR(Args...) {
    SET_APPEND(JAVA_IGNORE_CLASSPATH_CLASH_VALUE $Args $JAVA_IGNORE_CLASSPATH_CLASH_DEFAULE_VALUE)
}


IBTOOL_PATH=$XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/ibtool
# tag:src-processing
STORYBOARD_FLAGS=--errors --warnings --notices --auto-activate-custom-fonts --output-format human-readable-text
macro _SRC("storyboard", SRC, SRCFLAGS...) {
    .CMD=$IBTOOL_PATH $STORYBOARD_FLAGS --module $REALPRJNAME --output-partial-info-plist ${output;suf=.partial_plist:SRC} --compilation-directory $BINDIR ${input:SRC} && $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"}  ${output;tobindir;suf=.compiled_storyboard_tar:SRC} $BINDIR/${nopath;suf=c:SRC} $BINDIR/${nopath;suf=c:SRC}
}

# tag:src-processing
macro _SRC("xib", SRC, SRCFLAGS...) {
    .CMD=$IBTOOL_PATH $STORYBOARD_FLAGS --module $REALPRJNAME --output-partial-info-plist ${output;suf=.partial_plist:SRC} --compile ${output;tobindir;nopath;noext;suf=.nib:SRC} ${input:SRC}
}

ACTOOL_PATH=$XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/ibtool
# tag:ios-specific
ASSETS_FLAGS=--output-format human-readable-text --notices --warnings
macro _IOS_ASSETS(AssetsDir, Content...) {
    .CMD=$FS_TOOLS md $BINDIR/$REALPRJNAME && $ACTOOL_PATH $ASSETS_FLAGS --export-dependency-info $BINDIR/assetcatalog_dependencies --output-partial-info-plist ${output:"assetcatalog_generated_info.partial_plist"} --product-type com.apple.product-type.application --compile $BINDIR/$REALPRJNAME $AssetsDir ${input;hide:Content} && ${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"} ${output;suf=_assetes.resource_tar:REALPRJNAME} $REALPRJNAME $REALPRJNAME
}

# tag:ios-specific
macro IOS_APP_COMMON_FLAGS(Flags...) {
    SET_APPEND(STORYBOARD_FLAGS $Flags)
    SET_APPEND(ASSETS_FLAGS $Flags)
}

# tag:ios-specific
macro IOS_APP_ASSETS_FLAGS(Flags...) {
    SET_APPEND(ASSETS_FLAGS $Flags)
}

macro DARWIN_STRINGS_RESOURCE(Resource, Relpath) {
    .CMD=$COPY_CMD ${input:Resource} $BINDIR/$Relpath && $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"} ${output;tobindir;suf=.strings_tar:Relpath} $BINDIR/$Relpath $BINDIR
}

macro DARWIN_SIGNED_RESOURCE(Resource, Relpath) {
    .CMD=$COPY_CMD $Resource $BINDIR/$Relpath && $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"} ${output;tobindir;suf=.signed_resource_tar:Relpath} $BINDIR/$Relpath $BINDIR
}

# tag:ios-specific
DELIM=__DELIM__
PACK_IOS_ARCHIVE=$GENERATE_MF && $YMAKE_PYTHON ${input:"build/scripts/ios_wrapper.py"} bin $IBTOOL_PATH $TARGET $REALPRJNAME $BINDIR $DELIM $AUTO_INPUT $DELIM $STORYBOARD_FLAGS
### @usage: IOS_INTERFACE()
### iOS GUI module definition
module IOS_INTERFACE: _BARE_UNIT {
    .CMD=PACK_IOS_ARCHIVE
    .EXTS=.compiled_storyboard_tar .partial_plist .plist .xcent .nib .resource_tar .signed_resource_tar .strings_tar .plist_json
    .NODE_TYPE=Library
    .FINAL_TARGET=no
    SET(MODULE_SUFFIX .ios.interface)

    PEERDIR+=build/platform/xcode/tools
}

# tag:ios-specific
module DEFAULT_IOS_INTERFACE: IOS_INTERFACE {
    SET(MODULE_SUFFIX .default.ios.interface)
}

DEFAULT_IOS_TYPE=
IOS_TYPE=
when(!$IOS_TYPE) {
    when($DEFAULT_IOS_TYPE) {
        IOS_TYPE=$DEFAULT_IOS_TYPE
    }
    otherwise {
        IOS_TYPE=com.apple.CoreSimulator.SimDeviceType.iPhone-X
    }
}
DEFAULT_IOS_RUNTIME=
IOS_RUNTIME=
when(!$IOS_RUNTIME) {
    when($DEFAULT_IOS_RUNTIME) {
        IOS_RUNTIME=$DEFAULT_IOS_RUNTIME
    }
    otherwise {
        IOS_RUNTIME=com.apple.CoreSimulator.SimRuntime.iOS-12-1
    }
}
when ($ARCH_I386) {
    TEST_IOS_DEVICE_TYPE_VALUE=com.apple.CoreSimulator.SimDeviceType.iPhone-5
    TEST_IOS_RUNTIME_TYPE_VALUE=com.apple.CoreSimulator.SimRuntime.iOS-10-3
}
otherwise {
    TEST_IOS_DEVICE_TYPE_VALUE=$IOS_TYPE
    TEST_IOS_RUNTIME_TYPE_VALUE=$IOS_RUNTIME
}

# tag:frontend-specific
### @usage: COLLECT_FRONTEND_FILES(Varname, Dir)
###
### Recursively collect files with typical frontend extensions from Dir and save the result into variable Varname
macro COLLECT_FRONTEND_FILES(Varname, Dir) {
    _GLOB($Varname $Dir/**/*.(css|ejs|jpg|js|jsx|png|styl|svg|ts|tsx|json|html))
}

# tag:swift-specific
CPP_XCODE_TOOLCHAIN_VERSION=9.2
SWIFT_XCODE_TOOLCHAIN_VERSION=9.2
XCODE_TOOLS_VERSION=10.1
macro COMPILE_SWIFT_MODULE(SRCS{input}[], BRIDGE_HEADER{input}="", Flags...) {
    when ($BRIDGE_HEADER != "") {
        SWIFT_BRIDGE_HEADER=-import-objc-header ${input:BRIDGE_HEADER}
    }
    otherwise {
        SWIFT_BRIDGE_HEADER=
    }

    .PEERDIR+=build/platform/xcode/swift
    # swift core libraries
    LDFLAGS($SWIFT_LD_FLAGS)

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_swiftc_output_map.py"} $(SOURCE_ROOT) $(BUILD_ROOT) $BINDIR/swift_output_map.json ${input:SRCS} && $SWIFT_COMPILER -c $SWIFT_FLAGS_PLATFORM $Flags $SWIFT_BRIDGE_HEADER ${pre=-Xcc -I:_C__INCLUDE} ${input:SRCS} -emit-objc-header -emit-objc-header-path ${output;suf=-Swift.h:REALPRJNAME} -emit-module -module-name $REALPRJNAME -output-file-map $BINDIR/swift_output_map.json ${output;hide;suf=.o:SRCS}
}

TEST_TOOL_HOST_LOCAL=
TEST_TOOL_TARGET_LOCAL=

when ($MOST_USED_CUDA) {
    CUDA_VERSION=11.4
    CUDNN_VERSION=8.0.5
    TENSORRT_VERSION=7
}

when ($TENSORFLOW_WITH_CUDA) {
    CUDA_REQUIRED=yes
}

when (!$TENSORRT_VERSION) {
    TENSORRT_VERSION=5
}

ANDROID_APK_TEST_ACTIVITY_VALUE=com.yandex.test.unittests/.RunTestsActivity

# tag:windows-specific
WINDOWS_MANIFEST=
macro WINDOWS_MANIFEST(Manifest) {
    SET(WINDOWS_MANIFEST $Manifest)
}

# https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation#enable-long-paths-in-windows-10-version-1607-and-later
macro WINDOWS_LONG_PATH_MANIFEST() {
    SET(WINDOWS_MANIFEST build/long-path.manifest)
}

# tag:windows-specific
when ($MSVC == "yes" && $WINDOWS_MANIFEST) {
    LDFLAGS+=/MANIFEST:EMBED /MANIFESTINPUT:${input:WINDOWS_MANIFEST}
}

# tag:cpp-specific
_VISIBILITY_LEVEL=
### @usage: VISIBILITY(level)
###
### This macro sets visibility level for symbols compiled for the current module. 'level'
### may take only one of the following values: DEFAULT, HIDDEN.
macro VISIBILITY(LEVEL) {
    SET(_VISIBILITY_LEVEL ${LEVEL})
    select ($LEVEL) {
        "DEFAULT" | "HIDDEN" ? {
        }
        default ? {
            _OK = no
        }
    }
    ASSERT(_OK Unsupported value [$LEVEL] passed to VISIBILITY macro, expected values are DEFAULT, HIDDEN.)
}

# tag:cpp-specific
_CFLAGS_VISIBILITY=
when ($_VISIBILITY_LEVEL != "" && $IGNORE_VISIBILITY != "yes") {
    when ($CLANG == "yes" || $GCC == "yes") {
        _CFLAGS_VISIBILITY=-fvisibility=${tolower:_VISIBILITY_LEVEL}
    }
}
CFLAGS+=$_CFLAGS_VISIBILITY

# tag:cpp-specific
macro SDBUS_CPP_ADAPTOR(File) {
    .CMD=${tool:"contrib/libs/sdbus-cpp/tools/xml2cpp-codegen"} --adaptor=${output;nopath;noext:File.adaptor.h} ${input:File}
    .PEERDIR=contrib/libs/sdbus-cpp
}

# tag:cpp-specific
macro SDBUS_CPP_PROXY(File) {
    .CMD=${tool:"contrib/libs/sdbus-cpp/tools/xml2cpp-codegen"} --proxy=${output;nopath;noext:File.proxy.h} ${input:File}
    .PEERDIR=contrib/libs/sdbus-cpp
}

# tag:python-specific
macro _PY_ENUM_SERIALIZATION_TO_JSON(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --output ${output;noext;suf=.generated.h:File} --json-output ${output;noext:File.json} ${kv;hide:"p EN"} ${kv;hide:"pc yellow"}
}

# tag:python-specific
macro _PY_ENUM_SERIALIZATION_TO_PY(File) {
    .CMD=${tool:"metrika/core/tools/python_enum_generator"} ${input;noext:File.json} -D ${MODDIR} --output ${output;noext:File.py} ${kv;hide:"p EN"} ${kv;hide:"pc yellow"}
}

macro NGINX_MODULES(Modules...) {
    PEERDIR(${Modules})
    RUN_PROGRAM(nginx/module_gen ${Modules} CWD ${ARCADIA_ROOT} IN ${suf=/modules.json:Modules} OUTPUT_INCLUDES contrib/nginx/core/src/core/ngx_config.h contrib/nginx/core/src/core/ngx_core.h STDOUT ngx_modules.c)
}

### @usage: ORIGINAL_SOURCE(Source)
###
### This macro specifies the source repository for contrib
### Does nothing now (just a placeholder for future functionality)
### See https://st.yandex-team.ru/DTCC-316
macro ORIGINAL_SOURCE(Source) {
    ENABLE(UNUSED_MACRO)
}

# tag:licence
CREDITS_FILE_EXTRA_EXT=
CREDITS_FLAGS=
CREDITS_TEXTS_FILE=
NO_CREDITS_TEXTS_FILE=
WITH_CREDITS=
### @usage: LICENSE_TEXTS(File)
###
### This macro specifies the filename with all library licenses texts
macro LICENSE_TEXTS(Source) {
    SET(CREDITS_TEXTS_FILE $Source)
}

# tag:licence
### @usage: WITHOUT_LICENSE_TEXTS()
###
### This macro indicates that the module has no license text
macro WITHOUT_LICENSE_TEXTS() {
    ENABLE(NO_CREDITS_TEXTS_FILE)
}

# tag:licence
when ($WITH_CREDITS) {
    CREDITS_FLAGS+=--credits-output ${output;suf=${CREDITS_FILE_EXTRA_EXT}".CREDITS.txt":REALPRJNAME}
}

GENERATE_MF=
when ($WITH_CREDITS) {
    GENERATE_MF=$GENERATE_MF_CMD
}

macro _MCU_CONVERT(Bin) {
    .CMD=${cwd:BINDIR} $OBJCOPY_TOOL -O ihex $Bin ${output;noext:Bin.hex} && ${cwd:BINDIR} $OBJCOPY_TOOL -O srec $Bin ${output;noext:Bin.s37} && ${cwd:BINDIR} $OBJCOPY_TOOL -O binary $Bin ${output;noext:Bin.bin}
}

MCU_LINK_EXE=$LINK_EXE && $_MCU_CONVERT($MODULE_PREFIX$REALPRJNAME)

### @usage: MCU_PROGRAM([progname])
###
### Program module for microcontrollers. Converts ELF to Intel HEX, Motorola S-record and raw binary file formats.
### If name is not specified it will be generated from the name of the containing project directory.
module MCU_PROGRAM: PROGRAM {
    .CMD=MCU_LINK_EXE
}

@import "${CONF_ROOT}/conf/project_specific/esp.conf"

# tag:flags tag:internal tag:windows-specific
### @usage: _MSVC_FLAGS_WINDOWS_IMPL(target_platform compiler_flags) # internal
###
### Add CFLAGS when the firts argument is WINDOWS
macro _MSVC_FLAGS_WINDOWS_IMPL(WINDOWS[], FLAGS...) {
    CFLAGS($WINDOWS)
}

# tag:flags tag:windows-specific tag:cpp-specific
### @usage: MSVC_FLAGS([GLOBAL compiler_flag]* compiler_flags)
###
### Add the specified flags to the compilation line of C/C++files.
### Flags apply only if the compiler used is MSVC (cl.exe)
macro MSVC_FLAGS(FLAGS...) {
    _MSVC_FLAGS_WINDOWS_IMPL($TARGET_PLATFORM $FLAGS)
}

### @usage: COLLECT_YDB_API_SPECS_LEGACY(VarName Paths...)  #deprecated
###
### This macro is ugly hack for legacy YDB go API codegen, any other uses are prohibited
macro COLLECT_YDB_API_SPECS_LEGACY(FILES_VAR, PATHS...) {
    _GLOB($FILES_VAR ${suf=/*.proto:PATHS})
    RESTRICT_PATH(kikimr/public/sdk/go/ydb/api MSG This is ugly hack for legacy YDB go API codegen, any other uses are probibited)
}

# tag:proto tag:apphost
### @usage: APPHOST()
###
### Emit APPHOST service code for all .proto files in a PROTO_LIBRARY.
### This works only for C++ and Java at the moment.
macro APPHOST() {
    # C++
    CPP_PROTO_PLUGIN(cpp_plugin apphost/tools/stub_generator/cpp_plugin .apphost.h DEPS apphost/tools/stub_generator/cpp_includes)

    # Java
    JAVA_PROTO_PLUGIN(java_plugin apphost/tools/stub_generator/java_plugin DEPS apphost/api/service/java/apphost)
}

# tag:internal
### Add passed ya.conf.json and all bottle's formula external files to resources
### File MUST be arcadia root relative path (without "${ARCADIA_ROOT}/" prefix).
### NOTE:
###   An external formula file referenced from ya.conf.json must be passed as an arcadia root relative path and
###   should be located in any subdirectory of the ya.conf.json location ("build/" if we consider a production).
###   The later restriction prevents problems in selectively checkouted arcadia.
macro YA_CONF_JSON(File) {
    _YA_CONF_JSON($File)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS ${ARCADIA_ROOT}/$File)
}

# tag:internal
# Don't use directly - wrap with custom macros
macro ADD_LINTER_CHECK(CheckName, Linter, DEPENDS[], EXCLUDE[], FILES[], CONFIGS[]) {
    SET(_FILES_VAR uniq_${hash:VAR_SALT})
    _GLOB($_FILES_VAR $FILES EXCLUDE $EXCLUDE)
    _ADD_LINTER_CHECK($CheckName $Linter ${pre=DEPENDS :DEPENDS} FILES $$_FILES_VAR CONFIGS $CONFIGS)
}

# tag:internal
# Draft. Don't use.
macro _CPP_STYLE(EXCLUDE[], Files...) {
    ADD_LINTER_CHECK(cpp_style tools/cpp_style_checker/cpp_style_checker DEPENDS contrib/libs/clang12/tools/clang-format EXCLUDE $EXCLUDE FILES $Files CONFIGS devtools/ya/handlers/style/style_config)
}

# tag:proto
macro ALICE_CAPABILITY() {
    CPP_PROTO_PLUGIN(alice_capability_cpp yandex_io/tools/capability_gen .cap.h DEPS yandex_io/libs/protobuf_utils)

    JAVA_PROTO_PLUGIN(alice_capability_java alice/library/go/java_marker_interface_protoc_plugin DEPS alice/protos/endpoint/java_interface alice/megamind/protos/scenarios/java_interface)
}

@import "${CONF_ROOT}/conf/misc.conf"
