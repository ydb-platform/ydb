# !!! DISCLAIMER! PLEASE DON'T IGNORE !!!
# The FAKEID value is huge hammer. It affects UIDs of all nodes in build graph including, but not limited to
# any resource fetch (think java contrib), build on any language (C++, Python, Java, Go), any code generation.
# Any build after this change will pay the price:
# - Local builds and Sandbox builds will reload all resources from Sandbox and cached data from YT (if ready).
# - Distributed (YT) cache warmup will take significant time to catch up and will need to recache everything.
# - Autocheck will rebuild and recache everything.
# Use this with extreme care and only change if it is ultimately needed. Consider more specific XXX_FAKEIDs below instead.
FAKEID=328319516716

SANDBOX_FAKEID=${FAKEID}.7600000
CPP_FAKEID=2024-01-23
GO_FAKEID=11100371
ANDROID_FAKEID=2023-05-17
CLANG_TIDY_FAKEID=2023-06-06
IWYU_FAKEID=2025-01-08
CYTHON_FAKEID=16618405
JAVA_FAKEID=9377710
PROTO_FAKEID=0
FBS_FAKEID=2024-03-13
DOCS_FAKEID=1

# Change of this value will invalidate some parts of configure cache
# but will not affect builds anyhow (except tests referring build/ directory)
JSON_CACHE_FAKE_ID=20250819

STRUCT_CMD=yes
_DBG_EXPR_ERROR_DETAILS=one

CURDIR=.
MODDIR=.
BINDIR=bin:/
SRCDIR=
YMAKE=ymake
ECHO=echo
INCLUDE_EXTS=.h .hh .hpp .rli .cuh .inc .i .ipp .ixx .ya_exposed .hxx .H
CPP_EXT=.cpp
OBJ_SUF=
CFLAGS=
EXTRA_C_FLAGS=
SFLAGS=
SRCFLAGS=
FORCE_COVERAGE_ENABLED=
FORCE_COVERAGE_DISABLED=
COVERAGE_FILTER_PROGRAMS=no
LDFLAGS=
LDFLAGS_GLOBAL=
OBJADDE=
OBJADDE_LIB=
OBJADDE_LIB_GLOBAL=
TRUE=yes
FALSE=no

MODULE_PREFIX=
MODULE_SUFFIX=

__COMMA__=${comma:""}
__BSDQ__=\"
when ($STRUCT_CMD == "yes") {
    __BSDQ__=\\\"
}

# do not keep it undefined, since we directly subsitute it in LLVM_COMPILE_CXX etc.
WINDOWS=no

# tag:src-processing tag:internal
### @usage: _SRC(Ext Src Flags) # internal
###
### Basic building block of extension-based command dispatching
### To enable specific extension processing define _SRC() macro with fixed first argument (Ext).
### Internal logic will apply this macro to all files with this Ext listed in SRC/SRCS macros or outputs
### of other commands (except ones marked as noauto)
macro _SRC(EXT, SRC, SRCFLAGS...) {
    # Generic macro definition for _SRC (just a placeholder, it does nothing)
}

USE_ARCADIA_COMPILER_RUNTIME=yes

when ($LOCAL && $XCODE) {
    USE_ARCADIA_COMPILER_RUNTIME=no
}

@import "${CONF_ROOT}/conf/settings.conf"
@import "${CONF_ROOT}/conf/opensource.conf"
@import "${CONF_ROOT}/conf/opensource_export.conf"
@import "${CONF_ROOT}/conf/sysincl.conf"
@import "${CONF_ROOT}/conf/license.conf"
@import "${CONF_ROOT}/conf/docs.conf"
@import "${CONF_ROOT}/conf/swig.conf"
@import "${CONF_ROOT}/conf/proto.conf"
@import "${CONF_ROOT}/conf/fbs.conf"
@import "${CONF_ROOT}/conf/ts/ts.conf"

@import "${CONF_ROOT}/conf/project_specific/other.conf"
@import "${CONF_ROOT}/conf/project_specific/yt.conf"

@import "${CONF_ROOT}/conf/yndexing/cpp_instrumentation.conf"

SO_OUTPUTS=no

when ($USE_PYTHON) {
    C_DEFINES+= -DUSE_PYTHON
}

_PREBUILT_TOOLS_ROOT=build/prebuilt
_TOOL_PROTOC_GEN_GO=vendor/github.com/golang/protobuf/protoc-gen-go
_TOOL_PROTOC_GEN_GO_V2=vendor/google.golang.org/protobuf/cmd/protoc-gen-go
_TOOL_PROTOC_GEN_GO_GRPC_V2=vendor/google.golang.org/grpc/cmd/protoc-gen-go-grpc
_TOOL_RESCOMPILER=tools/rescompiler
_TOOL_RESCOMPRESSOR=tools/rescompressor
_TOOL_RORESCOMPILER=tools/rorescompiler

when ($DISABLE_SEPARATE_AUX_CPP != "yes") {
    SEPARATE_AUX_CPP=yes
}

_HOST_SUPPORTS_PREBUILT_PROTOC_GEN_GO=no
_TARGET_SUPPORTS_PREBUILT_PROTOC_GEN_GO=no
when ($USE_PREBUILT_TOOLS == "yes") {
    when ($HOST_ARCH_X86_64 == "yes" && ($HOST_OS_LINUX == "yes" || $HOST_OS_WINDOWS == "yes" || $HOST_OS_DARWIN == "yes")) {
        _HOST_SUPPORTS_PREBUILT_PROTOC_GEN_GO=yes
    }
    when ($HOST_ARCH_ARM64 == "yes" && $HOST_OS_DARWIN == "yes") {
        _HOST_SUPPORTS_PREBUILT_PROTOC_GEN_GO=yes
    }

    when ($ARCH_X86_64 == "yes" && ($OS_LINUX == "yes" || $OS_WINDOWS == "yes" || $OS_DARWIN == "yes")) {
        _TARGET_SUPPORTS_PREBUILT_PROTOC_GEN_GO=yes
    }
    when ($ARCH_ARM64 == "yes" && $OS_DARWIN == "yes") {
        _TARGET_SUPPORTS_PREBUILT_PROTOC_GEN_GO=yes
    }

    when ($_HOST_SUPPORTS_PREBUILT_PROTOC_GEN_GO == "yes" && $_TARGET_SUPPORTS_PREBUILT_PROTOC_GEN_GO == "yes") {
        _TOOL_PROTOC_GEN_GO=${_PREBUILT_TOOLS_ROOT}/vendor/github.com/golang/protobuf/protoc-gen-go
    }
}

CPP_LINTERS_DEFAULT_CONFIGS=build/config/tests/cpp_style/default_configs.json

### @usage: FUNCTION_ORDERING_FILE(VAR_NAME)
###
### Select file for function reordering. Works only with lld linker.
### VAR_NAME should be the same value that was passed into DECLARE_EXTERNAL_HOST_RESOURCES_BUNDLE library.
macro FUNCTION_ORDERING_FILE(ORDERING_FILE) {
    select ($_LINKER_ID) {
        "lld" ? {
        }
        default ? {
            _OK = no
        }
    }
    ASSERT(_OK FUNCTION_ORDERING_FILE macro can be used only with `lld` linker, but you chose `$_LINKER_ID`.)
    LDFLAGS("-Wl,--symbol-ordering-file=${suf=_RESOURCE_GLOBAL/funcs.ord;pre=$:ORDERING_FILE}")
}

### @usage: SELECT_CLANG_SA_CONFIG(static_analyzer.yaml)
###
### Select config file for clang static analyzer.
### The file should be called static_analyzer.yaml.
macro SELECT_CLANG_SA_CONFIG(config) {
    SET(_CLANG_SA_CONFIG ${input:config})
}

### @usage: USE_SA_PLUGINS(FROM path/to/external/module1 NAME VAR_NAME1 FROM path/to/external/module2 NAME VAR_NAME2 ...)
###
### Select additional plugins for clang static analyzer, each path/to/external/module should declare target RESOURCES_LIBRARY.
### VAR_NAME should be the same value that was passed into DECLARE_EXTERNAL_HOST_RESOURCES_BUNDLE as first argument.
### See example in market/report/csa_checks/static_analyzer_ymake.inc
macro USE_SA_PLUGINS(FROM[], NAME[]) {
    PEERDIR($FROM)
    SET_APPEND(CLANG_SA_PLUGINS ${suf=_RESOURCE_GLOBAL/plugin.so;pre=$:NAME})
}

# Helper macro for unwrapping sequence of files
macro _CLANG_SA_UNWRAP_PLUGINS(Plugins{input}[]) {
    .CMD=${Plugins}
}

CLANG_SA_PLUGINS=
CLANG_CSA_ROOT=${CLANG_CSA16_RESOURCE_GLOBAL}
CLANG_CSA_BIN=${CLANG_CSA16_RESOURCE_GLOBAL}/bin/clang
when ($CLANG_SA_ENABLE == "yes" && $_CLANG_SA_CONFIG && $CLANG_CSA_ROOT) {
    PEERDIR+=build/platform/clang/clang-static-analyzer
    CLANG_STATIC_ANALYZER_OPTIONS_NEW=$YMAKE_PYTHON3 ${input:"build/scripts/clang_static_analyzer.py"} \
                                      "--testing-src" ${input:SRC} \
                                      "--clang-bin" $CLANG_CSA_BIN \
                                      "--source-root" $(SOURCE_ROOT) \
                                      "--config-file" ${input:_CLANG_SA_CONFIG} \
                                      "--plugins-begin" "dummy_param" $CLANG_SA_PLUGINS "--plugins-end" \
                                      $GCC_COMPILE_FLAGS $CXXFLAGS $SRCFLAGS
}
otherwise {
    CLANG_STATIC_ANALYZER_OPTIONS_NEW=
}

FAIL_MODULE_CMD=$YMAKE_PYTHON3 ${input:"build/scripts/fail_module_cmd.py"} $TARGET ${hide;kv:"p ER"} ${hide;kv:"pc red"}
FAIL_EXPR=ERROR
DEFAULT_TIDY_CONFIG=build/config/tests/clang_tidy/config.yaml
PROJECT_TIDY_CONFIG=build/config/tests/clang_tidy/config.yaml
TIDY=
TIDY_ENABLED=
when($TIDY == "yes") {
    TIDY_ENABLED=yes
}

CLANG_TIDY_BIN=${CLANG_TIDY_RESOURCE_GLOBAL}/bin/clang-tidy

# IWYU configuration
IWYU=
IWYU_ENABLED=
when($IWYU == "yes") {
    IWYU_ENABLED=yes
}
DEFAULT_IWYU_MAPPING_FILE=build/config/tests/iwyu/mapping_file.imp

IWYU_BIN=${IWYU_RESOURCE_GLOBAL}/iwyu_resource/bin/include_what_you_use

when ($TIDY_ENABLED == "yes") {
    when ($TIDY_EXPORT_FIXES=="") {
        TIDY_EXPORT_FIXES="no"
    }

    CPP_ANALYSIS_ARGS=${hide:CLANG_TIDY_FAKEID} $YMAKE_PYTHON ${input:"build/scripts/clang_tidy.py"} "--ymake-python" $YMAKE_PYTHON "--clang-tidy-bin" $CLANG_TIDY_BIN "--config-validation-script" ${input:"build/tests/config/clang_tidy/tidy_config_validation.py"} "--testing-src" ${input:SRC} "--source-root" $(SOURCE_ROOT) "--build-root" $(BUILD_ROOT) "--tidy-json" ${noauto;output;suf=${COMPILE_OUT_SUFFIX}${OBJ_CROSS_SUF}.tidyjson:SRC} "--export-fixes" $TIDY_EXPORT_FIXES
    CPP_ANALYSIS_ARGS+="--default-config-file" ${input:DEFAULT_TIDY_CONFIG}
    CPP_ANALYSIS_ARGS+="--project-config-file" ${input:PROJECT_TIDY_CONFIG}
    when ($TIDY_CHECKS) {
        CPP_ANALYSIS_ARGS+="--checks=$TIDY_CHECKS"
    }

    when ($TIDY_HEADER_FILTER) {
        CPP_ANALYSIS_ARGS+="--header-filter=$TIDY_HEADER_FILTER"
    }

    CPP_ANALYSIS_VALUE=USE_CONDITIONAL_SRCS
}
elsewhen ($IWYU_ENABLED == "yes" && $WINDOWS != "yes") {
    CPP_ANALYSIS_ARGS=${hide:IWYU_FAKEID} $YMAKE_PYTHON3 ${input:"build/scripts/iwyu.py"} "--iwyu-bin" $IWYU_BIN "--testing-src" ${input:SRC} "--source-root" $(SOURCE_ROOT) "--build-root" $(BUILD_ROOT) "--iwyu-json" ${noauto;output;suf=${COMPILE_OUT_SUFFIX}${OBJ_CROSS_SUF}.iwyujson:SRC}

    when ($IWYU_MAPPING_FILE) {
        CPP_ANALYSIS_ARGS+="--mapping_file" ${input:IWYU_MAPPING_FILE}
    }
    when ($IWYU_VERBOSE) {
        CPP_ANALYSIS_ARGS+="--verbose=$IWYU_VERBOSE"
    }
    CPP_ANALYSIS_ARGS+="--default-mapping-file" ${input:DEFAULT_IWYU_MAPPING_FILE}

    CPP_ANALYSIS_VALUE=USE_CONDITIONAL_SRCS
}
otherwise {
    CPP_ANALYSIS_ARGS=
    CPP_ANALYSIS_VALUE=
}

CPP_ANALYSIS_MODE=no
when ($IWYU_ENABLED == "yes" || $TIDY_ENABLED == "yes") {
    CPP_ANALYSIS_MODE=yes
}

# tag:profile
NEED_PROFILE_RUNTIME=no
when ($BUILD_TYPE == "PROFILE" || $BUILD_TYPE == "COVERAGE" || $GCOV_COVERAGE == "yes" || $PGO_ADD == "yes") {
    NEED_PROFILE_RUNTIME=yes
}
otherwise {
    NEED_PROFILE_RUNTIME=no
}

when ($NEED_PROFILE_RUNTIME == "yes" && $CLANG && ($TARGET_PLATFORM == "LINUX" || $TARGET_PLATFORM == "DARWIN")) {
    COPY_PROFILE_RUNTIME=\
        $YMAKE_PYTHON3 ${input:"build/scripts/copy_clang_profile_rt.py"} \
        --arch $TARGET_PLATFORM \
        --build-root $ARCADIA_BUILD_ROOT --
    COPY_PROFILE_RUNTIME+=\
        ${rootrel:PEERS} \
        $LDFLAGS
}
otherwise {
    COPY_PROFILE_RUNTIME=
}

when ($RETRY == "yes") {
    RETRY_ARGS=$YMAKE_PYTHON ${input:"build/scripts/retry_cc.py"}
}
otherwise {
    RETRY_ARGS=
}

COVERAGE_FLAGS=
EXTRA_OUTPUT=
when ($CLANG == "yes" || $GCC == "yes") {
    when ($BUILD_TYPE == "COVERAGE" || $GCOV_COVERAGE) {
        COVERAGE_FLAGS=-fprofile-arcs -ftest-coverage
        EXTRA_OUTPUT=${hide;noauto;output;suf=${COMPILE_OUT_SUFFIX}${OBJ_SUF}${_CROSS_SUFFIX}.gcno:SRC}
    }
}

when ($OS_IOS == "yes" || $OS_ANDROID == "yes") {
    USE_ASMLIB=no
}

CFLAGS+=$COVERAGE_FLAGS
LDFLAGS+=$COVERAGE_FLAGS

CHECKFLAG=
NO_MAPREDUCE=

when ($NO_MAPREDUCE ==  "yes") {
    C_DEFINES+=-DNO_MAPREDUCE
}

when ($OS_ANDROID == "yes") {
    PIE=yes
}

when ($CLANG && $OS_DARWIN && $SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
    SO_OUTPUTS=yes
}

when ($OS_NONE == "yes" || $MAPSMOBI_BUILD_TARGET == "yes" && $OS_LINUX != "yes") {
    USE_STL_SYSTEM=yes
}

# USE_INTERNAL_STL is an internal flag (set on by default) but may be used externally to
# select system standard C++ library when USE_INTERNAL_STL=no is set.
#
# USE_STL_SYSTEM=yes is a regular way to select system standard C++ library.
#
when ($USE_STL_SYSTEM == "yes") {
    USE_INTERNAL_STL=no
}

when ($USE_INTERNAL_STL == "no") {
    USE_STL_SYSTEM=yes
}
otherwise {
    USE_INTERNAL_STL=yes
    # TODO: Extract to conf/sysincl.conf
    # This trigger doesn't work for module level since SYSINCL is processed at
    # configuration stage (This means that NO_RUNTIME() macro called in ya.make
    # won't affect SYSINCL and the only way to make this trigger work correctly
    # is to define configuration variable NORUNTIME (-DNORUNTIME) on the command
    # line when `ya make ...` is invoked.
    when ($NORUNTIME != "yes") {
        SYSINCL+=build/sysincl/stl-to-libcxx.yml
        when ($MSVC == "yes" && $CLANG_CL != "yes") {
            SYSINCL+=build/sysincl/stl-to-libcxxmsvc.yml
        }
        when ($NVCC_STD_VER == "17" || $CUDA11 == "yes") {
            SYSINCL+=build/sysincl/stl-to-libcxxcuda11.yml
        }
        when ($MUSL == "yes") {
            SYSINCL+=build/sysincl/libc-musl-libcxx.yml
        }
    }
}

USE_ARCADIA_PYTHON=yes
USE_ARCADIA_LIBM=no
USE_EAT_MY_DATA=no

HAVE_MKL=
when ($HAVE_MKL == "") {
    when ($OS_LINUX && $ARCH_X86_64 && !$SANITIZER_TYPE) {
        HAVE_MKL=yes
    }
    otherwise {
        HAVE_MKL=no
    }
}

SFDL_TMP_OUT= ${output;suf=.tmp:SRC}

# tag:tool-specific
ARCH_TOOL=${tool:"tools/archiver"}

# tag:tool-specific
LUA_TOOL=${tool:"tools/lua"}
ENUM_PARSER_TOOL=${tool:"tools/enum_parser/enum_parser"}

FATAL_ERROR_MODULE=no
FATAL_ERROR_MESSAGE=

ANTLR_PYTHON=Python2

### @usage: NO_LTO()
###
### Disable any lto (link-time optimizations) for the module.
### This will compile module source files as usual (without LTO) but will not prevent lto-enabled
### linking of entire program if global settings say so.
macro NO_LTO() {
    DISABLE(USE_LTO)
    DISABLE(USE_THINLTO)
}

# tag:allocator
DEFAULT_ALLOCATOR=SYSTEM

# tag:allocator
when ($MUSL == "yes") {
    DEFAULT_ALLOCATOR=TCMALLOC_TC
}

# tag:allocator
when ($OS_ANDROID == "yes" || $OS_WINDOWS == "yes" || $ARCH_TYPE_32 == "yes") {
    DEFAULT_ALLOCATOR=J
}

# tag:allocator
when ($OS_LINUX == "yes") {
    when ($GCC) {
        # tcmalloc broken build
    }
    elsewhen ($ARCH_X86_64) {
        DEFAULT_ALLOCATOR=TCMALLOC_TC
    }
}

# tag:allocator
when ($SANITIZER_TYPE) {
    when ($SANITIZER_TYPE != "no") {
        DEFAULT_ALLOCATOR=SYSTEM
    }
}

# tag:allocator
when ($ARCH_XTENSA == "yes") {
    DEFAULT_ALLOCATOR=FAKE
}

when ($OS_EMSCRIPTEN  == "yes") {
    DEFAULT_ALLOCATOR=FAKE
}

# tag:internal
### @usage: CHECK_CONFIG_H(<conf_header>) # internal
###
### This internal macro adds checking code for configuration header in external (contrib) library.
### The check is needed to avoid conflicts on certain types and functions available in arcadia.
###
### @see https://a.yandex-team.ru/arc/trunk/arcadia/build/scripts/check_config_h.py for exact details
macro CHECK_CONFIG_H(Conf) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/check_config_h.py"} ${rootrel;input:Conf} ${hide;from_input;output_include:Conf} ${output;suf=.config.cpp;nopath;noext:Conf} ${hide;kv:"p CH"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=${hide;rootrel;input:Conf} ${hide;output;suf=.config.cpp;nopath;noext:Conf}
    .STRUCT_SEM=yes
}

REQUIRED_TRANSITIVE_PEERS=
### @usage: REQUIRES(dirs...)
###
### Specify list of dirs which this module must depend on indirectly.
###
### This macro can be used if module depends on the directories specified but they can't be listed
### as direct PEERDIR dependencies (due to public include order or link order issues).
macro REQUIRES(DIRS...) {
    SET_APPEND(REQUIRED_TRANSITIVE_PEERS $DIRS)
}

CHECK_DEPENDENT_DIRS_TYPES=
CHECK_DEPENDENT_DIRS_RESTRICTIONS=
### @usage: CHECK_DEPENDENT_DIRS(DENY|ALLOW_ONLY ([ALL|PEERDIRS|GLOB] dir)...)
###
### Specify project transitive dependencies constraints.
###
### @params:
###  1. DENY: current module can not depend on module from any specified directory neither directly nor transitively.
###  2. ALLOW_ONLY: current module can not depend on module from a dir not specified in the directory list neither directly nor transitively.
###  3. ALL: directory constraints following after this modifier are applied to both transitive PEERDIR dependencies and tool dependencies.
###  4. PEERDIRS: directory constraints following after this modifier are applied to transitive PEERDIR dependencies only.
###  5. GLOB: next directory constraint is an ANT glob pattern.
###  6. EXCEPT: next constraint is an exception for the rest of other rules.
###
### Directory constraints added before either ALL or PEERDIRS modifier is used are treated as ALL directory constraints.
###
### Note: Can be used multiple times on the same module all specified constraints will be checked.
### All macro invocation for the same module must use same constraints type (DENY or ALLOW_ONLY)
macro CHECK_DEPENDENT_DIRS(TYPE, ALL?"UNUSED":"", PEERDIRS?"PEERDIRS":"ALL", RESTRICTIONS...) {
    SET_APPEND(CHECK_DEPENDENT_DIRS_RESTRICTIONS $PEERDIRS $RESTRICTIONS)
    SET_APPEND(CHECK_DEPENDENT_DIRS_TYPES $TYPE)
}

macro _HASH_HELPER(Args...) {
    .CMD=${hash:Args}
    .SEM=${hash:Args}
}

macro _RESOURCE_SEM(INPUTS[], KEYS[], OPTS[]) {
    SET(RESOURCE_OUTPUT $_HASH_HELPER($INPUTS $KEYS $OPTS).cpp)
    .SEM=target_macroses-ITEM && target_macroses-macro resources && target_macroses-args ${global;output:RESOURCE_OUTPUT} INPUTS ${input:INPUTS} KEYS $KEYS OPTS $OPTS ${hide;tool:"tools/rescompiler/bin"}
}

# tag:built-in
### @usage: RESOURCE([FORCE_TEXT ][Src Key]* [- Key=Value]*) # builtin
### Add data (resources, random files, strings) to the program)
### The common usage is to place Src file into binary. The Key is used to access it using library/cpp/resource or library/python/resource.
### Alternative syntax with '- Key=Value' allows placing Value string as resource data into binary and make it accessible by Key.
###
### This is a simpler but less flexible option than ARCHIVE(), because in the case of ARCHIVE(), you have to use the data explicitly,
### and in the case of RESOURCE(), the data will fall through SRCS() or SRCS(GLOBAL) to binary linking.
###
### Use the FORCE_TEXT parameter to explicitly mark all Src files as text files: they will not be parsed unless used elsewhere.
###
### @example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a2ispolzujjtekomanduresource
###
### @example:
###
###     LIBRARY()
###         RESOURCE(
###             path/to/file1 /key/in/program/1
###             path/to/file2 /key2
###         )
###     END()
###
macro RESOURCE(Args...) {
    PEERDIR(library/cpp/resource)
}

# tag:sanitize
RUN_NO_SANITIZE=$YMAKE_PYTHON ${input:"build/scripts/run_tool.py"} --

# tag:sanitize
when ($IS_CROSS_SANITIZE) {
    RUN_NO_SANITIZE=
}

YIELD=$YMAKE_PYTHON ${input:"build/scripts/yield_line.py"} -- ${BINDIR}/__args
XARGS=$YMAKE_PYTHON ${input:"build/scripts/xargs.py"} -- ${BINDIR}/__args

WRITER_PY=$YMAKE_PYTHON ${input:"build/scripts/writer.py"} ${hide;input:"build/scripts/process_command_files.py"}
FS_TOOLS=$YMAKE_PYTHON3 ${input:"build/scripts/fs_tools.py"} ${hide;input:"build/scripts/process_command_files.py"}
FIX_MSVC_OUTPUT=${YMAKE_PYTHON3} ${input:"build/scripts/fix_msvc_output.py"} ${hide;input:"build/scripts/process_command_files.py"}
_PROCESS_WHOLE_ARCHIVE_SCRIPT=${hide;input:"build/scripts/process_command_files.py"} ${hide;input:"build/scripts/process_whole_archive_option.py"}

COPY_CMD=$FS_TOOLS copy
LINK_OR_COPY_CMD=$FS_TOOLS link_or_copy
REMOVE_FILE=$FS_TOOLS remove
MOVE_FILE=$FS_TOOLS rename

# tag:allocator tag:windows-specific
MSVC_DYNAMICBASE=/DYNAMICBASE
when ($ALLOCATOR == "LF") {
    MSVC_DYNAMICBASE=/DYNAMICBASE:NO
}

# tag:sanitize
SANITIZER_CFLAGS=

# variables must be defined for all module types to make generate_mf.py work
NEED_PLATFORM_PEERDIRS=yes
PEERDIR_TEST_TOOL=yes

### @usage: _BARE_UNIT  # internal
###
### The base of all modules describing default bare minimum for all modules.
### To avoid surprises, all buildable modules are better to be inherited from it or its descendants.
module _BARE_UNIT {
    .EXTS=.*
    .CMD=$TOUCH_UNIT
    .STRUCT_CMD=yes
    .IGNORED=GO_PROTO_PLUGIN
    .NODE_TYPE=Bundle
    .PEERDIR_POLICY=as_include
    .RESTRICTED=GRPC USE_SKIFF INDUCED_DEPS FUZZ_DICTS FUZZ_OPTS PACK EXPLICIT_OUTPUTS DOCS_DIR DOCS_CONFIG DOCS_VARS YT_SPEC USE_CXX USE_UTIL WHOLE_ARCHIVE PRIMARY_OUTPUT SECONDARY_OUTPUT DEPENDENCY_MANAGEMENT EXCLUDE NO_DOCTESTS EMBED_JAVA_VCS_INFO RESOURCE_FILES PACK_GLOBALS_IN_LIBRARY _EXPOSE GLOBAL_DEPS LIST_PROTO
    .FINAL_TARGET=no

    PEERDIR_TAGS=__EMPTY__ RESOURCE_LIB
    PEERDIR+=$YMAKE_PYTHON3_PEERDIR

    when ($FATAL_ERROR_MESSAGE && $FATAL_ERROR_MODULE != "yes") {
        PEERDIR+=build/conf_fatal_error
    }

    DEFAULT(MODULE_VERSION)
    DEFAULT(MODULE_PREFIX)
    DEFAULT(MODULE_SUFFIX)
}

### @usage: GEN_LIBRARY()
###
### Definition of a module that brings generated artefacts. This module can PEERDIRed
### from any module. The resulted module is empty and cleaned up during construction
### of the build graph.
###
### NOTE! SRCS macro is not supported for this library.
module GEN_LIBRARY: _BARE_UNIT {
    .PROXY=yes
    .RESTRICTED=SRCS SRC
    .SEM=_SEM_IGNORED

    # ENABLE(_FAKE_MODULE)
    SET(MODULE_TAG RESOURCE_LIB)
    SET(MODULE_SUFFIX .pkg.fake)
}

### @usage: _BASE_UNIT  # internal
###
### The base of all LIBRARY/PROGRAM modules describing common logic for all modules.
### To avoid surprises, all buildable modules are better to be inherited from it or its descendants.
module _BASE_UNIT: _BARE_UNIT {
    .GLOBAL=_FBS_NAMESPACE_MAP

    PEERDIR_TAGS=CPP_PROTO CPP_PROTO_FROM_SCHEMA CPP_FBS CPP_ROS CPP_MLAUNCH CPP_PY3_MLAUNCH H_IDL PY3 PY3_NATIVE YQL_UDF_STATIC __EMPTY__ RESOURCE_LIB DLL_LIB

    _CPP_PROTO_WRAPPER_BASE=$YMAKE_PYTHON3 ${input:"build/scripts/cpp_proto_wrapper.py"}
    _CPP_PROTO_CMDLINE_BASE=${cwd;rootdir;input:File} $PROTOC -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT/$PROTO_NAMESPACE ${pre=-I=:_PROTO__INCLUDE} -I=$ARCADIA_BUILD_ROOT -I=$PROTOBUF_INCLUDE_PATH --cpp_out=${CPP_PROTO_PLUGINS}$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE $_PROTOC_FLAGS $PROTOC_STYLEGUIDE_OUT $PROTOC_PLUGIN_STYLEGUIDE ${hide:PROTO_FAKEID} ${rootrel;input:File}
    CPP_PROTO_CMDLINE=$_CPP_PROTO_WRAPPER_BASE --outputs $CPP_PROTO_OUTS -- $_CPP_PROTO_CMDLINE_BASE
    CPP_PROTO_OUTS+=${norel;output;suf=.pb.cc;nopath;noext:File} ${main;norel;output;suf=.pb.h;nopath;noext:File}
    CPP_PROTO_OUTS_SEM+=${hide;main;norel;output;suf=.pb.h;nopath;noext:File}
    CPP_EV_CMDLINE=$_CPP_PROTO_WRAPPER_BASE --outputs $CPP_EV_OUTS -- $_CPP_PROTO_CMDLINE_BASE
    CPP_EV_OUTS+=${norel;output;suf=.pb.cc:File} ${norel;output;suf=.pb.h:File}
    CPP_EV_OUTS_SEM+=${hide;norel;output;suf=.pb.h:File}

    when ($SWIG_LANG == "perl") {
        _SWIG_CMD=$_SWIG_PERL_CMD
        _SWIG_PEERDIR=contrib/tools/swig/Lib/perl5 build/platform/perl
    }
    elsewhen ($SWIG_LANG == "python") {
        _SWIG_CMD=$_SWIG_PYTHON_CMD
        _SWIG_PEERDIR=contrib/tools/swig/Lib/python
    }
    elsewhen ($SWIG_LANG == "jni_cpp") {
        _SWIG_CMD=$_SWIG_JNI_CPP_CMD
        _SWIG_PEERDIR=contrib/tools/swig/Lib/java $_SWIG_JNI_PEERDIR
    }
    elsewhen ($SWIG_LANG == "java") {
        _SWIG_CMD=$_SWIG_JNI_CMD
        _SWIG_PEERDIR=contrib/tools/swig/Lib/java $_SWIG_JNI_PEERDIR
    }

    when ($PY_PROTOS_FOR == "yes") {
        _EVLOG_CMDLINE=$_PY_EVLOG_CMDLINE
        _PROTO_CMDLINE=$_PY_PROTO_CMDLINE
    }
    otherwise {
        _EVLOG_CMDLINE=$_CPP_EVLOG_CMDLINE
        _FBS_CMDLINE=$_CPP_FLATC_CMDLINE
        when ($BUILD_PROTO_AS_EVLOG == "yes") {
            _PROTO_CMDLINE=$_CPP_PROTO_EVLOG_CMDLINE
        }
        otherwise {
            _PROTO_CMDLINE=$_CPP_PROTO_CMDLINE
        }
        when ($USE_VANILLA_PROTOC == "yes") {
            PROTOC=${tool:"contrib/tools/protoc_std"}
            PROTOC_STYLEGUIDE_OUT=
            PROTOC_PLUGIN_STYLEGUIDE=
            PROTOBUF_INCLUDE_PATH=${ARCADIA_ROOT}/contrib/libs/protobuf_std/src
            _PROTO_CMDLINE=$_CPP_VANILLA_PROTO_CMDLINE
        }
        when ($PROTOC_TRANSITIVE_HEADERS == "no") {
            CPP_PROTO_PLUGINS=proto_h=true:${CPP_PROTO_PLUGINS}
            CPP_PROTO_OUTS+=${main;norel;output;suf=.deps.pb.h;nopath;noext:File}
            CPP_PROTO_OUTS_SEM+=${hide;main;norel;output;suf=.deps.pb.h;nopath;noext:File}
            PROTOC_EXTRA_OUTS_SEM=&& protoc_extra_outs .deps.pb.h
        }
    }

    SANITIZER_DEFINED=no

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        CFLAGS+=-fsanitize=$SANITIZER_TYPE -D${SANITIZER_TYPE}_sanitizer_enabled $SANITIZER_CFLAGS -fno-omit-frame-pointer
        LDFLAGS+=-fsanitize=$SANITIZER_TYPE
        SANITIZER_DEFINED=yes

        when ($CLANG) {
            CFLAGS+=-fsanitize-blacklist=${input:"build/sanitize-blacklist.txt"} -fno-sanitize-link-runtime
            LDFLAGS+=-fsanitize-blacklist=${input:"build/sanitize-blacklist.txt"} -fno-sanitize-link-runtime
        }
    }

    when ($SANITIZER_TYPE && $SANITIZER_TYPE == "memory") {
        CFLAGS+=-fno-sanitize-memory-use-after-dtor -Wno-unused-command-line-argument
    }

    when ($SANITIZE_COVERAGE && $SANITIZE_COVERAGE != "no") {
        CFLAGS+=-fsanitize-coverage=$SANITIZE_COVERAGE
        LDFLAGS+=-fsanitize-coverage=$SANITIZE_COVERAGE
    }

    POPULATE_CPP_COVERAGE_FLAGS()

    when ($NLG_COVERAGE && $NLG_COVERAGE != "no") {
        CFLAGS+=-DNLG_COVERAGE
    }

    when ($GCC) {
        select ($SANITIZER_TYPE) {
            "address" ? {
                LDFLAGS+=-static-libasan
            }
            "undefined" ? {
                LDFLAGS+=-static-libubsan
            }
            "thread" ? {
                PIE=yes
                LDFLAGS+=-static-libtsan
            }
        }
    }

    when ($HARDENING == "yes") {
        when ($CLANG) {
            CFLAGS+=-fstack-protector-all -D_hardening_enabled_
            LDFLAGS+=-z relro -z now -z noexecstack
            PIE=yes
        }
    }

    when ($USE_LTO == "yes") {
        when ($GCC) {
            CFLAGS+=-flto -fno-fat-lto-objects
            LDFLAGS+=-flto
            NO_LTO_CFLAGS=-fno-lto
        }
        when ($CLANG) {
            CFLAGS+=-flto
            LDFLAGS+=-flto
            NO_LTO_CFLAGS=-fno-lto
        }
    }

    when ($USE_THINLTO == "yes") {
        when ($GCC) {
            CFLAGS+=-flto=thin
            LDFLAGS+=-flto=thin
            NO_LTO_CFLAGS=-fno-lto
        }
        when ($CLANG) {
            CFLAGS+=-flto=thin
            LDFLAGS+=-flto=thin
            NO_LTO_CFLAGS=-fno-lto
        }
    }


    when ($CLANG) {
        when ($PGO_ADD == "yes") {
            CFLAGS+=-fprofile-instr-generate
            NO_PGO_CFLAGS=$_DISABLE_CLANG_COVERAGE_CFLAGS
            LDFLAGS+=-fprofile-instr-generate
        }
        when ($PGO_PATH) {
            CFLAGS+=-fprofile-instr-use=$PGO_PATH -Wno-profile-instr-unprofiled -Wno-profile-instr-out-of-date
            NO_PGO_CFLAGS=-fno-profile-instr-use
            LDFLAGS+=-fprofile-instr-use=$PGO_PATH
        }
    }

    when ($COMPILER_PLATFORM && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=$COMPILER_PLATFORM
    }

    when ($OS_LINUX && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=contrib/libs/linux-headers
    }

    when ($NORUNTIME != "yes") {
        PEERDIR+=contrib/libs/cxxsupp
        when ($MAPSMOBI_BUILD_TARGET == "yes") {
            PEERDIR+=build/platform/mapkit
        }
    }

    when ($NOUTIL != "yes") {
        PEERDIR+=util
    }

    when ($MUSL == "yes") {
        CFLAGS += -D_musl_
        PEERDIR+=contrib/libs/musl/include
    }

    when ($OS_EMSCRIPTEN == "yes") {
        when ($NOLIBC != "yes") {
            PEERDIR+=contrib/restricted/emscripten/include
            # Important: In arcadia we usually build standalone WASM applications,
            # so standalone library must go before lib/c in linker command-line.
            # Emscripten uses two weak definitions for __clock_gettime function,
            # so linker will pick one from the first library present in command
            # line.
            PEERDIR+=contrib/restricted/emscripten/system/lib/standalonewasm
            PEERDIR+=contrib/restricted/emscripten/system/lib/stubs
            PEERDIR+=contrib/restricted/emscripten/system/lib/c
            PEERDIR+=contrib/restricted/emscripten/system/lib/dlmalloc
        }
    }

    # g++ has proxy C-headers which are incompatible with libc++ proxy C-headers.
    # The same problem exists for clang toolchain. On the other hand, the problem
    # doesn't affect cl since it has united C/C++ library and doesn't need
    # proxy C-headers.
    # Disable all C++ headers including proxy C-headers when we use libc++.
    when ($USE_INTERNAL_STL == "yes" && $MSVC != "yes") {
        CXXFLAGS += -nostdinc++
    }
    otherwise {
        CFLAGS += -DUSE_STL_SYSTEM
    }

    when ($CODENAVIGATION && $NOCODENAVIGATION != "yes") {
        PEERDIR += build/external_resources/codenavigation
    }

    when ($CYTHON_COVERAGE && $CYTHON_COVERAGE == "yes") {
        CFLAGS+=-DCYTHON_TRACE=1 -DCYTHON_TRACE_NOGIL=1
    }

    DEFAULT(USE_SSE4 yes)

    when ($NOSSE != "yes") {
       CFLAGS+=$SSE_CFLAGS
       when ($USE_SSE4 == "yes") {
           CFLAGS+=$SSE4_CFLAGS
       }
    }
    elsewhen ($MSVC != "yes") {
        CFLAGS += -mno-sse
    }

    POPULATE_CPP_COVERAGE_FLAGS()
    _REGISTER_NO_CHECK_IMPORTS()

    DEFAULT(PACKAGE_PREFIX_ARGS)

    DEFAULT(SWIG_LANG python)
    DEFAULT(GP_FLAGS -CtTLANSI-C -Dk* -c)

    when ($NEED_LLVM_TOOLS_PEERDIR && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=build/platform/clang
        LLVM_TOOLS_ROOT=$CLANG18_RESOURCE_GLOBAL
    }

    when ($TIDY_ENABLED == "yes") {
        PEERDIR+=build/platform/clang/clang-tidy
    }
    when ($IWYU_ENABLED == "yes") {
        PEERDIR+=build/platform/clang/iwyu
    }

    ENABLE(USE_YASM_ASSEMBLER)
    ENABLE(_BISON_FLEX_SET_DEFAULTS)

    POPULATE_CPP_YNDEXING()
}

_LINKER_ID=
# GCC does not support -fuse-ld with an executable path,
# only -fuse-ld=gold or -fuse-ld=lld.
when ($_LINKER_ID != "" && $_DEFAULT_LINKER_ID != "" && $CLANG == "yes" && $NEED_PLATFORM_PEERDIRS == "yes") {
    when ($_LINKER_ID in [ "gold", "lld", "mold" ]) {
        PEERDIR+=build/platform/${_LINKER_ID}
    }
}

macro _USE_LINKER_IMPL(LINKER_ID...) {
    SET(_LINKER_ID $LINKER_ID)
}

macro _USE_LINKER() {
    _USE_LINKER_IMPL($_DEFAULT_LINKER_ID)
}

### @usage: USE_LINKER_GOLD()
### Use gold linker for a program. This doesn't work in libraries
macro USE_LINKER_GOLD() {
    _USE_LINKER_IMPL(gold)
}

COMMON_LINK_SETTINGS=
_LINKER_CREF_SECTION=
_LINKER_MAP_SECTION=

LINK_ADDITIONAL_SECTIONS=$_LINKER_CREF_SECTION $_LINKER_MAP_SECTION
LINK_ADDITIONAL_SECTIONS_COMMAND=$IF(${not;empty:LINK_ADDITIONAL_SECTIONS} THEN $OBJCOPY_TOOL $LINK_ADDITIONAL_SECTIONS $TARGET)

when ($COMMON_LINK_SETTINGS == "yes") {
    when ($_LINKER_ID == "lld" && ($OS_LINUX == "yes" || $OS_ANDROID == "yes")) {
         LDFLAGS += -Wl,--gdb-index
    }

    when ($EMBED_LINKER_CREF == "yes") {
        LDFLAGS+=-Wl,--cref ${stdout;tmp;pre=$BINDIR/$MODULE_PREFIX;suf=.ldcref:REALPRJNAME} -Wl,--no-demangle
        _LINKER_CREF_SECTION=--add-section=.ya.linker_cref=${pre=$BINDIR/$MODULE_PREFIX;suf=.ldcref:REALPRJNAME}
    }
    elsewhen ($DUMP_LINKER_CREF == "yes") {
        LDFLAGS+=-Wl,--cref ${stdout;output;pre=$MODULE_PREFIX;suf=.ldcref:REALPRJNAME} -Wl,--no-demangle
    }

    when ($EMBED_LINKER_MAP == "yes") {
        LDFLAGS+=-Wl,-Map=${pre=$BINDIR/$MODULE_PREFIX;suf=.map.$_LINKER_ID:REALPRJNAME}
        _LINKER_MAP_SECTION=--add-section=.ya.linker_map.${_LINKER_ID}=${pre=$BINDIR/$MODULE_PREFIX;suf=.map.$_LINKER_ID:REALPRJNAME}
    }
    elsewhen ($DUMP_LINKER_MAP == "yes") {
        LDFLAGS+=-Wl,-Map=${rootrel;output;pre=$MODULE_PREFIX;suf=.map.$_LINKER_ID:REALPRJNAME}
    }

    when ($USE_MKL == "yes") {
        NOPLATFORM=yes
    }

    when ($AUTOCHECK == "yes" && $OS_LINUX == "yes") {
        PEERDIR+=contrib/libs/libeatmydata
        # We can not use LICENSE_RESTRICTION_EXCEPTIONS() macro inside a trigger.
        # Duplicate its implementation here
        MODULE_LICENSES_RESTRICTION_EXCEPTIONS+=contrib/libs/libeatmydata
    }

    when ($OS_EMSCRIPTEN == "yes") {
        # Do nothing.
    }
    otherwise {
        when ($USE_ARCADIA_LIBM == "yes") {
            PEERDIR+=contrib/libs/libm
        }
        when ($USE_ARCADIA_LIBM == "no") {
            C_SYSTEM_LIBRARIES+=-lm
        }
    }

    when (($MUSL != "yes" && $WITH_VALGRIND == "yes") || $SANITIZER_DEFINED == "yes") {
        when ($ALLOCATOR in [ "TCMALLOC", "TCMALLOC_SMALL_BUT_SLOW", "TCMALLOC_NUMA_256K", "TCMALLOC_NUMA_LARGE_PAGES", "TCMALLOC_256K", "TCMALLOC_TC", "GOOGLE", "J", "LF", "LF_YT", "LF_DBG", "B", "BM", "C", "LOCKLESS", "YT", "MIM", "MIM_SDC", "HU", "PROFILED_HU", "THREAD_PROFILED_HU" ]) {
            PEERDIR+=library/cpp/malloc/system
        }
    }
    otherwise {
        select ($ALLOCATOR) {
            "MIM" ? {
                PEERDIR+=library/cpp/malloc/mimalloc
            }
            "MIM_SDC" ? {
                PEERDIR+=library/cpp/malloc/mimalloc_sdc
            }
            "HU" ? {
                PEERDIR+=library/cpp/malloc/hu
            }
            "PROFILED_HU" ? {
                PEERDIR+=library/cpp/malloc/profiled_hu
            }
            "THREAD_PROFILED_HU" ? {
                PEERDIR+=library/cpp/malloc/thread_profiled_hu
            }
            "TCMALLOC_256K" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc
            }
            "TCMALLOC_SMALL_BUT_SLOW" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/small_but_slow
            }
            "TCMALLOC_NUMA_256K" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/numa_256k
            }
            "TCMALLOC_NUMA_LARGE_PAGES" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/numa_large_pages
            }
            "TCMALLOC" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/default
            }
            "TCMALLOC_TC" ? {
                PEERDIR+=library/cpp/malloc/tcmalloc
                PEERDIR+=contrib/libs/tcmalloc/no_percpu_cache
            }
            "GOOGLE" ? {
                PEERDIR+=library/cpp/malloc/galloc
            }
            "J" ? {
                when ($WIN32 == "yes") {
                    PEERDIR+=library/cpp/malloc/system
                }
                otherwise {
                    PEERDIR+=library/cpp/malloc/jemalloc
                }
            }
            "LF" ? {
                PEERDIR+=library/cpp/lfalloc
            }
            "LF_YT" ? {
                PEERDIR+=library/cpp/lfalloc/yt
            }
            "LF_DBG" ? {
                PEERDIR+=library/cpp/lfalloc/dbg
            }
            "B" ? {
                PEERDIR+=library/cpp/balloc
            }
            "BM" ? {
                PEERDIR+=library/cpp/balloc_market
            }
            "C" ? {
                PEERDIR+=library/cpp/malloc/calloc
            }
            "LOCKLESS" ? {
                PEERDIR+=library/cpp/malloc/lockless
            }
            "YT" ? {
                PEERDIR+=library/cpp/ytalloc/impl
            }
        }
    }

    when ($ALLOCATOR == "SYSTEM") {
        PEERDIR+=library/cpp/malloc/system
    }

    when ($ICC == "yes") {
        PEERDIR+=contrib/libs/intel/core
    }
    when ($WITH_VALGRIND == "yes") {
        PEERDIR+=contrib/libs/valgrind
        # https://st.yandex-team.ru/DTCC-122
        CFLAGS+=-fdebug-default-version=4
    }
}

_SO_EXT_FILTER=${ext=.so:PEERS} ${hide;late_out;ext=.so;pre=$BINDIR/;nopath;tags_cut:PEERS}
when ($OS_WINDOWS == "yes") {
    _SO_EXT_FILTER=${ext=.dll:PEERS} ${hide;late_out;ext=.dll;pre=$BINDIR/;nopath;tags_cut:PEERS}
}
elsewhen ($OS_DARWIN == "yes" || $OS_IOS == "yes") {
    _SO_EXT_FILTER=${ext=.dylib:PEERS} ${hide;late_out;ext=.dylib;pre=$BINDIR/;nopath;tags_cut:PEERS}
}

LINK_OR_COPY_SO_CMD=
RPATH_GLOBAL=
when ($SO_OUTPUTS == "yes") {
    LINK_OR_COPY_SO_CMD=$FS_TOOLS link_or_copy_to_dir --no-check $_SO_EXT_FILTER ${BINDIR}
    LDFLAGS+=$RPATH_GLOBAL
}

# tag:restricted tag:DLL
### @usage: WITH_DYNAMIC_LIBS() # restricted
###
### Include dynamic libraries as extra PROGRAM/DLL outputs
macro WITH_DYNAMIC_LIBS() {
    ENABLE(SO_OUTPUTS)
}

# tag:internal
### @usage: REAL_LINK_EXE_IMPL(peers...) # internal
macro REAL_LINK_EXE_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$REAL_LINK_EXE_CMDLINE && $LINK_OR_COPY_SO_CMD
}

# tag:internal
### @usage: REAL_LINK_EXEC_DYN_LIB_IMPL(peers...) # internal
macro REAL_LINK_EXEC_DYN_LIB_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$REAL_LINK_EXEC_DYN_LIB_CMDLINE
}

# tag:internal
### @usage: REAL_LINK_DYN_LIB_IMPL(peers...) # internal
macro REAL_LINK_DYN_LIB_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$REAL_LINK_DYN_LIB_CMDLINE && $LINK_OR_COPY_SO_CMD
}

# tag:internal
### @usage: LINK_EXE_IMPL(peers...) # internal
macro LINK_EXE_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$LINK_EXE_CMDLINE && $LINK_OR_COPY_SO_CMD
}

# tag:internal
### @usage: LINK_EXEC_DYN_LIB_IMPL(peers...) # internal
macro LINK_EXEC_DYN_LIB_IMPL(WHOLE_ARCHIVE_PEERS...) {
    .CMD=$LINK_EXEC_DYN_LIB_CMDLINE
}

# tag:internal
### @usage: _LINK_UNIT  # internal
###
### The base of all linkable modules: programs, DLLs etc. Describes common linking logic.
module _LINK_UNIT: _BASE_UNIT {
    .EXTS=.o .obj .supp .sbom .tidyjson .ld .a .lib .pyplugin .iwyujson
    .CMD=$LINK_EXE
    .STRUCT_CMD=yes
    .ALLOWED=EXTRALIBS OBJADDE_GLOBAL RESOURCE_FILES
    .NODE_TYPE=Program
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes
    .DEFAULT_NAME_GENERATOR=DirName
    .ARGS_PARSER=Base

    DEFAULT(ALLOCATOR $DEFAULT_ALLOCATOR)
    _USE_LINKER()

    #link with libunwind manually
    when ($DARWIN == "yes" && $NOPLATFORM != "yes") {
        PEERDIR += contrib/libs/cxxsupp
    }

    when ($NEED_PROFILE_RUNTIME == "yes" && $CLANG && ($TARGET_PLATFORM == "LINUX" || $TARGET_PLATFORM == "DARWIN")) {
        LDFLAGS+=-resource-dir=contrib/libs/clang-rt
        PEERDIR+=contrib/libs/clang${COMPILER_VERSION}-rt/lib/profile
    }

    when ($USE_DYNAMIC_CUDA == "yes") {
        LINK_DYN_LIB_FLAGS += --dynamic-cuda
        LINK_SCRIPT_EXE_FLAGS += --dynamic-cuda
    }

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        PEERDIR += library/cpp/sanitizer/plugin
    }

    when ($USE_DYNAMIC_CUDA != "yes") {
        LINK_DYN_LIB_FLAGS+=--objcopy-exe $OBJCOPY_TOOL
        LINK_SCRIPT_EXE_FLAGS+=--objcopy-exe $OBJCOPY_TOOL
    }

    LINK_SCRIPT_EXE_FLAGS += ${pre=--exclude-libs :_LINK_EXCLUDE_LIBRARIES_GLOBAL}

    when ($OPENSOURCE == "yes" && $AUTOCHECK == "yes") {
        # FIXME: Replace AUTOCHECK == yes with _not a host platform_ check after YMAKE-218
        MODULE_LICENSES_RESTRICTION_TYPES = ALLOW_ONLY
        MODULE_LICENSES_RESTRICTIONS = SERVICE REQUIRE_CITATION REQUIRE_MODIFICATIONS_DISCLOSURE
    }
    when ($OS_IOS == "yes" || $OS_ANDROID == "yes" || $MAPSMOBI_BUILD_TARGET == "yes") {
        MODULE_LICENSES_RESTRICTION_TYPES = ALLOW_ONLY
        MODULE_LICENSES_RESTRICTIONS = SERVICE REQUIRE_CITATION
    }
    ENABLE(COMMON_LINK_SETTINGS)
    CHECK_PROVIDES()

    ADD_CLANG_TIDY()
    when ($TIDY_ENABLED == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.tidyjson
        _MAKEFILE_INCLUDE_LIKE_DEPS+=${ARCADIA_ROOT}/build/yandex_specific/config/clang_tidy/tidy_project_map.json
        _MAKEFILE_INCLUDE_LIKE_DEPS+=${ARCADIA_ROOT}/build/yandex_specific/config/clang_tidy/tidy_default_map.json
    }
    ADD_IWYU()
    when ($IWYU_ENABLED == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.iwyujson
    }
}

MODULE_TYPE=UNKNOWN

macro ADD_CLANG_TIDY() {
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME$MODULE_SUFFIX clang_tidy)
}

macro ADD_IWYU() {
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME$MODULE_SUFFIX iwyu)
}

# tag:internal
### @usage: _BASE_PROGRAM  # internal
###
### The base of all programs. It adds dependencies to make final artefact complete and runnable.
module _BASE_PROGRAM: _LINK_UNIT {
    .SYMLINK_POLICY=EXE
    .ALLOWED=INDUCED_DEPS WHOLE_ARCHIVE
    .GLOBAL=LDFLAGS _WHOLE_ARCHIVE_LIBS_VALUE RPATH OBJADDE_LIB _LINK_EXCLUDE_LIBRARIES
    SET(MODULE_TYPE PROGRAM)
    .TRANSITION=nopic
    SET(MODULE_LANG CPP)

    when ($COVERAGE_FILTER_PROGRAMS != "yes") {
        FORCE_COVERAGE_ENABLED=yes
    }

    when ($OS_EMSCRIPTEN  == "yes") {
        # For WASM platforms at present we just check that code compiles successfully,
        # these entries need to suppress linker errors.
        LDFLAGS += -Wl,--no-entry
        LDFLAGS += -Wl,--import-undefined
    }
    when ($OS_IOS == "yes") {
        EXTS+=.ios.interface
    }

    when ($WIN32 == "yes") {
        MODULE_SUFFIX=.exe
    }

    when ($MSVC != "yes" && $NOPLATFORM != "yes" && $WITH_VALGRIND != "yes" && $USE_ASMLIB != "no" && $MIC_ARCH != "yes" && $PIC != "yes" && $PIE != "yes") {
        when ($OS_LINUX == "yes" && $ARCH_X86_64 == "yes" && $MUSL != "yes" && $SANITIZER_DEFINED != "yes") {
            PEERDIR+=contrib/libs/glibcasm
        }
        otherwise {
            PEERDIR+=contrib/libs/asmlib
        }
    }

    when ($MUSL == "yes") {
        when ($MUSL_LITE == "yes") {
            PEERDIR += contrib/libs/musl
        }
        otherwise {
            PEERDIR += contrib/libs/musl/full
        }
    }

    DEFAULT(CPU_CHECK yes)
    when ($USE_SSE4 != "yes" || $NOUTIL == "yes" || $ALLOCATOR == "FAKE") {
        CPU_CHECK = no
    }

    when ($CPU_CHECK == "yes") {
        PEERDIR += library/cpp/cpuid_check
    }

    when ($USE_ARC_PROFILE == "yes" && $NOUTIL != "yes") {
        PEERDIR += library/cpp/execprofile/autostart
    }

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        when ($CLANG) {
            select ($TARGET_PLATFORM) {
                "LINUX" ? {
                    PEERDIR += library/cpp/sanitizer/${SANITIZER_TYPE}/static
                }
                "DARWIN" ? {
                    # Memory sanitizer is not supported for darwin platform.
                    # https://clang.llvm.org/docs/MemorySanitizer.html#supported-platforms
                    when ($SANITIZER_TYPE != "memory") {
                        PEERDIR += library/cpp/sanitizer/${SANITIZER_TYPE}/dynamic
                    }
                }
                default ? {
                    FATAL_ERROR_MESSAGE+=Unsupported platform for sanitizer
                }
            }
        }
    }

    when ($_CUSTOM_LINK_STEP_SCRIPT) {
        LINK_SCRIPT_EXE_FLAGS+=--python=$YMAKE_PYTHON --custom-step=${input:_CUSTOM_LINK_STEP_SCRIPT}
    }
}

_VCS_INFO_SEM=target_macroses-ITEM && target_macroses-macro vcs_info && target_macroses-args ${hide;input:"build/scripts/vcs_info.py"} ${hide;input:"build/scripts/c_templates/svn_interface.c"} ${hide;input:"build/scripts/c_templates/svnversion.h"}
_CPP_PROGRAM_SEM=add_executable $MODDIR $CMAKE_TARGET_NAME ${hide:TARGET} ${hide:AUTO_INPUT} $CMAKE_TARGET_ARTEFACT_RENAME_RULES \
                && ${_VCS_INFO_SEM} \
                && target_options-privates-ITEM && target_options-privates-option target_link_options && target_options-privates-args $LDFLAGS_GLOBAL_RAW $LDFLAGS $OBJADDE_LIB $OBJADDE_LIB_GLOBAL $OBJADDE \
                && target_options-privates-ITEM && target_options-privates-option target_include_directories && target_options-privates-args $_C__INCLUDE_OWNED \
                && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
                && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW \
                && target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${MODULE_EXPLICIT_HEADERS}
### @usage: PROGRAM([progname])
###
### Regular program module.
### If name is not specified it will be generated from the name of the containing project directory.
module PROGRAM: _BASE_PROGRAM {
    .SEM=_CPP_PROGRAM_SEM
    .ALIASES=EXTRALIBS=PY_EXTRALIBS

    ADD_YTEST($MODULE_PREFIX$REALPRJNAME coverage.extractor)

    _DONT_REQUIRE_LICENSE()
    WITHOUT_VERSION()
}

### @usage: EXPORTS_SCRIPT(exports_file)
###
### Specify exports script within PROGRAM, DLL and DLL-derived modules.
### This accepts 2 kind of files: .exports with <lang symbol> pairs and JSON-line .symlist files.
### The other option use EXPORTS parameter of the DLL module itself.
###
### @see: [DLL](#module_DLL)
macro EXPORTS_SCRIPT(Arg) {
    SET(EXPORTS_FILE $Arg)
}

macro JNI_EXPORTS() {
    EXPORTS_SCRIPT(${ARCADIA_ROOT}/build/essentials/jni_exports.exports)
}

### @usage: NO_EXPORT_DYNAMIC_SYMBOLS()
###
### Disable exporting all non-hidden symbols as dynamic when linking a PROGRAM.
macro NO_EXPORT_DYNAMIC_SYMBOLS() {
    ENABLE(NO_EXPORT_DYNAMIC_SYMBOLS)
}

### @usage: EXPORT_ALL_DYNAMIC_SYMBOLS()
###
### Export all non-hidden symbols as dynamic when linking a PROGRAM.
macro EXPORT_ALL_DYNAMIC_SYMBOLS() {
    # Dummy: default behaviour
    ENABLE(EXPORT_ALL_DYNAMIC_SYMBOLS)
}

### @usage: USE_DYNAMIC_CUDA()
###
### Enable linking of PROGRAM with dynamic CUDA. By default CUDA uses static linking
macro USE_DYNAMIC_CUDA() {
    LDFLAGS(-Wl,-rpath,${"$"}ORIGIN)
    ENABLE(USE_DYNAMIC_CUDA)
}

### @usage: CUSTOM_LINK_STEP_SCRIPT(name)
###
### Specifies name of a script for custom link step. The scripts
### should be placed in the build/scripts directory and are subject to
### review by devtools@.
macro CUSTOM_LINK_STEP_SCRIPT(Name) {
    SET(_CUSTOM_LINK_STEP_SCRIPT build/scripts/$Name)
}

### @usage: _BASE_UNITTEST  # internal
###
### Module with base logic for all unit-test modules: it makes code runnable as unit-test by Arcadia testing machinery.
module _BASE_UNITTEST: _BASE_PROGRAM {
    .FINAL_TARGET=no
    .NODE_TYPE=Program
    .ALLOWED=YT_SPEC
    .DEFAULT_NAME_GENERATOR=FullPath
    when ($UT_SKIP_EXCEPTIONS == "yes") {
        C_DEFINES+=-DUT_SKIP_EXCEPTIONS
    }
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
    # Assume that no code may depend on unit test output and thus
    # do not mandate license markup in such modules.
    _DONT_REQUIRE_LICENSE()
    WITHOUT_VERSION()
}

_TEST_SPLIT_FACTOR_SEM=1
_TEST_TIMEOUT_SEM=
_TEST_PARTITION_SEM=
_UNITTEST_SEM=$_CPP_PROGRAM_SEM \
    && target_commands-ITEM && target_commands-macro set_property && target_commands-args TARGET $REALPRJNAME PROPERTY SPLIT_FACTOR $_TEST_SPLIT_FACTOR_SEM \
    $_TEST_PARTITION_SEM \
    && target_commands-ITEM && target_commands-macro add_yunittest && target_commands-args NAME $REALPRJNAME TEST_TARGET $REALPRJNAME TEST_ARG --print-before-suite --print-before-test --fork-tests --print-times --show-fails \
    && target_commands-ITEM && target_commands-macro set_yunittest_property && target_commands-args TEST $REALPRJNAME PROPERTY LABELS $TEST_SIZE_NAME $FILTER_ONLY_TEST_TAGS \
    && add_ytest_requirements $REALPRJNAME $DEFAULT_REQUIREMENTS $TEST_REQUIREMENTS_VALUE \
    && target_commands-ITEM && target_commands-macro set_yunittest_property && target_commands-args TEST $REALPRJNAME PROPERTY ENVIRONMENT && target_commands-args_escaped $TEST_ENV_VALUE \
    $_TEST_TIMEOUT_SEM

# tag:test
### @usage: UNITTEST([name])
###
### Unit test module based on library/cpp/testing/unittest.
### It is recommended not to specify the name.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#opisanievya.make1
module UNITTEST: _BASE_UNITTEST {
    .SEM=_UNITTEST_SEM
    .ARGS_PARSER=Base
    PEERDIR(library/cpp/testing/unittest_main)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME unittest.py)

    when ($TEST_FORK_MODE != "none") {
        when ($TEST_SPLIT_FACTOR) {
            _TEST_SPLIT_FACTOR_SEM=$TEST_SPLIT_FACTOR
        }
        otherwise {
            _TEST_SPLIT_FACTOR_SEM=10
        }
        when ($TEST_PARTITION == "MODULO") {
            _TEST_PARTITION_SEM=&& target_commands-ITEM && target_commands-macro set_property && target_commands-args TARGET $REALPRJNAME PROPERTY SPLIT_TYPE $TEST_PARTITION
        }
    }
    when ($TEST_TIMEOUT) {
        _TEST_TIMEOUT_SEM=&& target_commands-ITEM && target_commands-macro set_yunittest_property && target_commands-args TEST $REALPRJNAME PROPERTY TIMEOUT $TEST_TIMEOUT
    }
}

# tag:yt-specific tag:test
### @usage: YT_UNITTEST([name])
###
### YT Unit test module based on library/cpp/testing/unittest with NYT::Initialize hook
module YT_UNITTEST: _BASE_UNITTEST {
    .SEM=_UNITTEST_SEM
    PEERDIR(library/cpp/testing/unittest_main yt/cpp/mapreduce/tests/yt_initialize_hook)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME unittest.py)
}

# tag:test
### @usage: UNITTEST_WITH_CUSTOM_ENTRY_POINT([name])
###
### Generic unit test module.
module UNITTEST_WITH_CUSTOM_ENTRY_POINT: _BASE_UNITTEST {
    .SEM=_UNITTEST_SEM
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME unittest.py)
}

_GTEST_SEM=$_CPP_PROGRAM_SEM \
    && target_commands-ITEM && target_commands-macro add_test && target_commands-args NAME $REALPRJNAME COMMAND $REALPRJNAME \
    && target_commands-ITEM && target_commands-macro set_property && target_commands-args TEST $REALPRJNAME PROPERTY LABELS $TEST_SIZE_NAME $FILTER_ONLY_TEST_TAGS \
    && add_test_requirements $REALPRJNAME $DEFAULT_REQUIREMENTS $TEST_REQUIREMENTS_VALUE \
    && target_commands-ITEM && target_commands-macro set_property && target_commands-args TEST $REALPRJNAME PROPERTY ENVIRONMENT && target_commands-args_escaped $TEST_ENV_VALUE \
    $_TEST_TIMEOUT_SEM

# tag:cpp-specific tag:test
### @usage: GTEST([name])
###
### Unit test module based on library/cpp/testing/gtest.
### It is recommended not to specify the name.
###
### Documentation: https://docs.yandex-team.ru/arcadia-cpp/docs/build/manual/tests/cpp#gtest
module GTEST: _BASE_UNITTEST {
    .SEM=_GTEST_SEM
    .DEFAULT_NAME_GENERATOR=FullPath
    .ARGS_PARSER=Base
    PEERDIR(library/cpp/testing/gtest library/cpp/testing/gtest_main)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME gunittest)

    when ($TEST_TIMEOUT) {
        _TEST_TIMEOUT_SEM=&& target_commands-ITEM && target_commands-macro set_property && target_commands-args TEST $REALPRJNAME PROPERTY TIMEOUT $TEST_TIMEOUT
    }
}

USE_AFL=no

# tag:fuzzing
### @usage: FUZZ()
###
### In order to start using Fuzzing in Arcadia, you need to create a FUZZ module with the implementation of the function LLVMFuzzerTestOneInput().
### This module should be reachable by RECURSE from /autocheck project in order for the corpus to be regularly updated.
### AFL and Libfuzzer are supported in Arcadia via a single interface, but the automatic fuzzing still works only through Libfuzzer.
###
### Example: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/re2/re2/fuzzing/re2_fuzzer.cc?rev=2919463#L58
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
module FUZZ: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .ALLOWED=FUZZ_DICTS FUZZ_OPTS

    SET(LIBFUZZER_PATH contrib/libs/libfuzzer)
    when ($USE_AFL == "no") {
        PEERDIR+=$LIBFUZZER_PATH
    }
    when ($USE_AFL == "yes") {
        PEERDIR+=$LIBFUZZER_PATH/afl
    }

    when (!$SANITIZER_TYPE || $SANITIZER_TYPE == "no") {
        PEERDIR+=library/cpp/testing/nofuzz
    }

    ADD_YTEST($MODULE_PREFIX$REALPRJNAME fuzz.test)
}

# tag:ios-specific
PACK_IOS_CMD=
when ($OS_IOS && $BUILD_IOS_APP) {
    PACK_IOS_CMD=$YMAKE_PYTHON ${input:"build/scripts/pack_ios.py"} --binary $TARGET --target $TARGET --temp-dir $BINDIR $PEERS
}

LINK_BOOSTTEST_CMD=
BOOST_TEST_TYPE_STRING=

when ($BOOSTTEST_IS_FAT_OBJECT) {
    LINK_BOOSTTEST_CMD=$LINK_RECURSIVE_LIBRARY
    BOOST_TEST_TYPE_STRING=no.test
}
otherwise {
    LINK_BOOSTTEST_CMD=$LINK_EXE
    BOOST_TEST_TYPE_STRING=boost.test
}

# tag:deprecated
### @usage: BOOSTTEST([name]) #deprecated
###
### Test module based on boost/test/unit_test.hpp.
### As with entire boost library usage of this technology is deprecated in Arcadia and restricted with configuration error in most of projects.
### No new module of this type should be introduced unless it is explicitly approved by C++ committee.
module BOOSTTEST: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .CMD=$LINK_BOOSTTEST_CMD
    PEERDIR(library/cpp/testing/boost_test)
    when ($BOOSTTEST_IS_FAT_OBJECT) {
        MODULE_SUFFIX=.a
    }
    elsewhen ($OS_IOS && $BUILD_IOS_APP) {
        PEERDIR+=devtools/boosttest_ios_wrapper/library
        MODULE_SUFFIX=.ios.tar
    }
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME $BOOST_TEST_TYPE_STRING)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
    _DONT_REQUIRE_LICENSE()
    WITHOUT_VERSION()
}

# tag:deprecated
### @usage: BOOSTTEST_WITH_MAIN([name]) #deprecated
###
### Same as BOOSTTEST (see above), but comes with builtin int main(argc, argv) implementation
module BOOSTTEST_WITH_MAIN: BOOSTTEST {
    PEERDIR(library/cpp/testing/boost_test_main)
}

FUZZ_DICTS_VALUE=
### @usage: FUZZ_DICTS(path1 [path2...])
###
### Allows you to specify dictionaries, relative to the root of Arcadia, which will be used in Fuzzing.
### Libfuzzer and AFL use a single syntax for dictionary descriptions.
### Should only be used in FUZZ modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
macro FUZZ_DICTS(Data...) {
    SET_APPEND(FUZZ_DICTS_VALUE $Data)
}

FUZZ_OPTS_VALUE=
### @usage: FUZZ_OPTS(opt1 [Opt2...])
###
### Overrides or adds options to the corpus mining and fuzzer run.
### Currently supported only Libfuzzer, so you should use the options for it.
### Should only be used in FUZZ modules.
###
### @example:
###
###     FUZZ_OPTS (
###         -max_len=1024
###         -rss_limit_mb=8192
###     )
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
macro FUZZ_OPTS(Data...) {
    SET_APPEND(FUZZ_OPTS_VALUE $Data)
}

# tag:yt-specific tag:test
TEST_YT_SPEC_VALUE=
### @usage: YT_SPEC(path1 [path2...])
###
### Allows you to specify json-files with YT task and operation specs,
### which will be used to run test node in the YT.
### Test must be marked with ya:yt tag.
### Files must be relative to the root of Arcadia.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro YT_SPEC(Data...) {
    SET_APPEND(TEST_YT_SPEC_VALUE $Data)
}

# tag:test
TEST_SRCS_VALUE=
### @usage: TEST_SRCS(Files...)
###
### In PY2TEST, PY3TEST and PY*_LIBRARY modules used as PY_SRCS macro and additionally used to mine test cases to be executed by testing framework.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynapytest
macro TEST_SRCS(Tests...) {
    SET_APPEND(TEST_SRCS_VALUE $Tests)
}

macro DISABLE_DATA_VALIDATION(Args...) {
    # TODO(YMAKE-1731) restore no-args signature after YMAKE-1656 is done
    DISABLE(VALIDATE_DATA)
}

# tag:test
TEST_DATA_VALUE=
### @usage: DATA([path...])
###
### Specifies the path to the data necessary test.
### Valid values are: arcadia/<path> , arcadia_tests_data/<path> and sbr://<resource_id>.
### In the latter case resource will be brought to the working directory of the test before it is started
###
### Used only inside TEST modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#dannyeizrepozitorija
macro DATA(Data...) {
    SET_APPEND(TEST_DATA_VALUE $Data)
    ADD_CHECK(check.data $Data)
}

DOCKER_IMAGES_VALUE=
macro DOCKER_IMAGE(Images...) {
    SET_APPEND(DOCKER_IMAGES_VALUE $Images)
}
# tag:test
### @usage: DATA_FILES([path...])
###
### Specifies the path to the arcadia source data necessary test.
### Used only inside TEST modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#dannyeizrepozitorija
macro DATA_FILES(Paths...) {
    SET_APPEND(TEST_DATA_VALUE ${pre=arcadia/:Paths})
    _DATA_FILES($Paths)
}

# tag:test
### @usage: EXPLICIT_DATA()
###
### Disables implicit macro DATA(<module_path>).
ADD_SRCDIR_TO_TEST_DATA=yes
macro EXPLICIT_DATA() {
    SET(ADD_SRCDIR_TO_TEST_DATA no)
}

# tag:test
TEST_TAGS_VALUE=
### @usage: TAG ([tag...])
###
### Each test can have one or more tags used to filter tests list for running.
### There are also special tags affecting test behaviour, for example ya:external, sb:ssd.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#obshhieponjatija
macro TAG(Tags...) {
    SET_APPEND(TEST_TAGS_VALUE $Tags)
}

# tag:test
TEST_REQUIREMENTS_VALUE=
### @usage: REQUIREMENTS([cpu:<count>] [disk_usage:<size>] [ram:<size>] [ram_disk:<size>] [container:<id>] [network:<restricted|full>] [dns:dns64])
###
### Allows you to specify the requirements of the test.
###
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
macro REQUIREMENTS(Tags...) {
    SET_APPEND(TEST_REQUIREMENTS_VALUE $Tags)
}

# tag:test
TEST_ENV_VALUE=
### @usage: ENV(key[=value])
###
### Sets env variable key to value (gets value from system env by default).
macro ENV(Data...) {
    SET_APPEND(TEST_ENV_VALUE ${quo:Data})
}

### @usage: CONFTEST_LOAD_POLICY_LOCAL()
###
### Loads conftest.py files in a way that pytest does it
macro CONFTEST_LOAD_POLICY_LOCAL() {
    SET_APPEND(TEST_ENV_VALUE "CONFTEST_LOAD_POLICY=LOCAL")
}

# tag:test
TEST_RECIPES_VALUE=
### @usage: USE_RECIPE(path [arg1 arg2...])
###
### Provides prepared environment via recipe for test.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/recipes
macro USE_RECIPE(Data...) {
    SET_APPEND(TEST_RECIPES_VALUE $Data)
    SET_APPEND(TEST_RECIPES_VALUE "USE_RECIPE_DELIM")
}

# tag:python-specific tag:test
TEST_PYTHON_PATH_VALUE=

# tag:python-specific tag:test
### @usage: PYTHON_PATH(Path)
###
### Set path to Python that will be used to runs scripts in tests
macro PYTHON_PATH(Path) {
    SET(TEST_PYTHON_PATH_VALUE $Path)
}

# tag:test
SKIP_TEST_VALUE=
### @usage: SKIP_TEST(Reason)
###
### Skip the suite defined by test module. Provide a reason to be output in test execution report.
macro SKIP_TEST(Reason...) {
    SET(SKIP_TEST_VALUE $Reason)
}

# tag:test
LINT_LEVEL_VALUE=extended
_NO_LINT_VALUE=
### @usage: NO_LINT([ktlint])
###
### Do not check for style files included in PY_SRCS, TEST_SRCS, JAVA_SRCS.
### Ktlint can be disabled using NO_LINT(ktlint) explicitly.
macro NO_LINT(ktlint?"ktlint":"none") {
    SET(_NO_LINT_VALUE ${ktlint})
}

### @usage: LINT(<none|base|strict|extended>)
###
### Set linting level for sources of the module
macro LINT(level) {
    SET(LINT_LEVEL_VALUE $level)
}

# tag:test
### @usage: EXECTEST()
###
### Module definition of generic test that executes a binary.
### Use macro RUN to specify binary to run.
###
### @example:
###
###     EXECTEST()
###         RUN(
###             cat input.txt
###         )
###         DATA(
###             arcadia/devtools/ya/test/tests/exectest/data
###         )
###         DEPENDS(
###             devtools/dummy_arcadia/cat
###         )
###         TEST_CWD(devtools/ya/test/tests/exectest/data)
###     END()
###
### More examples: https://wiki.yandex-team.ru/yatool/test/#exec-testy
###
### @see: [RUN()](#macro_RUN)
module EXECTEST: _BARE_UNIT {
    .CMD=$TOUCH_UNIT
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .ALLOWED=YT_SPEC
    .RESTRICTED=FORK_TEST_FILES
    .DEFAULT_NAME_GENERATOR=FullPath
    .ARGS_PARSER=Base
    .STRUCT_CMD=yes
    SET(MODULE_SUFFIX .pkg.fake)
    SETUP_EXECTEST()
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS canondata/result.json)
    DISABLE(_NEED_SBOM_INFO)
}

# tag:cpp-specific tag:test
### @usage: Y_BENCHMARK([benchmarkname])
###
### Benchmark test based on the library/cpp/testing/benchmark.
###
### For more details see: https://wiki.yandex-team.ru/yatool/test/#zapuskbenchmark
module Y_BENCHMARK: PROGRAM {
    .SEM=_CPP_PROGRAM_SEM
    PEERDIR(library/cpp/testing/benchmark/main)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME y_benchmark)
}

_GBENCH_SEM=$_CPP_PROGRAM_SEM \
    && target_commands-ITEM && target_commands-macro add_test && target_commands-args NAME $REALPRJNAME COMMAND $REALPRJNAME \
    && target_commands-ITEM && target_commands-macro set_property && target_commands-args TEST $REALPRJNAME PROPERTY LABELS SMALL $FILTER_ONLY_TEST_TAGS \
    && add_test_requirements $REALPRJNAME $DEFAULT_REQUIREMENTS $TEST_REQUIREMENTS_VALUE \
    $_TEST_TIMEOUT_SEM

# tag:cpp-specific tag:test
### @usage: G_BENCHMARK([benchmarkname])
###
### Benchmark test based on the google benchmark.
###
### For more details see: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/benchmark/README.md
module G_BENCHMARK: _BASE_PROGRAM {
    .SEM=_GBENCH_SEM
    .ALLOWED=YT_SPEC
    PEERDIR(library/cpp/testing/gbenchmark)
    ADD_YTEST($MODULE_PREFIX$REALPRJNAME g_benchmark)
}

BENCHMARK_OPTS_VALUE=
### @usage: BENCHMARK_OPTS(opt1 [opt2...])
###
### Allows to specify extra args to benchmark binary.
### Supported for G_BENCHMARK and Y_BENCHMARK
###
### @example:
###     BENCHMARK_OPTS (
###         --benchmark_min_time=0
###     )
###
### Documentation: https://docs.yandex-team.ru/ya-make/manual/tests/benchmark
macro BENCHMARK_OPTS(Data...) {
    SET_APPEND(BENCHMARK_OPTS_VALUE $Data)
}

# tag:test
TEST_ROOT=$(TESTS_DATA_ROOT)
RESULT_MAX_FILE=0
STRIP_FILES=--dont-strip-files
VERIFY_RESULTS=--verify-results
ADDITIONAL_PATH=

# set for tests variables to fill it by YA_DEV or YA
YA_ROOT=ya
when ($YA_DEV == "yes") {
    YA_ROOT=ya-dev
}

# tag:test
### @usage: UNITTEST_FOR(path/to/lib)
###
### Convenience extension of UNITTEST module.
### The UNINTTEST module with additional SRCDIR + ADDINCL + PEERDIR on path/to/lib.
### path/to/lib is the path to the directory with the LIBRARY project.
###
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module UNITTEST_FOR: UNITTEST {
    .SEM=_UNITTEST_SEM
    PEERDIR(ADDINCL $UNITTEST_DIR)
    SRCDIR($UNITTEST_DIR)
}

### @usage: _LIBRARY # internal
###
### Base module definition for all libraries.
### Contains basic logic like module properties, default variable values etc.
### All libraries similar to C++-libraries should be inherited from it.
module _LIBRARY: _BASE_UNIT {
    .CMD=$LINK_LIB
    .STRUCT_CMD=yes
    .NODE_TYPE=Library
    .PEERDIR_POLICY=as_include
    .EXTS=.o .obj .a .mf .supp .sbom .tidyjson .ld .lib .sdcmeta .pyplugin .iwyujson
    .ALLOWED=GRPC USE_SKIFF EXTRALIBS OBJADDE_GLOBAL RESOURCE_FILES
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS USER_CONLYFLAGS LDFLAGS SRCS _WHOLE_ARCHIVE_LIBS_VALUE RPATH OBJADDE_LIB _LINK_EXCLUDE_LIBRARIES
    .RESTRICTED=ALLOCATOR SIZE TAG DATA TEST_DATA DEPENDS FORK_TESTS FORK_SUBTESTS SPLIT_FACTOR TEST_CWD RUN TIMEOUT SPLIT_DWARF
    .ALIASES=EXTRALIBS=PY_EXTRALIBS
    .FINAL_TARGET=no
    .GLOBAL_CMD=$GLOBAL_LINK_LIB
    .GLOBAL_EXTS=.o .obj .tidyjson .iwyujson

    GLOBAL_SUFFIX=.global$MODULE_SUFFIX
    #TODO: Remove this hack (really we do not need add fake src at all)
    ENABLE(NEED_ADD_FAKE_SRC)
    CHECK_CONTRIB_CREDITS(contrib/clickhouse contrib/libs contrib/deprecated EXCEPT contrib/deprecated/python)

    when ($USE_MKL == "yes") {
        NOPLATFORM=yes
    }

    when ($MSVC == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.lib
    }
    elsewhen ($TIDY_ENABLED == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.tidyjson
    }
    elsewhen ($IWYU_ENABLED == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.iwyujson
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.a
    }


    when ($WITH_VALGRIND == "yes") {
        PEERDIR+=contrib/libs/valgrind
        # https://st.yandex-team.ru/DTCC-1227
        CFLAGS+=-fdebug-default-version=4
    }
}

CPP_LIBRARY_INDUCED_LINKS=link-publics
_CPP_LIBRARY_SEM=add_library ${MODDIR} $CMAKE_TARGET_NAME ${hide:TARGET} ${hide:AUTO_INPUT} $CMAKE_TARGET_ARTEFACT_RENAME_RULES \
                && is_fake_module ${FAKE_MODULE} \
                && ${CPP_LIBRARY_INDUCED_LINKS} $CMAKE_LINK_TARGET \
                && target_options-publics-ITEM && target_options-publics-option target_include_directories && target_options-publics-args $_C__INCLUDE_GLOBAL \
                && target_options-privates-ITEM && target_options-privates-option target_include_directories && target_options-privates-args $_C__INCLUDE_OWNED \
                && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
                && target_options-publics-ITEM && target_options-publics-option target_compile_options && target_options-publics-args $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW \
                && target_options-interfaces-ITEM && target_options-interfaces-option target_link_options && target_options-interfaces-args $LDFLAGS_GLOBAL_RAW \
                && project_languages C && project_languages CXX \
                && target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${MODULE_EXPLICIT_HEADERS}
_CPP_OBJ_LIBRARY_SEM=add_global_library_for ${MODDIR} ${suf=.global:CMAKE_TARGET_NAME} $CMAKE_TARGET_NAME ${hide:GLOBAL_TARGET} ${hide:AUTO_INPUT} \
                && target_options-publics-ITEM && target_options-publics-option target_include_directories && target_options-publics-args $_C__INCLUDE_GLOBAL \
                && target_options-privates-ITEM && target_options-privates-option target_include_directories && target_options-privates-args $_C__INCLUDE_OWNED \
                && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
                && target_options-publics-ITEM && target_options-publics-option target_compile_options && target_options-publics-args $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW

CMAKE_FIND_PKG=
CMAKE_LINK_TARGET=$REALPRJNAME
CMAKE_FIND_PKG_COMP=

### @usage: LIBRARY()
###
### The regular static library module.
###
### The LIBRARY() is intermediate module, so when built directly it won't build its dependencies.
### It transitively provides its PEERDIRs to ultimate final target, where all LIBRARY() modules are built and linked together.
###
### This is C++ library, and it selects peers from multimodules accordingly.
###
### It makes little sense to mention LIBRARY in DEPENDS or BUNDLE, package and deploy it since it is not a standalone entity.
### In order to use library in tests PEERDIR it to link into tests.
### If you think you need to distribute static library please contact devtools@ for assistance.
module LIBRARY: _LIBRARY {
    .GLOBAL=_AARS _PROGUARD_RULES
    .SEM=_CPP_LIBRARY_SEM
    .ALIASES=EXTRALIBS=PY_EXTRALIBS
    .GLOBAL_SEM=_CPP_OBJ_LIBRARY_SEM
    .DEFAULT_NAME_GENERATOR=ThreeDirNames
    .ARGS_PARSER=Base

    when ($CMAKE_PACKAGE_SEM != "" || $CONAN_REQUIRES_SEM != "" || $CONAN_OPTS_SEM != "" || $CONAN_OS_REQUIRES_SEM != "" || $CONAN_OS_OPTIONS_SEM != "") {
        _CPP_LIBRARY_SEM=$CMAKE_PACKAGE_SEM && ${CPP_LIBRARY_INDUCED_LINKS} $CMAKE_LINK_TARGET $CONAN_REQUIRES_SEM $CONAN_OPTIONS_SEM $CONAN_OS_REQUIRES_SEM $CONAN_OS_OPTIONS_SEM && IGNORED
    }
    when ($OPENSOURCE_EXPORT == "no") {
        _CPP_LIBRARY_SEM=$_SEM_IGNORED
    }

    when ($HAS_CPP_PROTOBUF_PEERS == "yes") {
        PEERDIR+=$CPP_PROTOBUF_PEERS
    }
    SET(MODULE_TYPE LIBRARY)
    SET(MODULE_LANG CPP)

    ADD_CLANG_TIDY()
    ADD_IWYU()
    when ($TIDY_ENABLED == "yes") {
        _MAKEFILE_INCLUDE_LIKE_DEPS+=${ARCADIA_ROOT}/build/yandex_specific/config/clang_tidy/tidy_project_map.json
        _MAKEFILE_INCLUDE_LIKE_DEPS+=${ARCADIA_ROOT}/build/yandex_specific/config/clang_tidy/tidy_default_map.json
    }
}

# tag:internal
### @usage: _BARE_MODULE() # internal
###
### Remove unwanted dependencies for "empty" library module
macro _BARE_MODULE() {
    SET(NEED_PLATFORM_PEERDIRS no)
    SET(PEERDIR_TEST_TOOL no)
    DISABLE(WITH_VALGRIND)
    NO_CODENAVIGATION()
    NO_PLATFORM()
    NO_RUNTIME()
    NO_UTIL()
    NO_CLANG_TIDY()
    NO_IWYU()
}

# tag:internal
### @usage: _BARE_LINK_MODULE() # internal
###
### Remove unwanted dependencies for "empty" link module
macro _BARE_LINK_MODULE() {
    _BARE_MODULE()
    DISABLE(COMMON_LINK_SETTINGS)
    ALLOCATOR(FAKE)
    NO_PROFILE_RUNTIME()
}

# tag:internal
### @usage: _CONDITIONAL_SRCS([USE_CONDITIONAL_SRCS] Files...) # internal
###
### Adds Files... to SRCS if first word is `USE_CONDITIONAL_SRCS`
### To be used with some variable which is set to `USE_CONDITIONAL_SRCS` under condition
macro _CONDITIONAL_SRCS(USE_CONDITIONAL_SRCS[], DYMMY...) {
    SRCS($USE_CONDITIONAL_SRCS)
}

# XXX: dirty hack for correct LDFLAGS passing
RESOURCES_LIBRARY_LINK=$TOUCH_UNIT
_RESOURCES_LIBRARY_SEM=IGNORED

### @usage: RESOURCES_LIBRARY()
###
### Definition of a module that brings its content from external source (Sandbox) via DECLARE_EXTERNAL_RESOURCE macro.
### This can participate in PEERDIRs of others as library but it cannot have own sources and PEERDIRs.
###
### @see: [DECLARE_EXTERNAL_RESOURCE()](#macro_DECLARE_EXTERNAL_RESOURCE)
module RESOURCES_LIBRARY: _BARE_UNIT {
    .CMD=$RESOURCES_LIBRARY_LINK
    .STRUCT_CMD=yes
    .SEM=_RESOURCES_LIBRARY_SEM
    .ALLOWED=DECLARE_EXTERNAL_RESOURCE EXTRALIBS OBJADDE_GLOBAL
    .RESTRICTED=ALLOCATOR SIZE TAG DATA TEST_DATA DEPENDS FORK_TESTS FORK_SUBTESTS SPLIT_FACTOR TEST_CWD RUN TIMEOUT SRC SRCS SPLIT_DWARF
    .ALIASES=EXTRALIBS=PY_EXTRALIBS
    .NODE_TYPE=Library
    .PEERDIR_POLICY=as_include
    .EXTS=.o .obj .a .mf .supp .sbom .tidyjson .ld .lib .pyplugin .iwyujson
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS USER_CONLYFLAGS LDFLAGS _WHOLE_ARCHIVE_LIBS_VALUE RPATH OBJADDE_LIB SRCS


    SET(MODULE_TAG RESOURCE_LIB)
    SET(PEERDIR_TAGS RESOURCE_LIB)

    when ($CMAKE_PACKAGE_SEM != "" || $CONAN_REQUIRES_SEM != "" || $CONAN_OPTS_SEM != "" || $CONAN_OS_REQUIRES_SEM != "" || $CONAN_OS_OPTIONS_SEM != "") {
        _RESOURCES_LIBRARY_SEM=$CMAKE_PACKAGE_SEM && ${CPP_LIBRARY_INDUCED_LINKS} $CMAKE_LINK_TARGET $CONAN_REQUIRES_SEM $CONAN_OPTIONS_SEM $CONAN_OS_REQUIRES_SEM $CONAN_OS_OPTIONS_SEM && IGNORED
    }

    MODULE_SUFFIX=.pkg.fake
    ENABLE(NEED_ADD_FAKE_SRC)
    WITHOUT_LICENSE_TEXTS()
}

_FAT_OBJECT_SEM=add_fat_object ${MODDIR} ${CMAKE_TARGET_NAME} ${hide:TARGET} ${hide:AUTO_INPUT} ${CMAKE_TARGET_ARTEFACT_RENAME_RULES} \
    && target_options-privates-ITEM && target_options-privates-option target_include_directories && target_options-privates-args $_C__INCLUDE_OWNED \
    && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
    && platform_vars-FAT_OBJECT_PREFIX ${quo:MODULE_PREFIX} \
    && platform_vars-FAT_OBJECT_SUFFIX ${quo:MODULE_SUFFIX}

### Do not turn visibility=hidden symbos into static symbos of partially linked object file
###
### Note: This variable do not have any effect on platforms other than MacOS and iOS.
KEEP_FAT_OBJECT_SYMBOLS=no

### @usage: FAT_OBJECT()
###
### The "fat" object module. It will contain all its transitive dependencies reachable by PEERDIRs:
### static libraries, local (from own SRCS) and global (from peers') object files.
###
### Designed for use in XCode projects for iOS.
module FAT_OBJECT: LIBRARY {
    .ALLOWED=PACK_GLOBALS_IN_LIBRARY
    .CMD=$LINK_FAT_OBJECT
    .SEM=_FAT_OBJECT_SEM
    .PEERDIR_POLICY=as_build_from

    when ($OS_WINDOWS == "yes") {
        MODULE_SUFFIX=.lib
    }
    otherwise {
        MODULE_SUFFIX=.a
    }

    when (($OS_DARWIN == "yes" || $OS_IOS == "yes") && $KEEP_FAT_OBJECT_SYMBOLS == "yes") {
        LDFLAGS_GLOBAL += -keep_private_externs
    }

    when ($OS_IOS == "yes" || $OS_ANDROID == "yes" || $MAPSMOBI_BUILD_TARGET == "yes") {
        MODULE_LICENSES_RESTRICTION_TYPES = ALLOW_ONLY
        MODULE_LICENSES_RESTRICTIONS = SERVICE REQUIRE_CITATION
    }

    # FIXME: This is weird legacy
    when ($OS_ANDROID == "yes") {
        MODULE_PREFIX=lib
    }
    otherwise {
        MODULE_PREFIX=
    }

    _USE_LINKER()

    # This module requires at least one .o which is not subject to removal so just add _fake_src.cpp as SRCS
    # ymake's handling of NEED_ADD_FAKE_SRC may insert arbitrary command, not necessarily compilation
    DISABLE(NEED_ADD_FAKE_SRC)
    SRCS(build/scripts/_fake_src.cpp)
}

_RECURSIVE_LIBRARY_SEM=add_recursive_library ${MODDIR} ${CMAKE_TARGET_NAME} ${hide:TARGET} ${hide:AUTO_INPUT} ${CMAKE_TARGET_ARTEFACT_RENAME_RULES} \
    && target_options-publics-ITEM && target_options-publics-option target_include_directories && target_options-publics-args $_C__INCLUDE_GLOBAL \
    && target_options-privates-ITEM && target_options-privates-option target_include_directories && target_options-privates-args $_C__INCLUDE_OWNED \
    && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS \
    && target_options-publics-ITEM && target_options-publics-option target_compile_options && target_options-publics-args $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW \
    && target_options-interfaces-ITEM && target_options-interfaces-option target_link_options && target_options-interfaces-args $LDFLAGS_GLOBAL_RAW

### @usage: RECURSIVE_LIBRARY()
###
### The recursive ("fat") library module. It will contain all its transitive dependencies reachable by PEERDIRs:
### from static libraries, local (from own SRCS) and global (from peers') object files.
###
### Designed for use in XCode projects for iOS.
module RECURSIVE_LIBRARY: LIBRARY {
    .CMD=$LINK_RECURSIVE_LIBRARY
    .SEM=_RECURSIVE_LIBRARY_SEM
    .PEERDIR_POLICY=as_build_from

    # This module requires at least one .o which is not subject to removal so just add _fake_src.cpp as SRCS
    # ymake's handling of NEED_ADD_FAKE_SRC may insert arbitrary command, not necessarily compilation
    DISABLE(NEED_ADD_FAKE_SRC)
    SRCS(build/scripts/_fake_src.cpp)
}

_SONAME=
_EXPORT_SCRIPT_SEM=
_CLEAN_TEXTREL=
macro _ADD_DYNLYB_SEM(Libname) {
    .SEM=add_shared_library ${MODDIR} ${Libname} ${hide:TARGET} ${hide:AUTO_INPUT} && target_options-publics-ITEM && target_options-publics-option target_include_directories && target_options-publics-args $_C__INCLUDE_GLOBAL && target_options-privates-ITEM && target_options-privates-option target_include_directories && target_options-privates-args $_C__INCLUDE_OWNED && target_options-privates-ITEM && target_options-privates-option target_compile_options && target_options-privates-args $USER_CFLAGS $USER_CXXFLAGS $_SEM_EXTRA_CXX_FLAGS && target_options-publics-ITEM && target_options-publics-option target_compile_options && target_options-publics-args $USER_CFLAGS_GLOBAL_RAW $USER_CXXFLAGS_GLOBAL_RAW && target_options-privates-ITEM && target_options-privates-option target_link_options && target_options-privates-args $LDFLAGS_GLOBAL_RAW $LDFLAGS $OBJADDE_LIB $OBJADDE_LIB_GLOBAL $OBJADDE && ${_VCS_INFO_SEM} $_EXPORT_SCRIPT_SEM
}
_CPP_DYN_LIBRARY_SEM=$_ADD_DYNLYB_SEM($CMAKE_TARGET_NAME) $CMAKE_TARGET_ARTEFACT_RENAME_RULES

when ($EXPORT_GRADLE == "yes") {
    _DYN_LIBRARY_SEM=${hide:TARGET} ${hide:AUTO_INPUT} consumer-jar ${MODDIR}/${REALPRJNAME}.so && consumer-type dll && $_SEM_IGNORED
}
otherwise {
    _DYN_LIBRARY_SEM=$_CPP_DYN_LIBRARY_SEM
}
macro CLEAN_TEXTREL() {
    SET(_CLEAN_TEXTREL yes)
}
### @usage: DLL_UNIT # internal
###
### Base module for all dynamically linked libraries as final artifacts.
### Contains all general logic for such kind of modules. Supports versioning and export files.
### Cannot participate in linking to programs, intended to be used as final artifact (packaged and deployed).
module DLL_UNIT: _LINK_UNIT {
    .CMD=$LINK_DYN_LIB
    .NODE_TYPE=Library
    .SYMLINK_POLICY=SO
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS USER_CONLYFLAGS LDFLAGS _WHOLE_ARCHIVE_LIBS_VALUE RPATH OBJADDE_LIB
    .ALLOWED=WHOLE_ARCHIVE
    .ALIASES=EXTRALIBS=PY_EXTRALIBS
    .DEFAULT_NAME_GENERATOR=TwoDirNames
    .ARGS_PARSER=DLL
    DYNAMIC_LINK=yes
    ALLOCATOR(FAKE)
    SET(MODULE_TYPE DLL)
    .TRANSITION=pic
    SET(MODULE_TAG DLL)
    SET(MODULE_LANG CPP)

    when ($EXPORTS_FILE) {
        _EXPORT_SCRIPT_SEM=&& target_macroses-ITEM && target_macroses-macro use_export_script && target_macroses-args ${input:EXPORTS_FILE}
    }

    when ($OS_WINDOWS == "yes") {
        MODULE_SUFFIX=.dll
    }
    elsewhen ($DARWIN == "yes" || $OS_IOS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dylib
    }
    elsewhen ($TIDY_ENABLED != "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.so
    }

    # This by now replicates ymake's behavior. We'll get rid of SONAME setting in ymake and fix this code altogether
    SONAME=${pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX:REALPRJNAME}
    when ($MODULE_VERSION) {
       LINK_DYN_LIB_FLAGS=--soname ${output;pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX$MODULE_VERSION:REALPRJNAME}
    }
    _SONAME=$SONAME$MODULE_VERSION

    when ($LINUX == "yes") {
        # '-z notext' is needed for linking mkl into shared libraries
        when ($_CLEAN_TEXTREL != "yes") {
            LDFLAGS += -Wl,-z,notext
        }
    }

    when ($OS_LINUX == "yes" && $ARCH_X86_64 == "yes") {
        when ($_NO_FIX_ELF != "yes") {
            LINK_DYN_LIB_FLAGS+=--fix-elf ${tool:"tools/fix_elf"}
        }
    }

    when ($DARWIN == "yes") {
        LDFLAGS += -undefined dynamic_lookup
    }

    when ($_CUSTOM_LINK_STEP_SCRIPT) {
        LINK_DYN_LIB_FLAGS+=--python=$YMAKE_PYTHON --custom-step=${input:_CUSTOM_LINK_STEP_SCRIPT}
    }
}

# tag:r-specific
### @usage: R_MODULE(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
###
### The external module for R language.
### 1. major_ver and minor_ver must be integers.
### 2. The resulting .so will have the prefix "lib".
### 3. Processing EXPORTS and PREFIX is the same as for DLL module
### This is native DLL, so it will select C++ version from PROTO_LIBRARY.
module R_MODULE: DLL_UNIT {
    .SEM=_CPP_DYN_LIBRARY_SEM
    when ($DARWIN == "yes") {
        LDFLAGS+=-flat_namespace -dynamiclib
    }

    when ($OS_WINDOWS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dll
    }

    ADDINCL(contrib/libs/r-lang)
}

### @usage: DYNAMIC_LIBRARY_FROM(Paths)
###
### Use specified libraries as sources of DLL
macro DYNAMIC_LIBRARY_FROM(Path...) {
    PEERDIR($Path)
    WHOLE_ARCHIVE($Path)
}

### @usage: DLL(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
###
### Dynamic library module definition.
### 1. major_ver and minor_ver must be integers.
### 2. EXPORTS allows you to explicitly specify the list of exported functions. This accepts 2 kind of files: .exports with <lang symbol> pairs and JSON-line .symlist files
### 3. PREFIX allows you to change the prefix of the output file (default DLL has the prefix "lib").
###
### DLL cannot participate in linking to programs but can be used from Java or as final artifact (packaged and deployed).
module DLL: DLL_UNIT {
    .SEM=_DYN_LIBRARY_SEM
    SET(MAKE_ONLY_SHARED_LIB yes)
    when ($OS_WINDOWS) {
        MODULE_SUFFIX=.dll
    }

    # TODO: Make it possible to use this syntax
    # DEFAULT(DLL_FOR_DIR no)
    ### FIXME: XXX
    ###when ($DLL_FOR_DIR != "no") {
    ###    SRCDIR($DLL_FOR_DIR)
    ###    ADDINCL($DLL_FOR_DIR)
    ###}
}

### DLL_TOOL is a DLL that can be used as a LD_PRELOAD tool.
module DLL_TOOL: DLL {
    .SEM=_CPP_DYN_LIBRARY_SEM
    # ymake resolves only program nodes as tools.
    .NODE_TYPE=Program
}

### @usage: SO_PROGRAM(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
###
### Executable dynamic library module definition.
### 1. major_ver and minor_ver must be integers.
### 2. EXPORTS allows you to explicitly specify the list of exported functions. This accepts 2 kind of files: .exports with <lang symbol> pairs and JSON-line .symlist files
### 3. PREFIX allows you to change the prefix of the output file.
module SO_PROGRAM: DLL {
    .CMD=$LINK_EXEC_DYN_LIB
    SET(MODULE_TYPE PROGRAM)

    MODULE_PREFIX=
    when ($OS_WINDOWS == "yes") {
        MODULE_SUFFIX=.exe
    }
    otherwise {
        MODULE_SUFFIX=
    }
}

DLL_PROXY_CMD_MF=$GENERATE_MF && $COPY_CMD $AUTO_INPUT $TARGET ${hide;kv:"p MF"} ${hide;kv:"pc light-cyan"}

# tag:internal
### @usage: DEV_DLL_PROXY() # internal
###
### The use of this module is strictly prohibited!!!
### This is a temporary and project-specific solution.
module DEV_DLL_PROXY: _BARE_UNIT {
    .CMD=$DLL_PROXY_CMD_MF
    .EXTS=.so .dll .dylib .mf
    .NODE_TYPE=Library
    .STRUCT_CMD=yes
    DYNAMIC_LINK=yes

    when ($OS_WINDOWS == "yes") {
        MODULE_SUFFIX=.dll
    }
    elsewhen ($DARWIN == "yes" || $OS_IOS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dylib$MODULE_VERSION
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.so$MODULE_VERSION
    }
}

# tag:internal
### @usage: DYNAMIC_DEPS(Path...) # internal, temporary
###
### Enlist paths to all DYNAMIC_LIBRARY dependencies of the DYNAMIC_LIBRARY
### This it needed to transfer their outputs through the library to PROGRAM
### or dependent DLL/DYNAMIC_LIBRARY.
###
### Note: this is temporary solution until support of `super-global` variables come
###       which will enable transfer of some properties though final targets like DLLs.
macro DYNAMIC_DEPS(Path...) {
     # PEERDIR as macro completely ignored in place where this macro applies
     SET_APPEND(PEERDIR $Path)
}

# tag:internal
### @usage: DYNAMIC_LIBRARY() # internal
###
### The use of this module is strictly prohibited except LGPL-related opensourcing
### This provides linkable DLL module which brings its results to programs and tests
### for seamless testing and packaging
multimodule DYNAMIC_LIBRARY {
    module DLL_BIN: DLL {
        .SEM=_CPP_DYN_LIBRARY_SEM
        .PROXY=yes
        .IGNORED=PROVIDES
        SET(MODULE_TAG DLL)
    }
    module DLL_LIB: _DLL_COMPATIBLE_LIBRARY {
        .CMD=$TOUCH_UNIT_MF
        .SEM=_SEM_IGNORED
        .PEERDIRSELF=DLL_BIN
        .IGNORED=SRCS PEERDIR RUN_PROGRAM PYTHON DYNAMIC_LIBRARY_FROM GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER USE_PYTHON2 USE_PYTHON3
        .ALLOWED=DYNAMIC_DEPS

        SET(PEERDIR_TAGS DLL_LIB __EMPTY__ RESOURCE_LIB)

        _BARE_MODULE()
        DYNAMIC_LINK=yes
        MODULE_SUFFIX=.pkg.fake
        PEERDIR+=build/platform/local_so

        # disable credits generation for static library
        SET(CREDITS_FLAGS)
    }
}

### @usage: GLOBAL_SRCS(filenames...)
###
### Make all source files listed as GLOBAL.
### Call to GLOBAL_SRCS macro is equivalent to call to SRCS macro when each source file is marked with GLOBAL keyword.
### Arcadia root relative or project dir relative paths are supported for filenames arguments. GLOBAL keyword is not
### recognized for GLOBAL_SRCS in contrast to SRCS macro.
###
### @example:
### Consider the file to ya.make:
###
###     LIBRARY()
###         GLOBAL_SRCS(foo.cpp bar.cpp)
###     END()
###
### @see: [SRCS()](#macro_SRCS)
macro GLOBAL_SRCS(Files...) {
    SRCS(${pre=GLOBAL :Files})
}

### @usage: ALL_SRCS([GLOBAL] filenames...)
###
### Make all source files listed as GLOBAL or not depending on the keyword GLOBAL
### Call to ALL_SRCS macro is equivalent to call to GLOBAL_SRCS macro when GLOBAL keyword is specified
### as the first argument and is equivalent to call to SRCS macro otherwise.
###
### @example:
###
###     LIBRARY()
###         SET(MAKE_IT_GLOBAL GLOBAL)
###         ALL_SRCS(${MAKE_IT_GLOBAL} foo.cpp bar.cpp)
###     END()
###
### @see: [GLOBAL_SRCS()](#macro_GLOBAL_SRCS), [SRCS()](#macro_SRCS)
macro ALL_SRCS(GLOBAL?"GLOBAL":"", Files...) {
    SRCS(${pre=$GLOBAL :Files})
}

### @usage: _DLL_COMPATIBLE_LIBRARY # internal
###
### Base module to place DLLs into multimodules back to back with libraries.
### In order to function properly all modules in multimodule shall have the
### same set of arguments. So this module is just library that accepts but
### ignores all DLL arguments.
module _DLL_COMPATIBLE_LIBRARY: LIBRARY {
    .DEFAULT_NAME_GENERATOR=TwoDirNames
    .ARGS_PARSER=DLL
}

# as SRCS in packages use macro BUNDLE_SRCS!

PACKED_PACKAGE_ARGS=
PACKED_PACKAGE_EXT=
### @usage: PACK(archive_type)
###
### When placed inside the PACKAGE module, packs the build results tree to the archive with specified extension. Currently supported extensions are `tar` and `tar.gz`
###
### Is not allowed other module types than PACKAGE().
###
### @see: [PACKAGE()](#module_PACKAGE)
macro PACK(Ext) {
    SET(PACKED_PACKAGE_EXT $Ext)
}

module _PACKAGE_FINAL: _BASE_UNIT {
    .CMD=$TOUCH_PACKAGE_MF
    .STRUCT_CMD=yes
    .ALIASES=SRCS=FILES
    .ALLOWED=PACK
    .USE_PEERS_LATE_OUTS=yes
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes

    SET(PEERDIR_TAGS CPP_PROTO CPP_PROTO_FROM_SCHEMA CPP_FBS PY2 PY3 PY2_NATIVE PY3_NATIVE YQL_UDF_SHARED __EMPTY__ RESOURCE_LIB DOCSBOOK JAR_RUNNABLE PY3_BIN PY3TEST_PROGRAM DLL GO_PROGRAM TS PACKAGE_UNION)

    SET(MODULE_SUFFIX .final.pkg.fake)
    SET(DONT_RESOLVE_INCLUDES yes)
    NO_PLATFORM()
    when ($PACKED_PACKAGE_EXT) {
        PACKED_PACKAGE_ARGS+=--dest-arch ${output;pre=$MODULE_PREFIX;suf=.$PACKED_PACKAGE_EXT:REALPRJNAME}
    }
    SET(NEED_PLATFORM_PEERDIRS no)
    SET(_COPY_FILE_CONTEXT TEXT)
    DISABLE(_NEED_SBOM_INFO)
}

### @usage: PACKAGE(name)
###
### Module collects what is described directly inside it, builds and collects all its transitively available PEERDIRs.
### As a result, build directory of the project gets the structure of the accessible part of Arcadia, where the build result of each PEERDIR is placed to relevant Arcadia subpath.
### The data can be optionally packed if macro PACK() is used.
###
### Is only used together with the macros FILES(), PEERDIR(), COPY(), FROM_SANDBOX(), RUN_PROGRAM or BUNDLE(). Don't use SRCS inside a PACKAGE.
###
### Documentation: https://wiki.yandex-team.ru/yatool/large-data/
###
### @see: [PACK()](#macro_PACK)
multimodule PACKAGE {
    module PACKAGE_FINAL: _PACKAGE_FINAL {
        .PEERDIRSELF=PACKAGE_UNION
        .IGNORED=DECLARE_IN_DIRS
    }

    module PACKAGE_UNION: UNION {
        .CMD=$UNION_CMD
        .STRUCT_CMD=yes
        .FINAL_TARGET=no
        .ALLOWED=PACK
        .IGNORED=VCS_INFO_FILE

        SET(MODULE_SUFFIX .pkg.fake)

        SET(PEERDIR_TAGS CPP_PROTO CPP_PROTO_FROM_SCHEMA CPP_FBS PY2 PY3 PY2_NATIVE PY3_NATIVE YQL_UDF_SHARED __EMPTY__ RESOURCE_LIB DOCSBOOK JAR_RUNNABLE PY3_BIN PY3TEST_PROGRAM DLL GO_PROGRAM TS PACKAGE_UNION)

        DISABLE(START_TARGET)
        SET(_COPY_FILE_CONTEXT TEXT)
    }
}

TOUCH_GROUP=$FAKE_PACKAGE_CMD $VCS_INFO_DISABLE_CACHE__NO_UID__ ${hide:PEERS} ${hide:AUTO_INPUT} ${hide:SRCS_GLOBAL} ${hide;kv:"p CI"} ${hide;kv:"package PACKAGE"}

### @usage: CI_GROUP()
###
### Module collects what is described directly inside it transitively by PEERDIRs.
### No particular layout of built artifacts is implied. This module is needed primarily for CI dependency analysis and may not trigger builds at all.
###
### Is only used together with the macro PEERDIR() and FILES(). Don't use SRCS inside CI_GROUP().
module CI_GROUP: _BARE_UNIT  {
    .CMD=$TOUCH_GROUP
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes
    .RESTRICTED=SRCS
    .STRUCT_CMD=yes
    .USE_PEERS_LATE_OUTS=yes
    MODULE_SUFFIX=.ci.pkg.fake
    PEERDIR_TAGS=CPP_PROTO CPP_PROTO_FROM_SCHEMA PY3 PY3_NATIVE PY3_BIN PY3TEST_PROGRAM YQL_UDF_SHARED __EMPTY__ RESOURCE_LIB DOCSBOOK JAR_RUNNABLE DLL PACKAGE_FINAL
}

# tag:generic tag:internal
TOUCH_UNIT_MF=$TOUCH_UNIT && $GENERATE_MF

### @usage: UNION(name)
###
### Collection of PEERDIR dependencies, files and artifacts.
### UNION doesn't build its peers, just provides those to modules depending on it.
### When specified in DEPENDS() macro the UNION is transitively closed, building all its peers and providing those by own paths (without adding this module path like PACKAGE does).
###
### Is only used together with the macros like FILES(), PEERDIR(), COPY(), FROM_SANDBOX(), RUN_PROGRAM or BUNDLE(). Don't use SRCS inside a UNION.
###
### Documentation: https://wiki.yandex-team.ru/yatool/large-data/
module UNION: _BASE_UNIT {
    .CMD=$UNION_CMD_MF
    .STRUCT_CMD=yes
    .FINAL_TARGET=no
    .ALIASES=SRCS=FILES
    .ALLOWED=EXPLICIT_OUTPUTS
    .IGNORED=VCS_INFO_FILE
    NO_PLATFORM()
    SET(MODULE_SUFFIX .pkg.fake)
    SET(DONT_RESOLVE_INCLUDES yes)
    SET(NEED_PLATFORM_PEERDIRS no)

    PEERDIR_TAGS=CPP_PROTO CPP_PROTO_FROM_SCHEMA CPP_FBS PY3 PY2_NATIVE PY3_NATIVE YQL_UDF_SHARED __EMPTY__ RESOURCE_LIB DOCSBOOK JAR_RUNNABLE PY3_BIN DLL TS PACKAGE_UNION

    DISABLE(_NEED_SBOM_INFO)
    UNION_OUTS__LATEOUT__=${AUTO_INPUT}
    UNION_OUTS=${hide;late_out:UNION_OUTS__LATEOUT__}
    when ($_UNION_EXPLICIT_OUTPUTS) {
        UNION_OUTS=$_EXPAND_INS_OUTS(FILES $_UNION_EXPLICIT_OUTPUTS)
    }
    SET(_COPY_FILE_CONTEXT TEXT)
}

# tag:internal
### @usage: _ADD_HIDDEN_INPUTS(inputs...) # internal
macro _ADD_HIDDEN_INPUTS(Inputs...) {
    .CMD=${hide;input:Inputs}
}

# tag:internal
### @usage: _SET_FIRST_VALUE(name args...) # internal
###
### This macro sets the value of `name` variable to the value of next argument
macro _SET_FIRST_VALUE(NAME, VALUE, OTHER...) {
    SET($NAME $VALUE)
}

# tag:internal
### @usage: _SRCS_NO_GLOBAL(files...) # internal
###
### Proxy macro to SRCS macro which filters out GLOBAL keyword from the list of source files.
### Useful for modules like EXTERNAL_JAVA_LIBRARY, where GLOBAL keyword cannot be applied properly.
### Note: this macro changes order of source files.
macro _SRCS_NO_GLOBAL(GLOBAL[], FILES...) {
    SRCS($GLOBAL $FILES)
}

@import "${CONF_ROOT}/conf/java.conf"
@import "${CONF_ROOT}/conf/python.conf"

TEST_CWD_VALUE=
_TEST_CWD_SEM=
### @usage: TEST_CWD(path)
###
### Defines working directory for test runs. Often used in conjunction with DATA() macro.
### Is only used inside of the TEST modules.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro TEST_CWD(Arg) {
    SET(TEST_CWD_VALUE $Arg)
    SET(_TEST_CWD_SEM && test_cwd $Arg)
}

# tag:allocator
### @usage: ALLOCATOR(Alloc)  # Default: LF
###
### Set memory allocator implementation for the PROGRAM()/DLL() module.
### This may only be specified for programs and dlls, use in other modules leads to configuration errors.
###
### Available allocators are: "LF", "LF_YT", "LF_DBG", "YT", "J", "B", "BM", "C", "TCMALLOC", "GOOGLE", "LOCKLESS", "SYSTEM", "FAKE", "MIM", "MIM_SDC", "HU", "PROFILED_HU", "THREAD_PROFILED_HU".
###   - LF - lfalloc (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/lfalloc)
###   - LF_YT -  Allocator selection for YT (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/lfalloc/yt/ya.make)
###   - LF_DBG -  Debug allocator selection (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/lfalloc/dbg/ya.make)
###   - YT - The YTAlloc allocator (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/ytalloc/impl/ya.make)
###   - J - The JEMalloc allocator (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/jemalloc)
###   - B - The balloc allocator named Pyotr Popov and Anton Samokhvalov
###       - Discussion: https://ironpeter.at.yandex-team.ru/replies.xml?item_no=126
###       - Code: https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/balloc
###   - BM - The balloc for market (agri@ commits from july 2018 till November 2018 saved)
###   - C - Like B, but can be disabled for each thread to LF or SYSTEM one (B can be disabled only to SYSTEM)
###   - MIM -  Microsoft's mimalloc (actual version) (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/mimalloc)
###   - MIM_SDC - Microsoft's mimalloc patched by SDC (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/mimalloc_sdc)
###   - TCMALLOC -  Google TCMalloc (actual version) (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/tcmalloc)
###   - GOOGLE -  Google TCMalloc (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/galloc)
###   - LOCKLESS - Allocator based upon lockless queues (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/lockless)
###   - SYSTEM - Use target system allocator
###   - FAKE - Don't link with any allocator
###   - HU - Huge page allocator by @gulin.
###   - PROFILED_HU - patched HU. It is a bit slower but has metrics of memory consumption.
###   - THREAD_PROFILED_HU - patched (special for market) HU. It is a bit slower but has metrics of memory consumption.
###
### More about allocators in Arcadia: https://wiki.yandex-team.ru/arcadia/allocators/
macro ALLOCATOR(Alloc) {
    SET(ALLOCATOR $Alloc)

    when ($ALLOCATOR in [ "LF", "LF_YT", "LF_DBG", "YT", "YT_TCMALLOC", "YT_TCMALLOC_256K", "J", "B", "BM", "C", "TCMALLOC", "TCMALLOC_SMALL_BUT_SLOW", "TCMALLOC_NUMA_256K", "TCMALLOC_NUMA_LARGE_PAGES", "TCMALLOC_256K", "TCMALLOC_TC", "GOOGLE", "LOCKLESS", "SYSTEM", "FAKE", "MIM", "MIM_SDC", "HU", "PROFILED_HU", "THREAD_PROFILED_HU" ]) {
    }
    otherwise {
        PEERDIR+=___configure_error___unknown_allocator_type___$ALLOCATOR
    }
}

when ($MIC_ARCH == "yes") {
    CFLAGS+=-mmic
    LDFLAGS+=-mmic
}
when ($USE_OPENMP == "yes") {
    PEERDIR+=contrib/libs/openmp
}

when ($STRIP == "yes" && $NO_STRIP != "yes") {
    STRIP_FLAG=$LD_STRIP_FLAG
    DWARF_COMMAND=
    GO_LINK_FLAGS_VALUE+=-s
}

when ($NO_LINKER_DCE != "yes") {
    DCE_FLAG=$LD_DCE_FLAG
}

when ($BT_MINSIZEREL == "yes" || $LINKER_ICF == "yes") {
    ICF_FLAG=$LD_ICF_FLAG
}

OBJCOPY_TOOL=$OBJCOPY_TOOL_VENDOR
OBJDUMP_TOOL=$OBJDUMP_TOOL_VENDOR
STRIP_TOOL=$STRIP_TOOL_VENDOR
NM_TOOL=$NM_TOOL_VENDOR
NEED_LLVM_TOOLS_PEERDIR=
LLVM_TOOLS_ROOT=

when (!$OBJCOPY_TOOL_VENDOR) {
    OBJCOPY_TOOL=${LLVM_TOOLS_ROOT}/bin/llvm-objcopy
    NEED_LLVM_TOOLS_PEERDIR=yes
}
when (!$OBJDUMP_TOOL_VENDOR) {
    OBJDUMP_TOOL=${LLVM_TOOLS_ROOT}/bin/llvm-objdump
    NEED_LLVM_TOOLS_PEERDIR=yes
}
when (!$STRIP_TOOL_VENDOR) {
    STRIP_TOOL=${LLVM_TOOLS_ROOT}/bin/llvm-strip
    NEED_LLVM_TOOLS_PEERDIR=yes
}
when (!$NM_TOOL_VENDOR) {
    NM_TOOL=${LLVM_TOOLS_ROOT}/bin/llvm-nm
    NEED_LLVM_TOOLS_PEERDIR=yes
}

SPLIT_DWARF_VALUE=no
NO_SPLIT_DWARF=no

when ($OS_DARWIN || $OS_IOS || $OS_IOSSIM) {
    SPLIT_DWARF_VALUE=yes
}

when ($STRIP_DEBUG_INFO) {
    SPLIT_DWARF_VALUE=yes
    NO_SPLIT_DWARF=no
}

### @usage: SPLIT_DWARF()
###
### Emit debug info for the PROGRAM/DLL as a separate file <module_name>.debug.
### NB: It does not help you to save process RSS but can add problems (see e.g. BEGEMOT-2147).
macro SPLIT_DWARF() {
    SET(SPLIT_DWARF_VALUE yes)
}

### @usage: NO_SPLIT_DWARF()
###
### Do NOT emit debug info for the PROGRAM/DLL as a separate file.
### On macOS this also means do NOT generate dSym files (faster linkage)
macro NO_SPLIT_DWARF() {
    SET(SPLIT_DWARF_VALUE no)
}

SPLIT_DWARF_OUTPUT=${tobindir;output;pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX.debug:REALPRJNAME}
when ($SPLIT_DWARF_VALUE == "yes" && $NO_SPLIT_DWARF != "yes" && $NO_DEBUGINFO != "yes" && $HOST_OS_LINUX == "yes" && $TARGET_PLATFORM == "LINUX") {
    DWARF_COMMAND= \
        $OBJCOPY_TOOL --only-keep-debug $TARGET $SPLIT_DWARF_OUTPUT && \
        $STRIP_TOOL --strip-debug $TARGET && \
        $OBJCOPY_TOOL --remove-section=.gnu_debuglink --add-gnu-debuglink $SPLIT_DWARF_OUTPUT $TARGET
}

### @usage: EXTRALIBS_STATIC(Libs...)
###
### Add the specified external static libraries to the program link
macro EXTRALIBS_STATIC(Args...) {
    LDFLAGS(-Wl,-Bstatic ${Args} -Wl,-Bdynamic)
}

### @usage: ADD_COMPILABLE_TRANSLATE(Dict Name Options...)
###
### Generate translation dictionary code to transdict.LOWER(Name).cpp that will than be compiled into library
macro ADD_COMPILABLE_TRANSLATE(Dict, Name, MakeTransDictOptions...) {
     __translatename_lower=${tolower:Name}
     __translate_dict=${BINDIR}/transdict.${__translatename_lower}.cpp
     RUN_PROGRAM(dict/tools/maketransdict -i ${Dict} ${MakeTransDictOptions} ${Name} STDOUT_NOAUTO ${__translate_dict} IN ${Dict})
}

### @usage: ADD_COMPILABLE_TRANSLIT(TranslitTable NGrams Name Options...)
###
### Generate transliteration dictionary code
### This will emit both translit, untranslit and ngrams table codes those will be than further compiled into library
macro ADD_COMPILABLE_TRANSLIT(TranslitTable, NGrams, Name, Options...) {
     __translitname_lower=${tolower:Name}
     __translit_table=${BINDIR}/translit_trie_${__translitname_lower}.cpp
     __untranslit_table=${BINDIR}/untranslit_trie_${__translitname_lower}.cpp
     __ngrams_table=${BINDIR}/ngr_arr_${__translitname_lower}.cpp
     __gentrie_dir=dict/tools/make_untranslit_trie

     RUN_PROGRAM(${__gentrie_dir} -i ${TranslitTable} ${Options} ${__translitname_lower} IN ${TranslitTable} STDOUT ${__untranslit_table})
     RUN_PROGRAM(${__gentrie_dir} -i ${TranslitTable} -n ${Options} ${__translitname_lower} IN ${TranslitTable} STDOUT ${__translit_table})
     RUN_PROGRAM(dict/tools/make_ngrams -i ${NGrams} ${Options} ${__translitname_lower} IN ${NGrams} STDOUT ${__ngrams_table})
}

_COPY_FILE_CONTEXT=TEXT

macro _COPY_FILE_IMPL(TEXT[], AUTO_DST="", NOAUTO_DST="", OUTPUT_INCLUDES[], INDUCED_DEPS[], OUTPUT_INCLUDES_INP[], FILE...) {
    .CMD=$COPY_CMD ${input:FILE} ${context=TEXT;input=TEXT:TEXT} ${output:AUTO_DST} ${noauto;output:NOAUTO_DST} ${hide;output_include:OUTPUT_INCLUDES} ${hide;from_input;output_include:OUTPUT_INCLUDES_INP} $INDUCED_DEPS ${hide;kv:"p CP"} ${hide;kv:"pc light-cyan"}
    .SEM=target_commands-ITEM && target_commands-macro copy_file && target_commands-args ${input:FILE} ${output:AUTO_DST} ${noauto;output:NOAUTO_DST}
}

### @usage: COPY_FILE(File Destination [AUTO] [OUTPUT_INCLUDES...] [INDUCED_DEPS...] [TEXT])
###
### Copy file to build root. It is possible to change both location and the name.
###
### Parameters:
### - File - Source file name.
### - Dest - Output file name.
### - AUTO - Consider copied file for further processing automatically.
### - OUTPUT_INCLUDES output_includes... - Output file dependencies.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type)
###                           and set of dependencies
### - TEXT - deprecated
###
### The file will be just copied if AUTO boolean parameter is not specified. You should explicitly
### mention it in SRCS under new name (or specify AUTO boolean parameter) for further processing.
macro COPY_FILE(File, Dest, AUTO?"true":"false", OUTPUT_INCLUDES[], INDUCED_DEPS[], TEXT?"true":"false") {
    # FIXME: the "TEXT" argument is effectively unused since _COPY_FILE_CONTEXT defaulting to TEXT
    .CMD=$_COPY_FILE_CMD
    .STRUCT_CMD=yes
    .SEM=$_COPY_FILE_SEM
    .STRUCT_SEM=yes
}
_COPY_FILE_CMD=$IF( \
    ${parse_bool:AUTO} \
    THEN $_COPY_FILE_IMPL(TEXT $File   AUTO_DST $Dest OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS) \
    ELSE $_COPY_FILE_IMPL(TEXT $File NOAUTO_DST $Dest OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS) \
)
_COPY_FILE_SEM=$IF( \
    ${parse_bool:AUTO} \
    THEN $_COPY_FILE_IMPL($File   AUTO_DST $Dest) \
    ELSE $_COPY_FILE_IMPL($File NOAUTO_DST $Dest) \
)

### @usage: COPY_FILE_WITH_CONTEXT(File Dest [AUTO] [OUTPUT_INCLUDES...] [INDUCED_DEPS...])
###
### Copy file to build root the same way as it is done for COPY_FILE, but also
### propagates the context of the source file.
macro COPY_FILE_WITH_CONTEXT(File, Dest, AUTO?"true":"false", OUTPUT_INCLUDES[], INDUCED_DEPS[]) {
    .CMD=$_COPY_FILE_WITH_CONTEXT_CMD
    .STRUCT_CMD=yes
    .SEM=$_COPY_FILE_SEM
    .STRUCT_SEM=yes
}
_COPY_FILE_WITH_CONTEXT_CMD=$IF( \
    ${parse_bool:AUTO} \
    THEN $_COPY_FILE_IMPL($File   AUTO_DST $Dest OUTPUT_INCLUDES_INP $File OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS) \
    ELSE $_COPY_FILE_IMPL($File NOAUTO_DST $Dest OUTPUT_INCLUDES_INP $File OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS) \
)

### This is to join $ALL_RES_ and $EXT
macro _ARF_HELPER(Args...) {
     RESOURCE_FILES($Args)
}

### @usage: ALL_RESOURCE_FILES(Ext [PREFIX {prefix}] [STRIP {strip}] Dirs...)
###
### This macro collects all files with extension `Ext` and
### Passes them to `RESOURCE_FILES` macro as relative to current directory
###
### `PREFIX` and `STRIP` have the same meaning as in `RESOURCE_FILES`, both are applied over moddir-relative paths
###
### Note: This macro can be used multiple times per ya.make, but only once for each Ext value
### Note: Wildcards are not allowed neither as Ext nor in Dirs
macro ALL_RESOURCE_FILES(EXT, PREFIX="", STRIP="", DIRS...) {
     _GLOB(ALL_RES_$EXT ${suf=/*.$EXT:DIRS})
     _ARF_HELPER(${pre=PREFIX :PREFIX} STRIP ${ARCADIA_ROOT}/${MODDIR}/${STRIP} ${pre=$ALL_RES_:EXT})
}

### @usage: ALL_RESOURCE_FILES_FROM_DIRS([PREFIX {prefix}] [STRIP {strip}] Dirs...)
###
### This macro collects all files non-recursively from listed Dirs and
### Passes them to `RESOURCE_FILES` macro as relative to current directory
### The macro is usefull if literally all files are needed because `ALL_RESOURCE_FILES` requires extension to be specified
###
### `PREFIX` and `STRIP` have the same meaning as in `RESOURCE_FILES`, both are applied over moddir-relative paths
###
### Note: This macro can be used only once per ya.make
### Note: Wildcards are not allowed neither as Ext nor in Dirs
macro ALL_RESOURCE_FILES_FROM_DIRS(PREFIX="", STRIP="", DIRS...) {
     _GLOB(_ALL_RES_DIRS ${suf=/*:DIRS})
     _ARF_HELPER(${pre=PREFIX :PREFIX} STRIP ${ARCADIA_ROOT}/${MODDIR}/${STRIP} ${_ALL_RES_DIRS})
}

macro _BUNDLE_TARGET(Target, Destination, Suffix) {
    .CMD=$MOVE_FILE ${result:Target}$Suffix ${noauto;output:Destination} ${hide;kv:"p BN"} ${hide;kv:"pc light-cyan"} $VCS_INFO_DISABLE_CACHE__NO_UID__
    .STRUCT_CMD=yes
    # In Cmd use MOVE, but for ya ide gradle this is prebuilt foreign target, and for use it many times, use COPY symlink to bundle
    .SEM=target_commands-ITEM && target_commands-macro copy_file && target_commands-args ${result:Target}$Suffix ${noauto;output:Destination} && target_commands-flags src_is_depend
}

### @usage: TIMEOUT(TIMEOUT)
###
### Sets a timeout on test execution
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro TIMEOUT(Time) {
    SET(TEST_TIMEOUT $Time)
}

SBR_UID_EXT=""
# tag:test
### @usage: VALIDATE_DATA_RESTART(ext)
###
### Change uid for resource validation tests. May be useful when sandbox resource ttl is changed, but test status is cached in CI.
### You can change ext to change test's uid. For example VALIDATE_DATA_RESTART(X), where is X is current revision.
macro VALIDATE_DATA_RESTART(Ext) {
    SET(SBR_UID_EXT $Ext)
}

PARALLEL_TESTS_ON_YT_WITHIN_NODE_WORKERS=
# tag:test
### @usage: PARALLEL_TESTS_ON_YT_WITHIN_NODE(CPUS)
###
### Execute tests in parallel within one node.
### May cause some tests to break due to races or other circumstances.
### Allowed values of CPUS: 'all' to run tests in all available CPUs, or integer amount of workers used.
### EXPERIMENTAL! DO NOT USE IF YOU ARE NOT SURE.
macro PARALLEL_TESTS_ON_YT_WITHIN_NODE(CPUS) {
    SET(PARALLEL_TESTS_ON_YT_WITHIN_NODE_WORKERS $CPUS)
}

# tag:test
TEST_FORK_MODE=none
TEST_PARTITION=SEQUENTIAL

# tag:test
### @usage: FORK_TESTS()
###
### Splits a test run on chunks by test classes.
### The number of chunks can be overridden using the macro SPLIT_FACTOR.
###
### Allows to run tests in parallel. Supported in UNITTEST, JTEST/JUNIT5 and PY2TEST/PY3TEST modules.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_TESTS(MODE...) {
    SET(TEST_FORK_MODE tests)
    SET(TEST_PARTITION $MODE)
}

# tag:test
### @usage: FORK_SUBTESTS()
###
### Splits the test run in chunks on subtests.
### The number of chunks can be overridden using the macro SPLIT_FACTOR.
###
### Allows to run tests in parallel. Supported in UNITTEST, JTEST/JUNIT5 and PY2TEST/PY3TEST modules.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_SUBTESTS(MODE...) {
    SET(TEST_FORK_MODE subtests)
    SET(TEST_PARTITION $MODE)
}

# tag:test
### @usage: SPLIT_FACTOR(x)
###
### Sets the number of chunks for parallel run tests when used in test module with FORK_TESTS() or FORK_SUBTESTS().
### If none of those is specified this macro implies FORK_TESTS().
###
### Supports C++ ut and PyTest.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro SPLIT_FACTOR(Factor) {
    SET(TEST_SPLIT_FACTOR $Factor)
}

# tag:test
FORK_TEST_FILES_MODE=
### @usage: FORK_TEST_FILES()
###
### Only for PY2TEST and PY3TEST: splits a file executable with the tests on chunks in the files listed in TEST_SRCS
### Compatible with FORK_(SUB)TESTS.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_TEST_FILES() {
    SET(FORK_TEST_FILES_MODE on)
}

# tag:test
TEST_EXPERIMENTAL_FORK=
### @usage: EXPERIMENTAL_FORK()
###
### Only for java-tests: same as FORK_(SUB)TESTS(SEQUENTIAL) for other languages
### Compatible with FORK_(SUB)TESTS.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro EXPERIMENTAL_FORK() {
    SET(TEST_EXPERIMENTAL_FORK yes)
}

# tag:test
TEST_SIZE_NAME=SMALL
### @usage: SIZE(SMALL/MEDIUM/LARGE)
###
### Set the 'size' for the test. Each 'size' has own set of resrtictions, SMALL bein the most restricted and LARGE being the list.
### See documentation on test system for more details.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro SIZE(Type) {
    SET(TEST_SIZE_NAME $Type)
}

### @usage: JOIN_SRCS(Out Src...)
###
### Join set of sources into single file named Out and send it for further processing.
### This macro doesn't place all file into Out, it emits #include<Src>... Use the for C++ source files only.
### You should specify file name with the extension as Out. Further processing will be done according this extension.
macro JOIN_SRCS(Out, Src...) {
    .CMD=$YMAKE_PYTHON3 ${input:"build/scripts/gen_join_srcs.py"} ${hide;input:"build/scripts/process_command_files.py"} ${output:Out} --ya-start-command-file ${rootrel;context=TEXT;input=TEXT:Src} --ya-end-command-file ${hide;from_input;output_include:Src} ${hide;kv:"p JS"} ${hide;kv:"pc magenta"}
    .STRUCT_CMD=yes
    .SEM=target_macroses-ITEM && target_macroses-macro target_joined_source && target_macroses-args $Out ${input:Src} ${hide;output;suf=.o:Out} ${hide;input:"build/scripts/gen_join_srcs.py"} ${hide;input:"build/scripts/process_command_files.py"}
    _CONDITIONAL_SRCS($CPP_ANALYSIS_VALUE $Src)
}

### @usage: JOIN_SRCS_GLOBAL(Out Src...)
###
### Join set of sources into single file named Out and send it for further processing as if it were listed as SRCS(GLOBAL Out).
### This macro doesn't place all file into Out, it emits #include<Src>... Use the for C++ source files only.
### You should specify file name with the extension as Out. Further processing will be done according to this extension.
macro JOIN_SRCS_GLOBAL(Out, Src...) {
    .CMD=$YMAKE_PYTHON3 ${input:"build/scripts/gen_join_srcs.py"} ${hide;input:"build/scripts/process_command_files.py"} ${noauto;output:Out} --ya-start-command-file ${rootrel;context=TEXT;input=TEXT:Src} --ya-end-command-file ${hide;from_input;output_include:Src} ${hide;kv:"p JS"} ${hide;kv:"pc magenta"}
    .STRUCT_CMD=yes
    SRCS(GLOBAL $Out)
}

### @usage: FLAT_JOIN_SRCS_GLOBAL(Out Src...)
###
### Join set of sources into single file named Out and send it for further processing as if it were listed as SRCS(GLOBAL Out).
### This macro places all files into single file, so will work with any sources.
### You should specify file name with the extension as Out. Further processing will be done according to this extension.
macro FLAT_JOIN_SRCS_GLOBAL(Out, Src...) {
    .CMD=$FS_TOOLS cat ${noauto;output:Out} --ya-start-command-file ${context=TEXT;input=TEXT:Src} --ya-end-command-file ${hide;from_input;output_include:Src} ${hide;kv:"p JS"} ${hide;kv:"pc magenta"}
    .STRUCT_CMD=yes
    SRCS(GLOBAL $Out)
}

# tag:cpu
PIC_CFLAGS=
SSE2_CFLAGS=
SSE3_CFLAGS=
SSSE3_CFLAGS=
SSE41_CFLAGS=
SSE42_CFLAGS=
POPCNT_CFLAGS=
CX16_FLAGS=
AVX_CFLAGS=
AVX2_CFLAGS=
AVX512_CFLAGS=
AMX_CFLAGS=

# tag:cpu
SSE_CFLAGS=
SSE4_CFLAGS=
XOP_CFLAGS=

NO_LTO_CFLAGS=
NO_PGO_CFLAGS=

# tag:cpu
when (($ARCH_X86_64 || $ARCH_I386) && $DISABLE_INSTRUCTION_SETS != "yes") {
    when ($CLANG || $CLANG_CL || $GCC) {
        PIC_CFLAGS=-fPIC
        SSE2_CFLAGS=-msse2
        SSE3_CFLAGS=-msse3
        SSSE3_CFLAGS=-mssse3
        SSE41_CFLAGS=-msse4.1
        SSE42_CFLAGS=-msse4.2

        XOP_CFLAGS=-mxop
        POPCNT_CFLAGS=-mpopcnt
        # Intel added (non-vectorized) CLMUL instruction set in Westmere,
        # that is after introducing SSE4.2 in Nehalem but before introducing AVX in Sandy Bridge.
        #
        # AMD implemented CLMUL in Jaguar after adding SSE4.2 in Bobcat, but before introducing AVX in Puma.
        # Due to the above, it should be safe to bind AVX and CLMUL instructions together.
        #
        # See:
        # https://en.wikipedia.org/wiki/CLMUL_instruction_set
        # https://en.wikipedia.org/wiki/Nehalem_(microarchitecture)
        # https://en.wikipedia.org/wiki/Westmere_(microarchitecture)
        # https://en.wikipedia.org/wiki/Sandy_Bridge
        #
        # https://en.wikipedia.org/wiki/Jaguar_(microarchitecture)
        AVX_CFLAGS=-mavx -mpclmul

        # On Intel BMI1, BMI2 and FMA3 instruction sets come together with AVX-2 extension starting with Broadwell / Haswell.
        # See:
        # https://en.wikipedia.org/wiki/FMA_instruction_set
        # https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
        #
        # AMD implemented FMA3 in Piledriver architecture over AVX (that is, prior to AVX-2 which was introduced in Zen).
        # BMI2 implementation was released by AMD along with AVX-2 support.
        # See:
        # https://en.wikipedia.org/wiki/Template:AMD_x86_CPU_features
        #
        # Due to the above, it looks safe to enable all three extensions whenever AVX-2 is enabled.
        AVX2_CFLAGS=-mavx2 -mfma -mbmi -mbmi2

        # All Intel CPUS with AVX-512 have these instructions except for the Knights Landing / Knights Mill
        # (these are Xeon Phi)
        # See:
        # https://en.wikichip.org/wiki/x86/avx-512
        AVX512_CFLAGS=-mavx512f -mavx512cd -mavx512bw -mavx512dq -mavx512vl

        # AMX stands Advanced Matrix Extension supported by modern Intel architectures
        # See:
        # https://en.wikipedia.org/wiki/Advanced_Matrix_Extensions
        # https://en.wikichip.org/wiki/x86/amx
        AMX_CFLAGS=-mamx-tile -mamx-int8 ${AVX512_CFLAGS}

        when ($ARCH_X86_64 && $OS_ANDROID != "yes") {
            CX16_FLAGS=-mcx16
        }
    }
    elsewhen ($MSVC) {
        SSE2_CFLAGS=/D__SSE2__=1
        SSE3_CFLAGS=/D__SSE3__=1
        SSSE3_CFLAGS=/D__SSSE3__=1
        SSE41_CFLAGS=/D__SSE4_1__=1
        SSE42_CFLAGS=/D__SSE4_2__=1
        POPCNT_CFLAGS=/D__POPCNT__=1
        AVX_CFLAGS=/arch:AVX /D__AVX__ /D__PCLMUL__=1
        AVX2_CFLAGS=/arch:AVX2 /D__AVX2__
        AVX512_CFLAGS=/arch:AVX512 /D__AVX512__
    }
    SSE_CFLAGS=$SSE2_CFLAGS $SSE3_CFLAGS $SSSE3_CFLAGS
    SSE4_CFLAGS=$SSE41_CFLAGS $SSE42_CFLAGS $POPCNT_CFLAGS $CX16_FLAGS
    when ($ARCH_I386 && $OS_ANDROID == "yes") {
        USE_SSE4=no
    }
}
otherwise {
    USE_SSE4=no
    CPU_CHECK=no
}

# tag:cpu
when ($NOSSE == "yes") {
    USE_SSE4=no
}

# tag:cpu
### @usage: NO_SSE4()
###
### Compile module without SSE4
macro NO_SSE4() {
    SET(USE_SSE4 no)
}

# tag:cpu
### @usage: NO_CPU_CHECK()
###
### Compile module without startup CPU features check
macro NO_CPU_CHECK() {
    SET(CPU_CHECK no)
}

### @usage: ADDINCLSELF()
###
### The macro adds the -I<project source path> flag to the source compilation flags of the current project.
macro ADDINCLSELF(FOR="") {
    when($FOR) {
        ADDINCL+=FOR $FOR ${MODDIR}
    }
    otherwise {
        ADDINCL+=${MODDIR}
    }
}

COMPILE_OUT_SUFFIX=
_COMPILE_OUTPUTS=${output;suf=${COMPILE_OUT_SUFFIX}${OBJECT_SUF}:SRC}
_COMPILE_TIME_TRACE_OUTPUTS=${noauto;output;suf=${COMPILE_OUT_SUFFIX}${OBJECT_SUF}.time_trace.json:SRC}

macro SET_COMPILE_OUTPUTS_MODIFIERS(NOREL?"norel;output":"output") {
    SET(_COMPILE_OUTPUTS \${$NOREL;suf=\${OBJECT_SUF}:SRC})
    SET(_COMPILE_TIME_TRACE_OUTPUTS \${noauto;$NOREL;suf=\${OBJECT_SUF}.time_trace.json:SRC})
}

### @usage: _ADD_EXTRA_FLAGS_IMPL([GENERATE] Args...) # internal
### Generate prefix with specific semantics before $Args when GENERATE
### is specified in the list of actual arguments
macro _ADD_EXTRA_FLAGS_IMPL(GENERATE?" && target_commands-ITEM && target_commands-macro set_property && target_commands-args SOURCE ${input:SRC} APPEND PROPERTY COMPILE_OPTIONS ":"", Args...) {
    .SEM=$GENERATE $Args
}

# tag:internal
### @usage: _ADD_EXTRA_FLAGS([GENERATE] Args...) # internal
### Generate prefix if Args is not empty
macro _ADD_EXTRA_FLAGS(COMPILE_OUT_SUFFIX="", Args...) {
    .SEM=$_ADD_EXTRA_FLAGS_IMPL(${pre=GENERATE :Args})
}

_EMPTY_CMD=

# tag:src-processing
macro _SRC("swg", SRC, SRCFLAGS...) {
    .CMD=${_SWIG_CMD}
    .STRUCT_CMD=yes
    .PEERDIR=${_SWIG_PEERDIR}
    .SEM=conan-tool_requires swig/4.0.2 && conan-imports 'bin, *swig* -> ./bin' ${hide;input:SRC} ${_SWIG_SEM_TO_MODULE_LINK}
}

RODATA_SYMBOL_PREFIX=
when ($DARWIN == "yes" || $IOS == "yes" || ($WINDOWS == "yes" && $ARCH_TYPE_32 == "yes")) {
    RODATA_SYMBOL_PREFIX=_
}

RODATA_ELF_FLAGS=
when($LINUX  == "yes" || $ANDROID == "yes") {
    RODATA_ELF_FLAGS=--elf
}

RODATA_COMPILE=$YMAKE_PYTHON3 ${input:"build/scripts/rodata2asm.py"} $RODATA_ELF_FLAGS ${RODATA_SYMBOL_PREFIX}${noext;nopath:SRC} ${input:SRC} ${tmp;suf=.asm:SRC} ${hide:OBJECT_SUF} && $_SRC_yasm_helper(${suf=.asm:SRC} ${tmp;suf=.asm:SRC})
when (($ARCH_AARCH64 || $ARCH_ARM || $ARCH_PPC64LE || $ARCH_RISCV32) == "yes") {
    RODATA_COMPILE=$YMAKE_PYTHON3 ${input:"build/scripts/rodata2cpp.py"} ${noext;nopath:SRC} ${input:SRC} ${output;suf=.cpp:SRC}
}

# tag:src-processing
macro _SRC("rodata", SRC, SRCFLAGS...) {
    .CMD=$RODATA_COMPILE && ${hide;kv:"p RD"} ${hide;kv:"pc light-green"}
    .STRUCT_CMD=yes
    .SEM=target_macroses-ITEM && target_macroses-macro target_rodata_sources && target_macroses-args PRIVATE ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} ${hide;input:"build/scripts/rodata2cpp.py"}
}

macro _SRC_S_ASM(SRC, SRCFLAGS...) {
    # The cwd specification is necessary to ensure that the distbuild output is the same as the local one
    .CMD=${cwd:ARCADIA_BUILD_ROOT} $C_COMPILER $C_FLAGS_PLATFORM $CFLAGS $SFLAGS $SRCFLAGS -c -o ${output;suf=.o:SRC} ${input:SRC} $TOOLCHAIN_ENV ${pre=-I:_C__INCLUDE} ${hide;kv:"p AS"} ${hide;kv:"pc light-green"}
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} && project_languages ASM
}

# tag:src-processing
macro _SRC("S", SRC, SRCFLAGS...) {
    .CMD=$_SRC_S_ASM($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .SEM=$_SRC_S_ASM($SRC $SRCFLAGS)
    .STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("s", SRC, SRCFLAGS...) {
    .CMD=$_SRC_S_ASM($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .SEM=$_SRC_S_ASM($SRC $SRCFLAGS)
    .STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("s79", SRC, SRCFLAGS...) {
    .CMD=$_SRC(S, $SRC $SRCFLAGS -x assembler-with-cpp)
}

# tag:src-processing
macro _SRC("mm", SRC, SRCFLAGS...) {
    .CMD=$C_COMPILER $C_FLAGS_PLATFORM -x objective-c++ -fobjc-arc -fobjc-abi-version=2 -c -o ${output;suf=.o:SRC} ${input:SRC} $CXXFLAGS ${pre=-I:_C__INCLUDE} ${SRCFLAGS} ${hide;kv:"p CC"} ${hide;kv:"pc light-green"} $TOOLCHAIN_ENV
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("sfdl", SRC, SRCFLAGS...) {
    .CMD=$CXX_COMPILER $C_FLAGS_PLATFORM $CXXFLAGS $SFDL_FLAG ${SRCFLAGS} ${input:SRC} && ${tool:"tools/calcstaticopt"} -i ${tmp;suf=.tmp:SRC} -a $ARCADIA_ROOT ${stdout;output;defext=.inc;nopath;noext:SRC} ${hide;kv:"p SF"} ${hide;kv:"pc yellow"} $TOOLCHAIN_ENV
    .STRUCT_CMD=yes
}

macro _XS_SRCS(SRC, TYPEMAPS[], SRCFLAGS...) {
    .CMD=${env:PERL_LD_LIBRARY_PATH} $PERL $PERL_INCLUDE ${suf=/ExtUtils/xsubpp:PERL_PRIVLIB} -typemap ${suf=/ExtUtils/typemap:PERL_PRIVLIB} $PERLSUFFIX $XSUBPPFLAGS ${pre=-typemap :TYPEMAPS} ${hide;input:TYPEMAPS} ${SRCFLAGS} ${input:SRC} ${PERLOUTPUT} ${hide;kv:"p XS"} ${hide;kv:"pc yellow"}
}

# tag:src-processing
macro _SRC("xs", SRC, SRCFLAGS...) {
    .CMD=$_XS_SRCS($SRC $SRCFLAGS TYPEMAPS $_XSTYPEMAPS)
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("gperf", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/gperf"} $GP_FLAGS ${SRCFLAGS} ${pre=-Nin_;suf=_set;nopath;noallext:SRC} ${input:SRC} ${stdout;output;defext=.gperf.cpp;nopath;noext:SRC} ${hide;kv:"p GP"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("rl", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel5/ragel"} $RAGEL_FLAGS ${SRCFLAGS} -o ${tmp;suf=.tmp:SRC} ${input:SRC} && $RUN_NO_SANITIZE ${tool:"contrib/tools/ragel5/rlgen-cd"} $RLGEN_FLAGS -o ${output;defext=.rl5.cpp;nopath;noext:SRC} ${tmp;suf=.tmp:SRC} ${hide;kv:"p R5"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

macro _SRC("xsyn", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"library/cpp/xml/parslib/xsyn2ragel.py"} ${input:SRC} ${input:"library/cpp/xml/parslib/xmlpars.xh"} dontuse ${stdout;output;suf=.h.rl5:SRC} ${hide;kv:"p XN"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("rl5", SRC, SRCFLAGS...) {
    .CMD=$_SRC(rl $SRC $SRCFLAGS)
    #.STRUCT_CMD=yes # TODO overloading support for redirection
}

# tag:src-processing
macro _SRC("asp", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"tools/html2cpp"} ${input:SRC} ${output;suf=.cpp:SRC} ${hide;kv:"p HT"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("rl6", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel6"} $RAGEL6_FLAGS ${SRCFLAGS} -L -I${ARCADIA_ROOT} -o ${output;defext=.rl6.cpp;nopath;noext:SRC} ${input:SRC} ${hide;kv:"p R6"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_macroses-ITEM && target_macroses-macro target_ragel_lexers && target_macroses-args PRIVATE ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $RAGEL6_FLAGS ${SRCFLAGS} && platform_vars-RAGEL_FLAGS "-L -I $_DOLLAR_S/" && conan-tool_requires ragel/6.10 && conan-imports 'bin, ragel* -> ./bin' ${hide;input:"build/scripts/run_tool.py"}
    .STRUCT_SEM=yes
}
_DOLLAR_S=${"$S"}

# tag:src-processing
macro _SRC("xsyn", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"library/cpp/xml/parslib/xsyn2ragel.py"} ${input:SRC} ${input:"library/cpp/xml/parslib/xmlpars.xh"} dontuse ${stdout;output;suf=.h.rl5:SRC} ${hide;kv:"p XN"} ${hide;kv:"pc yellow"}
}

# tag:src-processing
macro _SRC("ev", SRC, SRCFLAGS...) {
    .CMD=$EVLOG_CMD($SRC)
    .STRUCT_CMD=yes
    .SEM=$EVLOG_CMD($SRC)
}

# tag:src-processing
macro _SRC("proto", SRC, SRCFLAGS...) {
    .CMD=$PROTO_CMD($SRC)
    .STRUCT_CMD=yes
    .SEM=$PROTO_CMD($SRC)
    .STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("gztproto", SRC, SRCFLAGS...) {
    # _PROTO__INCLUDE is before ARCADIA_ROOT in includes because in gazetteer we don't use builtins now and paths' canonization (resolving) depends on order of roots.
    # descriptor.proto must be resolved as google/protobuf/descriptor.proto
    .CMD=${tool:"dict/gazetteer/converter"} -I$PROTOBUF_INCLUDE_PATH ${pre=-I:_PROTO__INCLUDE} -I$ARCADIA_ROOT ${SRCFLAGS} ${input:SRC} ${norel;output;suf=.proto;nopath;noext:SRC} ${hide;kv:"p GZ"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .PEERDIR=kernel/gazetteer/proto
}

# tag:src-processing
macro _SRC("cfgproto", SRC, SRCFLAGS...) {
    .CMD=$_CPP_CFGPROTO_CMD($SRC)
    .STRUCT_CMD=yes
}


when ($EXPORT_CMAKE == "yes") {
    _CYTHON_SYS_INCLUDES=
}
otherwise {
    # Numpy includes must come first because of both numpy and Cython/Includes contain numpy.pxd definitions
    # but Numpy's variant should be preferred
    # https://github.com/cython/cython/issues/6249#issuecomment-2176633822
    _CYTHON_SYS_INCLUDES=\
        FOR cython contrib/tools/cython/Cython/Includes \
        contrib/python/numpy/include/numpy/core/include \
        contrib/python/numpy/include/numpy/core/include/numpy \
        contrib/python/numpy/include/numpy/core/src/common \
        contrib/python/numpy/include/numpy/core/src/npymath \
        contrib/python/numpy/include/numpy/distutils/include
}


# tag:src-processing
macro _SRC("pyx", SRC, SRCFLAGS...) {
    # Copy-paste from BUILDWITH_CYTHON
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:SRC} -o ${tobindir;output;suf=${OBJ_SUF}.cpp:SRC} $CYTHON_OUTPUT_INCLUDES ${SRCFLAGS} ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_options-privates-ITEM && target_options-privates-option target_cython_sources && target_options-privates-args ${input:Src} ${hide;tobindir;output;suf=.fake.o:Src} && target_macroses-ITEM && target_macroses-macro target_cython_options && target_macroses-args $CYTHON_OPTIONS --cplus ${SRCFLAGS} ${CYTHON_CPP_OUTPUT_INCLUDES} && target_macroses-ITEM && target_macroses-macro target_cython_include_directories && target_macroses-args $_CYTHON__INCLUDE && target_macroses-ITEM && target_macroses-macro set_python_type_for_cython && target_macroses-args $PYTHON_TYPE_FOR_CYTHON
    .ADDINCL=$_CYTHON_SYS_INCLUDES
}

# tag:src-processing
macro _SRC("in", SRC, SRCFLAGS...) {
   .CMD=$CONFIGURE_FILE(${SRC} ${nopath;noext:SRC})
   .STRUCT_CMD=yes
   .SEM=$CONFIGURE_FILE(${SRC} ${nopath;noext:SRC})
   .STRUCT_SEM=yes
}

macro MANUAL_GENERATION(Outs...) {
    .SEM=$_SEM_IGNORED ${hide;noauto;output:Outs}
}

# tag:src-processing
macro _SRC("sc", SRC, SRCFLAGS...) {
    .CMD=${tool:"tools/domschemec"} --in ${input:SRC} --out ${norel;output;suf=.h:SRC} ${hide;output_include:"library/cpp/domscheme/runtime.h"} ${SRCFLAGS} ${hide;kv:"p SC"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .PEERDIR=library/cpp/domscheme
}

# tag:src-processing
macro _SRC("ssqls", SRC, SRCFLAGS...) {
    .CMD=${tool:"metrika/core/tools/ssqls"} ${notransformbuilddir;input:SRC} -S $ARCADIA_ROOT -B $ARCADIA_BUILD_ROOT $SRCFLAGS ${hide;output;suf=.cpp;noext:SRC} ${hide;output;suf=.h;noext:SRC} ${hide;kv:"p SS"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

macro _SRC_f_new(SRC, SRCFLAGS...) {
    .CMD=${tool:"build/platform/flang"} -c ${input:SRC} -o ${output;suf=.o:SRC} ${hide;kv:"p FL"} ${hide;kv:"pc light-green"}
}

macro _SRC_f_old(SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/f2c.py"} -t ${tool:"contrib/tools/f2c"} -c ${input:SRC} -o ${output;suf=.c:SRC} ${hide;output_include:"f2c.h"} ${hide;kv:"p FT"} ${hide;kv:"pc light-green"}
}

### @usage: AR_PLUGIN(plugin_name)
###
### Register script, which will process module's .a (archive) output
### Script will receive path to archive, which it should modify in place
macro AR_PLUGIN(name) {
    SET(_AR_PLUGIN $name.pyplugin)
}

### @usage: LD_PLUGIN(plugin_name)
###
### Register script, which will process all inputs to any link_exe.py call with modules's library
### Script will receive all arguments to link_exe.py, and can output into stdout preprocessed list
### of all arguments, in JSON format
macro LD_PLUGIN(Name) {
    .CMD=$COPY_CMD ${context=TEXT;input=TEXT:Name} ${global;noauto;output;suf=.pyplugin:Name} ${hide;kv:"p CP"} ${hide;kv:"pc light-cyan"}
    .STRUCT_CMD=yes
    .SEM=_SEM_IGNORED
}

USE_FLANG=no

when ($USE_FLANG == "yes") {
    _SRC_FLANG=$_SRC_f_new($SRC $SRCFLAGS)
}
otherwise {
    _SRC_FLANG=$_SRC_f_old($SRC $SRCFLAGS)
}

# tag:src-processing
macro _SRC("f", SRC, SRCFLAGS...) {
    .CMD=$_SRC_FLANG
    .STRUCT_CMD=yes
    .PEERDIR=contrib/libs/libf2c
    .ADDINCL=contrib/libs/libf2c
}

_SRC_CPP_TOOLCHAIN_INFO_PEER=

# tag:src-processing
macro _SRC("cpp", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp_new($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CPP_TOOLCHAIN_INFO_PEER
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS)
    #.STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("cxx", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp_new($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CPP_TOOLCHAIN_INFO_PEER
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS)
    #.STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("cc", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp_new($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CPP_TOOLCHAIN_INFO_PEER
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS)
    #.STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("auxcpp", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp_new($SRC $_FORCE_CPP_FLAGS $SRCFLAGS)
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CPP_TOOLCHAIN_INFO_PEER
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($_FORCE_CPP_FLAGS $SRCFLAGS)
    #.STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("C", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp_new($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CPP_TOOLCHAIN_INFO_PEER
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS)
    #.STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("c", SRC, SRCFLAGS...) {
    .CMD=$_SRC_c_new($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CPP_TOOLCHAIN_INFO_PEER
    .SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $_ADD_EXTRA_FLAGS($SRCFLAGS $USER_CONLYFLAGS $USER_CONLYFLAGS_GLOBAL)
    #.STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("m", SRC, SRCFLAGS...) {
    .CMD=$_SRC(c $SRC $SRCFLAGS)
}

_MASM_SEM=target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} \
         && dir_macroses-ITEM && dir_macroses-macro curdir_masm_flags && dir_macroses-args ${MASMFLAGS}
_YASM_SEM=target_macroses-ITEM && target_macroses-macro target_yasm_source && target_macroses-args PRIVATE ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $YASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS ${pre=-P :PREINCLUDES} ${hide;input:"build/scripts/run_tool.py"} \
         && platform_vars-YASM_FLAGS "-f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} $_YASM_PLATFORM_FLAGS_VALUE -D ${pre=_;suf=_:HARDWARE_TYPE} -D _YASM_ $ASM_PREFIX_VALUE $_YASM_PREDEFINED_FLAGS_VALUE" \
         && project_languages ASM \
         && conan-tool_requires yasm/1.3.0 && conan-imports 'bin, *yasm* -> ./bin' && conan-imports 'bin, ytasm* -> ./bin'
_ASM_SEM=target_macroses-ITEM && target_macroses-macro target_yasm_source && target_macroses-args PRIVATE ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} $YASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS ${hide;input:"build/scripts/run_tool.py"} \
        && platform_vars-YASM_FLAGS "-f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} ${join= :_YASM_PLATFORM_FLAGS_VALUE} -D ${pre=_;suf=_:HARDWARE_TYPE} -D _YASM_ $ASM_PREFIX_VALUE ${join= :_YASM_PREDEFINED_FLAGS_VALUE}" \
        && project_languages ASM \
        && conan-tool_requires yasm/1.3.0 && conan-imports 'bin, *yasm* -> ./bin' && conan-imports 'bin, ytasm* -> ./bin'
# tag:src-processing
macro _SRC("masm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_masm($SRC $SRCFLAGS)
    .SEM=$_MASM_SEM
}

# tag:src-processing
macro _SRC("yasm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_yasm($SRC $SRCFLAGS PREINCLUDES $YASM_PREINCLUDES_VALUE)
    .STRUCT_CMD=yes
    .SEM=$_YASM_SEM
}

# tag:src-processing
macro _SRC("asm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_ASM($SRC $SRCFLAGS PREINCLUDES $YASM_PREINCLUDES_VALUE)
    .STRUCT_CMD=yes
    .SEM=$_ASM_SEM
    .STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("lua", SRC, SRCFLAGS...) {
    .CMD=${cwd:LUAJIT_PATH} ${tool:"contrib/libs/luajit/compiler"} -b -g ${input:SRC} ${SRCFLAGS} ${global;output;suf=.o:SRC} ${hide;kv:"p LJ"} ${hide;kv:"pc light-cyan"}
    .STRUCT_CMD=yes
    .PEERDIR=$LUAJIT_PATH
}

when ($MSVC == "yes") {
    NVCC_STD=/std:c++${NVCC_STD_VER}
}
otherwise {
    NVCC_STD=-std=c++${NVCC_STD_VER}
}

# tag:src-processing
macro _SRC("cu", SRC, SRCFLAGS...) {
    .CMD=$_SRC_CU_CMD
    .SEM=target_options-privates-ITEM && target_options-privates-option target_cuda_sources && target_options-privates-args ${input:SRC} ${hide;output;suf=${OBJ_SUF}.o:SRC} && platform_vars-CMAKE_CUDA_STANDARD ${quo:NVCC_STD_VER} && target_macroses-ITEM && target_macroses-macro target_cuda_flags && target_macroses-args $CUDA_NVCC_FLAGS && target_macroses-ITEM && target_macroses-macro target_cuda_cflags && target_macroses-args $USER_CXXFLAGS $SRCFLAGS $_SEM_EXTRA_CXX_FLAGS
    .STRUCT_CMD=yes
    .PEERDIR=$_SRC_CU_PEERDIR
}

# tag:src-processing
macro _SRC("fbs", SRC, SRCFLAGS...) {
    .CMD=$FBS_CMD($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
    .SEM=$FBS_CMD($SRC $SRCFLAGS)
    .STRUCT_SEM=yes
}

# tag:src-processing
macro _SRC("fbs64", SRC, SRCFLAGS...) {
    .CMD=$_CPP_FLATC64_CMD($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("pysrc", SRC, SRCFLAGS...) {
    .CMD=$_SRC_PYSRC($SRC $SRCFLAGS)
    .STRUCT_CMD=yes
}

# tag:src-processing
# This triggers configure error in attempt to add `ya.make` to SRCS macro or apply automatic processing by extension from codegen
macro _SRC("make", SRC, SRCFLAGS...) {
    .CMD=
}

@import "${CONF_ROOT}/conf/bison_lex.conf"

# tag:src-processing
macro _SRC_py2src(SRC, SRCFLAGS...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON3 ${input:"build/scripts/compile_pysrc.py"} --input ${input:SRC} --output ${output;suf=.py2_raw.cpp;noext:SRC} --rescompiler ${tool:"tools/rescompiler"} py2 --python $(PYTHON)/python --py_compile ${input:"build/scripts/py_compile.py"} ${hide;kv:"p P2"} ${hide;kv:"pc light-green"}
}

# tag:src-processing
macro _SRC_py3src(SRC, SRCFLAGS...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON3 ${input:"build/scripts/compile_pysrc.py"} --input ${input:SRC} --output ${output;suf=.py3_raw.cpp;noext:SRC} --rescompiler ${tool:"tools/rescompiler"} py3 --pycc ${tool:"tools/py3cc"} ${hide;kv:"p P3"} ${hide;kv:"pc light-green"}
}

# tag:src-processing python-specific
when ($PYTHON3 == "yes") {
    _SRC_PYSRC_CMDLINE=$_SRC_py3src($SRC $SRCFLAGS)
}
elsewhen ($PYTHON2 == "yes") {
    _SRC_PYSRC_CMDLINE=$_SRC_py2src($SRC $SRCFLAGS)
}
otherwise {
    _SRC_PYSRC_CMDLINE=
}

# tag:src-processing tag:python-specific
macro _SRC_PYSRC(SRC, SRCFLAGS...) {
    .CMD=$_SRC_PYSRC_CMDLINE
}

# tag:src-processing
macro _SRC_c_nodeps(SRC, OUTFILE, INC...) {
     # this macro is used by link commands; TODO switch to the new engine after those
     .CMD=$_SRC_C_NODEPS_CMD
}

# Custom flags for generated cpp-files
#
# ragel5 and ragel6 generated terrible code which makes use of goto's in switch statements.
# This triggers -Werror-implicit-fallthrough due to `unannotated fall-through between switch labels`.
#
# cython generated code also fails to pass this diagnostics due to `fallthrough annotation in unreachable code`.
# We use cython==0.29.26 at the time. This issue might be fixed in further versions.
#
# flags -fno-profile-instr-generate -fno-coverage-mapping needed to always disable coverage for .pyx, .rl5, .rl6
# generated sources
## tag:src-processing
when ($CLANG == "yes") {
    _LANG_CFLAGS_RL=-Wno-implicit-fallthrough $_DISABLE_CLANG_COVERAGE_CFLAGS
    _LANG_CFLAGS_SWG=-Wno-deprecated-declarations $_DISABLE_CLANG_COVERAGE_CFLAGS
    _LANG_CFLAGS_LEX=-Wno-unused-variable $_DISABLE_CLANG_COVERAGE_CFLAGS
    _LANG_CFLAGS_BISON=-Wno-unused-but-set-variable -Wno-deprecated-copy $_DISABLE_CLANG_COVERAGE_CFLAGS
    _LANG_CFLAGS_ANTLR=-Wno-unused-variable $_DISABLE_CLANG_COVERAGE_CFLAGS
}
otherwise {
    _LANG_CFLAGS_RL=-Wno-implicit-fallthrough
    _LANG_CFLAGS_SWG=-Wno-deprecated-declarations
    _LANG_CFLAGS_LEX=-Wno-unused-variable
    _LANG_CFLAGS_BISON=-Wno-unused-but-set-variable -Wno-deprecated-copy
    _LANG_CFLAGS_ANTLR=-Wno-unused-variable
}

# tag:src-processing
# ymake bug workaround: variables followed a macros call in .CMD are not substituted and are placed in result as is
# Pack macro call into a variable and use it in _SRC_CPP_CMD instead of macro call
_LANG_CFLAGS_VALUE_NEW=
when ($CLANG == "yes" || $CLANG_CL == "yes" || $GCC == "yes") {
    _LANG_CFLAGS_VALUE_NEW=\
        ${pre=$_LANG_CFLAGS_BISON;clear;ext=.y;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_BISON;clear;ext=.ypp;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_RL;clear;ext=.rl5;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_RL;clear;ext=.rl6;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_RL;clear;ext=.pyx;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_SWG;clear;ext=.swg;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_LEX;clear;ext=.l;noext;input:SRC} \
        ${pre=$_LANG_CFLAGS_ANTLR;clear;ext=.g4;noext;input:SRC}
}

# Allows to add single compilation unit name to the node's 'kv' section.
# This is used by the coverage machinery to instrument only the necessary sources
# when --coverage-prefix-filter <rootrelpath> is specified. For more info see DEVTOOLSSUPPORT-16891
SCU_NAME_KV_NEW=
SCU_NAME_KV_NEW_BODY=scu_name ${input:SRC}
when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no" && $USE_SCU_VALUE == "yes") {
    SCU_NAME_KV_NEW=${hide;kv:SCU_NAME_KV_NEW_BODY}
}

macro _ADD_SCU_NAME_NEW(KV_VAL) {
    .CMD=$SCU_NAME_KV_NEW
}

# tag:src-processing
macro _SRC_cpp_new(SRC, COMPILE_OUT_SUFFIX="", SRCFLAGS...) {
    .CMD=$_SRC_CPP_CMD_NEW && $_ADD_SCU_NAME_NEW(${input:SRC})
}

# tag:src-processing
macro _SRC_c_new(SRC, COMPILE_OUT_SUFFIX="", SRCFLAGS...) {
    .CMD=$_SRC_C_CMD_NEW $_ADD_SCU_NAME_NEW(${input:SRC})
}

# tag:src-processing
macro _SRC_m(SRC, SRCFLAGS...) {
    .CMD=$_SRC_M_CMD
}

# tag:src-processing
macro _SRC_masm(SRC, SRCFLAGS...) {
    .CMD=$_SRC_MASM_CMD
}

# tag:lua-specific
### @usage: COMPILE_LUA(Src, [NAME <import_name>])
###
### Compile LUA source file to object code using LUA 2.0
### Optionally override import name which is by default reflects Src name
macro COMPILE_LUA(Src, NAME="") {
    .CMD=$_SRC(lua $Src ${pre=-n :NAME})
    #.STRUCT_CMD=yes
}

# tag:lua-specific
### @usage: _SRC_lua_21(SRC [SRCFLAGS...]) # internal
###
### Compile LUA source file to object code using LUA 2.1
macro _SRC_lua_21(SRC, SRCFLAGS...) {
    .CMD=${cwd:LUAJIT_21_PATH} ${tool:"contrib/libs/luajit_21/compiler"} -b -g ${input:SRC} ${SRCFLAGS} ${global;output;suf=.o:SRC} ${hide;kv:"p LJ"} ${hide;kv:"pc light-cyan"}
    .PEERDIR=$LUAJIT_21_PATH
}

# tag:lua-specific
### @usage: COMPILE_LUA_21(Src, [NAME <import_name>])
###
### Compile LUA source file to object code using LUA 2.1
### Optionally override import name which is by default reflects Src name
macro COMPILE_LUA_21(Src, NAME="") {
    .CMD=$_SRC_lua_21($Src ${pre=-n :NAME})
    .STRUCT_CMD=yes
}

# tag:lua-specific
### @usage: _SRC_lua_openresty(SRC [SRCFLAGS...]) # internal
###
### Compile LUA source file to object code using OpenResty LUA 2.1
macro _SRC_lua_openresty(SRC, SRCFLAGS...) {
    .CMD=${cwd:LUAJIT_OPENRESTY_PATH} ${tool:"contrib/libs/luajit_openresty/compiler"} -b -g ${input:SRC} ${SRCFLAGS} ${global;output;suf=.o:SRC} ${hide;kv:"p LJ"} ${hide;kv:"pc light-cyan"}
    .PEERDIR=$LUAJIT_OPENRESTY_PATH
}

# tag:lua-specific
### @usage: COMPILE_LUA_OPENRESTY(Src, [NAME <import_name>])
###
### Compile LUA source file to object code using OpenResty LUA 2.1
### Optionally override import name which is by default reflects Src name
macro COMPILE_LUA_OPENRESTY(Src, NAME="") {
    .CMD=$_SRC_lua_openresty($Src, ${pre=-n :NAME})
}

GETTEXT_KEEP_PATH=no
_MO_OUTPUT=
when ($GETTEXT_KEEP_PATH == "yes") {
    _MO_OUTPUT=${noauto;norel;output;suf=.mo;noext:SRC}
}
otherwise {
    _MO_OUTPUT=${noauto;tobindir;output;suf=.mo;nopath;noext:SRC}
}

# tag:src-processing
macro _SRC("po", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"contrib/tools/python/src/Tools/i18n/msgfmt.py"} -o $_MO_OUTPUT ${input:SRC} ${hide;kv:"p PO"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:ydl-specific
YDL_FLAGS= --force-color -I ${ARCADIA_ROOT}
YDL_DESC_FLAGS=

# tag:src-processing tag:ydl-specific
macro _SRC("ydl", SRC, SRCFLAGS...) {
    .CMD=${tool:"statbox/ydl/compiler/tooling/ydl/bin"} c $YDL_FLAGS --cpp-output-header ${output;suf=.h:SRC} --cpp-output-source ${output;suf=.cpp:SRC} ${input:SRC} ${hide;output_include:"statbox/ydl/runtime/cpp/gen_support/standard_includes.h"} ${hide;kv:"p YDL"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .PEERDIR+=statbox/ydl/runtime/cpp
}

# tag:ydl-specific
### @usage: BUILD_YDL_DESC(Input Symbol Output)
###
### Generate a descriptor for a Symbol located in a ydl module Input, and put it to the file Output.
###
### @example:
###
###     PACKAGE()
###         BUILD_YDL_DESC(../types.ydl Event Event.ydld)
###     END()
###
### This will parse file ../types.ydl, generate a descriptor for a symbol Event defined in the said file, and put the descriptor to the Event.ydld.
macro BUILD_YDL_DESC(Input, Symbol, Output) {
    .CMD=${tool:"statbox/ydl/compiler/tooling/ydl/bin"} ti $YDL_FLAGS $YDL_DESC_FLAGS -o ${noauto;output:Output} ${input:Input} ${Symbol} ${hide;kv:"p YDL"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:ydl-specific
### @usage: YDL_DESC_USE_BINARY()
###
### Used in conjunction with BUILD_YDL_DESC. When enabled, all generated descriptors are binary.
###
### @example:
###
###     PACKAGE()
###         YDL_DESC_USE_BINARY()
###         BUILD_YDL_DESC(../types.ydl Event Event.ydld)
###     END()
###
### This will generate descriptor Event.ydld in a binary format.
macro YDL_DESC_USE_BINARY() {
    YDL_DESC_FLAGS_BINARY= --binary
    SET_APPEND(YDL_DESC_FLAGS $YDL_DESC_FLAGS_BINARY)
}

### @usage: SRC(File Flags...)
###
### Compile single file with extra Flags.
### Compilation is driven by the last extension of the File and Flags are specific to corresponding compilation command
macro SRC(FILE, FLAGS...) {
    _SRC(${lastext:FILE} $FILE $FLAGS)
}

### @usage: SRCS(<[GLOBAL] File> ...)
###
### Source files of the project. Files are built according to their extension and put int module output or fed to ultimate PROGRAM/DLL depending on GLOBAL presence.
### Arcadia Paths from the root and is relative to the project's LIST are supported
###
### GLOBAL marks next file as direct input to link phase of the program/shared library project built into. This prevents symbols of the file to be excluded by linker as unused.
### The scope of the GLOBAL keyword is the following file (that is, in the case of SRCS(GLOBAL foo.cpp bar.cpp) global will be only foo.cpp)
###
### @example:
###
###     LIBRARY(test_global)
###         SRCS(GLOBAL foo.cpp)
###     END()
###
### This will produce foo.o and feed it to any PROGRAM/DLL module transitively depending on test_global library. The library itself will be empty and won't produce .a file.
macro SRCS(FILES...) {
    foreach (FILE : $FILES) {
        _SRC(${lastext:FILE} $FILE)
    }
}

# tag:c-specific
macro _SRC_C_CUSTOM_FLAGS(SRC, COMPILE_OUT_SUFFIX, CUSTOM_FLAGS...) {
    .CMD=$_SRC_c_new($SRC COMPILE_OUT_SUFFIX ${COMPILE_OUT_SUFFIX} ${CUSTOM_FLAGS})
    .SEM=target_macroses-ITEM && target_macroses-macro target_sources_custom && target_macroses-args $COMPILE_OUT_SUFFIX SRCS ${input:SRC} ${hide;output;suf=${COMPILE_OUT_SUFFIX}.o:SRC} CUSTOM_FLAGS $CUSTOM_FLAGS $USER_CONLYFLAGS $USER_CONLYFLAGS_GLOBAL
    .STRUCT_CMD=yes
}

macro _SRC_CPP_CUSTOM_FLAGS(SRC, COMPILE_OUT_SUFFIX, CUSTOM_FLAGS...) {
    .CMD=$_SRC_cpp_new($SRC COMPILE_OUT_SUFFIX ${COMPILE_OUT_SUFFIX} ${CUSTOM_FLAGS})
    .SEM=target_macroses-ITEM && target_macroses-macro target_sources_custom && target_macroses-args $COMPILE_OUT_SUFFIX SRCS ${input:SRC} ${hide;output;suf=${COMPILE_OUT_SUFFIX}.o:SRC} CUSTOM_FLAGS $CUSTOM_FLAGS
    .STRUCT_CMD=yes
}


# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Defenition of generic macro. Report an error that the File with Ext is not
### supported by macro MacroName if no appropriate macro specialization is found.
macro _SRC_CUSTOM_C_CPP(EXT, MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    MESSAGE(FATAL_ERROR macro [[alt1]]$MACRO_NAME[[rst]] does not support files with [[imp]].$EXT[[rst]] extension)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single C file (with .c extension)
macro _SRC_CUSTOM_C_CPP("c", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_C_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .cpp extension)
macro _SRC_CUSTOM_C_CPP("cpp", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .cxx extension)
macro _SRC_CUSTOM_C_CPP("cxx", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .cc extension)
macro _SRC_CUSTOM_C_CPP("cc", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_CUSTOM_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_CUSTOM_C_CPP which compiles a single Cpp file (with .C extension)
macro _SRC_CUSTOM_C_CPP("C", MACRO_NAME, FILE, COMPILE_OUT_SUFFIX, FLAGS...) {
    _SRC_CPP_CUSTOM_FLAGS($FILE $COMPILE_OUT_SUFFIX $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_SSE2(File Flags...)
###
### Compile a single C/C++ file with SSE2 and additional Flags
macro SRC_C_SSE2(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE2 $FILE .sse2 $SSE2_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_SSE3(File Flags...)
###
### Compile a single C/C++ file with SSE3 and additional Flags
macro SRC_C_SSE3(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE3 $FILE .sse3 $SSE3_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_SSSE3(File Flags...)
###
### Compile a single C/C++ file with SSSE3 and additional Flags
macro SRC_C_SSSE3(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSSE3 $FILE .ssse3 $SSSE3_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_SSE4(File Flags...)
###
### Compile a single C/C++ file with SSE4 and additional Flags
macro SRC_C_SSE4(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE4 $FILE .sse4 $SSE4_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_SSE41(File Flags...)
###
### Compile a single C/C++ file with SSE4.1 and additional Flags
macro SRC_C_SSE41(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_SSE41 $FILE .sse41 $SSE41_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_AVX(File Flags...)
###
### Compile a single C/C++ file with AVX and additional Flags
macro SRC_C_AVX(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AVX $FILE .avx $AVX_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_AVX2(File Flags...)
###
### Compile a single C/C++ file with AVX2 and additional Flags
macro SRC_C_AVX2(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AVX2 $FILE .avx2 $AVX2_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_AVX512(File Flags...)
###
### Compile a single C/C++ file with AVX512 and additional Flags
macro SRC_C_AVX512(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AVX512 $FILE .avx512 $AVX512_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_AMX(File Flags...)
###
### Compile a single C/C++ file with AVX512 and additional Flags
macro SRC_C_AMX(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_AMX $FILE .amx $AMX_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific tag:cpu
### @usage: SRC_C_XOP(File Flags...)
###
### Compile a single C/C++ file with (an AMD-specific instruction set,
### see https://en.wikipedia.org/wiki/XOP_instruction_set) and additional Flags
macro SRC_C_XOP(FILE, FLAGS...) {
    _SRC_CUSTOM_C_CPP(${lastext:FILE} SRC_C_XOP $FILE .xop $XOP_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Defenition of generic macro. Report an error that the File with Ext is not
### supported by macro MacroName if no appropriate macro specialization is found.
macro _SRC_STRICT_C_CPP(EXT, MACRO_NAME, FILE, FLAGS...) {
    MESSAGE(FATAL_ERROR macro [[alt1]]$MACRO_NAME[[rst]] does not support files with [[imp]].$EXT[[rst]] extension)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single C file (with .c extension)
macro _SRC_STRICT_C_CPP("c", MACRO_NAME, FILE, FLAGS...) {
    _SRC(c $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .cpp extension)
macro _SRC_STRICT_C_CPP("cpp", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .cxx extension)
macro _SRC_STRICT_C_CPP("cxx", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .cc extension)
macro _SRC_STRICT_C_CPP("cc", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: _SRC_STRICT_C_CPP(Ext MacroName File Flags...) # internal
###
### Specialization of genreric macro _SRC_STRICT_C_CPP which compiles a single Cpp file (with .C extension)
macro _SRC_STRICT_C_CPP("C", MACRO_NAME, FILE, FLAGS...) {
    _SRC(cpp $FILE $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: SRC_C_PIC(File Flags...)
###
### Compile a single C/C++ file with -fPIC and additional Flags
macro SRC_C_PIC(FILE, FLAGS...) {
    _SRC_STRICT_C_CPP(${lastext:FILE} SRC_C_PIC $FILE $PIC_CFLAGS $FLAGS)
}

# tag:src-specific tag:cpp-specific
### @usage: SRC_C_NO_LTO(File Flags...)
###
### Compile a single C/C++ file with link-time-optimization disabling and additional Flags
macro SRC_C_NO_LTO(FILE, FLAGS...) {
    _SRC_STRICT_C_CPP(${lastext:FILE} SRC_C_NO_LTO $FILE $NO_LTO_CFLAGS $FLAGS)
}

# tag:python-processing tag:cython
# TODO: use it in [.pyx] cmd
### @usage: BUILDWITH_CYTHON_CPP(Src Options...)
###
### Generates .cpp file from .pyx.
macro BUILDWITH_CYTHON_CPP(Src, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} -o ${tobindir;output;suf=${OBJ_SUF}.cpp:Src} $CYTHON_OUTPUT_INCLUDES ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_options-privates-ITEM && target_options-privates-option target_cython_sources && target_options-privates-args ${input:Src} ${hide;tobindir;output;suf=.fake.o:Src} && target_macroses-ITEM && target_macroses-macro target_cython_options && target_macroses-args $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} && target_macroses-ITEM && target_macroses-macro target_cython_include_directories && target_macroses-args $_CYTHON__INCLUDE && target_macroses-ITEM && target_macroses-macro set_python_type_for_cython && target_macroses-args $PYTHON_TYPE_FOR_CYTHON
    .STRUCT_SEM=yes
    ADDINCL($_CYTHON_SYS_INCLUDES)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_CPP_DEP(Src Dep Options...) # internal
###
### Generates .cpp file from .pyx and attach extra input Dep.
### If Dep changes the .cpp file will be re-generated.
macro _BUILDWITH_CYTHON_CPP_DEP(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${hide;input:Dep} -o ${tobindir;output;suf=${OBJ_SUF}.cpp:Src} $CYTHON_OUTPUT_INCLUDES ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_options-privates-ITEM && target_options-privates-option target_cython_sources && target_options-privates-args ${input:Src} ${hide;input:Dep} ${hide;tobindir;output;suf=.fake.o:Src} && target_macroses-ITEM && target_macroses-macro target_cython_options && target_macroses-args $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} && target_macroses-ITEM && target_macroses-macro target_cython_include_directories && target_macroses-args $_CYTHON__INCLUDE && target_macroses-ITEM && target_macroses-macro set_python_type_for_cython && target_macroses-args $PYTHON_TYPE_FOR_CYTHON
    ADDINCL($_CYTHON_SYS_INCLUDES)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_CPP_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_CPP without .pyx infix and with cdef public .h file.
macro _BUILDWITH_CYTHON_CPP_H(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT_H $CYTHON_OPTIONS ${Options} --cplus ${CYTHON_CPP_OUTPUT_INCLUDES} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${hide;input:Dep} -o ${tobindir;output;suf=.cpp;noext:Src} ${hide;addincl;tobindir;output;suf=.h;noext:Src} ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    ADDINCL($_CYTHON_SYS_INCLUDES)
}


# tag:python-processing tag:cython
### @usage: BUILDWITH_CYTHON_C(Src Options...)
###
### Generates .c file from .pyx.
macro BUILDWITH_CYTHON_C(Src, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} -o ${tobindir;output;suf=${OBJ_SUF}.c:Src} $CYTHON_OUTPUT_INCLUDES ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_options-privates-ITEM && target_options-privates-option target_cython_sources && target_options-privates-args ${input:Src} ${hide;tobindir;output;suf=.fake.o:Src} && target_macroses-ITEM && target_macroses-macro target_cython_options && target_macroses-args $CYTHON_OPTIONS ${Options} ${CYTHON_OUTPUT_INCLUDES} && target_macroses-ITEM && target_macroses-macro target_cython_include_directories && target_macroses-args $_CYTHON__INCLUDE && target_macroses-ITEM && target_macroses-macro set_python_type_for_cython && target_macroses-args $PYTHON_TYPE_FOR_CYTHON
    ADDINCL($_CYTHON_SYS_INCLUDES)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_C_DEP(Src Dep Options...) # internal
###
### Generates .c file from .pyx and attach extra input Dep.
### If Dep changes the .c file will be re-generated.
macro _BUILDWITH_CYTHON_C_DEP(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${hide;input:Dep} -o ${tobindir;output;suf=${OBJ_SUF}.c:Src} $CYTHON_OUTPUT_INCLUDES ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_options-privates-ITEM && target_options-privates-option target_cython_sources && target_options-privates-args ${input:Src} ${hide;input:Dep} ${hide;tobindir;output;suf=.fake.o:Src} && target_macroses-ITEM && target_macroses-macro target_cython_options && target_macroses-args $CYTHON_OPTIONS ${Options} ${CYTHON_OUTPUT_INCLUDES} && target_macroses-ITEM && target_macroses-macro target_cython_include_directories && target_macroses-args $_CYTHON__INCLUDE && target_macroses-ITEM && target_macroses-macro set_python_type_for_cython && target_macroses-args $PYTHON_TYPE_FOR_CYTHON
    ADDINCL($_CYTHON_SYS_INCLUDES)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_C_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_C without .pyx infix and with cdef public .h file.
macro _BUILDWITH_CYTHON_C_H(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT_H $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${hide;input:Dep} -o ${tobindir;output;suf=.c;noext:Src} ${hide;addincl;tobindir;output;suf=.h;noext:Src} $CYTHON_OUTPUT_INCLUDES ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    ADDINCL($_CYTHON_SYS_INCLUDES)
}

# tag:python-processing tag:cython tag:internal
### @usage: _BUILDWITH_CYTHON_C_API_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_C_H with cdef api _api.h file.
macro _BUILDWITH_CYTHON_C_API_H(Src, Dep, Options...) {
    .CMD=$RUN_CYTHON_SCRIPT_H $CYTHON_OPTIONS ${Options} ${pre=-I:_CYTHON__INCLUDE} ${input:Src} ${hide;input:Dep} -o ${tobindir;output;suf=.c;noext:Src} ${hide;addincl;tobindir;output;suf=.h;noext:Src} ${hide;addincl;tobindir;output;defext=_api.h;noext:Src} $CYTHON_OUTPUT_INCLUDES ${hide;kv:"p CY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    ADDINCL($_CYTHON_SYS_INCLUDES)
}

### @usage: BUILDWITH_RAGEL6(Src Options...)
###
### Compile .rl file using Ragel6.
macro BUILDWITH_RAGEL6(Src, Options...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel6"} $RAGEL6_FLAGS ${Options} -I${ARCADIA_ROOT} -o ${output;defext=.rl6.cpp;nopath;noext:Src} ${input:Src} ${hide;kv:"p R6"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:python-processing tag:internal
# TODO: use it in [.pyx] cmd
### @usage: _PY_REGISTER() # internal
###
### Register Python 2.x module in internal resource file system. Arcadia Python 2.x importer will be retrieve these on import directive.
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY_REGISTER(Func) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_py_reg.py"} $Func ${noauto;output;suf=.reg.cpp:Func} ${hide;kv:"p PY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    SRCS(GLOBAL $Func.reg.cpp)
}

# tag:python-processing tag:internal
### @usage: _PY3_REGISTER() # internal
###
### Register Python 3.x module in internal resource file system. Arcadia Python 3.x importer will be retrieve these on import directive
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY3_REGISTER(Func) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_py3_reg.py"} $Func ${noauto;output;suf=.reg3.cpp:Func} ${hide;kv:"p PY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    SRCS(GLOBAL $Func.reg3.cpp)
}

# tag:python-processing tag:internal
### @usage: _PY_COMPILE_BYTECODE(SrcX Src) # internal
###
### Compile Python 2.x .py source file into Arcadia binary form suitable for PY2_PROGRAM
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY_COMPILE_BYTECODE(SrcX, Src, Dst) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/py_compile.py"} $SrcX ${input:Src} ${noauto;output;suf=.yapyc:Dst} ${hide;kv:"p PY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

# tag:python-processing tag:internal
### @usage: _PY3_COMPILE_BYTECODE(SrcX Src) # internal
###
### Compile Python 3.x .py source file into Arcadia binary form suitable for PY3_PROGRAM
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY3_COMPILE_BYTECODE(SrcX, Src, Dst) {
    .CMD=${env:"PYTHONHASHSEED=0"} ${tool:"tools/py3cc"} $SrcX ${input:Src} ${noauto;output;suf=.yapyc3:Dst} ${hide;kv:"p PY"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

macro _ARCHIVE_SEM_HELPER(FLAGS[], OUT, Files...) {
    .SEM=custom_runs-ITEM && custom_runs-outputs ${OUT} && custom_runs-depends $ARCH_TOOL ${join= :Files} && custom_runs-command $ARCH_TOOL $FLAGS ${suf=\::Files} -o ${OUT}
}

### @usage: ARCHIVE_ASM(NAME archive_name files...)
###
### Similar to the macro ARCHIVE, but:
### 1. works faster and it is better to use for large files.
### 2. Different syntax (see examples in codesearch or users/pg/tests/archive_test)
macro ARCHIVE_ASM(NAME="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q $DONTCOMPRESS ${suf=\:;input:Files} -o ${output;suf=$OBJ_SUF.rodata:NAME} ${hide;kv:"p AR"} ${hide;kv:"pc light-cyan"}
    .STRUCT_CMD=yes
    .SEM=$_ARCHIVE_SEM_HELPER(${output;suf=$OBJ_SUF.rodata:NAME} ${input:Files} FLAGS -q $DONTCOMPRESS)
    .STRUCT_SEM=yes
}

# tag:yweb-specific
macro PIRE_INLINE_CMD(SRC) {
   .CMD=${tool:"library/cpp/regex/pire/inline"} -o ${output:SRC} ${input:SRC} ${hide;output_include:SRC} ${hide;kv:"p PI"} ${hide;kv:"pc yellow"}
   .STRUCT_CMD=yes
}

# tag:yweb-specific
macro PIRE_INLINE(FILES...) {
    foreach (FILE : $FILES) {
        PIRE_INLINE_CMD($FILE)
    }
}

### @usage: ARCHIVE(archive_name [DONT_COMPRESS] files...)
###
### Add arbitrary data to a modules. Unlike RESOURCE macro the result should be futher processed by othet macros in the module.
###
### Example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a1ispolzujjtekomanduarchive
macro ARCHIVE(NAME="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q -x $DONTCOMPRESS ${suf=\:;input:Files} -o ${addincl;noauto;output:NAME} ${hide;kv:"p AR"} ${hide;kv:"pc light-red"}
    .STRUCT_CMD=yes
    .SEM=$_ARCHIVE_SEM_HELPER(${addincl;noauto;output:NAME} ${input:Files} FLAGS -q -x $DONTCOMPRESS) && target_options-privates-ITEM && target_options-privates-option target_sources && target_options-privates-args $BINDIR/$NAME
    .STRUCT_SEM=yes
}

### @usage: ARCHIVE_BY_KEYS(archive_name key [DONT_COMPRESS] files...)
###
### Add arbitrary data to a module be accessible by specified key.
### Unlike RESOURCE macro the result should be futher processed by othet macros in the module.
###
### Example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a1ispolzujjtekomanduarchive
macro ARCHIVE_BY_KEYS(NAME="", KEYS="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q -x $DONTCOMPRESS ${input:Files} -k $KEYS -o ${addincl;noauto;output:NAME} ${hide;kv:"p AR"} ${hide;kv:"pc light-red"}
    .STRUCT_CMD=yes
}

#scripts

#special commands
BUILDVERSION_SCRIPT=build/scripts/build_info_gen.py
SVNVERSION_JAVA_MARKER=output-java-class
SVNVERSION_GO_MARKER=output-go
VCS_C_OBJ=$BINDIR/__vcs_version__.c$OBJECT_SUF
VCS_C_OBJ_RR=$MODDIR/__vcs_version__.c$OBJECT_SUF
VCS_C=$BINDIR/__vcs_version__.c
VCS_GO=$BINDIR/__vcs_version__.go
VCS_JAVA=$BINDIR/__vcs_version__.mf
VCS_INFO_DISABLE_CACHE__NO_UID__=
YASM_DEBUG_INFO_DISABLE_CACHE__NO_UID__=
CL_DEBUG_INFO_DISABLE_CACHE__NO_UID__=
CL_MACRO_INFO_DISABLE_CACHE__NO_UID__=
YASM_DEBUG_INFO=
CL_DEBUG_INFO=
CL_MACRO_INFO=
when ($FORCE_VCS_INFO_UPDATE == "yes") {
    VCS_INFO_DISABLE_CACHE__NO_UID__=${hide;kv:"disable_cache"}
}
### Works for pyton too.
GENERATE_VCS_C_INFO_NODEP=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} $(VCS)/vcs.json $VCS_C ${input:"build/scripts/c_templates/svn_interface.c"} $VCS_INFO_DISABLE_CACHE__NO_UID__ && $_SRC_c_nodeps($VCS_C $VCS_C_OBJ $(SOURCE_ROOT))
GENERATE_VCS_GO_INFO_NODEP=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-go $(VCS)/vcs.json $VCS_GO $GO_ARCADIA_PROJECT_PREFIX $VCS_INFO_DISABLE_CACHE__NO_UID__
GENERATE_VCS_JAVA_INFO_NODEP=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-java $(VCS)/vcs.json $VCS_JAVA $VCS_INFO_DISABLE_CACHE__NO_UID__
macro UPDATE_VCS_JAVA_INFO_NODEP(Jar) {
    .CMD=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-java $(VCS)/vcs.json $VCS_JAVA $Jar $VCS_INFO_DISABLE_CACHE__NO_UID__
}

VCS_INFO_FILE=

### @usage: VCS_INFO_FILE([FILE out_file])
###
### Enable saving vcs info as a json-file into PACKAGE
###
### Info is saved to 'vcs_info.json' by default.
### Use FILE parameter if you want another name.
###
### Note: macro can be used only once per module
macro VCS_INFO_FILE(FILE="vcs_info.json") {
    SET(VCS_INFO_FILE $FILE)
}

ADD_VCS_INFO_FILE_CMD=
when ($VCS_INFO_FILE) {
    ADD_VCS_INFO_FILE_CMD=$YMAKE_PYTHON3 ${input:"build/scripts/vcs_info.py"} output-json $(VCS)/vcs.json ${output:VCS_INFO_FILE} $VCS_INFO_DISABLE_CACHE__NO_UID__
}

### @usage: CREATE_BUILDINFO_FOR(GenHdr)
###
### Creates header file to access some information about build specified via configuration variables.
### Unlike CREATE_SVNVERSION_FOR() it doesn't take revion information from VCS, it uses revision and SandboxTaskId passed via -D options to ya make
macro CREATE_BUILDINFO_FOR(GenHdr) {
    .CMD=$YIELD $CXX_COMPILER && $YIELD $CXXFLAGS && $XARGS $YMAKE_PYTHON3 ${input:BUILDVERSION_SCRIPT} ${output:GenHdr} ${hide;kv:"p BI"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"} $SVN_DEPENDS_CACHE__NO_UID__
    .STRUCT_CMD=yes
    .SEM=$RUN_PYTHON3($BUILDVERSION_SCRIPT $GenHdr \\\"\${CMAKE_CXX_COMPILER}\\\" \\\"\${CMAKE_CXX_FLAGS}\\\" OUT $GenHdr)
    #.STRUCT_SEM=yes # for now, keep this layer old-school for deep-replacement purposes
}

DECIMAL_MD5_SCRIPT=build/scripts/decimal_md5.py
DECIMAL_MD5_FIXED=

### @usage: DECIMAL_MD5_LOWER_32_BITS(<fileName> [FUNCNAME funcName] [inputs...])
###
### Generates .cpp file <fileName> with one defined function 'const char* <funcName>() { return "<calculated_md5_hash>"; }'.
### <calculated_md5_hash> will be md5 hash for all inputs passed to this macro.
macro DECIMAL_MD5_LOWER_32_BITS(File, FUNCNAME="", Opts...) {
    .CMD=$YMAKE_PYTHON ${input:DECIMAL_MD5_SCRIPT} --fixed-output=${DECIMAL_MD5_FIXED} --func-name=${FUNCNAME} --lower-bits 32 --source-root=$ARCADIA_ROOT ${context=TEXT;input=TEXT:Opts} ${stdout;output:File} ${hide;kv:"p SV"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
}

# tag:internal
### @usage: CFG_VARS # internal
###
### Mark commands that embed Configuration variables into files
macro CFG_VARS() {
    .GEN_FROM_FILE=yes
}

### @usage: CONFIGURE_FILE(from to)
###
### Copy file with the replacement of configuration variables in form of @ANY_CONF_VAR@ with their values.
### The values are collected during configure stage, while replacement itself happens during build stage.
### Used implicitly for .in-files processing.
macro CONFIGURE_FILE(Src, Dst) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/configure_file.py"} ${input:Src} ${addincl;output:Dst} $CFG_VARS ${hide;kv:"p CF"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=dir_macroses-ITEM && dir_macroses-macro set_vars && dir_macroses-args ${CFG_VARS} && target_commands-ITEM && target_commands-macro configure_file && target_commands-args ${"$S"}/${rootrel;input:Src} ${"$B"}/${rootrel;addincl;output:Dst}
    .STRUCT_SEM=yes
}

# tag:flags
### @usage: LDFLAGS(LinkerFlags...)
###
### Add flags to the link command line of executable or shared library/dll.
### Note: LDFLAGS are always global. When set in the LIBRARY module they will affect all programs/dlls/tests the library is linked into.
### Note: remember about the incompatibility of flags for gcc and cl.
macro LDFLAGS(Flags...) {
    SET_APPEND(LDFLAGS_GLOBAL $Flags)
}

# tag:flags
### @usage: CFLAGS([GLOBAL compiler_flag]* compiler_flags)
###
### Add the specified flags to the compilation command of C and C++ files.
### @params: GLOBAL - Propagates these flags to dependent projects
### Bear in mind that certain flags might be incompatible with certain compilers.
macro CFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CFLAGS $Flags)
}

# tag:flags
### @usage: GLOBAL_CFLAGS(compiler_flags)
###
### Add the specified flags to the compilation command of C and C++ files and propagate these flags to dependent projects
macro GLOBAL_CFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CFLAGS ${pre=GLOBAL :Flags})
}

# tag:flags
### @usage: MASMFLAGS(compiler flags)
### Add the specified flags to the compilation command of .masm files.
macro MASMFLAGS(Flags...) {
   SET_APPEND(MASMFLAGS $Flags)
}

# tag:flags
### @usage: CONLYFLAGS([GLOBAL compiler_flag]* compiler_flags)
### Add the specified flags to the compilation command of .c (but not .cpp) files.
### @params: GLOBAL - Distributes these flags on dependent projects
macro CONLYFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CONLYFLAGS $Flags)
}

# tag:flags
### @usage: CXXFLAGS(compiler_flags)
### Add the specified flags to the compilation command of .cpp (but not .c) files.
macro CXXFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CXXFLAGS $Flags)
}

# tag:flags
### @usage: CUDA_NVCC_FLAGS(compiler flags)
### Add the specified flags to the compile line .cu-files.
macro CUDA_NVCC_FLAGS(Flags...) {
   SET_APPEND(CUDA_NVCC_FLAGS $Flags)
}

CUDA_DEVICE_LINK_LIBRARY_CMD=$NVCC_OLD $NVCC_FLAGS -o ${output;suf=${OBJ_SUF}${NVCC_OBJ_EXT}:"devlink"} -dlink ${input:_NVCC_DEVICE_SRCS} -I$CUDA_TARGET_ROOT/include --compiler-options ${join= :C_FLAGS_PLATFORM} $NVCC_ENV ${hide;kv:"p DL"} ${hide;kv:"pc light-blue"} && $LINK_LIB

### @usage: CUDA_DEVICE_LINK_LIBRARY()
###
### The LIBRARY() module with an additional step with CUDA device linking.
### Use [NVCC_DEVICE_LINK](#macro_NVCC_DEVICE_LINK) macro to specify sources for device link.
module CUDA_DEVICE_LINK_LIBRARY: LIBRARY {
    SET(_LD_LINK_LIB_EXTRA_INPUT ${output;suf=${OBJ_SUF}${NVCC_OBJ_EXT}:"devlink"})
    .CMD=$CUDA_DEVICE_LINK_LIBRARY_CMD
}

# tag:flags
### @usage: NVCC_DEVICE_LINK(file.cu...)
### Run nvcc --device-link on objects compiled from srcs with --device-c.
### This generates a stub object devlink.o that supplies missing pieces for the
### host linker to link relocatable device objects into the final executable.
### This macro can be used only with [CUDA_DEVICE_LINK_LIBRARY](#module_CUDA_DEVICE_LINK_LIBRARY) module.
macro NVCC_DEVICE_LINK(Srcs...) {
    SET_APPEND(_NVCC_DEVICE_SRCS ${suf=${OBJ_SUF}${NVCC_OBJ_EXT}:Srcs})
    .PEERDIR=build/platform/cuda
}

# tag:flags
### @usage: CYTHON_FLAGS(compiler_flags)
### Add the specified flags to the compilation command of .pyx files.
macro CYTHON_FLAGS(Flags...) {
   SET_APPEND(CYTHON_OPTIONS $Flags)
}

### @usage: STRIP()
### Strip debug info from a PROGRAM, DLL or TEST.
### This macro doesn't work in LIBRARY's, UNION's and PACKAGE's.
macro STRIP() {
    ENABLE(STRIP)
}

### @usage: NO_OPTIMIZE()
### Build code without any optimizations (-O0 mode).
macro NO_OPTIMIZE() {
    ENABLE(NO_OPTIMIZE)
}

#TODO(YMAKE-91) read proper compile flags instead of sending explicit flags to semgraph directly
_SEM_EXTRA_CXX_FLAGS=

### @usage: NO_COMPILER_WARNINGS()
### Disable all compiler warnings in the module.
macro NO_COMPILER_WARNINGS() {
    ENABLE(NO_COMPILER_WARNINGS)
    SET(_SEM_EXTRA_CXX_FLAGS "$<IF:$<CXX_COMPILER_ID:MSVC>,,-Wno-everything>")
}

### @usage: NO_WSHADOW()
### Disable C++ shadowing warnings.
macro NO_WSHADOW() {
    ENABLE(NO_WSHADOW)
}

# tag:internal
### @usage: NO_PLATFORM_RESOURCES() # internal
### Exclude dependency on platform resources libraries.
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro NO_PLATFORM_RESOURCES() {
    ENABLE(NOPLATFORM_RESOURCES)
}

# tag:internal tag:codenav
### @usage: NO_CODENAVIGATION() # internal
### Disable codenaviagtion for a module. Needed to avoid PEERDIR loops in codenavigation support.
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro NO_CODENAVIGATION() {
    ENABLE(NOCODENAVIGATION)
}

### @usage: NO_UTIL()
### Build module without dependency on util.
### Note: use this with care. Util most likely will be linked into executable anyway,
### so using util headers/functions/classes may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_UTIL() {
    ENABLE(NOUTIL)
}

### @usage: NO_RUNTIME()
###
### This macro:
### 1. Sets the ENABLE(NOUTIL) + DISABLE(USE_INTERNAL_STL);
### 2. If the project that contains the macro NO_RUNTIME(), peerdir-it project does not contain NO_RUNTIME() => Warning.
### Note: use this with care. Arcadia STL most likely will be linked into executable anyway, so using STL headers/functions/classes
### may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_RUNTIME() {
    SET(USE_ARCADIA_LIBM no)
    NO_UTIL()
    ENABLE(NORUNTIME)
}

### @usage: NO_LIBC()
###
### Exclude dependencies on C++ and C runtimes (including util, musl and libeatmydata).
### Note: use this with care. libc most likely will be linked into executable anyway,
### so using libc headers/functions may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_LIBC() {
    NO_RUNTIME()
    DISABLE(MUSL)
    ENABLE(NOLIBC)
}

### @usage: NO_PLATFORM()
###
### Exclude dependencies on C++ and C runtimes (including util, musl and libeatmydata) and set NO_PLATFORM variable for special processing.
### Note: use this with care. libc most likely will be linked into executable anyway,
### so using libc headers/functions may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_PLATFORM() {
    NO_LIBC()
    ENABLE(NOPLATFORM)
}

# tag:cpp-specific
### @usage: USE_CXX()
###
### Add dependency on C++ runtime
### Note: This macro is inteneded for use in _GO_BASE_UNIT like module when the module is built without C++ runtime by default
macro USE_CXX() {
    DISABLE(NORUNTIME)
}

### @usage: USE_UTIL()
###
### Add dependency on util and C++ runtime
### Note: This macro is intended for use in _GO_BASE_UNIT like module when the module is build without util by default
macro USE_UTIL() {
    USE_CXX()
    DISABLE(NOUTIL)
}

### @usage: USE_NASM()
###
### Build only .asm files with nasm toolchain instead of yasm
### Add to ya.make file ADDINCL(asm ...) with all folders where .asm files include smth
macro USE_NASM() {
    ENABLE(USE_NASM_ASSEMBLER)
    PEERDIR(build/external_resources/nasm)
}

# tag:deprecated
### @usage: NO_JOIN_SRC() # deprecated, does-nothing
### This macro currently does nothing. This is default behavior which cannot be overridden at module level.
macro NO_JOIN_SRC() {
    ENABLE(UNUSED_MACRO)
}

# tag:sanitize
### @usage: NO_SANITIZE()
###
### Disable all sanitizers for the module.
macro NO_SANITIZE() {
    DISABLE(SANITIZER_TYPE)
}

# tag:coverage tag:sanitize
### @usage: NO_SANITIZE_COVERAGE()
###
### Disable lightweight coverage (-fsanitize-coverage) for the module.
### Sanitize coverage is commonly used with fuzzing.
### It might be useful to disable it for libraries that should never
### be the main targets for fuzzing, like libfuzzer library itself.
### Sanitize coverage instrumentation is enabled by the --sanitize-coverage option.
macro NO_SANITIZE_COVERAGE() {
    DISABLE(SANITIZE_COVERAGE)
}

# tag:coverage
### @usage: NO_CLANG_COVERAGE()
###
### Disable heavyweight clang coverage for the module. Clang coverage instrumentation is enabled by the --clang-coverage option.
macro NO_CLANG_COVERAGE() {
    DISABLE(CLANG_COVERAGE)
}

# tag:coverage
### @usage: NO_PROFILE_RUNTIME()
###
### Never link this target with profile runtime. Only should be used for very basic build tools
macro NO_PROFILE_RUNTIME() {
    DISABLE(NEED_PROFILE_RUNTIME)
}

macro NO_CLANG_TIDY() {
    DISABLE(TIDY_ENABLED)
}


### @usage: IWYU_MAPPING_FILE(mapping_file)
###
### Specify a mapping file for IWYU to provide custom mappings for headers.
macro IWYU_MAPPING_FILE(File) {
    SET(IWYU_MAPPING_FILE $File)
}

### @usage: NO_IWYU()
###
### Disable Include What You Use (IWYU) analysis for the module.
macro NO_IWYU() {
    DISABLE(IWYU_ENABLED)
}

# tag:lua-specific
LUAJIT_PATH=${ARCADIA_ROOT}/contrib/libs/luajit
macro _LUAJIT_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_PATH} ${tool:"contrib/libs/luajit/compiler"} -b -g ${input:Src} ${noauto;output:OUT} ${hide;kv:"p LJ"} ${hide;kv:"pc light-cyan"}
}

# tag:lua-specific
LUAJIT_21_PATH=${ARCADIA_ROOT}/contrib/libs/luajit_21
macro _LUAJIT_21_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_21_PATH} ${tool:"contrib/libs/luajit_21/compiler"} -b -g ${input:Src} ${noauto;output:OUT} ${hide;kv:"p LJ"} ${hide;kv:"pc light-cyan"}
   .STRUCT_CMD=yes
}

# tag:lua-specific
LUAJIT_OPENRESTY_PATH=${ARCADIA_ROOT}/contrib/libs/luajit_openresty
macro _LUAJIT_OPENRESTY_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_OPENRESTY_PATH} ${tool:"contrib/libs/luajit_openresty/compiler"} -b -g ${input:Src} ${noauto;output:OUT} ${hide;kv:"p LJ"} ${hide;kv:"pc light-cyan"}
}

### @usage: GENERATE_ENUM_SERIALIZATION(File.h)
###
### Create serialization support for enumeration members defined in the header (String <-> Enum conversions) and compile it into the module.
###
### Documentation: https://wiki.yandex-team.ru/yatool/HowToWriteYaMakeFiles/
macro GENERATE_ENUM_SERIALIZATION(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --include-path ${rootrel;input:File} --output ${output;suf=_serialized.cpp:File} ${hide;from_input;output_include:File} ${hide;output_include:"util/generic/serialized_enum.h"} ${hide;kv:"p EN"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_macroses-ITEM && target_macroses-macro generate_enum_serilization && target_macroses-args ${input:File} ${hide;output;suf=_serialized.o:File} INCLUDE_HEADERS ${rootrel;input:File} ${hide;tool:"tools/enum_parser/enum_parser"}
    PEERDIR(tools/enum_parser/enum_serialization_runtime)
    .STRUCT_SEM=yes
}

### @usage: GENERATE_ENUM_SERIALIZATION_WITH_HEADER(File.h)
###
### Create serialization support for enumeration members defined in the header (String <-> Enum conversions) and compile it into the module
### Provide access to serialization functions via generated header File_serialized.h
###
### Documentation: https://wiki.yandex-team.ru/yatool/HowToWriteYaMakeFiles/
macro GENERATE_ENUM_SERIALIZATION_WITH_HEADER(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --include-path ${rootrel;input:File} --output ${output;suf=_serialized.cpp:File} --header ${output;suf=_serialized.h:File} ${hide;from_input;output_include:File} ${hide;kv:"p EN"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=target_macroses-ITEM && target_macroses-macro generate_enum_serilization && target_macroses-args ${input:File} ${hide;output;suf=_serialized.o:File} GEN_HEADER ${output;suf=_serialized.h:File} INCLUDE_HEADERS ${rootrel;input:File} ${hide;tool:"tools/enum_parser/enum_parser"}
    .STRUCT_SEM=yes
    PEERDIR(tools/enum_parser/enum_serialization_runtime)
}

### @usage: DEB_VERSION(File)
###
### Creates a header file DebianVersion.h define the DEBIAN_VERSION taken from the File.
macro DEB_VERSION(File) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/mkver.py"} ${input:File} ${stdout;output:"DebianVersion.h"} ${hide;kv:"p CL"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

### @usage: NEED_CHECK()
###
### Commits to the project marked with this macro will be blocked by pre-commit check and then will be
### automatically merged to trunk only if there is no new broken build targets in check results.
### The use of this macro is disabled by default.
macro NEED_CHECK(Flags...) {
    # TODO: FIXME
    ENABLE(UNUSED_MACRO)
}

# tag:deprecated
### @usage: NO_NEED_CHECK() # deprecated
###
### Commits to the project marked with this macro will not be affected by higher-level NEED_CHECK macro.
macro NO_NEED_CHECK(Flags...) {
    ENABLE(UNUSED_MACRO)
}

# tag:deprecated
### @usage: NEED_REVIEW() # deprecated
###
### Mark the project as needing review.
### Details can be found here: https://clubs.at.yandex-team.ru/arcadia/6104
macro NEED_REVIEW(Flags...) {
    # TODO: FIXME
    ENABLE(UNUSED_MACRO)
}

### @usage: SUBSCRIBER(UsersOrGroups)
###
### Add observers of the code.
### In the SUBSCRIBER macro you can use:
### 1. login-s from staff.yandex-team.ru
### 2. Review group (to specify the Code-review group need to use the prefix g:)
###
### Note: currently SUBSCRIBER is read only by Arcanum and is not processed by
### the build system. It's planned to be phased out in favor of subcription via a.yaml
macro SUBSCRIBER(Subscribers...) {
    ENABLE(UNUSED_MACRO)
}

MODVER=unknown
### @usage: VERSION(Args...)
###
### Specify version of a module. Currently unused by build system, only informative.
macro VERSION(Flags...) {
    SET(MODVER ${Flags})
}

DATAWORK_SCHEEME_EXPORT_FLAGS=

when ($UNIX == "yes") {
    SCHEEME2_CFLAGS= -E -x c++
}

when ($WIN32 == "yes") {
    SCHEEME2_CFLAGS= /E /TP
}

SCHEEME2_STRUCT_INFO_FLAGS=-f "const static ui32 RecordSig" -u "RecordSig" --gcc44_no_typename --no_complex_overloaded_func_export
### @usage: GEN_SCHEEME2(scheeme_name from_file dependent_files...)
###
### Generates a C++ description for structure(contains the field RecordSig) in the specified file (and connected).
###
### 1. ${scheeme_name}.inc - the name of the generated file.
### 2. Use an environment variable - DATAWORK_SCHEEME_EXPORT_FLAGS that allows to specify flags to tools/structparser
###
### @example:
###
###     SET(DATAWORK_SCHEEME_EXPORT_FLAGS --final_only -m "::")
###
### all options are passed to structparser (in this example --final_only - do not export heirs with public base that contains the required field,,- m "::" only from the root namespace)
### sets in extra option
###
### @example:
###
###     SET(EXTRACT_STRUCT_INFO_FLAGS -f \"const static ui32 RecordSig\"
###         -u \"RecordSig\" -n${scheeme_name}SchemeInfo ----gcc44_no_typename no_complex_overloaded_func_export
###         ${DATAWORK_SCHEEME_EXPORT_FLAGS})
###
### for compatibility with C++ compiler and the external environment.
### See tools/structparser for more details.
macro GEN_SCHEEME2(ScheemeName, FromFile) {
    .CMD=$CXX_COMPILER_OLD $C_FLAGS_PLATFORM -c ${stdout;tmp;suf=.cph:FromFile} $SCHEEME2_CFLAGS ${input:FromFile} ${pre=-I:_C__INCLUDE} $CXXFLAGS -Wno-error && ${tool:"tools/structparser"} -o ${output;suf=.inc:ScheemeName} -n N${ScheemeName}SchemeInfo $SCHEEME2_STRUCT_INFO_FLAGS $DATAWORK_SCHEEME_EXPORT_FLAGS ${tmp;suf=.cph:FromFile} ${stdout;noauto;output;suf=.inc.log:ScheemeName} ${hide;kv:"p SH"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
}

### @usage: SYMLINK(from to)
### Add symlink
macro SYMLINK(From, To) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/symlink.py"} ${dirallowed;input:From} ${noauto;output:To} ${hide;kv:"p LN"} ${hide;kv:"pc light-cyan"}
    #.STRUCT_CMD=yes
}

macro _FMT_INDUCED_DEPS(For, Deps...) {
    .CMD=${hide;induced_deps=$For:Deps}
}

### @usage: PREPARE_INDUCED_DEPS(VAR Type Files...)
###
### Format value for `INDUCED_DEPS` param in certain macros and assign to `VAR`
### This tells that files of Type resulted from code generation macros (not neccessarily directly,
### but in processing chain of generated files) should have extra dependencies from list of Files...
###
### Prominent example here is Cython: one can generate .pyx file that may depend on .pxd and have cimpot from
### certain .h. The former is dependency for .pyx itself, while the latter is dependency for .pyx.cpp
### resulted from Cython-processing of generated pyx. The code ganeration will look like:
### ```
### PREPARE_INDUCED_DEPS(PYX_DEPS pyx imported.pxd)
### PREPARE_INDUCED_DEPS(CPP_DEPS cpp cdefed.h)
### RUN_PYTHON3(generate_pyx.py genereted.pyx OUT generated.pyx INDUCED_DEPS $PYX_DEPS $CPP_DEPS)
### ```
###
### The VAR will basically contain pair of `Type:[Files...]` in a form suitable for passing
### as an element of array parameter. This is needed because language of ya.make doesn't support
### Dict params right now and so it is impossible to directly pass something
### like `{Type1:[Files2...], Type2:[Files2...]}`
###
macro PREPARE_INDUCED_DEPS(VAR, For, Deps...) {
    SET($VAR \$_FMT_INDUCED_DEPS($For $Deps))
}



### Helper macro for DECLARE_IN_DIRS to add proper '/' to non-empty SRCDIR and form proper EXCLUDES
macro _DECL_IN_DIR_GLOB(var_prefix, pattern_suf, SRCDIR="", EXCLBASE="", EXCLUDES[], DIRS[], DUMMY[]) {
    _PATTERN=${pre=${SRCDIR};suf=${pattern_suf}:DIRS}
    _EXCLUDES=${EXCLBASE}**/ya.make ${EXCLBASE}**/a.yaml ${pre=${EXCLBASE}:EXCLUDES}

    _LATE_GLOB(_${var_prefix}_FILES ${_PATTERN} EXCLUDE ${_EXCLUDES})
    SET(${var_prefix}_PATTERN ${_PATTERN})
    SET(${var_prefix}_EXCLUDES ${_EXCLUDES})
}

### @usage: DECLARE_IN_DIRS(var_prefix files_mask DIRS dirs [RECURSIVE] [EXCLUDES excludes] [SRCDIR srcdir])
###
### This macro allow passing content of directories to macros like `RUN_PROGRAM` and `RUN_PYTHON3` as IN parameter.
###
### The content is matched by following rules:
### - The files are looked in <srcdir>. The srcdir is relative to module directory and defaulted to module directory.
### - Inside <srcdir> files are looked in all <dirs>, recursively or not depending on RECURSIVE parameter.
### - Files are matched by file_mask which may contain * or ?.
### - <excludes> are then applied over matched files. Excludes are regular globs including recursive parts support.
###
### Taking `var_prefix` macro declared 4 variables:
### - <var_prefix>_FILES - the file list matched by the macro using rules above. This variable can be passed to `IN` parameter of `RUN_PROGRAM` and alikes.
###                        Also it may be passed escaped as argument to tool/script. See example below.
### - <var_prefix>_PATTERNS - the glob patterns used for match.
### - <var_prefix>_EXCLUDES - exclude patterns from EXCLUDES argument and ones to exclude ya.make and a.yaml
### - <var_prefix>_SRCDIR - value of SRCDIR argument
###
### Parameters:
### - var_prefix - Mandatory prefix of variables the macro declares
### - file_mask - Mandatory glob-like mask for files
###   file_mask should not conatain '**'
### - DIRS dirs - Mandatory list of dirs relative to srcdir or current one in which files should be looked
###   Dirs cannot contain ${ARCADIA_ROOT} (and other similar vars), '..', '*' or '?'.
### - RECURSIVE - Optional request to lookup dirs recursively. Default is non-recursive lookup
### - EXCLUDES excludes - Optional list of globs to exclude from match.
### - SRCDIR srcdir - Optional directory (relative to current one) to apply globs. Default is the current dir.
###   We strongly discourage this, but srcdir may contain '..' or start from ${ARCADIA_ROOT} for root-relative addressing.
###   scrdir cannot contain any of '*' or '?'
###
### Examples:
### ```
### DECLARE_IN_DIRS(TXT *.txt DIRS . EXCLUDE .*.txt **/.*.txt)
### # file list requires escaping as argument
### RUN_PYTHON3(concat.py \${TXT_FILES} IN ${TXT_FILES} STDOUT concatenated.txt)
### ```
###
### ```
### DECLARE_IN_DIRS(ALL_TXT *.txt SRCDIR txt RECURSIVE DIRS design rules EXCLUDE all.txt)
### RUN_PYTHON3(concat_all.py --dirs ${MODDIR}/${ALL_TXT_SRCDIR} --pattern ${ALL_TXT_PATTERNS} --exclude ${ALL_TXT_EXCLUDES} IN ${ALL_TXT_FILES} STDOUT concatenated.txt)
### ```
###
### ```
### DECLARE_IN_DIRS(D_TXT *.txt SRCDIR txt/design EXCLUDE all.txt DIRS .)
### DECLARE_IN_DIRS(R_TXT *.txt SRCDIR txt/rules DIRS .)
### RUN_PYTHON3(concat_all.py --dirs ${MODDIR}/${D_TXT_SRCDIR} ${MODDIR}/${R_TXT_SRCDIR} --patterns ${D_TXT_PATTERNS} ${R_TXT_PATTERNS} --exclude ${D_TXT_EXCLUDES} IN ${D_TXT_FILES} ${R_TXT_FILES} STDOUT concatenated.txt)
### ```
###
### Notes:
### 1. All 'ya.make' and 'a.yaml' files are excluded from match.
### 2. Matched files are never parsed for dependencies even though they shall be passed to IN, not to IN_NOPARSE.
### 3. The list of files expanded late and will not work in macros like SRCS. This macro only meant for use with generating macros like RUN_PROGRAM processing entire matching list with one command.
### 4. We support extended file mask syntax for multiple masks like "(*.cpp|*.h)". However, this will be preserved in <var_prefix>_PATTERNS variable and so tool/script either should support such syntax or
###    or should not rely on value of the variable for actual matching.
### 5. There is known issue with empty match and escaped substitution like `concat.py \${TXT_FILES}`. It may result in weird errors and can be workarounded by extra argument like `concat.py - \${TXT_FILES}`
### 6. EXCLUDES work differently with SRCDIR is specified. Use discriminating tail of SRCDIR in order to match exact files non-recursively.
###    E.g. if SRCDIR is a/b/zz and EXCLUDE is *.x the exclude will work recursively on all matches including zz's child dierctories. To limit match to zz's level use EXCLUDE zz/*.x instead.
### 6. Parameters of macro are somewhat validated and we may add extra checks in the fulture including protection over too broad match.
###
macro DECLARE_IN_DIRS(var_prefix, PATTERN, SRCDIR="", RECURSIVE?"**/":"", EXCLUDES[], DIRS[]) {
    _DECL_IN_DIR_GLOB($var_prefix ${pre=/${RECURSIVE}:PATTERN} ${pre=SRCDIR ;suf=/:SRCDIR} ${pre=EXCLBASE ${ARCADIA_ROOT}/**/ DUMMY :SRCDIR} EXCLUDES ${EXCLUDES} DIRS ${DIRS})

    SET(${var_prefix}_FILES \$_${var_prefix}_FILES)
    SET(${var_prefix}_SRCDIR $SRCDIR)
    VALIDATE_IN_DIRS(${var_prefix}_FILES $PATTERN $SRCDIR -- $DIRS)
}


### @usage: RUN_PROGRAM(tool_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a program from arcadia.
### These macros are similar: RUN_PYTHON3, RUN_LUA, PYTHON.
###
### Parameters:
### - tool_path - Path to the directory of the tool.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
### Note that Tool is always built for the host platform, so be careful to provide that tool can be built for all Arcadia major host platforms (Linux, MacOS and Windows).
macro RUN_PROGRAM(Tool, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV{env}[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} ${tool:Tool} $Args ${hide;input:IN} ${hide;context=TEXT;input=TEXT:IN_NOPARSE} ${hide;input:IN_DEPS} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;tool:TOOL} ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${stdout;output:STDOUT} ${stdout;noauto;output:STDOUT_NOAUTO} ${hide;kv:"p PR"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:IN} ${context=TEXT;input=TEXT:IN_NOPARSE} ${tool:Tool} ${tool:TOOL} && $IF(${not;empty:ENV} THEN custom_runs-env ${ENV}) && custom_runs-command ${tool:Tool} $Args ${pre=> :STDOUT} ${pre=> :STDOUT_NOAUTO} && custom_runs-outputs ${output:OUT} ${noauto;output:OUT_NOAUTO} ${output:STDOUT} ${noauto;output:STDOUT_NOAUTO} && $IF(${not;empty:CWD} THEN custom_runs-cwd ${CWD})
    .STRUCT_SEM=yes
}

# tag:lua-specific
### @usage: RUN_LUA(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a lua script.
### These macros are similar: RUN_PROGRAM, RUN_LUA, PYTHON.
###
### Parameters:
### - script_path - Path to the script.3
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro RUN_LUA(ScriptPath, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $LUA_TOOL ${input:ScriptPath} $Args ${hide;input:IN} ${hide;context=TEXT;input=TEXT:IN_NOPARSE} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;tool:TOOL} ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${stdout;output:STDOUT} ${stdout;noauto;output:STDOUT_NOAUTO} ${hide;kv:"p LU"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
}

# tag:python-specific
### @usage: RUN_PYTHON3(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### Run a python script with prebuilt python3 interpretor built from devtools/huge_python3.
### These macros are similar: RUN_PROGRAM, RUN_LUA, PYTHON.
###
### Parameters:
### - script_path - Path to the script.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - OUT_GLOBAL outputs... - Global output files.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro RUN_PYTHON3(ScriptPath, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], OUT_GLOBAL{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $YMAKE_PYTHON3 ${input:ScriptPath} $Args ${hide;input:IN} ${hide;context=TEXT;input=TEXT:IN_NOPARSE} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;tool:TOOL} ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${hide;global;output:OUT_GLOBAL} ${stdout;output:STDOUT} ${stdout;noauto;output:STDOUT_NOAUTO} ${hide;kv:"p PY"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:IN} ${context=TEXT;input=TEXT:IN_NOPARSE} ${input:ScriptPath} ${tool:TOOL} && $IF(${not;empty:ENV} THEN custom_runs-env ${ENV}) && custom_runs-command python3 ${input:ScriptPath} $Args ${pre=> :STDOUT} ${pre=> :STDOUT_NOAUTO} && custom_runs-outputs ${output:OUT} ${noauto;output:OUT_NOAUTO} ${global;output:OUT_GLOBAL} ${output:STDOUT} ${noauto;output:STDOUT_NOAUTO} && $IF(${not;empty:CWD} THEN custom_runs-cwd ${CWD}) && custom_runs-cmake_packages-ITEM && custom_runs-cmake_packages-name Python3
    .STRUCT_SEM=yes
}

### @usage: RUN_PY3_PROGRAM(tool_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN[_NOPARSE] inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...] [INDUCED_DEPS $VARs...])
###
### When build by ya make - Run a program from arcadia.
### When exporting to other build systems (Cmake, Gradle, ...) - Run a python script __main__.py in tool project. Of course,
### for exporting __main__.py must exists in tool project and must support execute by system Python3
### These macros are similar: RUN_PROGRAM, RUN_PYTHON3, RUN_LUA, PYTHON.
###
### Parameters:
### - tool_path - Path to the directory of the tool.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN[_NOPARSE] inputs... - Input files. NOPARSE inputs are treated as textual and not parsed for dependencies regardless of file extensions.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### - INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                           In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
### Note that Tool is always built for the host platform, so be careful to provide that tool can be built for all Arcadia major host platforms (Linux, MacOS and Windows).
macro RUN_PY3_PROGRAM(Tool, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=$RUN_PROGRAM($Tool                               $Args IN $IN IN_NOPARSE $IN_NOPARSE OUT $OUT OUT_NOAUTO $OUT_NOAUTO TOOL $TOOL OUTPUT_INCLUDES $OUTPUT_INCLUDES INDUCED_DEPS $INDUCED_DEPS STDOUT $STDOUT STDOUT_NOAUTO $STDOUT_NOAUTO CWD $CWD ENV $ENV)
    .STRUCT_CMD=yes
    .SEM=$RUN_PYTHON3(${ARCADIA_ROOT}/${Tool}/__main__.py $Args ${pre=IN :IN} ${pre=IN_NOPARSE :IN_NOPARSE} ${pre=OUT :OUT} ${pre=OUT_NOAUTO :OUT_NOAUTO} ${pre=TOOL :TOOL} ${pre=OUTPUT_INCLUDES :OUTPUT_INCLUDES} ${pre=INDUCED_DEPS :INDUCED_DEPS} ${pre=STDOUT :STDOUT} ${pre=STDOUT_NOAUTO :STDOUT_NOAUTO} ${pre=CWD :CWD} ${pre=ENV :ENV})
}

# tag:java-specific
macro _RUN_ANTLR_BASE(IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], TOOL[], STDOUT="", STDOUT_NOAUTO="", CWD="", JAR{input}[], SEM="run_java", ENV[], HIDE_OUTPUT?"stderr2stdout":"stdout2stderr", GRAMMAR_FILES[], GRAMMAR_CWD="", Args...) {
    PEERDIR(build/platform/java/jdk $JDK_RESOURCE_PEERDIR)
    .CMD=${cwd:CWD} ${cwd;rootdir;input:GRAMMAR_CWD} ${env:ENV} $YMAKE_PYTHON ${input;pre=build/scripts/;suf=.py:HIDE_OUTPUT} $JDK_RESOURCE/bin/java -jar ${input:JAR} ${rootrel;input:GRAMMAR_FILES} $Args ${hide;tool:TOOL} ${hide;input:IN} ${hide;context=TEXT;input=TEXT:IN_NOPARSE} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${stdout;output:STDOUT} ${stdout;noauto;output:STDOUT_NOAUTO} ${hide;kv:"p JV"} ${hide;kv:"pc light-blue"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:IN} && custom_runs-command $SEM && custom_runs-command $Args && custom_runs-outputs ${output:OUT} ${noauto;output:OUT_NOAUTO} && $IF(${not;empty:CWD} THEN custom_runs-cwd ${CWD})
    .STRUCT_SEM=yes
}

### @usage: FROM_SANDBOX([FILE] resource_id [AUTOUPDATED script] [RENAME <resource files>] OUT_[NOAUTO] <output files> [EXECUTABLE] [OUTPUT_INCLUDES <include files>] [INDUCED_DEPS $VARs...])
###
### Download the resource from the Sandbox, unpack (if not explicitly specified word FILE) and add OUT files to the build. EXECUTABLE makes them executable.
### You may specify extra dependencies that output files bring using OUTPUT_INCLUDES or INDUCED_DEPS. The change of these may e.g. lead to recompilation of .cpp files extracted from resource.
### If there is no default processing for OUT files or you need process them specially use OUT_NOAUTO instead of OUT.
###
### It is disallowed to specify directory as OUT/OUT_NOAUTO since all outputs of commands shall be known to build system.
###
### RENAME renames files to the corresponding OUT and OUT_NOAUTO outputs:
### FROM_SANDBOX(resource_id RENAME in_file1 in_file2 OUT out_file1 out_file2 out_file3)
### FROM_SANDBOX(resource_id RENAME in_file1 OUT out_file1 RENAME in_file2 OUT out_file2)
### FROM_SANDBOX(FILE resource_id RENAME resource_file OUT out_name)
###
### RENAME RESOURCE allows to rename the resource without specifying its file name.
###
### OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
### INDUCED_DEPS $VARs... - Dependencies for generated files. Unlike `OUTPUT_INCLUDES` these may target files further in processing chain.
###                         In order to do so VAR should be filled by PREPARE_INDUCED_DEPS macro, stating target files (by type) and set of dependencies
###
### If AUTOUPDATED is specified than macro will be regularly updated according to autoupdate script. The dedicated Sandbox task scans the arcadia and
### changes resource_ids in such macros if newer resource of specified type is available. Note that the task seeks AUTOUPDATED in specific position,
### so you shall place it immediately after resource_id.
macro FROM_SANDBOX(Id, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], FILE?"--copy-to-dir":"--untar-to", AUTOUPDATED="", PREFIX=".", RENAME[], EXECUTABLE?"--executable":"", SBR="sbr:") {
    .CMD=${hide:SANDBOX_FAKEID} ${cwd:BINDIR} ${resource;pre=$SBR:Id} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_sandbox.py"} --resource-file $(RESOURCE_ROOT)/sbr/$Id/resource --resource-id $Id $FILE $PREFIX ${pre=--rename :RENAME} $EXECUTABLE -- $OUT $OUT_NOAUTO ${hide;input:"build/scripts/fetch_from.py"} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${hide;requirements:"network:full"} ${hide;kv:"p SB"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
    ADD_CHECK(check.resource $Id)
}

### @usage: LARGE_FILES([AUTOUPDATED]  Files...)
###
### Use large file ether from working copy or from remote storage via placeholder <File>.external
### If <File> is present locally (and not a symlink!) it will be copied to build directory.
### Otherwise macro will try to locate <File>.external, parse it retrieve ot during build phase.
macro LARGE_FILES(AUTOUPDATED?, Files...) {
    # This is needed to correctly switch between remote and local modes
    _GLOB($LF $Files)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS ${suf=.external:Files})
}

### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT_[NOAUTO] <output files> [EXECUTABLE] [OUTPUT_INCLUDES <include files>] [INDUCED_DEPS $VARs...])
###
### Process file archive as [FROM_SANDBOX()](#macro_FROM_SANDBOX).
macro FROM_ARCHIVE(Src, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], PREFIX=".", RENAME[], EXECUTABLE?"--executable":"") {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_archive.py"} "--archive" ${input:Src} "--file-name" ${suf=-:Src} "--untar-to" $PREFIX ${pre=--rename :RENAME} $EXECUTABLE -- $OUT $OUT_NOAUTO ${hide;input:"build/scripts/fetch_from.py"} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${hide;kv:"p FA"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
}

when ($MSVC == "yes") {
    C_AS_CXX_FLAGS=/TP /std:c++17
}
otherwise {
    C_AS_CXX_FLAGS=-x c++ -std=c++17
}

# tag:cpp-specific
### @usage: COMPILE_C_AS_CXX()
###
### Compile .c files as .cpp ones within a module.
macro COMPILE_C_AS_CXX() {
    SET(EXTRA_C_FLAGS $C_AS_CXX_FLAGS)
}

### @usage: NO_DEBUG_INFO()
###
### Compile files without debug info collection.
macro NO_DEBUG_INFO() {
    SET(NO_DEBUGINFO yes)
}

### @usage: CTEMPLATE_VARNAMES(File)
###
### Generate File.varnames.h using contrib/libs/ctemplate/make_tpl_varnames_h
###
### Documentation: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/ctemplate/README.md
macro CTEMPLATE_VARNAMES(File) {
    .CMD=${tool:"contrib/libs/ctemplate/make_tpl_varnames_h"} -f ${addincl;output;nopath;noallext;suf=.varnames.h:File} ${input:File}
}

LLVM_OPTS=
CLANG_BC_ROOT=

macro USE_LLVM_BC16() {
    SET(CLANG_BC_ROOT ${CLANG16_RESOURCE_GLOBAL})
    SET(LLVM_LLC_TOOL contrib/libs/llvm16/tools/llc)
}

macro USE_LLVM_BC18() {
    SET(CLANG_BC_ROOT ${CLANG18_RESOURCE_GLOBAL})
    SET(LLVM_LLC_TOOL contrib/libs/llvm18/tools/llc)
}

### @usage: CLANG_EMIT_AST_CXX(Input Output Opts...)
###
### Emit Clang AST from .cpp file. CXXFLAGS and LLVM_OPTS are passed in, while CFLAGS and C_FLAGS_PLATFORM are not.
### Note: Output name is used as is, no extension added.
macro CLANG_EMIT_AST_CXX(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_RESOURCE_GLOBAL}/bin/clang++ ${pre=-I:_C__INCLUDE} $CXXFLAGS $C_FLAGS_PLATFORM $LLVM_OPTS -emit-ast -c ${input:Input} -o ${noauto;output:Output} $Opts ${hide;kv:"p ST"} ${hide;kv:"pc light-green"}
    .STRUCT_CMD=yes
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_COMPILE_CXX(Input Output Opts...)
###
### Emit LLVM bytecode from .cpp file. BC_CXXFLAGS, LLVM_OPTS and C_FLAGS_PLATFORM are passed in, while CFLAGS are not.
### Note: Output name is used as is, no extension added.
macro LLVM_COMPILE_CXX(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_BC_ROOT}/bin/clang++ ${pre=-I:_C__INCLUDE} $BC_CXXFLAGS $C_FLAGS_PLATFORM -Wno-unknown-warning-option $LLVM_OPTS ${NO_LTO_CFLAGS} $NO_PGO_CFLAGS -emit-llvm -c ${input:Input} -o ${noauto;output:Output} $Opts ${hide;kv:"p BC"} ${hide;kv:"pc light-green"}
    .SEM=target_macroses-ITEM && target_macroses-macro llvm_compile_cxx && target_macroses-args ${input:Input} ${noauto;output:Output} ${"${CLANGPLUSPLUS}"} -Wno-unknown-warning-option $LLVM_OPTS ${NO_LTO_CFLAGS} $NO_PGO_CFLAGS -emit-llvm ${Opts}
    .STRUCT_CMD=yes
    when ($CLANG_BC_ROOT == "") {
      _OK = no
    }
    ASSERT(_OK "Invoke USE_LLVM_BC() with specific version first")
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_COMPILE_C(Input Output Opts...)
###
### Emit LLVM bytecode from .c file. BC_CFLAGS, LLVM_OPTS and C_FLAGS_PLATFORM are passed in, while CFLAGS are not.
### Note: Output name is used as is, no extension added.
macro LLVM_COMPILE_C(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_BC_ROOT}/bin/clang ${pre=-I:_C__INCLUDE} $BC_CFLAGS $C_FLAGS_PLATFORM $LLVM_OPTS ${NO_LTO_CFLAGS} $NO_PGO_CFLAGS -emit-llvm -c ${input:Input} -o ${noauto;output:Output} $Opts ${hide;kv:"p BC"} ${hide;kv:"pc light-green"}
    .SEM=target_macroses-ITEM && target_macroses-macro llvm_compile_c && target_macroses-args ${input:Input} ${noauto;output:Output} ${"${CLANGC}"} -Wno-unknown-warning-option $LLVM_OPTS ${NO_LTO_CFLAGS} $NO_PGO_CFLAGS -emit-llvm ${Opts}
    .STRUCT_CMD=yes
    when ($CLANG_BC_ROOT == "") {
      _OK = no
    }
    ASSERT(CLANG_BC_ROOT "Invoke USE_LLVM_BC() with specific version first")
    PEERDIR(build/platform/clang)
}

### @usage: BPF(Input Output Opts...)
###
### Emit eBPF bytecode from .c file.
### Note: Output name is used as is, no extension added.
macro BPF(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_RESOURCE_GLOBAL}/bin/clang ${pre=-I:_C__INCLUDE} $C_FLAGS_PLATFORM -target bpf -c ${input:Input} -o ${noauto;output:Output} $Opts ${hide;kv:"p BP"} ${hide;kv:"pc light-green"}
    .STRUCT_CMD=yes
    PEERDIR(build/platform/clang)
}

LD_BINARY_NAME=ld
when($OS_LINUX) {
    LD_BINARY_NAME=ld.lld
}

### @usage: BPF_STATIC(Input Output Opts...)
###
### Emit eBPF bytecode from .c file.
### Note: Output name is used as is, no extension added.
macro BPF_STATIC(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_RESOURCE_GLOBAL}/bin/clang ${pre=-I:_C__INCLUDE} $C_FLAGS_PLATFORM -target bpf -c ${input:Input} -o ${noauto;output:Output} $Opts ${hide;kv:"p BP"} ${hide;kv:"pc light-green"} && ${cwd:BINDIR} $LLD_ROOT_RESOURCE_GLOBAL/bin/$LD_BINARY_NAME -r -b binary -m elf_x86_64 -o ${noauto;output;suf=.bpf.o:Input} ${nopath:Output}
    .STRUCT_CMD=yes
    PEERDIR(build/platform/clang build/platform/lld)
}

### @usage: LLVM_COMPILE_LL(Input Output Opts...)
###
### Compile LLVM bytecode to object representation.
### Note: Output name is used as is, no extension added.
macro LLVM_COMPILE_LL(Input, Output, Opts...) {
    .CMD=${CLANG_BC_ROOT}/bin/llvm-as ${input:Input} -o ${noauto;output:Output} ${hide;kv:"p BC"} ${hide;kv:"pc light-green"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:Input} && custom_runs-command ${LLVMAS} ${input:Input} -o ${noauto;output:Output} && custom_runs-outputs ${noauto;output:Output}
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_LINK(Output Inputs...)
###
### Call llvm-link on set of Inputs to produce Output.
### Note: Unlike many other macros output argument goes first. Output name is used as is, no extension added.
macro LLVM_LINK(Output, Inputs...) {
    .CMD=${CLANG_BC_ROOT}/bin/llvm-link ${input:Inputs} -o ${noauto;output:Output} ${hide;kv:"p LD"} ${hide;kv:"pc light-red"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:Inputs} && custom_runs-command ${"${LLVMLINK}"} ${input:Inputs} -o ${noauto;output:Output} && custom_runs-outputs ${noauto;output:Output}
    .STRUCT_SEM=yes
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_OPT(Input Output Opts...)
###
### Call llvm-opt with set of Opts on Input to produce Output.
### Note: Output name is used as is, no extension added.
macro LLVM_OPT(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/llvm_opt_wrapper.py"} ${CLANG_BC_ROOT}/bin/opt ${input:Input} -o ${noauto;output:Output} $Opts ${hide;kv:"p OP"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:Input} && custom_runs-command ${"${LLVMOPT}"} ${input:Input} -o ${noauto;output:Output} $Opts && custom_runs-outputs ${noauto;output:Output}
    .STRUCT_SEM=yes
    PEERDIR(build/platform/clang)
}

### @usage: LLVM_LLC(Src Opts...)
###
### Call llvm-llc with set of Opts on Src to produce object file.
###
### Note: Output name is calculated as concatenation of Src name and platform specific object file extension.
macro LLVM_LLC(Src, Opts...) {
    .CMD=${tool:LLVM_LLC_TOOL} ${input:Src} --filetype obj -o ${noauto;output;suf=$OBJECT_SUF:Src} $Opts ${hide;kv:"p LC"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .SEM=custom_runs-ITEM && custom_runs-depends ${input:Src} && custom_runs-command ${LLVMLLC} --filetype obj ${input:Src} -o ${output;suf=$OBJECT_SUF;noauto:Src} $Opts && custom_runs-outputs ${output;suf=$OBJECT_SUF;noauto:Src}
    PEERDIR(build/platform/clang)
}

when ($NO_DEBUGINFO == "yes") {
    DEBUG_INFO_FLAGS=
}

when ($CLANG && $DEBUGINFO_LINES_ONLY == "yes" && $NO_DEBUGINFO != "yes") {
    DEBUG_INFO_FLAGS=-gline-tables-only
}

# NB: Assertions under sanitizers are disabled as they cause
#     a couple _relocation out of range_ problems plus an
#     ICE when building contrib/libs/hyperscan/runtime_avx512.
when ($BUILD_TYPE == "RELEASE" || $BUILD_TYPE == "MINSIZEREL" || $BUILD_TYPE == "VALGRIND-RELEASE" || $BUILD_TYPE == "PROFILE" || $BUILD_TYPE == "GPROF" || $BUILD_TYPE == "DEBUGNOASSERTS") {
    CFLAGS += -DNDEBUG
    when ($OS_WINDOWS) {
        # FIXME: defining _DEBUG on Linux gives more relation problems and breaks certain tests
        CFLAGS += -U_DEBUG
        # For the flags regarding runtime library selection, see
        # https://msdn.microsoft.com/en-us/library/abx4dbyh.aspx
        CFLAGS += /MT
    }
}
otherwise {
    CFLAGS += -UNDEBUG
    when ($OS_WINDOWS) {
        CFLAGS += -D_DEBUG
        CFLAGS += /MTd
    }
}

# TODO: configurable tar and touch
PACK_TGZ=${cwd:ARCADIA_BUILD_ROOT} tar -czf ${rootrel:OUTPUT} ${rootrel:INPUT} ${hide;kv:"p AR"} ${hide;kv:"pc light-red"}

#  tag:internal
### @usage: TOUCH(Outputs...) # internal
### Just introduce outputs
macro TOUCH(Outputs...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${output:Outputs} ${hide;kv:"p TC"} ${hide;kv:"pc light-red"}
    .STRUCT_CMD=yes
}

_EXTRA_PACKAGE_CMD=

TOUCH_UNIT=$YMAKE_PYTHON3 ${input:"build/scripts/touch.py"} ${hide;kv:"p UN"} ${hide;kv:"pc light-cyan"} $TARGET
FAKE_PACKAGE_CMD=$YMAKE_PYTHON3 ${input:"build/scripts/touch.py"} ${hide;kv:"pc light-red"} $TARGET
COPY_PACKAGE_CMD__LATEOUT__=\
    ${AUTO_INPUT} \
    ${pre=$BINDIR/;nobuildroot:SRCS_GLOBAL} \
    ${pre=$BINDIR/;nobuildroot:PEERS_LATE_OUTS} \
    ${pre=$BINDIR/;nobuildroot;skip_by_ext=.pkg.fake:PEERS}
COPY_PACKAGE_CMD=\
    $YMAKE_PYTHON3 ${input:"build/scripts/copy_to_dir.py"} \
    --dest-dir $BINDIR \
    --build-root $ARCADIA_BUILD_ROOT \
    $PACKED_PACKAGE_ARGS \
    $SRCS_GLOBAL \
    $PEERS_LATE_OUTS \
    ${skip_by_ext=.pkg.fake:PEERS} \
    ${hide;late_out:COPY_PACKAGE_CMD__LATEOUT__} \
    ${hide;kv:"package PACKAGE"}
TOUCH_PACKAGE=$FAKE_PACKAGE_CMD $VCS_INFO_DISABLE_CACHE__NO_UID__ && $COPY_PACKAGE_CMD && $_EXTRA_PACKAGE_CMD
_P_PK=${hide;kv:"p PK"}
TOUCH_PACKAGE_MF=$GENERATE_MF && $TOUCH_PACKAGE && $_P_PK && $ADD_VCS_INFO_FILE_CMD

# Note: we don't use touch.py in the command below to avoid introduction of undesired input
UNION_CMD=$YMAKE_PYTHON3 -c open(\'$TARGET\',\'w\').close() ${hide;kv:"p UN"} ${hide;kv:"package UNION"} ${hide;kv:"pc light-cyan"} $UNION_OUTS $VCS_INFO_DISABLE_CACHE__NO_UID__
UNION_CMD_MF=$UNION_CMD && $GENERATE_MF

_EXPAND_INS_OUTS__LATEOUT__=${INPUT}
macro _EXPAND_INS_OUTS(FILES{input}[]) {
    .CMD=${hide;input:FILES} ${hide;late_out:_EXPAND_INS_OUTS__LATEOUT__}
}

_UNION_EXPLICIT_OUTPUTS=

### @usage: EXPLICIT_OUTPUTS(Files...)
###
### Let UNION has only explicitly specified outputs listed in this macro
### The list of files shall contain results of commands in this UNION.
### Only these files will be outputs of the UNION. This allows to eliminate
### intermediate files being result of the UNION
macro EXPLICIT_OUTPUTS(Files...) {
     SET_APPEND(_UNION_EXPLICIT_OUTPUTS ${Files})
}

NO_CHECK_IMPORTS_FOR_VALUE=None
### @usage: NO_CHECK_IMPORTS([patterns])
###
### Do not run checks on imports of Python modules.
### Optional parameter mask patterns describes the names of the modules that do not need to check.
macro NO_CHECK_IMPORTS(Masks...) {
    SET(NO_CHECK_IMPORTS_FOR_VALUE $Masks)
}


# tag:yasm-specific
_YASM_FMT_VALUE=
_YASM_PLATFORM_FLAGS_VALUE=
_YASM_PREDEFINED_FLAGS_VALUE=
when ($OS_DARWIN || $OS_IOS) {
    _YASM_FMT_VALUE=macho
    _YASM_PLATFORM_FLAGS_VALUE=-D DARWIN -D UNIX
}
elsewhen ($OS_WINDOWS && $ARCH_X86_64) {
    _YASM_FMT_VALUE=win
    _YASM_PLATFORM_FLAGS_VALUE=-D WIN64
}
elsewhen ($OS_WINDOWS && $ARCH_I386) {
    _YASM_FMT_VALUE=win
    _YASM_PLATFORM_FLAGS_VALUE=-D WIN32
}
otherwise {
    _YASM_FMT_VALUE=elf
    _YASM_PLATFORM_FLAGS_VALUE=-D UNIX
    _YASM_PREDEFINED_FLAGS_VALUE=-g dwarf2
}

when ($ASM_PREFIX) {
    ASM_PREFIX_VALUE=--prefix=$ASM_PREFIX
}
otherwise {
    ASM_PREFIX_VALUE=
}

# tag:yasm-specific
YASM_FLAGS=
YASM_PREINCLUDES_VALUE=

# tag:yasm-specific
macro _SRC_yasm_helper(SRC, SRCIN, PREINCLUDES[], SRCFLAGS...) {
    .CMD=${tool:"contrib/tools/yasm"} -f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} $_YASM_PLATFORM_FLAGS_VALUE $YASM_DEBUG_INFO $YASM_DEBUG_INFO_DISABLE_CACHE__NO_UID__ -D ${pre=_;suf=_:HARDWARE_TYPE} -D_YASM_ $ASM_PREFIX_VALUE $_YASM_PREDEFINED_FLAGS_VALUE $YASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS -o ${output;suf=${OBJECT_SUF};noext:SRC} ${pre=-P :PREINCLUDES} ${hide;input:PREINCLUDES} ${SRCIN} ${hide;kv:"p AS"} ${hide;kv:"pc light-green"}
}

# tag:yasm-specific
macro _SRC_yasm(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=$_SRC_yasm_helper($SRC ${input:SRC} $SRCFLAGS PREINCLUDES $PREINCLUDES)
}

# tag:nasm-specific
NASM_FLAGS=

# tag:nasm-specific
macro _SRC_nasm_helper(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=${NASM_RESOURCE_GLOBAL}/bin/nasm -f ${_YASM_FMT_VALUE}${HARDWARE_ARCH} -D ${pre=_;suf=_:HARDWARE_TYPE} $NASM_FLAGS ${pre=-I :_ASM__INCLUDE} $SRCFLAGS -o ${output;suf=${OBJECT_SUF};noext:SRC} ${pre=-P :PREINCLUDES} ${input:SRC} ${hide;kv:"p AS"} ${hide;kv:"pc light-green"}
}

# tag:nasm-specific
macro _SRC_nasm(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=$_SRC_nasm_helper($SRC $SRCFLAGS PREINCLUDES $PREINCLUDES)
}

# tag:src-processing
when ($USE_NASM_ASSEMBLER == "yes") {
    _SRC_ASM_CMDLINE=$_SRC_nasm($SRC $SRCFLAGS PREINCLUDES $PREINCLUDES)
}
elsewhen ($USE_YASM_ASSEMBLER == "yes") {
    _SRC_ASM_CMDLINE=$_SRC_yasm($SRC $SRCFLAGS PREINCLUDES $PREINCLUDES)
}
otherwise {
    _SRC_ASM_CMDLINE=
}

# tag:src-processing
macro _SRC_ASM(SRC, PREINCLUDES[], SRCFLAGS...) {
    .CMD=$_SRC_ASM_CMDLINE
}

### @usage: ASM_PREINCLUDE(AsmFiles...)
###
### Supply additional .asm files to all assembler calls within a module
macro ASM_PREINCLUDE(PREINCLUDES...) {
    SET_APPEND(YASM_PREINCLUDES_VALUE $PREINCLUDES)
}

### @usage: RUN_ANTLR(Args...)
###
### Macro to invoke ANTLR3 generator (general case)
macro RUN_ANTLR(Args...) {
    _RUN_ANTLR_BASE($Args JAR contrib/java/antlr/antlr3/antlr.jar SEM run_antlr)
}

_ANTLR4_11_1_JAR=contrib/java/antlr/antlr4_11/antlr.jar
_ANTLR4_11_1_PYTHON_RUNTIME=contrib/python/antlr4

_ANTLR4_JAR=contrib/java/antlr/antlr4/antlr.jar
_ANTLR4_PYTHON_RUNTIME=contrib/python/antlr4

### @usage: RUN_ANTLR4(Args...)
###
### Macro to invoke ANTLR4 (version 4.11.1) generator (general case)
macro _RUN_ANTLR4_11_1(Args...) {
    _RUN_ANTLR_BASE($Args JAR $_ANTLR4_11_1_JAR SEM run_antlr4)
}

### @usage: RUN_ANTLR4(Args...)
###
### Macro to invoke ANTLR4 generator (general case)
macro RUN_ANTLR4(Args...) {
    _RUN_ANTLR_BASE($Args JAR $_ANTLR4_JAR SEM run_antlr4)
}

_ANTLR4_LISTENER_GRAMMAR=-listener
_ANTLR4_LISTENER_PARSER=-listener
_ANTLR4_LISTENER__ANTLR4_EMPTY=-no-listener
_ANTLR4_VISITOR_GRAMMAR=-visitor
_ANTLR4_VISITOR_PARSER=-visitor
_ANTLR4_VISITOR__ANTLR4_EMPTY=-no-visitor

### @usage: RUN_ANTLR4_CPP_SPLIT(LEXER, PARSER, OUTPUT_INCLUDES, LISTENER, VISITOR, Args...)
###
### Macro to invoke ANTLR4 generator for separate lexer and parser grammars (Cpp)
macro RUN_ANTLR4_CPP_SPLIT(LEXER, PARSER, OUTPUT_INCLUDES[], LISTENER?"PARSER":"_ANTLR4_EMPTY", VISITOR?"PARSER":"_ANTLR4_EMPTY", _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${LEXER} ${PARSER} -Dlanguage=Cpp -o ${BINDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${LEXER} ${PARSER} OUT_NOAUTO ${suf=.cpp;noext:LEXER} ${suf=.h;noext:LEXER} ${suf=.cpp;noext:PARSER} ${suf=.h;noext:PARSER} ${suf=Listener.h;noext:$LISTENER} ${suf=BaseListener.h;noext:$LISTENER} ${suf=Visitor.h;noext:$VISITOR} ${suf=BaseVisitor.h;noext:$VISITOR} OUTPUT_INCLUDES ${ARCADIA_ROOT}/contrib/libs/antlr4_cpp_runtime/src/antlr4-runtime.h ${OUTPUT_INCLUDES})
    COPY_FILE(AUTO ${suf=.cpp;noext:LEXER} ${suf=.g4.cpp;noext:LEXER} OUTPUT_INCLUDES ${suf=.h;noext:LEXER} ${OUTPUT_INCLUDES})
    COPY_FILE(AUTO ${suf=.cpp;noext:PARSER} ${suf=.g4.cpp;noext:PARSER} OUTPUT_INCLUDES ${suf=.h;noext:PARSER} ${OUTPUT_INCLUDES})
    PEERDIR(contrib/libs/antlr4_cpp_runtime)
}

### @usage: RUN_ANTLR4_CPP(GRAMMAR, OUTPUT_INCLUDES, LISTENER, VISITOR, Args...)
###
### Macro to invoke ANTLR4 generator for combined lexer+parser grammars (Cpp)
macro RUN_ANTLR4_CPP(GRAMMAR, OUTPUT_INCLUDES[], LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${GRAMMAR} -Dlanguage=Cpp -o ${BINDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${GRAMMAR} OUT_NOAUTO ${suf=Lexer.cpp;noext:GRAMMAR} ${suf=Lexer.h;noext:GRAMMAR} ${suf=Parser.cpp;noext:GRAMMAR} ${suf=Parser.h;noext:GRAMMAR} ${suf=Listener.h;noext:$LISTENER} ${suf=BaseListener.h;noext:$LISTENER} ${suf=Visitor.h;noext:$VISITOR} ${suf=BaseVisitor.h;noext:$VISITOR} OUTPUT_INCLUDES ${ARCADIA_ROOT}/contrib/libs/antlr4_cpp_runtime/src/antlr4-runtime.h ${OUTPUT_INCLUDES})
    COPY_FILE(AUTO ${suf=Lexer.cpp;noext:GRAMMAR} ${suf=Lexer.g4.cpp;noext:GRAMMAR} OUTPUT_INCLUDES ${suf=Lexer.h;noext:GRAMMAR} ${OUTPUT_INCLUDES})
    COPY_FILE(AUTO ${suf=Parser.cpp;noext:GRAMMAR} ${suf=Parser.g4.cpp;noext:GRAMMAR} OUTPUT_INCLUDES ${suf=Parser.h;noext:GRAMMAR} ${OUTPUT_INCLUDES})
    PEERDIR(contrib/libs/antlr4_cpp_runtime)
}

### @usage: RUN_ANTLR4_GO(GRAMMAR, DEPS <extra_go_deps>, LISTENER, VISITOR, Args...)
###
### Macro to invoke ANTLR4 generator (Go)
macro RUN_ANTLR4_GO(GRAMMAR, DEPS[], LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(-Dlanguage=Go -o ${BINDIR} -Xexact-output-dir ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} GRAMMAR_FILES $GRAMMAR GRAMMAR_CWD $GRAMMAR OUT ${noext;tolower;suf=_lexer.go:GRAMMAR} ${noext;tolower;suf=_parser.go:GRAMMAR} ${noext;tolower;suf=_listener.go:$LISTENER} ${noext;tolower;suf=_base_listener.go:$LISTENER} ${noext;tolower;suf=_visitor.go:$VISITOR} ${noext;tolower;suf=_base_visitor.go:$VISITOR})
    PEERDIR(${GOSTD}/fmt ${GOSTD}/reflect ${GOSTD}/strconv ${GOSTD}/sync ${GOSTD}/unicode vendor/github.com/antlr4-go/antlr/v4 $DEPS)
}

### @usage: RUN_ANTLR4_PYTHON2(Grammar [LISTENER] [VISITOR] [SUBDIR] [EXTRA_OUTS Outs...] Args...)
###
### `LISTENER` - emit grammar listener
### `VISITOR` -  emit grammar visitor
### `SUBDIR` - place generated files to specified subdirectory of BINDIR
### `EXTRA_OUTS` - list extra outputs produced by Antlr (e.g. .interp and .token files) if they are needed. If `SUBDIR` is specied it will affect these as well. Use file names only.
###
### Macro to invoke ANTLR4 (version 4.11.1) generator (Python).
macro RUN_ANTLR4_PYTHON2(GRAMMAR, LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", SUBDIR=".", EXTRA_OUTS[], _ANTLR4_EMPTY="", Args...) {
    _RUN_ANTLR4_11_1(${GRAMMAR} -Dlanguage=Python2 -o ${BINDIR}/${SUBDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${GRAMMAR} OUT_NOAUTO ${pre=${SUBDIR}/;suf=Lexer.py;nopath;noext:GRAMMAR} ${pre=${SUBDIR}/;suf=Parser.py;nopath;noext:GRAMMAR} ${pre=${SUBDIR}/;suf=Listener.py;nopath;noext:$LISTENER} ${pre=${SUBDIR}/;suf=Visitor.py;nopath;noext:$VISITOR} ${pre=${SUBDIR}/:EXTRA_OUTS})
    PEERDIR(${_ANTLR4_11_1_PYTHON_RUNTIME})
}

### @usage: RUN_ANTLR4_PYTHON3(Grammar [LISTENER] [VISITOR] [SUBDIR] [EXTRA_OUTS Outs...] Args...)
###
### `LISTENER` - emit grammar listener
### `VISITOR` -  emit grammar visitor
### `SUBDIR` - place generated files to specified subdirectory of BINDIR
### `EXTRA_OUTS` - list extra outputs produced by Antlr (e.g. .interp and .token files) if they are needed. If `SUBDIR` is specied it will affect these as well. Use file names only.
###
### Macro to invoke ANTLR4 generator (Python).
macro RUN_ANTLR4_PYTHON3(GRAMMAR, LISTENER?"GRAMMAR":"_ANTLR4_EMPTY", VISITOR?"GRAMMAR":"_ANTLR4_EMPTY", SUBDIR=".", EXTRA_OUTS[], _ANTLR4_EMPTY="", Args...) {
    RUN_ANTLR4(${GRAMMAR} -Dlanguage=Python3 -o ${BINDIR}/${SUBDIR} ${_ANTLR4_VISITOR_$VISITOR} ${_ANTLR4_LISTENER_$LISTENER} ${Args} CWD ${BINDIR} IN ${GRAMMAR} OUT_NOAUTO ${pre=${SUBDIR}/;suf=Lexer.py;nopath;noext:GRAMMAR} ${pre=${SUBDIR}/;suf=Parser.py;nopath;noext:GRAMMAR} ${pre=${SUBDIR}/;suf=Listener.py;nopath;noext:$LISTENER} ${pre=${SUBDIR}/;suf=Visitor.py;nopath;noext:$VISITOR} ${pre=${SUBDIR}/:EXTRA_OUTS})
    PEERDIR(${_ANTLR4_PYTHON_RUNTIME})
}
# tag:cpp-specific
macro CPP_ADDINCL(Dirs...) {
    ADDINCL($Dirs)
}

# tag:internal
_WHOLE_ARCHIVE_PEERS_VALUE=
### @usage: WHOLE_ARCHIVE(dirnames...) # internal
macro WHOLE_ARCHIVE(PEERS...) {
    SET_APPEND(_WHOLE_ARCHIVE_PEERS_VALUE ${PEERS})
    REQUIRES(${PEERS})
}

ANDROID_SDK_ROOT=${ANDROID_SDK_RESOURCE_GLOBAL}/android_sdk

macro TASKLET() {
    PEERDIR(tasklet/v1/api)

    # CPP
    CPP_PROTO_PLUGIN(tasklet_cpp tasklet/v1/gen/cpp .tasklet.h)

    # Python
    PY_PROTO_PLUGIN2(tasklet_py _tasklet.py _sbtask.py tasklet/v1/gen/python DEPS tasklet/v1/domain/sandbox tasklet/v1/runtime sandbox/sdk2)
}

TASKLET_REG_INCLUDES= \
    ${hide;output_include:"tasklet/v1/runtime/lib/cpp_wrapper.h"} \
    ${hide;output_include:"tasklet/v1/runtime/lib/go_wrapper.h"} \
    ${hide;output_include:"tasklet/v1/runtime/lib/py_wrapper.h"} \
    ${hide;output_include:"tasklet/v1/runtime/lib/js_wrapper.h"} \
    ${hide;output_include:"tasklet/v1/runtime/lib/registry.h"}

macro TASKLET_REG(Name, Lang, Impl, Includes...) {
    PEERDIR(tasklet/v1/domain sandbox/bin sandbox/taskbox/worker)

    when($Lang == "js") {
        # JS runtime links the Node.js from contrib as a library, which is a bit heavy,
        # so we do it, only if any JS tasklets are linked into the target
        PEERDIR+=tasklet/v1/runtime/js
    }

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_tasklet_reg.py"} $Name -l $Lang -i $Impl ${noauto;output;suf=.task.cpp:Name} $Includes ${hide;output_include:Includes} $TASKLET_REG_INCLUDES ${hide;kv:"p TT"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    SRCS(GLOBAL $Name.task.cpp)
}

# TEMPORARY METHOD FOR EXTENDED REGISTRY SETUP
# NOT COMPLETE
macro TASKLET_REG_EXT(Name, Lang, Impl, Wrapper, Includes...) {
    PEERDIR(tasklet/v1/domain sandbox/bin sandbox/taskbox/worker)

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_tasklet_reg.py"} $Name -l $Lang -i $Impl -w $Wrapper ${noauto;output;suf=.task.cpp:Name} $Includes ${hide;output_include:Includes} $TASKLET_REG_INCLUDES ${hide;kv:"p TT"} ${hide;kv:"pc yellow"}
    SRCS(GLOBAL $Name.task.cpp)
}

# tag:cpp-specific
_CPP_PROTO_MODULE_PREFIX=
_CPP_PROTO_MODULE_SUFFIX=
when ($OS_WINDOWS == "yes") {
    _CPP_PROTO_MODULE_PREFIX=
    _CPP_PROTO_MODULE_SUFFIX=.lib
}
otherwise {
    _CPP_PROTO_MODULE_PREFIX=lib
    _CPP_PROTO_MODULE_SUFFIX=.a
}

### @usage: _EXPOSE(OutputsToExport...)
###
### Allows to mark outputs of macro command as unused in the current module but intended
### to be used in modules consuming current via PEERDIR.
###
### TODO(DEVTOOLS-9000) proper implementation needed
macro _EXPOSE(Args...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${output;suf=$_HASH_HELPER($Args).ya_exposed:"empty_"} ${hide;input:Args}
    .STRUCT_CMD=yes
}

# tag:internal
### @usage: _PROXY_LIBRARY() # internal
###
### The use of this module is strictly prohibited!!!
module _PROXY_LIBRARY: LIBRARY {
    .EXTS=.a .lib
    .PEERDIR_POLICY=as_build_from
    .PROXY=yes
    .FINAL_TARGET=yes
    DISABLE(NEED_ADD_FAKE_SRC)

    NO_UTIL()
    NO_RUNTIME()
}

@import "${CONF_ROOT}/conf/project_specific/yql_udf.conf"

_PRIMARY_OUTPUT_VALUE=

# tag:internal
### @usage: PRIMARY_OUTPUT_VALUE(Output) # internal
###
### The use of this module is strictly prohibited!!!
macro PRIMARY_OUTPUT(OUTPUT) {
    SET(_PRIMARY_OUTPUT_VALUE $OUTPUT)
}

_DLL_PROXY_LIBRARY_CMD=$GENERATE_MF && $COPY_CMD $_PRIMARY_OUTPUT_VALUE ${hide;input:_PRIMARY_OUTPUT_VALUE} ${TARGET}

# tag:internal
### @usage: DLL_PROXY_LIBRARY() # internal
###
### The use of this module is strictly prohibited!!!
module DLL_PROXY_LIBRARY: _PROXY_LIBRARY {
    .ALLOWED=PRIMARY_OUTPUT
    .CMD=$_DLL_PROXY_LIBRARY_CMD
}

_PREBUILT_PROGRAM_CMD=$GENERATE_MF && $COPY_CMD $_PRIMARY_OUTPUT_VALUE ${TARGET} ${hide;kv:"p ld"} ${hide;kv:"pc light-blue"} ${hide;kv:"show_out"}

# tag:internal
### @usage: PREBUILT_PROGRAM([programname]) # internal
###
### Program module which uses a prebuilt prgram as its output.
module PREBUILT_PROGRAM: _LINK_UNIT {
    .CMD=$_PREBUILT_PROGRAM_CMD
    .SYMLINK_POLICY=EXE
    .ALLOWED=INDUCED_DEPS PRIMARY_OUTPUT
    .RESTRICTED=SRCS

    _BARE_LINK_MODULE()

    SET(MODULE_TYPE PROGRAM)

    _DONT_REQUIRE_LICENSE()
    WITHOUT_VERSION()

    when ($WIN32 == "yes") {
        MODULE_SUFFIX=.exe
    }
}

### @usage: COLLECT_JINJA_TEMPLATES(varname path)
###
### This macro collects all jinja and yaml files in the directory specified by second argument and
### stores result in the variable with mane specified by first parameter.
macro COLLECT_JINJA_TEMPLATES(VAR, DIR) {
    _GLOB($VAR ${DIR}/**/*.jinja ${DIR}/**/*.yaml)
}

@import "${CONF_ROOT}/conf/go.conf"

IBTOOL_PATH=$XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/ibtool
# tag:src-processing
STORYBOARD_FLAGS=--errors --warnings --notices --auto-activate-custom-fonts --output-format human-readable-text
macro _SRC("storyboard", SRC, SRCFLAGS...) {
    .CMD=$IBTOOL_PATH $STORYBOARD_FLAGS --module $REALPRJNAME --output-partial-info-plist ${output;suf=.partial_plist:SRC} --compilation-directory $BINDIR ${input:SRC} && $YMAKE_PYTHON3 ${input:"build/scripts/tar_directory.py"}  ${tobindir;output;suf=.compiled_storyboard_tar:SRC} $BINDIR/${suf=c;nopath:SRC} $BINDIR/${suf=c;nopath:SRC}
}

# tag:src-processing
macro _SRC("xib", SRC, SRCFLAGS...) {
    .CMD=$IBTOOL_PATH $STORYBOARD_FLAGS --module $REALPRJNAME --output-partial-info-plist ${output;suf=.partial_plist:SRC} --compile ${tobindir;output;suf=.nib;nopath;noext:SRC} ${input:SRC}
}

# tag:src-processing
macro _SRC("msg", SRC, SRCFLAGS...) {
    .CMD=$ROS_MSG_CMD($SRC)
    .STRUCT_CMD=yes
}

# tag:src-processing
macro _SRC("srv", SRC, SRCFLAGS...) {
    .CMD=$ROS_SRV_CMD($SRC)
    .STRUCT_CMD=yes
}

ACTOOL_PATH=$XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/ibtool
# tag:ios-specific
ASSETS_FLAGS=--output-format human-readable-text --notices --warnings
macro _IOS_ASSETS(AssetsDir, Content...) {
    .CMD=$FS_TOOLS md $BINDIR/$REALPRJNAME && $ACTOOL_PATH $ASSETS_FLAGS --export-dependency-info $BINDIR/assetcatalog_dependencies --output-partial-info-plist ${output:"assetcatalog_generated_info.partial_plist"} --product-type com.apple.product-type.application --compile $BINDIR/$REALPRJNAME $AssetsDir ${hide;input:Content} && ${cwd:BINDIR} $YMAKE_PYTHON3 ${input:"build/scripts/tar_directory.py"} ${output;suf=_assetes.resource_tar:REALPRJNAME} $REALPRJNAME $REALPRJNAME
}

# tag:ios-specific
macro IOS_APP_COMMON_FLAGS(Flags...) {
    SET_APPEND(STORYBOARD_FLAGS $Flags)
    SET_APPEND(ASSETS_FLAGS $Flags)
}

# tag:ios-specific
macro IOS_APP_ASSETS_FLAGS(Flags...) {
    SET_APPEND(ASSETS_FLAGS $Flags)
}

macro DARWIN_STRINGS_RESOURCE(Resource, Relpath) {
    .CMD=$COPY_CMD ${input:Resource} $BINDIR/$Relpath && $YMAKE_PYTHON3 ${input:"build/scripts/tar_directory.py"} ${tobindir;output;suf=.strings_tar:Relpath} $BINDIR/$Relpath $BINDIR
}

macro DARWIN_SIGNED_RESOURCE(Resource, Relpath) {
    .CMD=$COPY_CMD $Resource $BINDIR/$Relpath && $YMAKE_PYTHON3 ${input:"build/scripts/tar_directory.py"} ${tobindir;output;suf=.signed_resource_tar:Relpath} $BINDIR/$Relpath $BINDIR
}

# tag:ios-specific
DELIM=__DELIM__
PACK_IOS_ARCHIVE=$GENERATE_MF && $YMAKE_PYTHON ${input:"build/scripts/ios_wrapper.py"} bin $IBTOOL_PATH $TARGET $REALPRJNAME $BINDIR $DELIM $AUTO_INPUT $DELIM $STORYBOARD_FLAGS
### @usage: IOS_INTERFACE()
### iOS GUI module definition
module IOS_INTERFACE: _BARE_UNIT {
    .CMD=$PACK_IOS_ARCHIVE
    .EXTS=.compiled_storyboard_tar .partial_plist .plist .xcent .nib .resource_tar .signed_resource_tar .strings_tar .plist_json
    .FINAL_TARGET=no
    .NODE_TYPE=Library
    .STRUCT_CMD=yes
    SET(MODULE_SUFFIX .ios.interface)

    PEERDIR+=build/platform/xcode/tools
}

# tag:ios-specific
module DEFAULT_IOS_INTERFACE: IOS_INTERFACE {
    SET(MODULE_SUFFIX .default.ios.interface)
}

DEFAULT_IOS_TYPE=
IOS_TYPE=
when(!$IOS_TYPE) {
    when($DEFAULT_IOS_TYPE) {
        IOS_TYPE=$DEFAULT_IOS_TYPE
    }
    otherwise {
        IOS_TYPE=com.apple.CoreSimulator.SimDeviceType.iPhone-X
    }
}
DEFAULT_IOS_RUNTIME=
IOS_RUNTIME=
when(!$IOS_RUNTIME) {
    when($DEFAULT_IOS_RUNTIME) {
        IOS_RUNTIME=$DEFAULT_IOS_RUNTIME
    }
    otherwise {
        IOS_RUNTIME=com.apple.CoreSimulator.SimRuntime.iOS-12-1
    }
}
when ($ARCH_I386) {
    TEST_IOS_DEVICE_TYPE_VALUE=com.apple.CoreSimulator.SimDeviceType.iPhone-5
    TEST_IOS_RUNTIME_TYPE_VALUE=com.apple.CoreSimulator.SimRuntime.iOS-10-3
}
otherwise {
    TEST_IOS_DEVICE_TYPE_VALUE=$IOS_TYPE
    TEST_IOS_RUNTIME_TYPE_VALUE=$IOS_RUNTIME
}

# tag:frontend-specific
### @usage: COLLECT_FRONTEND_FILES(Varname, Dir)
###
### Recursively collect files with typical frontend extensions from Dir and save the result into variable Varname
macro COLLECT_FRONTEND_FILES(Varname, Dir) {
    _GLOB($Varname $Dir/**/*.(css|ejs|jpg|js|jsx|png|styl|svg|ts|tsx|json|html))
}

### @usage: COLLECT_YAML_CONFIG_FILES(Varname, Dir)
###
### Recursively collect YAML files except for system-reserved a.yaml ones from Dir and save the result into Varname variable
macro COLLECT_YAML_CONFIG_FILES(Varname, Dir) {
    _GLOB($Varname $Dir/**/*.yaml EXCLUDE **/a.yaml)
}

TEST_TOOL_HOST_LOCAL=
TEST_TOOL_TARGET_LOCAL=

when ($MOST_USED_CUDA) {
    CUDA12=yes
}

CUDA_VERSION=0
TENSORRT_VERSION=10

when ($CUDA11) {
    CUDA_VERSION=11.4
    CUDNN_VERSION=8.0.5
    TENSORRT_VERSION=7
    NVCC_STD_VER=17
}

when ($CUDA12) {
    CUDA_VERSION=12.6
    CUDNN_VERSION=9.0.0
    TENSORRT_VERSION=10
    CUDA_ARCHITECTURES=
    NVCC_STD_VER=20
}

when ($TENSORFLOW_WITH_CUDA) {
    CUDA_REQUIRED=yes
}

ANDROID_APK_TEST_ACTIVITY_VALUE=com.yandex.test.unittests/.RunTestsActivity

# tag:windows-specific
WINDOWS_MANIFEST=
macro WINDOWS_MANIFEST(Manifest) {
    SET(WINDOWS_MANIFEST $Manifest)
}

# https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation#enable-long-paths-in-windows-10-version-1607-and-later
macro WINDOWS_LONG_PATH_MANIFEST() {
    SET(WINDOWS_MANIFEST build/long-path.manifest)
}

# tag:windows-specific
when ($MSVC == "yes" && $WINDOWS_MANIFEST) {
    LDFLAGS+=/MANIFEST:EMBED /MANIFESTINPUT:${input:WINDOWS_MANIFEST}
}

# tag:cpp-specific
_VISIBILITY_LEVEL=
### @usage: VISIBILITY(level)
###
### This macro sets visibility level for symbols compiled for the current module. 'level'
### may take only one of the following values: DEFAULT, HIDDEN.
macro VISIBILITY(LEVEL) {
    SET(_VISIBILITY_LEVEL ${LEVEL})
    select ($LEVEL) {
        "DEFAULT" | "HIDDEN" ? {
        }
        default ? {
            _OK = no
        }
    }
    ASSERT(_OK Unsupported value [$LEVEL] passed to VISIBILITY macro, expected values are DEFAULT, HIDDEN.)
}

# tag:cpp-specific
_CFLAGS_VISIBILITY=
when ($_VISIBILITY_LEVEL != "" && $IGNORE_VISIBILITY != "yes") {
    when ($CLANG == "yes" || $GCC == "yes") {
        _CFLAGS_VISIBILITY=-fvisibility=${tolower:_VISIBILITY_LEVEL}
    }
}
CFLAGS+=$_CFLAGS_VISIBILITY

# tag:cpp-specific
macro SDBUS_CPP_ADAPTOR(File) {
    .CMD=${tool:"contrib/libs/sdbus-cpp/tools/xml2cpp-codegen"} --adaptor=${output;suf=.adaptor.h;nopath;noext:File} ${input:File} ${hide;kv:"p SD"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .PEERDIR=contrib/libs/sdbus-cpp
}

# tag:cpp-specific
macro SDBUS_CPP_PROXY(File) {
    .CMD=${tool:"contrib/libs/sdbus-cpp/tools/xml2cpp-codegen"} --proxy=${output;suf=.proxy.h;nopath;noext:File} ${input:File} ${hide;kv:"p SD"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes
    .PEERDIR=contrib/libs/sdbus-cpp
}

# tag:python-specific
macro _PY_ENUM_SERIALIZATION_TO_JSON(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --output ${output;suf=.generated.h;noext:File} --json-output ${output;suf=.json;noext:File} ${hide;kv:"p EN"} ${hide;kv:"pc yellow"}
}

# tag:python-specific
macro _PY_ENUM_SERIALIZATION_TO_PY(File) {
    .CMD=${tool:"metrika/core/tools/python_enum_generator"} ${input;suf=.json;noext:File} -D ${MODDIR} --output ${output;suf=.py;noext:File} ${hide;kv:"p EN"} ${hide;kv:"pc yellow"}
}

macro NGINX_MODULES(Modules...) {
    PEERDIR(${Modules})
    RUN_PROGRAM(nginx/module_gen ${Modules} CWD ${ARCADIA_ROOT} IN ${suf=/modules.json:Modules} OUTPUT_INCLUDES contrib/nginx/core/src/core/ngx_config.h contrib/nginx/core/src/core/ngx_core.h STDOUT ngx_modules.c)
}

### @usage: ORIGINAL_SOURCE(Source)
###
### This macro specifies the source repository for contrib
### Does nothing now (just a placeholder for future functionality)
### See https://st.yandex-team.ru/DTCC-316
macro ORIGINAL_SOURCE(Source) {
    ENABLE(UNUSED_MACRO)
}

# tag:licence
CREDITS_FILE_EXTRA_EXT=
CREDITS_FLAGS=
CREDITS_TEXTS_FILE=
NO_CREDITS_TEXTS_FILE=
WITH_CREDITS=
### @usage: LICENSE_TEXTS(File)
###
### This macro specifies the filename with all library licenses texts
macro LICENSE_TEXTS(Source) {
    SET(CREDITS_TEXTS_FILE $Source)
}

# tag:licence
### @usage: WITHOUT_LICENSE_TEXTS()
###
### This macro indicates that the module has no license text
macro WITHOUT_LICENSE_TEXTS() {
    ENABLE(NO_CREDITS_TEXTS_FILE)
}

# tag:licence
when ($WITH_CREDITS) {
    CREDITS_FLAGS+=--credits-output ${output;pre=${MODULE_PREFIX};suf=${MODULE_SUFFIX}${CREDITS_FILE_EXTRA_EXT}.CREDITS.txt:REALPRJNAME}
}

GENERATE_MF=
when ($WITH_CREDITS) {
    GENERATE_MF=$GENERATE_MF_CMD
}

# tag:internal
### Add passed ya.conf.json and all bottle's formula external files to resources
### File MUST be arcadia root relative path (without "${ARCADIA_ROOT}/" prefix).
### NOTE:
###   An external formula file referenced from ya.conf.json must be passed as an arcadia root relative path and
###   should be located in any subdirectory of the ya.conf.json location ("build/" if we consider a production).
###   The later restriction prevents problems in selectively checkouted arcadia.
macro YA_CONF_JSON(File) {
    _YA_CONF_JSON($File)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS ${ARCADIA_ROOT}/$File)
}

# tag:internal
### @usage: _ADD_CPP_LINTER_CHECK(NAME name LINTER linter [DEPENDS deps] CONFIGS configs_file [GLOBAL_RESOURCES gr] [FILE_PROCESSING_TIME fpt] [EXTRA_PARAMS params] [CONFIG_TYPE ct])
###
### Triggers respective plugin
macro _ADD_CPP_LINTER_CHECK(Args...) {
    SET(USE_ALL_SRCS yes)
    HEADERS(.)
    SET_APPEND(_MAKEFILE_INCLUDE_LIKE_DEPS ${ARCADIA_ROOT}/${CPP_LINTERS_DEFAULT_CONFIGS})
}

# tag:test
### @usage: STYLE_CPP([CONFIG_TYPE config_type])
###
### Run 'ya tool clang-format' test on all cpp sources and headers of the current module
macro STYLE_CPP(CONFIG_TYPE="") {
    .ALLOWED_IN_LINTERS_MAKE=yes
    _ADD_CPP_LINTER_CHECK(NAME clang_format WRAPPER_SCRIPT tools/cpp_style_checker/wrapper.py GLOBAL_RESOURCES build/platform/clang/clang-format CONFIGS $CPP_LINTERS_DEFAULT_CONFIGS CONFIG_TYPE $CONFIG_TYPE)
}

### @usage: HEADERS(<Dirs...> [EXCLUDE patterns...])
###
### Add all C/C++ header files (h|H|hh|hpp|hxx|ipp) in given directories to SRCS
### Exclude files matching EXCLUDE patterns
macro HEADERS(EXCLUDE[], Dirs...) {
    SET(_VAR_HEADERS_SALT __Dirs__ ${Dirs} __EXCLUDE__ ${EXCLUDE})
    SET(_HEADERS_GLOB uniq_headers_${hash:_VAR_HEADERS_SALT})
    _GLOB(${_HEADERS_GLOB} ${suf=/*.(h|H|hh|hpp|hxx|ipp):Dirs} EXCLUDE ${EXCLUDE})
    SRCS(${${_HEADERS_GLOB}})
}

### @usage: CLANG_EMIT_AST_CXX_RUN_TOOL(Tool Args... [SOURCES ...] [OPTS ...] [IN ...] [IN_NOPARSE ...] [TOOL ...] [OUTPUT_INCLUDES ...] [INDUCED_DEPS ...] [IN_DEPS ...] [STDOUT out-file-name] [STDOUT_NOAUTO out-file-name] [CWD cwd])
###
### Emit Clang ASTs from .cpp files listed in SOURCES parameter (CXXFLAGS and LLVM_OPTS are passed in, while CFLAGS and C_FLAGS_PLATFORM are not) and run tool Tool with Args... .
### OPTS[] parameter is used to pass additional flags to clang. Parameters other than OPTS[] and SOURCES[] are used for runnig a generator (Tool):
### - Tool - path to the directory of the tool
### - Args... - Tool's arguments
### - IN[] - input files required for running the Tool
### - IN_NOPARSE[] - input files required for running the Tool, but these files are not parsed for dependencies
### - TOOL[] - list of directories of axiliary tools used by Tool
### - OUTPUT_INCLUDES[] - includes of the output files which are needed to "build" them
### - STDOUT - redirect stdout of the Tool to the output file
### - STDOUT_NOAUTO - redirect stdout of the Tool to the output file, but do not chain this file automatically to the processing queue
### - CWD - path to the working directory of the Tool
### Note: Generated AST files generated into BINDIR according to corresponding .cpp file names listed in SOURCES parameter.
macro CLANG_EMIT_AST_CXX_RUN_TOOL(SOURCES[], OPTS[], Tool, IN{input}[], IN_NOPARSE{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], INDUCED_DEPS[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS ${CLANG_RESOURCE_GLOBAL}/bin/clang++ ${pre=-I:_C__INCLUDE} $CXXFLAGS $C_FLAGS_PLATFORM $LLVM_OPTS -emit-ast -c ${input:SOURCES} ${hide;tmp;suf=.ast;noext;nopath:SOURCES} $OPTS ${hide;kv:"p ST"} ${hide;kv:"pc light-green"} && ${cwd:CWD} ${env:ENV} ${tool:Tool} $Args ${hide;input:IN} ${hide;context=TEXT;input=TEXT:IN_NOPARSE} ${hide;input:IN_DEPS} ${hide;output_include:OUTPUT_INCLUDES} $INDUCED_DEPS ${hide;tool:TOOL} ${hide;output:OUT} ${hide;noauto;output:OUT_NOAUTO} ${stdout;output:STDOUT} ${stdout;noauto;output:STDOUT_NOAUTO} ${hide;kv:"p PR"} ${hide;kv:"pc yellow"} ${hide;kv:"show_out"}
    .STRUCT_CMD=yes
    PEERDIR(build/platform/clang)
}

### Hooks for contrib modules which can be transparenctly extended in repo internal python plugins
macro _CONTRIB_MODULE_HOOKS() {
    ENABLE(UNUSED_MACRO)
}


### Specify that current module is used as toolchain. Allows to have contrib hooks for toolchain modules
### defined in repo internal python plugins
macro TOOLCHAIN(Name) {
    ENABLE(UNUSED_MACRO)
}

macro WITHOUT_VERSION() {
    ENABLE(SKIP_VERSION_REQUIREMENTS)
}

### @usage: LINK_EXCLUDE_LIBRARIES(Libs...)
###
### Exclude specified external dynamic libraries from linker command
###
### May be used to implement shims/mocks, e.g. a lazy loader
###
### @example:
###
###     LIBRARY()
###
###     SRCS(
###         # provide some shim/mock implementation for libcuda.so
###     )
###
###     LINK_EXCLUDE_LIBRARIES(cuda)
###
###     END()
###
macro LINK_EXCLUDE_LIBRARIES(Libs...) {
    SET_APPEND(_LINK_EXCLUDE_LIBRARIES_GLOBAL $Libs)
}

### @usage: GENERATE_IMPLIB(Lib, Path, [SONAME Name])
###
### Generates a wrapper for external dynamic library using Implib.so and excludes the real library from linker command
###
### The wrapper loads the real library on the first call to any of its functions
###
### @example:
###
###     PEERDIR(build/platform/cuda)
###
###     GENERATE_IMPLIB(cuda $CUDA_TARGET_ROOT/lib64/stubs/libcuda.so SONAME libcuda.so.1)
###
macro GENERATE_IMPLIB(Lib, Path, SONAME="", DLOPEN_CALLBACK="_") {
    .CMD=${tool:"contrib/tools/implib"} --target $HARDWARE_TYPE --dlopen-callback $DLOPEN_CALLBACK --outdir $BINDIR ${pre=--library-load-name :SONAME} $Path ${hide;output;suf=.init.c;nopath:Path} ${hide;output;suf=.tramp.S;nopath:Path} ${hide;kv:"p IL"} ${hide;kv:"pc yellow"}
    .STRUCT_CMD=yes

    LINK_EXCLUDE_LIBRARIES($Lib)
}
