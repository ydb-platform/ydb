diff --git a/include/__memory/allocator.h b/include/__memory/allocator.h
index c8e3b08..326be6d 100644
--- a/include/__memory/allocator.h
+++ b/include/__memory/allocator.h
@@ -172,6 +172,8 @@ inline _LIBCPP_HIDE_FROM_ABI bool operator!=(const allocator<_Tp>&, const alloca
 
 #endif
 
+#include <__memory/allocator_const.h>
+
 _LIBCPP_END_NAMESPACE_STD
 
 #endif // _LIBCPP___MEMORY_ALLOCATOR_H
diff --git a/include/__memory/construct_at.h b/include/__memory/construct_at.h
index 1f129d1..9abd335 100644
--- a/include/__memory/construct_at.h
+++ b/include/__memory/construct_at.h
@@ -37,7 +37,7 @@ _LIBCPP_BEGIN_NAMESPACE_STD
 template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
 _LIBCPP_HIDE_FROM_ABI constexpr _Tp* construct_at(_Tp* __location, _Args&&... __args) {
   _LIBCPP_ASSERT_NON_NULL(__location != nullptr, "null pointer given to construct_at");
-  return ::new (static_cast<void*>(__location)) _Tp(std::forward<_Args>(__args)...);
+  return ::new (const_cast<void*>(static_cast<const void*>(__location))) _Tp(std::forward<_Args>(__args)...);
 }
 
 #endif
@@ -48,7 +48,7 @@ _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 _Tp* __construct_at(_Tp* __l
   return std::construct_at(__location, std::forward<_Args>(__args)...);
 #else
   return _LIBCPP_ASSERT_NON_NULL(__location != nullptr, "null pointer given to construct_at"),
-         ::new (static_cast<void*>(__location)) _Tp(std::forward<_Args>(__args)...);
+         ::new (const_cast<void*>(static_cast<const void*>(__location))) _Tp(std::forward<_Args>(__args)...);
 #endif
 }
 
diff --git a/include/__memory/uninitialized_algorithms.h b/include/__memory/uninitialized_algorithms.h
index 9587f01..33354b6 100644
--- a/include/__memory/uninitialized_algorithms.h
+++ b/include/__memory/uninitialized_algorithms.h
@@ -563,8 +563,9 @@ struct __allocator_has_trivial_copy_construct<allocator<_Type>, _Type> : true_ty
 
 template <class _Alloc,
           class _In,
+          class _RawTypeIn = __remove_const_t<_In>,
           class _Out,
-          __enable_if_t<is_trivially_copy_constructible<_In>::value && is_trivially_copy_assignable<_In>::value &&
+          __enable_if_t<is_trivially_copy_constructible<_RawTypeIn>::value && is_trivially_copy_assignable<_RawTypeIn>::value &&
                             is_same<__remove_const_t<_In>, __remove_const_t<_Out> >::value &&
                             __allocator_has_trivial_copy_construct<_Alloc, _In>::value,
                         int> = 0>
@@ -578,7 +579,11 @@ __uninitialized_allocator_copy_impl(_Alloc&, _In* __first1, _In* __last1, _Out*
     }
     return __first2;
   } else {
+#ifdef _LIBCPP_ENABLE_REMOVED_ALLOCATOR_CONST
+    return std::copy(__first1, __last1, const_cast<_RawTypeIn*>(__first2));
+#else
     return std::copy(__first1, __last1, __first2);
+#endif
   }
 }
 
@@ -642,7 +647,11 @@ _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void __uninitialized_allocat
     std::__allocator_destroy(__alloc, __first, __last);
   } else {
     // Casting to void* to suppress clang complaining that this is technically UB.
+#ifdef _LIBCPP_ENABLE_REMOVED_ALLOCATOR_CONST
+    __builtin_memcpy(static_cast<void*>(const_cast<__remove_const_t<__remove_pointer_t<_ContiguousIterator>>*>(std::__to_address(__result))),
+#else
     __builtin_memcpy(static_cast<void*>(std::__to_address(__result)),
+#endif
                      std::__to_address(__first),
                      sizeof(_ValueType) * (__last - __first));
   }
