syntax = "proto2";

// Portod daemon listens on /run/portod.socket unix socket.
// Protocol: Varint length, TContainerRequest req | TContainerResponse rsp.

package rpc;

// List of error codes
enum EError {
    // Request executed successfully. No errors occured.
    Success = 0;
    // Unknown critical error.
    Unknown = 1;
    // Unknown or bad request
    InvalidMethod = 2;
    // Container with specified name already exists. Can't create a new one.
    ContainerAlreadyExists = 3;
    // Container with specified name doesn't exist.
    ContainerDoesNotExist = 4;
    // Unknown property specified.
    InvalidProperty = 5;
    // Unknown data specified.
    InvalidData = 6;
    // Invalid value of property or data.
    InvalidValue = 7;
    // Can't perform specified operation in current container state.
    InvalidState = 8;
    // Operation is not supported due to some reasons (old kernel version, missing
    // kernel modules, etc).
    NotSupported = 9;
    // Requested resources are not available (e.g. can't allocate requested memory
    // without overcommiting).
    ResourceNotAvailable = 10;
    // Insufficient rights for performing requested operation.
    Permission = 11;

    // Can't create new volume with specified name, because there is already one.
    VolumeAlreadyExists = 12;
    // Volume with specified name doesn't exist.
    VolumeNotFound = 13;
    // Operation failed because of insufficient disk space.
    NoSpace = 14;
    // Operation can't be performed, because container or volume are in use by
    // other simultaneous operation.
    Busy = 15;
    // Volume already linked with container
    VolumeAlreadyLinked = 16;
    // Volume not linked with container
    VolumeNotLinked = 17;

    LayerAlreadyExists = 18;
    LayerNotFound = 19;

    NoValue = 20;

    VolumeNotReady = 21;

    // Cannot parse or execute command
    InvalidCommand = 22;

    // Error code is lost or came from future
    LostError = 23;

    DeviceNotFound = 24;

    InvalidPath = 25;

    InvalidNetworkAddress = 26;

    PortoFrozen = 27;

    LabelNotFound = 28;

    InvalidLabel = 29;

    NotFound = 404;

    SocketError = 502;

    SocketUnavailable = 503;

    SocketTimeout = 504;

    // Reserved error code used by Porto internals. Can't be returned to a user.
    Queued = 1000;
}


message TContainerRequest {
    optional TContainerCreateRequest create = 1;
    optional TContainerDestroyRequest destroy = 2;
    optional TContainerListRequest list = 3;
    optional TContainerGetPropertyRequest getProperty = 4;
    optional TContainerSetPropertyRequest setProperty = 5;
    optional TContainerGetDataRequest getData = 6;  // deprecated

    optional TContainerStartRequest start = 7;
    optional TContainerStopRequest stop = 8;
    optional TContainerPauseRequest pause = 9;
    optional TContainerResumeRequest resume = 10;

    optional TContainerPropertyListRequest propertyList = 11;
    optional TContainerDataListRequest dataList = 12; // deprecated

    optional TContainerKillRequest kill = 13;

    optional TVersionRequest version = 14;

    optional TContainerGetRequest get = 15;

    optional TContainerWaitRequest wait = 16;

    optional TContainerCreateRequest createWeak = 17;
    optional TContainerRespawnRequest Respawn = 18;
    optional TContainerWaitRequest AsyncWait = 19;

    optional TFindLabelRequest FindLabel = 20;
    optional TSetLabelRequest SetLabel = 21;
    optional TIncLabelRequest IncLabel = 22;

    optional TVolumePropertyListRequest listVolumeProperties = 103;
    optional TVolumeCreateRequest createVolume = 104;
    optional TVolumeLinkRequest linkVolume = 105;
    optional TVolumeLinkRequest LinkVolumeTarget = 120;
    optional TVolumeUnlinkRequest unlinkVolume = 106;
    optional TVolumeUnlinkRequest UnlinkVolumeTarget = 121;
    optional TVolumeListRequest listVolumes = 107;
    optional TVolumeTuneRequest tuneVolume = 108;

    optional TLayerImportRequest importLayer = 110;
    optional TLayerRemoveRequest removeLayer = 111;
    optional TLayerListRequest listLayers = 112;
    optional TLayerExportRequest exportLayer = 113;

    optional TLayerGetPrivateRequest getlayerprivate = 114;
    optional TLayerSetPrivateRequest setlayerprivate = 115;

    optional TStorageListRequest listStorage = 116;
    optional TStorageRemoveRequest removeStorage = 117;
    optional TStorageImportRequest importStorage = 118;
    optional TStorageExportRequest exportStorage = 119;

    optional TMetaStorage CreateMetaStorage = 122;
    optional TMetaStorage ResizeMetaStorage = 123;
    optional TMetaStorage RemoveMetaStorage = 124;

    optional TSetSymlinkRequest SetSymlink = 125;

    optional TNewVolumeRequest NewVolume = 126;
    optional TGetVolumeRequest GetVolume = 127;

    optional TConvertPathRequest convertPath = 200;
    optional TAttachProcessRequest attachProcess = 201;
    optional TLocateProcessRequest locateProcess = 202;
    optional TAttachProcessRequest AttachThread = 203;

    optional TGetSystemRequest GetSystem = 300;
    optional TSetSystemRequest SetSystem = 301;
}


message TContainerResponse {
    // Actually always set, hack for adding new error codes
    optional EError error = 1 [ default = LostError ];

    // Human readable comment - must be shown to user as is
    optional string errorMsg = 2;

    optional uint64 timestamp = 1000;       // for next changed_since

    optional TContainerListResponse list = 3;

    optional TContainerGetPropertyResponse getProperty = 4;
    optional TContainerGetDataResponse getData = 5;     // deprecated

    optional TContainerPropertyListResponse propertyList = 6;
    optional TContainerDataListResponse dataList = 7;   // deprecated

    optional TVersionResponse version = 8;

    optional TVolumeListResponse volumeList = 9;

    optional TContainerGetResponse get = 10;
    optional TContainerWaitResponse wait = 11;

    optional TVolumePropertyListResponse volumePropertyList = 12;

    optional TVolumeDescription volume = 13;        // reponse to createVolume
    optional TLayerListResponse layers = 14;
    optional TConvertPathResponse convertPath = 15;
    optional TLayerGetPrivateResponse layer_private = 16;
    optional TStorageListResponse storageList = 17;

    optional TLocateProcessResponse locateProcess = 18;

    optional TContainerWaitResponse AsyncWait = 19;

    optional TFindLabelResponse FindLabel = 20;
    optional TSetLabelResponse SetLabel = 21;
    optional TIncLabelResponse IncLabel = 22;

    optional TNewVolumeResponse NewVolume = 126;
    optional TGetVolumeResponse GetVolume = 127;

    optional TGetSystemResponse GetSystem = 300;
    optional TSetSystemResponse SetSystem = 301;
}


// Common objects


message TCred {
    optional string user = 1;           // requires user or uid or both
    optional fixed32 uid = 2;
    optional string group = 3;
    optional fixed32 gid = 4;
}


// Volumes


message TVolumeProperty {
    required string name = 1;
    required string value = 2;
}

message TVolumeDescription {
    required string path = 1;
    repeated TVolumeProperty properties = 2;
    repeated string containers = 3;
    repeated TVolumeLink links = 4;

    optional uint64 change_time = 5;
    optional bool no_changes = 6;           // change_time < changed_since
}


message TVolumeLink {
    required string container = 1;
    optional string target = 2;         // absolute path in container, default: anon
    optional bool required = 3;         // container cannot work without it
    optional bool read_only = 4;
    optional string host_target = 5;    // out, absolute path in host
}

message TVolumeResource {
    optional uint64 limit = 1;
    optional uint64 guarantee = 2;
    optional uint64 usage = 3;          // out
    optional uint64 available = 4;      // out
}

message TVolumeDirectory {
    required string path = 1;           // relative path in volume
    optional TCred cred = 2;            // default: volume cred
    optional fixed32 permissions = 3;   // default: volume permissions
}

message TVolumeSymlink {
    required string path = 1;           // relative path in volume
    required string target_path = 2;
}

message TVolumeShare {
    required string path = 1;           // relative path in volume
    required string origin_path = 2;    // absolute path to origin
    optional bool cow = 3;              // default: mutable
}

message TVolumeSpec {
    optional string path = 1;               // path in container, default: auto
    optional string container = 2;          // default: self
    repeated TVolumeLink links = 3;         // default: anon link to self

    optional string id = 4;                 // out
    optional string state = 5;              // out

    optional string private_value = 6;      // at most 4096 bytes

    optional string device_name = 7;        // out

    optional string backend = 10;           // default: auto
    optional string place = 11;             // path in host, default: default place for self
    optional string storage = 12;           // default: temp
    repeated string layers = 13;
    optional bool read_only = 14;

    // defines root directory user, group and permissions
    optional TCred cred = 20;               // default: self task cred
    optional fixed32 permissions = 21;      // default: 0775

    optional TVolumeResource space = 22;
    optional TVolumeResource inodes = 23;

    optional TCred owner = 30;              // default: self owner
    optional string owner_container = 31;   // default: self
    optional string place_key = 32;         // out
    optional string creator = 33;           // out
    optional bool auto_path = 34;           // out
    optional uint32 device_index = 35;      // out
    optional uint64 build_time = 37;        // out

    // customization at creation
    repeated TVolumeDirectory directories = 40; // in
    repeated TVolumeSymlink symlinks = 41;      // in
    repeated TVolumeShare shares = 42;          // in

    optional uint64 change_time = 50;       // out
    optional bool no_changes = 51;          // out, change_time < changed_since
}


message TLayerDescription {
    required string name = 1;
    required string owner_user = 2;
    required string owner_group = 3;
    required uint64 last_usage = 4;
    required string private_value = 5;
}


message TStorageDescription {
    required string name = 1;
    required string owner_user = 2;
    required string owner_group = 3;
    required uint64 last_usage = 4;
    required string private_value = 5;
}


message TMetaStorage {
    required string name = 1;
    optional string place = 2;
    optional string private_value = 3;
    optional uint64 space_limit = 4;
    optional uint64 inode_limit = 5;

    optional uint64 space_used = 6;         // out
    optional uint64 space_available = 7;    // out
    optional uint64 inode_used = 8;         // out
    optional uint64 inode_available = 9;    // out
    optional string owner_user = 10;        // out
    optional string owner_group = 11;       // out
    optional uint64 last_usage = 12;        // out
}


// COMMANDS

// System

// Get porto version
message TVersionRequest {
}

message TVersionResponse {
    required string tag = 1;
    required string revision = 2;
}


// Get porto statistics
message TGetSystemRequest {
}

message TGetSystemResponse {
    required string porto_version = 1;
    required string porto_revision = 2;
    required string kernel_version = 3;

    required fixed64 errors = 4;
    required fixed64 warnings = 5;
    required fixed64 porto_starts = 6;
    required fixed64 porto_uptime = 7;
    required fixed64 master_uptime = 8;
    optional fixed64 taints = 9;

    optional bool frozen = 10;
    required bool verbose = 100;
    required bool debug = 101;
    required fixed64 log_lines = 102;
    required fixed64 log_bytes = 103;

    required fixed64 stream_rotate_bytes = 104;
    required fixed64 stream_rotate_errors = 105;

    required fixed64 log_lines_lost = 106;
    required fixed64 log_bytes_lost = 107;
    required fixed64 log_open = 108;

    required fixed64 container_count = 200;
    required fixed64 container_limit = 201;
    required fixed64 container_running = 202;
    required fixed64 container_created = 203;
    required fixed64 container_started = 204;
    required fixed64 container_start_failed = 205;
    required fixed64 container_oom = 206;
    required fixed64 container_buried = 207;
    required fixed64 container_lost = 208;
    optional fixed64 container_tainted = 209;

    required fixed64 volume_count = 300;
    required fixed64 volume_limit = 301;
    required fixed64 volume_created = 303;
    required fixed64 volume_failed = 304;
    required fixed64 volume_links = 305;
    required fixed64 volume_links_mounted = 306;
    required fixed64 volume_lost = 307;

    required fixed64 layer_import = 390;
    required fixed64 layer_export = 391;
    required fixed64 layer_remove = 392;

    required fixed64 client_count = 400;
    required fixed64 client_max = 401;
    required fixed64 client_connected = 402;

    required fixed64 request_queued = 500;
    required fixed64 request_completed = 501;
    required fixed64 request_failed = 502;
    required fixed64 request_threads = 503;
    required fixed64 request_longer_1s = 504;
    required fixed64 request_longer_3s = 505;
    required fixed64 request_longer_30s = 506;
    required fixed64 request_longer_5m = 507;

    required fixed64 fail_system = 600;
    required fixed64 fail_invalid_value = 601;
    required fixed64 fail_invalid_command = 602;
    optional fixed64 fail_memory_guarantee = 603;

    optional fixed64 network_count = 700;
    optional fixed64 network_created = 701;
}


// Change porto state
message TSetSystemRequest {
    optional bool frozen = 10;
    optional bool verbose = 100;
    optional bool debug = 101;
}

message TSetSystemResponse {
}


// List available properties
message TContainerPropertyListRequest {
}

message TContainerPropertyListResponse {
    message TContainerPropertyListEntry {
        required string name = 1;
        required string desc = 2;
        optional bool read_only = 3;
        optional bool dynamic = 4;
    }
    repeated TContainerPropertyListEntry list = 1;
}


// deprecated, use PropertyList
message TContainerDataListRequest {
}

message TContainerDataListResponse {
    message TContainerDataListEntry {
        required string name = 1;
        required string desc = 2;
    }
    repeated TContainerDataListEntry list = 1;
}


// Create stopped container
message TContainerCreateRequest {
    required string name = 1;
}


// Stop and destroy container
message TContainerDestroyRequest {
    required string name = 1;
}


// List container names
message TContainerListRequest {
    optional string mask = 1;
    optional uint64 changed_since = 2;  // change_time >= changed_since
}

message TContainerListResponse {
    repeated string name = 1;
}


// Read one property
message TContainerGetPropertyRequest {
    required string name = 1;
    required string property = 2;
    // update cached counters
    optional bool sync = 3;
    optional bool real = 4;
}

message TContainerGetPropertyResponse {
    required string value = 1;
}


// Alias for GetProperty, deprecated
message TContainerGetDataRequest {
    required string name = 1;
    required string data = 2;
    // update cached counters
    optional bool sync = 3;
    optional bool real = 4;
}

message TContainerGetDataResponse {
    required string value = 1;
}


// Change one property
message TContainerSetPropertyRequest {
    required string name = 1;
    required string property = 2;
    required string value = 3;
}


// Get multiple properties/data of many containers with one request
message TContainerGetRequest {
    // list of containers or wildcards, "***" - all
    repeated string name = 1;

    // list of properties/data
    repeated string variable = 2;

    // do not wait busy containers
    optional bool nonblock = 3;

    // update cached counters
    optional bool sync = 4;
    optional bool real = 5;

    // change_time >= changed_since
    optional uint64 changed_since = 6;
}

message TContainerGetResponse {
    message TContainerGetValueResponse {
        required string variable = 1;
        optional EError error = 2;
        optional string errorMsg = 3;
        optional string value = 4;
    }

    message TContainerGetListResponse {
        required string name = 1;
        repeated TContainerGetValueResponse keyval = 2;

        optional uint64 change_time = 3;
        optional bool no_changes = 4;   // change_time < changed_since
    }

    repeated TContainerGetListResponse list = 1;
}


// Start stopped container
message TContainerStartRequest {
    required string name = 1;
}


// Restart dead container
message TContainerRespawnRequest {
    required string name = 1;
}


// Stop dead or running container
message TContainerStopRequest {
    required string name = 1;
    // Timeout in 1/1000 seconds between SIGTERM and SIGKILL, default 30s
    optional uint32 timeout_ms = 2;
}


// Freeze running container
message TContainerPauseRequest {
    required string name = 1;
}


// Unfreeze paused container
message TContainerResumeRequest {
    required string name = 1;
}


// Translate filesystem path between containers
message TConvertPathRequest {
    required string path = 1;
    required string source = 2;
    required string destination = 3;
}

message TConvertPathResponse {
    required string path = 1;
}


// Wait while container(s) is/are in running state
message TContainerWaitRequest {
    // list of containers or wildcards, "***" - all
    repeated string name = 1;

    // timeout in 1/1000 seconds
    optional uint32 timeout_ms = 2;

    // list of label names or wildcards
    repeated string label = 3;
}

message TContainerWaitResponse {
    required string name = 1;           // container name
    optional string state = 2;          // container state or timeout
    optional uint64 when = 3;           // unix time stamp in seconds
    optional string label = 4;
    optional string value = 5;
}


// Send signal main process in container
message TContainerKillRequest {
    required string name = 1;
    required int32 sig = 2;
}


// Move process into container
message TAttachProcessRequest {
    required string name = 1;
    required uint32 pid = 2;
    required string comm = 3; // ignored if empty
}


// Determine container by pid
message TLocateProcessRequest {
    required uint32 pid = 1;
    required string comm = 2; // ignored if empty
}

message TLocateProcessResponse {
    required string name = 1;
}


// Labels


message TFindLabelRequest {
    optional string mask = 1;           // containers name or wildcard
    optional string state = 2;          // filter by container state
    required string label = 3;          // label name or wildcard
    optional string value = 4;          // filter by label value
}

message TFindLabelResponse {
    message TFindLabelEntry {
        required string name = 1;
        required string state = 2;
        required string label = 3;
        required string value = 4;
    }
    repeated TFindLabelEntry list = 1;
}


message TSetLabelRequest {
    required string name = 1;
    required string label = 2;
    required string value = 3;
    optional string prev_value = 4;     // fail with Busy if does not match
    optional string state = 5;          // fail with InvalidState if not match
}

message TSetLabelResponse {
    optional string prev_value = 1;
    optional string state = 2;
}


message TIncLabelRequest {
    required string name = 1;
    required string label = 2;          // missing label starts from 0
    optional int64 add = 3 [ default = 1];
}

message TIncLabelResponse {
    required int64 result = 1;
}


message TSetSymlinkRequest {
    required string container = 1;
    required string symlink = 2;
    optional string target = 3;
}


// Volumes


message TNewVolumeRequest {
    required TVolumeSpec volume = 1;
}

message TNewVolumeResponse {
    required TVolumeSpec volume = 1;
}


message TGetVolumeRequest {
    optional string container = 1;  // get paths in container, default: self
    repeated string path = 2;       // volume path in container, default: all
    optional uint64 changed_since = 3;  // change_time >= changed_since
}

message TGetVolumeResponse {
    repeated TVolumeSpec volume = 1;
}


// List available volume properties
message TVolumePropertyListRequest {
}

message TVolumePropertyListResponse {
    message TVolumePropertyDescription {
        required string name = 1;
        required string desc = 2;
    }
    repeated TVolumePropertyDescription properties = 1;
}


// Create new volume
// "createVolume" returns TVolumeDescription in "volume"
message TVolumeCreateRequest {
    optional string path = 1;
    repeated TVolumeProperty properties = 2;
}


message TVolumeLinkRequest {
    required string path = 1;
    optional string container = 2;      // default - self
    optional string target = 3;         // path in container, "" - anon
    optional bool required = 4;         // stop container at fail
    optional bool read_only = 5;
}


message TVolumeUnlinkRequest {
    required string path = 1;
    optional string container = 2;      // default - self, "***" - all
    optional bool strict = 3;           // non-lazy umount
    optional string target = 4;         // path in container, "" - anon, default - "***" - all
}


message TVolumeListRequest {
    optional string path = 1;
    optional string container = 2;
    optional uint64 changed_since = 3;  // change_time >= changed_since
}

message TVolumeListResponse {
    repeated TVolumeDescription volumes = 1;
}


message TVolumeTuneRequest {
    required string path = 1;
    repeated TVolumeProperty properties = 2;
}


// Layers


message TLayerListRequest {
    optional string place = 1;
    optional string mask = 2;
}

message TLayerListResponse {
    repeated string layer = 1;
    repeated TLayerDescription layers = 2;
}


message TLayerImportRequest {
    required string layer = 1;
    required string tarball = 2;
    required bool merge = 3;
    optional string place = 4;
    optional string private_value = 5;
    optional string compress = 6;
}


message TLayerExportRequest {
    required string volume = 1;
    required string tarball = 2;
    optional string layer = 3;
    optional string place = 4;
    optional string compress = 5;
}


message TLayerRemoveRequest {
    required string layer = 1;
    optional string place = 2;
}


message TLayerGetPrivateRequest {
    required string layer = 1;
    optional string place = 2;
}

message TLayerGetPrivateResponse {
    optional string private_value = 1;
}


message TLayerSetPrivateRequest {
    required string layer = 1;
    optional string place = 2;
    required string private_value = 3;
}


// Storages


message TStorageListRequest {
    optional string place = 1;
    optional string mask = 2;
}

message TStorageListResponse {
    repeated TStorageDescription storages = 1;
    repeated TMetaStorage meta_storages = 2;
}


message TStorageRemoveRequest {
    required string name = 1;
    optional string place = 2;
}


message TStorageImportRequest {
    required string name = 1;
    required string tarball = 2;
    optional string place = 3;
    optional string private_value = 5;
    optional string compress = 6;
}


message TStorageExportRequest {
    required string name = 1;
    required string tarball = 2;
    optional string place = 3;
    optional string compress = 4;
}
