syntax = "proto3";

package yandex.cloud.mdb.clickhouse.v1;

import "google/api/annotations.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "google/type/timeofday.proto";
import "yandex/cloud/api/operation.proto";
import "yandex/cloud/mdb/clickhouse/v1/backup.proto";
import "yandex/cloud/mdb/clickhouse/v1/cluster.proto";
import "yandex/cloud/mdb/clickhouse/v1/config/clickhouse.proto";
import "yandex/cloud/mdb/clickhouse/v1/database.proto";
import "yandex/cloud/mdb/clickhouse/v1/maintenance.proto";
import "yandex/cloud/mdb/clickhouse/v1/user.proto";
import "yandex/cloud/operation/operation.proto";
import "yandex/cloud/validation.proto";

option go_package = "github.com/yandex-cloud/go-genproto/yandex/cloud/mdb/clickhouse/v1;clickhouse";
option java_package = "yandex.cloud.api.mdb.clickhouse.v1";

// A set of methods for managing ClickHouse clusters.
service ClusterService {
  // Returns the specified ClickHouse cluster.
  //
  // To get the list of available ClickHouse clusters, make a [List] request.
  rpc Get(GetClusterRequest) returns (Cluster) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}"};
  }

  // Retrieves a list of ClickHouse clusters that belong
  // to the specified folder.
  rpc List(ListClustersRequest) returns (ListClustersResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters"};
  }

  // Creates a ClickHouse cluster in the specified folder.
  rpc Create(CreateClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "CreateClusterMetadata"
      response: "Cluster"
    };
  }

  // Updates the specified ClickHouse cluster.
  rpc Update(UpdateClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {
      patch: "/managed-clickhouse/v1/clusters/{cluster_id}"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "UpdateClusterMetadata"
      response: "Cluster"
    };
  }

  // Deletes the specified ClickHouse cluster.
  rpc Delete(DeleteClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {delete: "/managed-clickhouse/v1/clusters/{cluster_id}"};
    option (yandex.cloud.api.operation) = {
      metadata: "DeleteClusterMetadata"
      response: "google.protobuf.Empty"
    };
  }

  // Starts the specified ClickHouse cluster.
  rpc Start(StartClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {post: "/managed-clickhouse/v1/clusters/{cluster_id}:start"};
    option (yandex.cloud.api.operation) = {
      metadata: "StartClusterMetadata"
      response: "Cluster"
    };
  }

  // Stops the specified ClickHouse cluster.
  rpc Stop(StopClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {post: "/managed-clickhouse/v1/clusters/{cluster_id}:stop"};
    option (yandex.cloud.api.operation) = {
      metadata: "StopClusterMetadata"
      response: "Cluster"
    };
  }

  // Moves a ClickHouse cluster to the specified folder.
  rpc Move(MoveClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}:move"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "MoveClusterMetadata"
      response: "Cluster"
    };
  }

  // Adds a ZooKeeper subcluster to the specified ClickHouse cluster.
  rpc AddZookeeper(AddClusterZookeeperRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}:addZookeeper"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "AddClusterZookeeperMetadata"
      response: "Cluster"
    };
  }

  // Creates a backup for the specified ClickHouse cluster.
  rpc Backup(BackupClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {post: "/managed-clickhouse/v1/clusters/{cluster_id}:backup"};
    option (yandex.cloud.api.operation) = {
      metadata: "BackupClusterMetadata"
      response: "Cluster"
    };
  }

  // Creates a new ClickHouse cluster using the specified backup.
  rpc Restore(RestoreClusterRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters:restore"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "RestoreClusterMetadata"
      response: "Cluster"
    };
  }

  // Reschedules planned maintenance operation.
  rpc RescheduleMaintenance(RescheduleMaintenanceRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}:rescheduleMaintenance"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "RescheduleMaintenanceMetadata"
      response: "Cluster"
    };
  }

  // Retrieves logs for the specified ClickHouse cluster.
  rpc ListLogs(ListClusterLogsRequest) returns (ListClusterLogsResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}:logs"};
  }

  // Same as ListLogs but using server-side streaming. Also allows for `tail -f` semantics.
  rpc StreamLogs(StreamClusterLogsRequest) returns (stream StreamLogRecord) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}:stream_logs"};
  }

  // Retrieves the list of Operation resources for the specified cluster.
  rpc ListOperations(ListClusterOperationsRequest) returns (ListClusterOperationsResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/operations"};
  }

  // Retrieves the list of available backups for the specified ClickHouse cluster.
  rpc ListBackups(ListClusterBackupsRequest) returns (ListClusterBackupsResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/backups"};
  }

  // Retrieves a list of hosts for the specified cluster.
  rpc ListHosts(ListClusterHostsRequest) returns (ListClusterHostsResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/hosts"};
  }

  // Creates new hosts for a cluster.
  rpc AddHosts(AddClusterHostsRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}/hosts:batchCreate"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "AddClusterHostsMetadata"
      response: "google.protobuf.Empty"
    };
  }

  // Updates the specified hosts.
  rpc UpdateHosts(UpdateClusterHostsRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}/hosts:batchUpdate"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "UpdateClusterHostsMetadata"
      response: "google.protobuf.Empty"
    };
  }

  // Deletes the specified hosts for a cluster.
  rpc DeleteHosts(DeleteClusterHostsRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}/hosts:batchDelete"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "DeleteClusterHostsMetadata"
      response: "google.protobuf.Empty"
    };
  }

  rpc RestartHosts(RestartClusterHostsRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}/hosts:restartHosts"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "RestartClusterHostsMetadata"
      response: "google.protobuf.Empty"
    };
  }

  // Returns the specified shard.
  rpc GetShard(GetClusterShardRequest) returns (Shard) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/shards/{shard_name}"};
  }

  // Retrieves a list of shards that belong to the specified cluster.
  rpc ListShards(ListClusterShardsRequest) returns (ListClusterShardsResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/shards"};
  }

  // Creates a new shard in the specified cluster.
  rpc AddShard(AddClusterShardRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}/shards"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "AddClusterShardMetadata"
      response: "Shard"
    };
  }

  // Modifies the specified shard.
  rpc UpdateShard(UpdateClusterShardRequest) returns (operation.Operation) {
    option (google.api.http) = {
      patch: "/managed-clickhouse/v1/clusters/{cluster_id}/shards/{shard_name}"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "UpdateClusterShardMetadata"
      response: "Shard"
    };
  }

  // Deletes the specified shard.
  rpc DeleteShard(DeleteClusterShardRequest) returns (operation.Operation) {
    option (google.api.http) = {delete: "/managed-clickhouse/v1/clusters/{cluster_id}/shards/{shard_name}"};
    option (yandex.cloud.api.operation) = {
      metadata: "DeleteClusterShardMetadata"
      response: "google.protobuf.Empty"
    };
  }

  // Returns the specified shard group.
  rpc GetShardGroup(GetClusterShardGroupRequest) returns (ShardGroup) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/shardGroups/{shard_group_name}"};
  }

  // Retrieves a list of shard groups that belong to specified cluster.
  rpc ListShardGroups(ListClusterShardGroupsRequest) returns (ListClusterShardGroupsResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/shardGroups"};
  }

  // Creates a new shard group in the specified cluster.
  rpc CreateShardGroup(CreateClusterShardGroupRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}/shardGroups"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "CreateClusterShardGroupMetadata"
      response: "ShardGroup"
    };
  }

  // Updates the specified shard group.
  rpc UpdateShardGroup(UpdateClusterShardGroupRequest) returns (operation.Operation) {
    option (google.api.http) = {
      patch: "/managed-clickhouse/v1/clusters/{cluster_id}/shardGroups/{shard_group_name}"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "UpdateClusterShardGroupMetadata"
      response: "ShardGroup"
    };
  }

  // Deletes the specified shard group.
  rpc DeleteShardGroup(DeleteClusterShardGroupRequest) returns (operation.Operation) {
    option (google.api.http) = {delete: "/managed-clickhouse/v1/clusters/{cluster_id}/shardGroups/{shard_group_name}"};
    option (yandex.cloud.api.operation) = {
      metadata: "DeleteClusterShardGroupMetadata"
      response: "google.protobuf.Empty"
    };
  }

  // Retrieves a list of external dictionaries that belong to specified cluster.
  rpc ListExternalDictionaries(ListClusterExternalDictionariesRequest) returns (ListClusterExternalDictionariesResponse) {
    option (google.api.http) = {get: "/managed-clickhouse/v1/clusters/{cluster_id}/externalDictionaries"};
  }

  // Creates an external dictionary for the specified ClickHouse cluster.
  rpc CreateExternalDictionary(CreateClusterExternalDictionaryRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}:createExternalDictionary"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "CreateClusterExternalDictionaryMetadata"
      response: "Cluster"
    };
  }

  // Updates an external dictionary for the specified ClickHouse cluster.
  rpc UpdateExternalDictionary(UpdateClusterExternalDictionaryRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}:updateExternalDictionary"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "UpdateClusterExternalDictionaryMetadata"
      response: "Cluster"
    };
  }

  // Deletes the specified external dictionary.
  rpc DeleteExternalDictionary(DeleteClusterExternalDictionaryRequest) returns (operation.Operation) {
    option (google.api.http) = {
      post: "/managed-clickhouse/v1/clusters/{cluster_id}:deleteExternalDictionary"
      body: "*"
    };
    option (yandex.cloud.api.operation) = {
      metadata: "DeleteClusterExternalDictionaryMetadata"
      response: "Cluster"
    };
  }
}

message GetClusterRequest {
  // ID of the ClickHouse Cluster resource to return.
  // To get the cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];
}

message ListClustersRequest {
  // ID of the folder to list ClickHouse clusters in.
  // To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
  string folder_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClustersResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "<=1000"];

  // Page token. To get the next page of results, set [page_token] to the [ListClustersResponse.next_page_token]
  // returned by the previous list request.
  string page_token = 3 [(length) = "<=100"];

  // A filter expression that filters resources listed in the response.
  // The expression must specify:
  // 1. The field name. Currently you can only use filtering with the [Cluster.name] field.
  // 2. An `=` operator.
  // 3. The value in double quotes (`"`). Must be 1-63 characters long and match the regular expression `[a-zA-Z0-9_-]+`.
  string filter = 4 [(length) = "<=1000"];
}

message ListClustersResponse {
  // List of ClickHouse Cluster resources.
  repeated Cluster clusters = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClustersRequest.page_size], use the [next_page_token] as the value
  // for the [ListClustersRequest.page_token] parameter in the next list request. Each subsequent
  // list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message CreateClusterRequest {
  // ID of the folder to create the ClickHouse cluster in.
  string folder_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the ClickHouse cluster. The name must be unique within the folder.
  string name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // Description of the ClickHouse cluster.
  string description = 3 [(length) = "<=256"];

  // Custom labels for the ClickHouse cluster as `key:value` pairs. Maximum 64 per resource.
  // For example, "project": "mvp" or "source": "dictionary".
  map<string, string> labels = 4 [
    (yandex.cloud.size) = "<=64",
    (length) = "<=63",
    (pattern) = "[-_0-9a-z]*",
    (map_key).length = "<=63",
    (map_key).pattern = "[a-z][-_0-9a-z]*"
  ];

  // Deployment environment of the ClickHouse cluster.
  Cluster.Environment environment = 5 [(required) = true];

  // Configuration and resources for hosts that should be created for the ClickHouse cluster.
  ConfigSpec config_spec = 6 [(required) = true];

  // Descriptions of databases to be created in the ClickHouse cluster.
  repeated DatabaseSpec database_specs = 7 [(size) = ">0"];

  // Descriptions of database users to be created in the ClickHouse cluster.
  repeated UserSpec user_specs = 8 [(size) = ">0"];

  // Individual configurations for hosts that should be created for the ClickHouse cluster.
  repeated HostSpec host_specs = 9 [(size) = ">0"];

  // ID of the network to create the cluster in.
  string network_id = 10 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the first shard in cluster. If not set, defaults to the value 'shard1'.
  string shard_name = 11 [
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // ID of the service account used for access to Object Storage.
  string service_account_id = 12;

  // User security groups
  repeated string security_group_ids = 13;

  // Deletion Protection inhibits deletion of the cluster
  bool deletion_protection = 14;

  // Window of maintenance operations.
  MaintenanceWindow maintenance_window = 15;
}

message CreateClusterMetadata {
  // ID of the ClickHouse cluster that is being created.
  string cluster_id = 1;
}

message UpdateClusterRequest {
  // ID of the ClickHouse Cluster resource to update.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Field mask that specifies which fields of the ClickHouse Cluster resource should be updated.
  google.protobuf.FieldMask update_mask = 2;

  // New description of the ClickHouse cluster.
  string description = 3 [(length) = "<=256"];

  // Custom labels for the ClickHouse cluster as `key:value` pairs. Maximum 64 per resource.
  // For example, "project": "mvp" or "source": "dictionary".
  //
  // The new set of labels will completely replace the old ones. To add a label, request the current
  // set with the [ClusterService.Get] method, then send an [ClusterService.Update] request with the new label added to the set.
  map<string, string> labels = 4 [
    (yandex.cloud.size) = "<=64",
    (length) = "<=63",
    (pattern) = "[-_0-9a-z]*",
    (map_key).length = "<=63",
    (map_key).pattern = "[a-z][-_0-9a-z]*"
  ];

  // New configuration and resources for hosts in the cluster.
  ConfigSpec config_spec = 5;

  // New name for the cluster.
  string name = 6 [
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // ID of the service account used for access to Object Storage.
  string service_account_id = 7;

  // New maintenance window settings for the cluster.
  MaintenanceWindow maintenance_window = 8;

  // User security groups
  repeated string security_group_ids = 9;

  // Deletion Protection inhibits deletion of the cluster
  bool deletion_protection = 10;
}

message UpdateClusterMetadata {
  // ID of the ClickHouse Cluster resource that is being updated.
  string cluster_id = 1;
}

message DeleteClusterRequest {
  // ID of the ClickHouse cluster to delete.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];
}

message DeleteClusterMetadata {
  // ID of the ClickHouse cluster that is being deleted.
  string cluster_id = 1;
}

message StartClusterRequest {
  // ID of the ClickHouse cluster to start.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];
}

message StartClusterMetadata {
  // ID of the ClickHouse cluster being started.
  string cluster_id = 1;
}

message StopClusterRequest {
  // ID of the ClickHouse cluster to stop.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];
}

message StopClusterMetadata {
  // ID of the ClickHouse cluster being stopped.
  string cluster_id = 1;
}

message MoveClusterRequest {
  // ID of the ClickHouse cluster to move.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // ID of the destination folder.
  string destination_folder_id = 2 [
    (required) = true,
    (length) = "<=50"
  ];
}

message MoveClusterMetadata {
  // ID of the ClickHouse cluster being moved.
  string cluster_id = 1;

  // ID of the source folder.
  string source_folder_id = 2;

  // ID of the destination folder.
  string destination_folder_id = 3;
}

message AddClusterZookeeperRequest {
  // ID of the ClickHouse cluster to modify.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Resources allocated to Zookeeper hosts.
  Resources resources = 2;

  // Configuration of ZooKeeper hosts.
  repeated HostSpec host_specs = 3;

  // Enable automatic convertation of non-replicated MergeTree tables to replicated ones.
  google.protobuf.BoolValue convert_tables_to_replicated = 4;
}

message AddClusterZookeeperMetadata {
  // ID of the ClickHouse cluster.
  string cluster_id = 1;
}

message BackupClusterRequest {
  // ID of the ClickHouse cluster to back up.
  // To get the ClickHouse cluster ID use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];
}

message BackupClusterMetadata {
  // ID of the ClickHouse cluster that is being backed up.
  string cluster_id = 1;
}

message RestoreClusterRequest {
  reserved 12;
  // ID of the backup to restore from. This backup will be used to create one cluster shard.
  // To get the backup ID, use a [ClusterService.ListBackups] request.
  string backup_id = 1 [(required) = true];

  // Additional IDs of the backups to restore from.
  // Each additional backup is responsible for restoring separate shard.
  // Restored cluster will have len(additional_backup_ids)+1 shards in total.
  // To get the backup ID, use a [ClusterService.ListBackups] request.
  repeated string additional_backup_ids = 13;

  // Name of the new ClickHouse cluster. The name must be unique within the folder.
  string name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // Description of the new ClickHouse cluster.
  string description = 3 [(length) = "<=256"];

  // Custom labels for the ClickHouse cluster as `key:value` pairs. Maximum 64 per resource.
  // For example, "project": "mvp" or "source": "dictionary".
  map<string, string> labels = 4 [
    (yandex.cloud.size) = "<=64",
    (length) = "<=63",
    (pattern) = "[-_0-9a-z]*",
    (map_key).length = "<=63",
    (map_key).pattern = "[a-z][-_0-9a-z]*"
  ];

  // Deployment environment of the new ClickHouse cluster.
  Cluster.Environment environment = 5 [(required) = true];

  // Configuration for the ClickHouse cluster to be created.
  ConfigSpec config_spec = 6 [(required) = true];

  // Configurations for ClickHouse hosts that should be created for
  // the cluster that is being created from the backup.
  repeated HostSpec host_specs = 7 [(size) = ">0"];

  // ID of the network to create the ClickHouse cluster in.
  string network_id = 8 [
    (required) = true,
    (length) = "<=50"
  ];

  // ID of the folder to create the ClickHouse cluster in.
  string folder_id = 9 [(length) = "<=50"];

  // ID of the service account used for access to Object Storage.
  string service_account_id = 10;

  // User security groups
  repeated string security_group_ids = 11;

  // Deletion Protection inhibits deletion of the cluster
  bool deletion_protection = 14;
}

message RestoreClusterMetadata {
  // ID of the new ClickHouse cluster that is being created from a backup.
  string cluster_id = 1;

  // ID of the backup that is being used for creating a cluster.
  string backup_id = 2;
}

message RescheduleMaintenanceRequest {
  // ID of the ClickHouse cluster to reschedule the maintenance operation for.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  enum RescheduleType {
    RESCHEDULE_TYPE_UNSPECIFIED = 0;

    // Start the maintenance operation immediately.
    IMMEDIATE = 1;

    // Start the maintenance operation within the next available maintenance window.
    NEXT_AVAILABLE_WINDOW = 2;

    // Start the maintenance operation at the specific time.
    SPECIFIC_TIME = 3;
  }
  // The type of reschedule request.
  RescheduleType reschedule_type = 2 [(required) = true];

  // The time until which this maintenance operation should be delayed. The value should be ahead of the first time when the maintenance operation has been scheduled for no more than two weeks. The value can also point to the past moment of time if [reschedule_type.IMMEDIATE] reschedule type is chosen.
  google.protobuf.Timestamp delayed_until = 3;
}

// Rescheduled maintenance operation metadata.
message RescheduleMaintenanceMetadata {
  reserved 2 to 3;
  // Required. ID of the ClickHouse cluster.
  string cluster_id = 1;

  // Required. The time until which this maintenance operation is to be delayed.
  google.protobuf.Timestamp delayed_until = 4;
}

message LogRecord {
  // Log record timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  google.protobuf.Timestamp timestamp = 1;

  // Contents of the log record.
  map<string, string> message = 2;
}

message ListClusterLogsRequest {
  // ID of the ClickHouse cluster to request logs for.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Columns from logs table to request.
  // If no columns are specified, entire log records are returned.
  repeated string column_filter = 2;

  // Type of the service to request logs about.
  ServiceType service_type = 3 [(required) = true];

  enum ServiceType {
    SERVICE_TYPE_UNSPECIFIED = 0;

    // Logs of ClickHouse activity.
    CLICKHOUSE = 1;
  }

  // Start timestamp for the logs request, in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  google.protobuf.Timestamp from_time = 4;

  // End timestamp for the logs request, in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  google.protobuf.Timestamp to_time = 5;

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClusterLogsResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 6 [(value) = "<=1000"];

  // Page token.  To get the next page of results, set [page_token] to the [ListClusterLogsResponse.next_page_token]
  // returned by the previous list request.
  string page_token = 7 [(length) = "<=100"];
}

message ListClusterLogsResponse {
  // Requested log records.
  repeated LogRecord logs = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClusterLogsRequest.page_size], use the [next_page_token] as the value
  // for the [ListClusterLogsRequest.page_token] query parameter in the next list request.
  // Each subsequent list request will have its own [next_page_token] to continue paging through the results.
  // This value is interchangeable with the [StreamLogRecord.next_record_token] from StreamLogs method.
  string next_page_token = 2;
}

message StreamLogRecord {
  // One of the requested log records.
  LogRecord record = 1;

  // This token allows you to continue streaming logs starting from the exact
  // same record. To continue streaming, specify value of [next_record_token[
  // as value for the [StreamClusterLogsRequest.record_token] parameter in the next StreamLogs request.
  // This value is interchangeable with the [ListClusterLogsResponse.next_page_token] from ListLogs method.
  string next_record_token = 2;
}

message StreamClusterLogsRequest {
  // Required. ID of the ClickHouse cluster.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Columns from logs table to get in the response.
  repeated string column_filter = 2;

  ServiceType service_type = 3 [(required) = true];

  enum ServiceType {
    SERVICE_TYPE_UNSPECIFIED = 0;

    // Logs of ClickHouse activity.
    CLICKHOUSE = 1;
  }

  // Start timestamp for the logs request.
  google.protobuf.Timestamp from_time = 4;

  // End timestamp for the logs request.
  // If this field is not set, all existing logs will be sent and then the new ones as
  // they appear. In essence it has `tail -f` semantics.
  google.protobuf.Timestamp to_time = 5;

  // Record token. Set [record_token] to the [StreamLogRecord.next_record_token] returned by a previous StreamLogs
  // request to start streaming from next log record.
  string record_token = 6 [(length) = "<=100"];

  // A filter expression that filters resources listed in the response.
  // The expression must specify:
  // 1. The field name. Currently filtering can be applied to the [LogRecord.logs.message.hostname], [LogRecord.logs.message.severity] fields.
  // 2. An `=` operator.
  // 3. The value in double quotes (`"`). Must be 1-63 characters long and match the regular expression `[a-z0-9.-]{1,61}`.
  // Examples of a filter:
  // - `message.hostname='node1.db.cloud.yandex.net'`
  // - `message.severity IN ('Error', 'Fatal') AND message.hostname != 'node2.db.cloud.yandex.net'`.
  string filter = 7 [(length) = "<=1000"];
}

message ListClusterOperationsRequest {
  // ID of the ClickHouse Cluster resource to list operations for.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClusterOperationsResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "<=1000"];

  // Page token.  To get the next page of results, set [page_token] to the [ListClusterOperationsResponse.next_page_token]
  // returned by the previous list request.
  string page_token = 3 [(length) = "<=100"];
}

message ListClusterOperationsResponse {
  // List of Operation resources for the specified ClickHouse cluster.
  repeated operation.Operation operations = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClusterOperationsRequest.page_size], use the [next_page_token] as the value
  // for the [ListClusterOperationsRequest.page_token] query parameter in the next list request.
  // Each subsequent list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message ListClusterBackupsRequest {
  // ID of the ClickHouse cluster.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClusterBackupsResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "<=1000"];

  // Page token. To get the next page of results, set [page_token] to the
  // [ListClusterBackupsResponse.next_page_token] returned by the previous list request.
  string page_token = 3 [(length) = "<=100"];
}

message ListClusterBackupsResponse {
  // List of ClickHouse Backup resources.
  repeated Backup backups = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClusterBackupsRequest.page_size], use the [next_page_token] as the value
  // for the [ListClusterBackupsRequest.page_token] query parameter in the next list request.
  // Each subsequent list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message ListClusterHostsRequest {
  // ID of the ClickHouse cluster.
  // To get the ClickHouse cluster ID use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClusterHostsResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "<=1000"];

  // Page token.  To get the next page of results, set [page_token] to the [ListClusterHostsResponse.next_page_token]
  // returned by the previous list request.
  string page_token = 3 [(length) = "<=100"];
}

message ListClusterHostsResponse {
  // Requested list of hosts for the cluster.
  repeated Host hosts = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClusterHostsRequest.page_size], use the [next_page_token] as the value
  // for the [ListClusterHostsRequest.page_token] query parameter in the next list request.
  // Each subsequent list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message AddClusterHostsRequest {
  // ID of the ClickHouse cluster to add hosts to.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Configurations for ClickHouse hosts that should be added to the cluster.
  repeated HostSpec host_specs = 2 [(size) = ">0"];

  // Whether to copy schema to new ClickHouse hosts from replicas.
  google.protobuf.BoolValue copy_schema = 3;
}

message AddClusterHostsMetadata {
  // ID of the ClickHouse cluster to which the hosts are being added.
  string cluster_id = 1;

  // Names of hosts that are being added to the cluster.
  repeated string host_names = 2;
}

message UpdateHostSpec {
  // Name of the host to update.
  // To get the ClickHouse host name, use a [ClusterService.ListHosts] request.
  string host_name = 1 [(required) = true];

  // Field mask that specifies which fields of the ClickHouse host should be updated.
  google.protobuf.FieldMask update_mask = 2;

  // Whether the host should get a public IP address on creation.
  google.protobuf.BoolValue assign_public_ip = 3;
}

message UpdateClusterHostsRequest {
  // ID of the ClickHouse cluster to update hosts in.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // New configurations to apply to hosts.
  repeated UpdateHostSpec update_host_specs = 2 [(size) = ">0"];
}

message UpdateClusterHostsMetadata {
  // ID of the ClickHouse cluster to modify hosts in.
  string cluster_id = 1;

  // Names of hosts that are being modified.
  repeated string host_names = 2;
}

message DeleteClusterHostsRequest {
  // ID of the ClickHouse cluster to remove hosts from.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Names of hosts to delete.
  repeated string host_names = 2 [
    (size) = ">0",
    (length) = "<=253"
  ];
}

message DeleteClusterHostsMetadata {
  // ID of the ClickHouse cluster to remove hosts from.
  string cluster_id = 1;

  // Names of hosts that are being deleted.
  repeated string host_names = 2;
}

message RestartClusterHostsRequest {
  // Required. ID of the Clickhouse cluster.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Required. Name of the hosts to restart.
  repeated string host_names = 2 [
    (size) = ">0",
    (length) = "<=353"
  ];
}

message RestartClusterHostsMetadata {
  // Required. ID of the ClickHouse cluster.
  string cluster_id = 1;

  // Required. The name of restarting host.
  repeated string host_names = 2;
}

message GetClusterShardRequest {
  // ID of the cluster that the shard belongs to.
  // To get the cluster ID, use a [ClusterService.List] request.
  // To get the name of the database, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the shard to request information about.
  // To get the name of a shard, use a [ClusterService.ListShards] request.
  string shard_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];
}

message ListClusterShardsRequest {
  // ID of the ClickHouse cluster to list shards in.
  // To get the cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClusterShardsResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "0-1000"];

  // Page token.  to get the next page of results, set [page_token] to the [ListClusterShardsResponse.next_page_token]
  // returned by the previous list request.
  string page_token = 3 [(length) = "<=100"];
}

message ListClusterShardsResponse {
  // List of ClickHouse shards.
  repeated Shard shards = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClusterShardsRequest.page_size], use the [next_page_token] as the value
  // for the [ListClusterShardsRequest.page_token] parameter in the next list request. Each subsequent
  // list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message AddClusterShardRequest {
  // ID of the ClickHouse cluster to add a shard to.
  // To get the ClickHouse cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name for the new shard.
  string shard_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // Configuration of the new shard.
  ShardConfigSpec config_spec = 3;

  // Configurations for ClickHouse hosts that should be created with the shard.
  repeated HostSpec host_specs = 4 [(size) = ">0"];

  // Whether to copy schema to hosts of the shard to be created. The schema is copied from hosts of an existing shard.
  google.protobuf.BoolValue copy_schema = 5;
}

message AddClusterShardMetadata {
  // ID of the cluster that a shard is being added to.
  string cluster_id = 1;

  // Name of the shard being created.
  string shard_name = 2;
}

message UpdateClusterShardRequest {
  // ID of the ClickHouse cluster the shard belongs to.
  // To get the cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the shard to be updated.
  // To get the name of a shard, use a [ClusterService.ListShards] request.
  string shard_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // Field mask that specifies which attributes of the ClickHouse shard should be updated.
  google.protobuf.FieldMask update_mask = 3;

  // New configuration for the specified shard.
  ShardConfigSpec config_spec = 4;
}

message UpdateClusterShardMetadata {
  // ID of the cluster that contains the shard being updated.
  string cluster_id = 1;

  // Name of the shard being updated.
  string shard_name = 2;
}

message DeleteClusterShardRequest {
  // ID of the ClickHouse cluster the shard belongs to.
  // To get the cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the shard to be deleted.
  // To get the name of a shard, use a [ClusterService.ListShards] request.
  string shard_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];
}

message DeleteClusterShardMetadata {
  // ID of the cluster that contains the shard being deleted.
  string cluster_id = 1;

  // Name of the shard being deleted.
  string shard_name = 2;
}

message GetClusterShardGroupRequest {
  // ID of the cluster that the shard group belongs to.
  //
  // To get the cluster ID, make a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the shard group to request information about.
  //
  // To get the name of a shard group, make a [ClusterService.ListShardGroups] request.
  string shard_group_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];
}

message ListClusterShardGroupsRequest {
  // ID of the cluster that the shard group belongs to.
  //
  // To get the cluster ID, make a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return.
  //
  // If the number of available results is larger than [page_size], the service returns a [ListClusterShardGroupsResponse.next_page_token] that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "0-1000"];

  // Page token.
  //
  // To get the next page of results, set [page_token] to the [ListClusterShardGroupsResponse.next_page_token] returned by the previous list request.
  string page_token = 3 [(length) = "<=100"];
}

message ListClusterShardGroupsResponse {
  // List of ClickHouse cluster's shard groups.
  repeated ShardGroup shard_groups = 1;

  // This token allows you to get the next page of results for list requests.
  //
  // If the number of results is larger than [ListClusterShardGroupsRequest.page_size], use the [next_page_token] as the value for the [ListClusterShardGroupsRequest.page_token] parameter in the next list request.
  // Each subsequent list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message CreateClusterShardGroupRequest {
  // ID of the ClickHouse cluster to add a shard group to.
  //
  // To get the cluster ID, make a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name for the new shard group.
  string shard_group_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  // Description of the new shard group. 0-256 characters long.
  string description = 3;

  // List of shard names that should be put into the new group.
  //
  // To get the list, make a [ClusterService.ListShardGroups] request.
  repeated string shard_names = 4;
}

message CreateClusterShardGroupMetadata {
  // ID of the cluster to add a shard group to.
  string cluster_id = 1;

  // Name of the shard group that is being added.
  string shard_group_name = 2;
}

message UpdateClusterShardGroupRequest {
  // ID of the ClickHouse cluster that contains the shard group to update.
  //
  // To get the cluster ID, make a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the shard group that should be updated.
  //
  // To get the name, make a [ClusterService.ListShardGroups] request.
  string shard_group_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];

  google.protobuf.FieldMask update_mask = 3;

  // Updated description of the shard group. 0-256 characters long.
  string description = 4;

  // Updated list of shard names that belongs to the shard group.
  repeated string shard_names = 5;
}

message UpdateClusterShardGroupMetadata {
  // ID of the cluster that contains the shard group being updated.
  string cluster_id = 1;

  // Name of the shard group that is being updated.
  string shard_group_name = 2;
}

message DeleteClusterShardGroupRequest {
  // ID of the ClickHouse cluster that contains the shard group to delete.
  //
  // To get the cluster ID, make a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the shard group that should be deleted.
  //
  // To get the name, make a [ClusterService.ListShardGroups] request.
  string shard_group_name = 2 [
    (required) = true,
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];
}

message DeleteClusterShardGroupMetadata {
  // ID of the cluster that contains the shard group being deleted.
  string cluster_id = 1;

  // Name of the shard group that is being deleted.
  string shard_group_name = 2;
}

message ListClusterExternalDictionariesRequest {
  // ID of the cluster that the external dictionaries belong to.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListClusterExternalDictionaryResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  int64 page_size = 2 [(value) = "0-1000"];

  // Page token. To get the next page of results, set [page_token] to the [ListClusterExternalDictionaryResponse.next_page_token]
  // returned by a previous list request.
  string page_token = 3 [(length) = "<=100"];
}

message ListClusterExternalDictionariesResponse {
  // List of ClickHouse Cluster external dictionaries.
  repeated config.ClickhouseConfig.ExternalDictionary external_dictionaries = 1;

  // This token allows you to get the next page of results for list requests. If the number of results
  // is larger than [ListClusterExternalDictionaryRequest.page_size], use the [next_page_token] as the value
  // for the [ListClusterExternalDictionaryRequest.page_token] parameter in the next list request. Each subsequent
  // list request will have its own [next_page_token] to continue paging through the results.
  string next_page_token = 2;
}

message CreateClusterExternalDictionaryRequest {
  // ID of the ClickHouse cluster to create the external dictionary for.
  // To get the cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Configuration of the external dictionary.
  config.ClickhouseConfig.ExternalDictionary external_dictionary = 2;
}

message CreateClusterExternalDictionaryMetadata {
  // ID of the cluster for which an external dictionary is being created.
  string cluster_id = 1;
}

message UpdateClusterExternalDictionaryRequest {
  // ID of the ClickHouse cluster to update the external dictionary for.
  // To get the cluster ID, use a [List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Configuration of the external dictionary.
  config.ClickhouseConfig.ExternalDictionary external_dictionary = 2;

  // Field mask that specifies which fields of the External Dictionary should be updated.
  google.protobuf.FieldMask update_mask = 3;
}

message UpdateClusterExternalDictionaryMetadata {
  // ID of the cluster for which an external dictionary is being updated.
  string cluster_id = 1;

  // Name of the external dictionary.
  string external_dictionary_name = 2;
}

message DeleteClusterExternalDictionaryRequest {
  // ID of the ClickHouse cluster to delete the external dictionary from.
  // To get the cluster ID, use a [ClusterService.List] request.
  string cluster_id = 1 [
    (required) = true,
    (length) = "<=50"
  ];

  // Name of the external dictionary to delete.
  string external_dictionary_name = 2;
}

message DeleteClusterExternalDictionaryMetadata {
  // ID of the cluster where an external dictionary is being deleted.
  string cluster_id = 1;
}

message HostSpec {
  // ID of the availability zone where the host resides.
  // To get a list of available zones, use the [yandex.cloud.compute.v1.ZoneService.List] request.
  string zone_id = 1 [(length) = "<=50"];

  // Type of the host to be deployed.
  Host.Type type = 2 [(required) = true];

  // ID of the subnet that the host should belong to. This subnet should be a part
  // of the network that the cluster belongs to.
  // The ID of the network is set in the [Cluster.network_id] field.
  string subnet_id = 3 [(length) = "<=50"];

  // Whether the host should get a public IP address on creation.
  //
  // After a host has been created, this setting cannot be changed. To remove an assigned public IP, or to assign
  // a public IP to a host without one, recreate the host with [assign_public_ip] set as needed.
  //
  // Possible values:
  // * false - don't assign a public IP to the host.
  // * true - the host should have a public IP address.
  bool assign_public_ip = 4;

  // Name of the shard that the host is assigned to.
  string shard_name = 5 [
    (length) = "<=63",
    (pattern) = "[a-zA-Z0-9_-]*"
  ];
}

message ConfigSpec {
  message Clickhouse {
    // Configuration for a ClickHouse server.
    config.ClickhouseConfig config = 1;

    // Resources allocated to ClickHouse hosts.
    Resources resources = 2;
  }

  message Zookeeper {
    // Resources allocated to ZooKeeper hosts. If not set, minimal available resources will be used.
    // All available resource presets can be retrieved with a [ResourcePresetService.List] request.
    Resources resources = 1;
  }

  // Version of the ClickHouse server software.
  string version = 3;

  // Configuration and resources for a ClickHouse server.
  Clickhouse clickhouse = 1;

  // Configuration and resources for a ZooKeeper server.
  Zookeeper zookeeper = 2;

  // Time to start the daily backup, in the UTC timezone.
  google.type.TimeOfDay backup_window_start = 4;

  // Access policy for external services.
  //
  // If you want a specific service to access the ClickHouse cluster, then set the necessary values in this policy.
  Access access = 5;

  CloudStorage cloud_storage = 6;

  // Whether database management through SQL commands is enabled.
  google.protobuf.BoolValue sql_database_management = 7;

  // Whether user management through SQL commands is enabled.
  google.protobuf.BoolValue sql_user_management = 8;

  // Password for user 'admin' that has SQL user management access.
  string admin_password = 9;

  // Whether cluster should use embedded Keeper instead of Zookeeper
  google.protobuf.BoolValue embedded_keeper = 10;
}

message ShardConfigSpec {
  message Clickhouse {
    // ClickHouse settings for the shard.
    config.ClickhouseConfig config = 1;

    // Computational resources for the shard.
    Resources resources = 2;

    // Relative weight of the shard considered when writing data to the cluster.
    // For details, see [ClickHouse documentation](https://clickhouse.com/docs/en/operations/table_engines/distributed/).
    google.protobuf.Int64Value weight = 3;
  }

  // ClickHouse configuration for a shard.
  Clickhouse clickhouse = 1;
}
