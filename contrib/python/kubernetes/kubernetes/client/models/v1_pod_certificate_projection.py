# coding: utf-8

"""
    Kubernetes

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: release-1.34
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from kubernetes.client.configuration import Configuration


class V1PodCertificateProjection(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'certificate_chain_path': 'str',
        'credential_bundle_path': 'str',
        'key_path': 'str',
        'key_type': 'str',
        'max_expiration_seconds': 'int',
        'signer_name': 'str'
    }

    attribute_map = {
        'certificate_chain_path': 'certificateChainPath',
        'credential_bundle_path': 'credentialBundlePath',
        'key_path': 'keyPath',
        'key_type': 'keyType',
        'max_expiration_seconds': 'maxExpirationSeconds',
        'signer_name': 'signerName'
    }

    def __init__(self, certificate_chain_path=None, credential_bundle_path=None, key_path=None, key_type=None, max_expiration_seconds=None, signer_name=None, local_vars_configuration=None):  # noqa: E501
        """V1PodCertificateProjection - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._certificate_chain_path = None
        self._credential_bundle_path = None
        self._key_path = None
        self._key_type = None
        self._max_expiration_seconds = None
        self._signer_name = None
        self.discriminator = None

        if certificate_chain_path is not None:
            self.certificate_chain_path = certificate_chain_path
        if credential_bundle_path is not None:
            self.credential_bundle_path = credential_bundle_path
        if key_path is not None:
            self.key_path = key_path
        self.key_type = key_type
        if max_expiration_seconds is not None:
            self.max_expiration_seconds = max_expiration_seconds
        self.signer_name = signer_name

    @property
    def certificate_chain_path(self):
        """Gets the certificate_chain_path of this V1PodCertificateProjection.  # noqa: E501

        Write the certificate chain at this path in the projected volume.  Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.  # noqa: E501

        :return: The certificate_chain_path of this V1PodCertificateProjection.  # noqa: E501
        :rtype: str
        """
        return self._certificate_chain_path

    @certificate_chain_path.setter
    def certificate_chain_path(self, certificate_chain_path):
        """Sets the certificate_chain_path of this V1PodCertificateProjection.

        Write the certificate chain at this path in the projected volume.  Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.  # noqa: E501

        :param certificate_chain_path: The certificate_chain_path of this V1PodCertificateProjection.  # noqa: E501
        :type: str
        """

        self._certificate_chain_path = certificate_chain_path

    @property
    def credential_bundle_path(self):
        """Gets the credential_bundle_path of this V1PodCertificateProjection.  # noqa: E501

        Write the credential bundle at this path in the projected volume.  The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.  The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).  Using credentialBundlePath lets your Pod's application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.  # noqa: E501

        :return: The credential_bundle_path of this V1PodCertificateProjection.  # noqa: E501
        :rtype: str
        """
        return self._credential_bundle_path

    @credential_bundle_path.setter
    def credential_bundle_path(self, credential_bundle_path):
        """Sets the credential_bundle_path of this V1PodCertificateProjection.

        Write the credential bundle at this path in the projected volume.  The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private key.  The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the signer (leaf and any intermediates).  Using credentialBundlePath lets your Pod's application code make a single atomic read that retrieves a consistent key and certificate chain.  If you project them to separate files, your application code will need to additionally check that the leaf certificate was issued to the key.  # noqa: E501

        :param credential_bundle_path: The credential_bundle_path of this V1PodCertificateProjection.  # noqa: E501
        :type: str
        """

        self._credential_bundle_path = credential_bundle_path

    @property
    def key_path(self):
        """Gets the key_path of this V1PodCertificateProjection.  # noqa: E501

        Write the key at this path in the projected volume.  Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.  # noqa: E501

        :return: The key_path of this V1PodCertificateProjection.  # noqa: E501
        :rtype: str
        """
        return self._key_path

    @key_path.setter
    def key_path(self, key_path):
        """Sets the key_path of this V1PodCertificateProjection.

        Write the key at this path in the projected volume.  Most applications should use credentialBundlePath.  When using keyPath and certificateChainPath, your application needs to check that the key and leaf certificate are consistent, because it is possible to read the files mid-rotation.  # noqa: E501

        :param key_path: The key_path of this V1PodCertificateProjection.  # noqa: E501
        :type: str
        """

        self._key_path = key_path

    @property
    def key_type(self):
        """Gets the key_type of this V1PodCertificateProjection.  # noqa: E501

        The type of keypair Kubelet will generate for the pod.  Valid values are \"RSA3072\", \"RSA4096\", \"ECDSAP256\", \"ECDSAP384\", \"ECDSAP521\", and \"ED25519\".  # noqa: E501

        :return: The key_type of this V1PodCertificateProjection.  # noqa: E501
        :rtype: str
        """
        return self._key_type

    @key_type.setter
    def key_type(self, key_type):
        """Sets the key_type of this V1PodCertificateProjection.

        The type of keypair Kubelet will generate for the pod.  Valid values are \"RSA3072\", \"RSA4096\", \"ECDSAP256\", \"ECDSAP384\", \"ECDSAP521\", and \"ED25519\".  # noqa: E501

        :param key_type: The key_type of this V1PodCertificateProjection.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and key_type is None:  # noqa: E501
            raise ValueError("Invalid value for `key_type`, must not be `None`")  # noqa: E501

        self._key_type = key_type

    @property
    def max_expiration_seconds(self):
        """Gets the max_expiration_seconds of this V1PodCertificateProjection.  # noqa: E501

        maxExpirationSeconds is the maximum lifetime permitted for the certificate.  Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.  If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).  The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.  # noqa: E501

        :return: The max_expiration_seconds of this V1PodCertificateProjection.  # noqa: E501
        :rtype: int
        """
        return self._max_expiration_seconds

    @max_expiration_seconds.setter
    def max_expiration_seconds(self, max_expiration_seconds):
        """Sets the max_expiration_seconds of this V1PodCertificateProjection.

        maxExpirationSeconds is the maximum lifetime permitted for the certificate.  Kubelet copies this value verbatim into the PodCertificateRequests it generates for this projection.  If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values shorter than 3600 (1 hour).  The maximum allowable value is 7862400 (91 days).  The signer implementation is then free to issue a certificate with any lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour).  This constraint is enforced by kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than 24 hours.  # noqa: E501

        :param max_expiration_seconds: The max_expiration_seconds of this V1PodCertificateProjection.  # noqa: E501
        :type: int
        """

        self._max_expiration_seconds = max_expiration_seconds

    @property
    def signer_name(self):
        """Gets the signer_name of this V1PodCertificateProjection.  # noqa: E501

        Kubelet's generated CSRs will be addressed to this signer.  # noqa: E501

        :return: The signer_name of this V1PodCertificateProjection.  # noqa: E501
        :rtype: str
        """
        return self._signer_name

    @signer_name.setter
    def signer_name(self, signer_name):
        """Sets the signer_name of this V1PodCertificateProjection.

        Kubelet's generated CSRs will be addressed to this signer.  # noqa: E501

        :param signer_name: The signer_name of this V1PodCertificateProjection.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and signer_name is None:  # noqa: E501
            raise ValueError("Invalid value for `signer_name`, must not be `None`")  # noqa: E501

        self._signer_name = signer_name

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, V1PodCertificateProjection):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, V1PodCertificateProjection):
            return True

        return self.to_dict() != other.to_dict()
