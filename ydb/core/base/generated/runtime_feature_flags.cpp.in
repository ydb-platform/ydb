// Auto-generated by {{ generator }}, do not modify.
#include <ydb/core/base/generated/runtime_feature_flags.h>
#include <ydb/core/protos/feature_flags.pb.h>

namespace NKikimr {

{% for slot in slots %}
std::tuple<ui64, ui64> TRuntimeFeatureFlags::BitsFromProto_{{ slot.name }}(const NKikimrConfig::TFeatureFlags& flags) {
    ui64 bits = 0;
    ui64 mask = 0;
{%- for field in slot.fields %}
    if (flags.Has{{ field.name }}()) {
        bits |= flags.Get{{ field.name }}() ? {{ field.full_mask }}ULL : {{ field.has_mask }}ULL;
        mask |= {{ field.full_mask }}ULL;
    }
{%- endfor %}
    return { bits, mask };
}

ui64 TRuntimeFeatureFlags::FromProto_{{ slot.name }}(const NKikimrConfig::TFeatureFlags& flags, ui64 value) {
    auto [bits, mask] = BitsFromProto_{{ slot.name }}(flags);
    return (value & ~mask) | bits;
}

void TRuntimeFeatureFlags::Update_{{ slot.name }}(ui64 bits, ui64 mask) {
    ui64 slot = {{ slot.name }}_.load(std::memory_order_relaxed);
    for (;;) {
        ui64 updated = (slot & ~mask) | bits;
        // We perform a CAS so unrelated updates by concurrent threads are not lost
        if ({{ slot.name }}_.compare_exchange_weak(slot, updated, std::memory_order_relaxed)) {
            break;
        }
    }
}
{% endfor %}

TRuntimeFeatureFlags::TRuntimeFeatureFlags()
{%- for slot in slots %}
    {{ ',' if slot.index else ':' }} {{ slot.name }}_{ {{ slot.default_value }}ULL }
{%- endfor %}
{}

TRuntimeFeatureFlags::TRuntimeFeatureFlags(const TRuntimeFeatureFlags& flags)
{%- for slot in slots %}
    {{ ',' if slot.index else ':' }} {{ slot.name }}_{ flags.{{ slot.name }}_.load(std::memory_order_relaxed) }
{%- endfor %}
{}

TRuntimeFeatureFlags& TRuntimeFeatureFlags::operator=(const TRuntimeFeatureFlags& flags) {
{%- for slot in slots %}
    {{ slot.name }}_.store(
        flags.{{ slot.name }}_.load(std::memory_order_relaxed),
        std::memory_order_relaxed);
{%- endfor %}
    return *this;
}

TRuntimeFeatureFlags::TRuntimeFeatureFlags(const NKikimrConfig::TFeatureFlags& flags)
{%- for slot in slots %}
    {{ ',' if slot.index else ':' }} {{ slot.name }}_{ FromProto_{{ slot.name }}(flags, {{ slot.default_value }}ULL) }
{%- endfor %}
{}

TRuntimeFeatureFlags& TRuntimeFeatureFlags::operator=(const NKikimrConfig::TFeatureFlags& flags) {
    CopyFrom(flags);
    return *this;
}

void TRuntimeFeatureFlags::CopyFrom(const NKikimrConfig::TFeatureFlags& flags) {
{%- for slot in slots %}
    ui64 {{ slot.name }} = FromProto_{{ slot.name }}(flags, {{ slot.default_value }}ULL);
{%- endfor %}
{%- for slot in slots %}
    {{ slot.name }}_.store({{ slot.name }}, std::memory_order_relaxed);
{%- endfor %}
}

void TRuntimeFeatureFlags::MergeFrom(const NKikimrConfig::TFeatureFlags& flags) {
{%- for slot in slots %}
    auto [{{ slot.name }}_bits, {{ slot.name }}_mask] = BitsFromProto_{{ slot.name }}(flags);
{%- endfor %}
{%- for slot in slots %}
    Update_{{ slot.name }}({{ slot.name }}_bits, {{ slot.name }}_mask);
{%- endfor %}
}

void TRuntimeFeatureFlags::CopyRuntimeFrom(const NKikimrConfig::TFeatureFlags& flags) {
{%- for slot in slots %}
    ui64 {{ slot.name }} = FromProto_{{ slot.name }}(flags, {{ slot.default_value }}ULL);
{%- endfor %}
{%- for slot in slots %}
    Update_{{ slot.name }}({{ slot.name }} & {{ slot.runtime_flags_mask }}ULL, {{ slot.runtime_flags_mask }}ULL);
{%- endfor %}
}

TRuntimeFeatureFlags::operator NKikimrConfig::TFeatureFlags() const {
    NKikimrConfig::TFeatureFlags flags;
{%- for slot in slots %}
    ui64 {{ slot.name }} = {{ slot.name }}_.load(std::memory_order_relaxed);
{%- endfor %}
{%- for field in fields %}
    if ({{ field.slot.name }} & {{ field.has_mask }}ULL) {
        flags.Set{{ field.name }}(bool({{ field.slot.name }} & {{ field.value_mask }}ULL));
    }
{%- endfor %}
    return flags;
}

{% for field in fields %}
bool TRuntimeFeatureFlags::Has{{ field.name }}() const {
    return {{ field.slot.name }}_.load(std::memory_order_relaxed) & {{ field.has_mask }}ULL;
}

bool TRuntimeFeatureFlags::Get{{ field.name }}() const {
    return {{ field.slot.name }}_.load(std::memory_order_relaxed) & {{ field.value_mask }}ULL;
}

void TRuntimeFeatureFlags::Set{{ field.name }}(bool value) {
    Update_{{ field.slot.name }}(value ? {{ field.full_mask }}ULL : {{ field.has_mask }}ULL, {{ field.full_mask}}ULL);
}

void TRuntimeFeatureFlags::Clear{{ field.name }}() {
    Update_{{ field.slot.name }}({{ field.default_value }}ULL, {{ field.full_mask }}ULL);
}
{% endfor %}

} // namespace NKikimr
