#pragma once

#include <util/generic/ptr.h>
#include <ydb/core/tx/data_events/events.h>
#include <ydb/core/tx/scheme_cache/scheme_cache.h>
#include <ydb/core/scheme/scheme_types_proto.h>
#include <ydb/core/protos/kqp.pb.h>
#include <ydb/library/yql/minikql/computation/mkql_computation_node_holders.h>

namespace NKikimr {
namespace NKqp {

class IPayloadSerializer : public TThrRefBase {
public:
    virtual void AddData(NMiniKQL::TUnboxedValueBatch&& data, bool close) = 0;

    virtual bool IsClosed() = 0;
    virtual bool IsEmpty() = 0;
    virtual bool IsFinished() = 0;

    virtual NKikimrDataEvents::EDataFormat GetDataFormat() = 0;
    virtual std::vector<ui32> GetWriteColumnIds() = 0;

    using TBatches = THashMap<ui64, std::deque<TString>>;

    virtual TBatches FlushBatchesForce() = 0;

    virtual TString FlushBatch(ui64 shardId) = 0;
    virtual const THashSet<ui64>& GetShardIds() const = 0;

    virtual i64 GetMemory() = 0;
};

using IPayloadSerializerPtr = TIntrusivePtr<IPayloadSerializer>;

IPayloadSerializerPtr CreateColumnShardPayloadSerializer(
    const NSchemeCache::TSchemeCacheNavigate::TEntry& schemeEntry,
    const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
    const NMiniKQL::TTypeEnvironment& typeEnv);

IPayloadSerializerPtr CreateDataShardPayloadSerializer(
    const NSchemeCache::TSchemeCacheNavigate::TEntry& schemeEntry,
    const NSchemeCache::TSchemeCacheRequest::TEntry& partitionsEntry,
    const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
    const NMiniKQL::TTypeEnvironment& typeEnv);

}
}
