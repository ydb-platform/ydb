#include "kqp_join_topology_generator.h"
#include <ydb/core/kqp/ut/common/kqp_serializable_rng.h>
#include <ydb/library/yql/dq/opt/dq_opt_make_join_hypergraph.h>
#include <sstream>
#include <string>
#include <random>
#include <vector>
#include <map>


namespace NKikimr::NKqp {
    NYql::NDq::TJoinColumn GetJoinColumn(ui32 tableID, ui32 columnID) {
        return {getTableName(tableID), getColumnName(tableID, columnID)};
    }

    // Generate a random valid join tree to be used later for hypegraph construction.
    //
    // The reason to generate a random tree, not left-deep one (like TRelationGraph::MakeQuery
    // does), even though they are all equivalent to optimizer and produce the same graph
    // is to allow for randomized construction of not fully reorderable queries later.
    //
    // This construction will be carried out by randomly selecting joins in the tree generated by
    // this procedure and replacing them with more complex joins (like left joins, etc...)
    std::shared_ptr<NYql::IBaseOptimizerNode> ToJoinTree(TRNG &rng, const TRelationGraph &graph, double bushiness) {

        const auto& adjacencyList = graph.GetAdjacencyList();

        struct TEdge { ui32 u, v; TVector<NYql::NDq::TJoinColumn> lhs, rhs; };
        std::vector<TEdge> edges;
        for (ui32 i = 0; i < adjacencyList.size(); ++i) {
            for (const auto& edge : adjacencyList[i]) {
                if (i < edge.Target) {
                    edges.push_back(TEdge{i, edge.Target,
                        {GetJoinColumn(i, edge.ColumnLHS)},
                        {GetJoinColumn(edge.Target, edge.ColumnRHS)}
                    });
                }
            }
        }

        // The core idea is to initially put every relation into a separate tree
        // and then randomly merge those trees, creating a bushy tree of all relations.

        // Stores already connected trees, used to find which components to connect next
        // and to figure out where to store tree decomposition of a particular component
        TDisjointSets connectedComponents(adjacencyList.size());

        // Tree decompositions that gradually get merged, only stores trees for
        // canonical set elements of a particular component.

        // tree[i] is only valid if i is a canonical element for one of the components
        // inside connectedComponents disjointSet.
        std::vector<std::shared_ptr<NYql::IBaseOptimizerNode>> trees(adjacencyList.size());

        // Initial forest is just a relation for each graph node:
        for (ui32 i = 0; i < adjacencyList.size(); ++ i) {
            auto relation = std::static_pointer_cast<NYql::IBaseOptimizerNode>(
                std::make_shared<NYql::TRelOptimizerNode>(
                    getTableName(i),
                    NYql::TOptimizerStatistics(NYql::EStatisticsType::BaseTable, 1e9, 20, 1e10)
                )
            );

            trees[i] = std::move(relation);
        }

        // Merges trees containing node "i" and node "j", stores resulting tree in trees
        auto mergeTrees = [&](TEdge edge) {
            ui32 u = connectedComponents.CanonicSetElement(edge.u);
            ui32 v = connectedComponents.CanonicSetElement(edge.v);
            if (u == v) {
                return;
            }

            auto newTree = std::static_pointer_cast<NYql::IBaseOptimizerNode>(
                std::make_shared<NYql::TJoinOptimizerNode>(
                    std::move(trees[u]),
                    std::move(trees[v]),
                    edge.lhs,
                    edge.rhs,
                    NYql::EJoinKind::LeftJoin,
                    NYql::EJoinAlgoType::GraceJoin,
                    /*leftAny=*/false,
                    /*rightAny=*/false
                )
            );

            connectedComponents.UnionSets(u, v);
            ui32 dominantComponent = connectedComponents.CanonicSetElement(u);

            trees[dominantComponent] = std::move(newTree);
        };

        auto computeWeight = [](double sizeU, double sizeV, double bushiness) {
            double minSize = std::min(sizeU, sizeV);
            double maxSize = std::max(sizeU, sizeV);

            assert(maxSize != 0);
            double ratio = minSize / maxSize;
            double imbalance = 1.0 - ratio;  // 1 = very unbalanced, 0 = balanced

            // bushiness in [0, 1]
            // 0 = left-deep (prefer unbalanced)
            // 1 = bushy (no preference, uniform)
            return std::pow(imbalance, 1.0 - bushiness);
        };

        auto mergeTreesRandomly = [&]() {
            std::vector<double> weights;
            std::vector<TEdge> candidates;
            for (const auto& edge : edges) {
                ui32 u = connectedComponents.CanonicSetElement(edge.u);
                ui32 v = connectedComponents.CanonicSetElement(edge.v);

                if (u != v) {
                    double sizeU = connectedComponents.SizeOfSet(u);
                    double sizeV = connectedComponents.SizeOfSet(v);

                    double weight = computeWeight(sizeU, sizeV, bushiness);

                    candidates.push_back(edge);
                    weights.push_back(weight);
                }
            }

            Y_ENSURE(!candidates.empty());

            std::discrete_distribution distribution(weights.begin(), weights.end());
            TEdge edge = candidates[distribution(rng)];

            mergeTrees(edge);
        };

        while (connectedComponents.SetCount() > 1) {
            mergeTreesRandomly();
        }

        return trees[connectedComponents.CanonicSetElement(0)];
    }


    void RandomizeJoinTypes(TRNG rng, std::shared_ptr<NYql::IBaseOptimizerNode> joinTree,
                            const std::map<NYql::EJoinKind, double>& probabilities) {

        auto join = std::dynamic_pointer_cast<NYql::TJoinOptimizerNode>(joinTree);
        if (!join) {
            return;
        }

        std::vector<NYql::EJoinKind> kinds;
        std::vector<double> weights;
        for (const auto& [kind, probability] : probabilities) {
            kinds.push_back(kind);
            weights.push_back(probability);
        }

        std::discrete_distribution<> distribution(weights.begin(), weights.end());
        join->JoinType = kinds[distribution(rng)];
        join->JoinType = NYql::EJoinKind::InnerJoin;

        RandomizeJoinTypes(rng, join->LeftArg, probabilities);
        RandomizeJoinTypes(rng, join->RightArg, probabilities);
    }


    template <typename TNodeSet>
    class TJoinHypergraphSerializer {
    public:
        static NJson::TJsonValue Serialize(NYql::NDq::TJoinHypergraph<TNodeSet>& graph) {
            NJson::TJsonValue edgesArray(NJson::JSON_ARRAY);
            const auto& edges = graph.GetEdges();

            for (const auto& edge : edges) {
                if (edge.IsReversed) {
                    continue;
                }

                NJson::TJsonValue edgeJson(NJson::JSON_MAP);
                edgeJson.InsertValue("sources", SerializeNodeSet(edge.Left));
                edgeJson.InsertValue("targets", SerializeNodeSet(edge.Right));
                edgeJson.InsertValue("join_kind", NJson::TJsonValue(JoinKindToString(edge.JoinKind)));

                NJson::TJsonValue conditions(NJson::JSON_ARRAY);
                for (size_t i = 0; i < edge.LeftJoinKeys.size(); ++i) {
                    NJson::TJsonValue condition(NJson::JSON_MAP);

                    condition.InsertValue("lhs", SerializeColumn(edge.LeftJoinKeys[i]));
                    condition.InsertValue("rhs", SerializeColumn(edge.RightJoinKeys[i]));

                    conditions.AppendValue(condition);
                }
                edgeJson.InsertValue("conditions", conditions);

                // Optional metadata
                NJson::TJsonValue metadata(NJson::JSON_MAP);
                metadata.InsertValue("is_commutative", NJson::TJsonValue(edge.IsCommutative));
                metadata.InsertValue("left_any", NJson::TJsonValue(edge.LeftAny));
                metadata.InsertValue("right_any", NJson::TJsonValue(edge.RightAny));
                edgeJson.InsertValue("metadata", metadata);

                edgesArray.AppendValue(edgeJson);
            }

            return edgesArray;
        }

    private:
        static NJson::TJsonValue SerializeNodeSet(const TNodeSet& nodeSet) {
            NJson::TJsonValue array(NJson::JSON_ARRAY);

            for (size_t i = 0; i < nodeSet.size(); ++ i) {
                if (nodeSet[i]) {
                    array.AppendValue(NJson::TJsonValue(getTableName(i)));
                }
            }

            return array;
        }

        static NJson::TJsonValue SerializeColumn(const NYql::NDq::TJoinColumn& column) {
            NJson::TJsonValue array(NJson::JSON_ARRAY);

            return TStringBuilder()
                << column.RelName
                << "."
                << column.AttributeName;
        }

        static TString JoinKindToString(NYql::EJoinKind kind) {
            switch (kind) {
                case NYql::EJoinKind::InnerJoin:
                    return "inner";
                case NYql::EJoinKind::LeftJoin:
                    return "left";
                case NYql::EJoinKind::RightJoin:
                    return "right";
                case NYql::EJoinKind::OuterJoin:
                    return "full";
                case NYql::EJoinKind::Cross:
                    return "cross";
                case NYql::EJoinKind::LeftSemi:
                    return "left_semi";
                case NYql::EJoinKind::RightSemi:
                    return "right_semi";
                case NYql::EJoinKind::LeftOnly:
                    return "left_only";
                case NYql::EJoinKind::RightOnly:
                    return "right_only";
                case NYql::EJoinKind::Exclusion:
                    return "exclusion";
                default:
                    return "unknown";
            }
        }
    };


}
