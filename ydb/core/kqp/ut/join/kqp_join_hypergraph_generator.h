#include "kqp_join_topology_generator.h"
#include <ydb/core/kqp/ut/common/kqp_serializable_rng.h>
#include <ydb/library/yql/dq/opt/dq_opt_make_join_hypergraph.h>
#include <sstream>
#include <string>
#include <random>
#include <vector>
#include <map>


namespace NKikimr::NKqp {
    NYql::NDq::TJoinColumn GetJoinColumn(ui32 tableID, ui32 columnID) {
        return {getTableName(tableID), getColumnName(tableID, columnID)};
    }

    // Generate a random valid join tree to be used later for hypegraph construction.
    //
    // The reason to generate a random tree, not left-deep one (like TRelationGraph::MakeQuery
    // does), even though they are all equivalent to optimizer and produce the same graph
    // is to allow for randomized construction of not fully reorderable queries later.
    //
    // This construction will be carried out by randomly selecting joins in the tree generated by
    // this procedure and replacing them with more complex joins (like left joins, etc...)
    std::shared_ptr<NYql::IBaseOptimizerNode> ToJoinTree(TRNG &rng, const TRelationGraph &graph, double bushiness) {

        const auto& adjacencyList = graph.GetAdjacencyList();

        struct TEdge { ui32 u, v; TVector<NYql::NDq::TJoinColumn> lhs, rhs; };
        std::vector<TEdge> edges;
        for (ui32 i = 0; i < adjacencyList.size(); ++i) {
            for (const auto& edge : adjacencyList[i]) {
                if (i < edge.Target) {
                    edges.push_back(TEdge{i, edge.Target,
                        {GetJoinColumn(i, edge.ColumnLHS)},
                        {GetJoinColumn(edge.Target, edge.ColumnRHS)}
                    });
                }
            }
        }

        // The core idea is to initially put every relation into a separate tree
        // and then randomly merge those trees, creating a bushy tree of all relations.

        // Stores already connected trees, used to find which components to connect next
        // and to figure out where to store tree decomposition of a particular component
        TDisjointSets connectedComponents(adjacencyList.size());

        // Tree decompositions that gradually get merged, only stores trees for
        // canonical set elements of a particular component.

        // tree[i] is only valid if i is a canonical element for one of the components
        // inside connectedComponents disjointSet.
        std::vector<std::shared_ptr<NYql::IBaseOptimizerNode>> trees(adjacencyList.size());

        // Initial forest is just a relation for each graph node:
        for (ui32 i = 0; i < adjacencyList.size(); ++ i) {
            auto relation = std::static_pointer_cast<NYql::IBaseOptimizerNode>(
                std::make_shared<NYql::TRelOptimizerNode>(
                    getTableName(i),
                    NYql::TOptimizerStatistics(NYql::EStatisticsType::BaseTable, 1e9, 20, 1e10)
                )
            );

            trees[i] = std::move(relation);
        }

        // Merges trees containing node "i" and node "j", stores resulting tree in trees
        auto mergeTrees = [&](TEdge edge) {
            ui32 u = connectedComponents.CanonicSetElement(edge.u);
            ui32 v = connectedComponents.CanonicSetElement(edge.v);
            if (u == v) {
                return;
            }

            auto newTree = std::static_pointer_cast<NYql::IBaseOptimizerNode>(
                std::make_shared<NYql::TJoinOptimizerNode>(
                    std::move(trees[u]),
                    std::move(trees[v]),
                    edge.lhs,
                    edge.rhs,
                    NYql::EJoinKind::LeftJoin,
                    NYql::EJoinAlgoType::GraceJoin,
                    /*leftAny=*/false,
                    /*rightAny=*/false
                )
            );

            connectedComponents.UnionSets(u, v);
            ui32 dominantComponent = connectedComponents.CanonicSetElement(u);

            trees[dominantComponent] = std::move(newTree);
        };

        auto computeWeight = [](double sizeU, double sizeV, double bushiness) {
            double minSize = std::min(sizeU, sizeV);
            double maxSize = std::max(sizeU, sizeV);

            assert(maxSize != 0);
            double ratio = minSize / maxSize;
            // TODO: weight should depend on number of nodes on both sides?

            return std::pow(ratio, bushiness);
        };

        auto mergeTreesRandomly = [&]() {
            std::vector<double> weights;
            std::vector<TEdge> candidates;
            for (const auto& edge : edges) {
                ui32 u = connectedComponents.CanonicSetElement(edge.u);
                ui32 v = connectedComponents.CanonicSetElement(edge.v);

                if (u != v) {
                    double sizeU = connectedComponents.SizeOfSet(u);
                    double sizeV = connectedComponents.SizeOfSet(v);

                    double weight = computeWeight(sizeU, sizeV, bushiness);

                    candidates.push_back(edge);
                    weights.push_back(weight);
                }
            }

            Y_ENSURE(!candidates.empty());

            std::discrete_distribution distribution(weights.begin(), weights.end());
            TEdge edge = candidates[distribution(rng)];

            mergeTrees(edge);
        };

        while (connectedComponents.SetCount() > 1) {
            mergeTreesRandomly();
        }

        return trees[connectedComponents.CanonicSetElement(0)];
    }


    void RandomizeJoinTypes(TRNG rng, std::shared_ptr<NYql::IBaseOptimizerNode> joinTree,
                            const std::map<NYql::EJoinKind, double>& probabilities) {

        auto join = std::dynamic_pointer_cast<NYql::TJoinOptimizerNode>(joinTree);
        if (!join) {
            return;
        }

        std::vector<NYql::EJoinKind> kinds;
        std::vector<double> weights;
        for (const auto& [kind, probability] : probabilities) {
            kinds.push_back(kind);
            weights.push_back(probability);
        }

        std::discrete_distribution<> distribution(weights.begin(), weights.end());
        join->JoinType = kinds[distribution(rng)];
        join->JoinType = NYql::EJoinKind::InnerJoin;

        RandomizeJoinTypes(rng, join->LeftArg, probabilities);
        RandomizeJoinTypes(rng, join->RightArg, probabilities);
    }


    template <typename TNodeSet>
    class TJoinHypergraphSerializer {
    public:
        static TString Serialize(NYql::NDq::TJoinHypergraph<TNodeSet>& graph) {
            TStringStream ss;

            // Build reverse mapping: nodeId -> relationName
            TVector<TString> nodeIdToRelName(graph.GetNodes().size());
            for (const auto& [relName, nodeId] : graph.NodeIdByRelationName_) {
                if (nodeIdToRelName[nodeId].empty()) {
                    nodeIdToRelName[nodeId] = relName;
                } else {
                    // Handle multiple labels for same node
                    nodeIdToRelName[nodeId] += "," + relName;
                }
            }

            const auto& edges = graph.GetEdges();
            bool firstEdge = true;

            for (const auto& edge : edges) {
                // Skip reversed edges to avoid duplication
                if (edge.IsReversed) {
                    continue;
                }

                if (!firstEdge) {
                    ss << "|";
                }
                firstEdge = false;

                // Serialize left node set
                ss << SerializeNodeSet(edge.Left, nodeIdToRelName);
                ss << ";";

                // Serialize join kind
                ss << JoinKindToString(edge.JoinKind);
                ss << ";";

                // Serialize join conditions
                SerializeJoinConditions(ss, edge.LeftJoinKeys, edge.RightJoinKeys);
                ss << ";";

                // Serialize right node set
                ss << SerializeNodeSet(edge.Right, nodeIdToRelName);
            }

            return ss.Str();
        }

    private:
        static TString SerializeNodeSet(const TNodeSet& nodeSet,
                                        const TVector<TString>& nodeIdToRelName) {
            TStringStream ss;
            ss << "{";

            bool first = true;
            for (size_t i = 0; i < nodeSet.size(); ++i) {
                if (nodeSet[i]) {
                    if (!first) {
                        ss << ",";
                    }
                    ss << nodeIdToRelName[i];
                    first = false;
                }
            }

            ss << "}";
            return ss.Str();
        }

        static void SerializeJoinConditions(TStringStream& ss,
                                            const TVector<NYql::NDq::TJoinColumn>& leftKeys,
                                            const TVector<NYql::NDq::TJoinColumn>& rightKeys) {
            for (size_t i = 0; i < leftKeys.size(); ++i) {
                if (i > 0) {
                    ss << ";";
                }
                ss << leftKeys[i].RelName << "." << leftKeys[i].AttributeName;
                ss << "=";
                ss << rightKeys[i].RelName << "." << rightKeys[i].AttributeName;
            }
        }

        static TString JoinKindToString(NYql::EJoinKind kind) {
            switch (kind) {
                case NYql::EJoinKind::InnerJoin:
                    return "inner";
                case NYql::EJoinKind::LeftJoin:
                    return "left";
                case NYql::EJoinKind::RightJoin:
                    return "right";
                case NYql::EJoinKind::OuterJoin:
                    return "full";
                case NYql::EJoinKind::Cross:
                    return "cross";
                case NYql::EJoinKind::LeftSemi:
                    return "leftsemi";
                case NYql::EJoinKind::RightSemi:
                    return "rightsemi";
                case NYql::EJoinKind::LeftOnly:
                    return "leftonly";
                case NYql::EJoinKind::RightOnly:
                    return "rightonly";
                default:
                    return "unknown";
            }
        }
    };

}
