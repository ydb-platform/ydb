#include "kqp_join_topology_generator.h"
#include <ydb/core/kqp/ut/common/kqp_serializable_rng.h>
#include <ydb/library/yql/dq/opt/dq_opt_make_join_hypergraph.h>
#include <sstream>
#include <string>



namespace NKikimr::NKqp {

    // Generate a random valid join tree to be used later for hypegraph construction.
    //
    // The reason to generate a random tree, not left-deep one (like TRelationGraph::MakeQuery
    // does), even though they are all equivalent to optimizer and produce the same graph
    // is to allow for randomized construction of not fully reorderable queries later.
    //
    // This construction will be carried out by randomly selecting joins in the tree generated by
    // this procedure and replacing them with more complex joins (like left joins, etc...)
    std::shared_ptr<NYql::IBaseOptimizerNode> ToJoinTree(TRNG &rng, const TRelationGraph &graph, double bushiness) {

        const auto& adjacencyList = graph.GetAdjacencyList();

        struct Edge { ui32 u, v; TVector<NYql::NDq::TJoinColumn> lhs, rhs; };
        std::vector<Edge> edges;
        for (ui32 i = 0; i < adjacencyList.size(); ++i) {
            for (const auto& edge : adjacencyList[i]) {
                if (i < edge.Target) {
                    edges.push_back(Edge{i, edge.Target, {NYql::NDq::TJoinColumn(getTableName(i), getColumnName(i, edge.ColumnLHS))}, {NYql::NDq::TJoinColumn(getTableName(edge.Target), getColumnName(edge.Target, edge.ColumnRHS))}});
                }
            }
        }

        // The core idea is to initially put every relation into a separate tree
        // and then randomly merge those trees, creating a bushy tree of all relations.

        // Stores already connected trees, used to find which components to connect next
        // and to figure out where to store tree decomposition of a particular component
        TDisjointSets connectedComponents(adjacencyList.size());

        // Tree decompositions that gradually get merged, only stores trees for
        // canonical set elements of a particular component.

        // tree[i] is only valid if i is a canonical element for one of the components
        // inside connectedComponents disjointSet.
        std::vector<std::shared_ptr<NYql::IBaseOptimizerNode>> trees(adjacencyList.size());

        // Initial forest is just a relation for each graph node:
        for (ui32 i = 0; i < adjacencyList.size(); ++ i) {
            auto relation = std::static_pointer_cast<NYql::IBaseOptimizerNode>(
                std::make_shared<NYql::TRelOptimizerNode>(getTableName(i), NYql::TOptimizerStatistics(NYql::EStatisticsType::BaseTable))
            );

            trees[i] = std::move(relation);
        }

        // Merges trees containing node "i" and node "j", stores resulting tree in trees
        auto mergeTrees = [&](Edge edge) {
            ui32 u = connectedComponents.CanonicSetElement(edge.u);
            ui32 v = connectedComponents.CanonicSetElement(edge.v);
            if (u == v) {
                return;
            }

            auto newTree = std::static_pointer_cast<NYql::IBaseOptimizerNode>(
                std::make_shared<NYql::TJoinOptimizerNode>(
                    std::move(trees[u]),
                    std::move(trees[v]),
                    edge.lhs,
                    edge.rhs,
                    NYql::EJoinKind::LeftJoin,
                    NYql::EJoinAlgoType::Undefined,
                    /*leftAny=*/false,
                    /*rightAny=*/false
                )
            );

            connectedComponents.UnionSets(u, v);
            ui32 dominantComponent = connectedComponents.CanonicSetElement(u);

            trees[dominantComponent] = std::move(newTree);
        };

        auto computeWeight = [](double sizeU, double sizeV, double bushiness) {
            double minSize = std::min(sizeU, sizeV);
            double maxSize = std::max(sizeU, sizeV);

            assert(maxSize != 0);
            double ratio = minSize / maxSize;

            return std::pow(ratio, bushiness);
        };

        auto mergeTreesRandomly = [&]() {
            std::vector<double> weights;
            std::vector<Edge> candidates;
            for (const auto& edge : edges) {
                ui32 u = connectedComponents.CanonicSetElement(edge.u);
                ui32 v = connectedComponents.CanonicSetElement(edge.v);

                if (u != v) {
                    double sizeU = connectedComponents.SizeOfSet(u);
                    double sizeV = connectedComponents.SizeOfSet(v);

                    double weight = computeWeight(sizeU, sizeV, bushiness);

                    candidates.push_back(edge);
                    weights.push_back(weight);
                }
            }

            assert(!candidates.empty() && "Graph has to be connected");

            std::discrete_distribution distribution(weights.begin(), weights.end());
            Edge edge = candidates[distribution(rng)];

            mergeTrees(edge);
        };

        while (connectedComponents.SetCount() > 1) {
            mergeTreesRandomly();
        }

        return trees[connectedComponents.CanonicSetElement(0)];
    }


    template <typename TNodeSet>
    class TJoinHypergraphSerializer {
    public:
        static TString Serialize(NYql::NDq::TJoinHypergraph<TNodeSet>& graph) {
            TStringStream ss;

            // Build reverse mapping: nodeId -> relationName
            TVector<TString> nodeIdToRelName(graph.GetNodes().size());
            for (const auto& [relName, nodeId] : graph.NodeIdByRelationName_) {
                if (nodeIdToRelName[nodeId].empty()) {
                    nodeIdToRelName[nodeId] = relName;
                } else {
                    // Handle multiple labels for same node
                    nodeIdToRelName[nodeId] += "," + relName;
                }
            }

            const auto& edges = graph.GetEdges();
            bool firstEdge = true;

            for (const auto& edge : edges) {
                // Skip reversed edges to avoid duplication
                if (edge.IsReversed) {
                    continue;
                }

                if (!firstEdge) {
                    ss << "|";
                }
                firstEdge = false;

                // Serialize left node set
                ss << SerializeNodeSet(edge.Left, nodeIdToRelName);
                ss << ";";

                // Serialize join kind
                ss << JoinKindToString(edge.JoinKind);
                ss << ";";

                // Serialize join conditions
                SerializeJoinConditions(ss, edge.LeftJoinKeys, edge.RightJoinKeys);
                ss << ";";

                // Serialize right node set
                ss << SerializeNodeSet(edge.Right, nodeIdToRelName);
            }

            return ss.Str();
        }

    private:
        static TString SerializeNodeSet(const TNodeSet& nodeSet,
                                        const TVector<TString>& nodeIdToRelName) {
            TStringStream ss;
            ss << "{";

            bool first = true;
            for (size_t i = 0; i < nodeSet.size(); ++i) {
                if (nodeSet[i]) {
                    if (!first) {
                        ss << ",";
                    }
                    ss << nodeIdToRelName[i];
                    first = false;
                }
            }

            ss << "}";
            return ss.Str();
        }

        static void SerializeJoinConditions(TStringStream& ss,
                                            const TVector<NYql::NDq::TJoinColumn>& leftKeys,
                                            const TVector<NYql::NDq::TJoinColumn>& rightKeys) {
            for (size_t i = 0; i < leftKeys.size(); ++i) {
                if (i > 0) {
                    ss << ";";
                }
                ss << leftKeys[i].RelName << "." << leftKeys[i].AttributeName;
                ss << "=";
                ss << rightKeys[i].RelName << "." << rightKeys[i].AttributeName;
            }
        }

        static TString JoinKindToString(NYql::EJoinKind kind) {
            switch (kind) {
                case NYql::EJoinKind::InnerJoin:
                    return "inner";
                case NYql::EJoinKind::LeftJoin:
                    return "left";
                case NYql::EJoinKind::RightJoin:
                    return "right";
                case NYql::EJoinKind::OuterJoin:
                    return "full";
                case NYql::EJoinKind::Cross:
                    return "cross";
                case NYql::EJoinKind::LeftSemi:
                    return "leftsemi";
                case NYql::EJoinKind::RightSemi:
                    return "rightsemi";
                case NYql::EJoinKind::LeftOnly:
                    return "leftonly";
                case NYql::EJoinKind::RightOnly:
                    return "rightonly";
                default:
                    return "unknown";
            }
        }
    };

    void DoIt(TRNG &rng, const TRelationGraph &graph, double bushiness) {
        auto tree = ToJoinTree(rng, graph, bushiness);

        std::stringstream ss;
        tree->Print(ss, 0);

        Cout << ss.str() << "\n";

        auto hypergraph = NYql::NDq::MakeJoinHypergraph<std::bitset<16>>(tree);
        Cout << hypergraph.String() << "\n";

        Cout << TJoinHypergraphSerializer<std::bitset<16>>::Serialize(hypergraph) << "\n";
    }



}
