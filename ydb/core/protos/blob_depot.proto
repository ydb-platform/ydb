import "ydb/core/protos/blob_depot_config.proto";
import "ydb/core/protos/base.proto";

package NKikimrBlobDepot;

enum EKeepState {
    Default = 0;
    Keep = 1;
    DoNotKeep = 2;
}

message TBlobSeqId {
    optional uint32 Channel = 1;
    optional uint32 Generation = 2;
    optional uint32 Step = 3;
    optional uint32 Index = 4;
}

message TBlobLocator {
    optional uint32 GroupId = 1;
    optional TBlobSeqId BlobSeqId = 2;
    optional uint32 Checksum = 3;
    optional uint64 TotalDataLen = 4;
    optional uint32 FooterLen = 5;
}

message TValueChain {
    optional TBlobLocator Locator = 1;
    optional uint64 SubrangeBegin = 2;
    optional uint64 SubrangeEnd = 3;
}

message TValue {
    optional bytes Meta = 1;
    repeated TValueChain ValueChain = 2;
    optional EKeepState KeepState = 3;
    optional bool Public = 4;
}

message TGivenIdRange {
    message TChannelRange {
        optional uint32 Channel = 1;
        optional uint64 Begin = 2;
        optional uint64 End = 3;
    }
    repeated TChannelRange ChannelRanges = 1;
}




message TEvApplyConfig {
    optional uint64 TxId = 1;
    optional NKikimrBlobDepot.TBlobDepotConfig Config = 2;
}

message TEvApplyConfigResult {
    optional uint64 TabletId = 1;
    optional uint64 TxId = 2;
}

message TEvRegisterAgent {
    optional uint32 VirtualGroupId = 1; // for validation purposes
    optional fixed64 AgentInstanceId = 2; // randomly generated number every time agent starts from scratch
}

message TEvRegisterAgentResult {
    message TChannelGroupId {
        optional uint32 Channel = 1;
        optional uint32 GroupId = 2;
    };
    message TChannelKind {
        optional NKikimrBlobDepot.TChannelKind.E ChannelKind = 1;
        repeated TChannelGroupId ChannelGroups = 2;
    }
    optional uint32 Generation = 1;
    repeated TChannelKind ChannelKinds = 2;
    repeated uint32 DecommittingGroups = 3;
}

message TEvAllocateIds {
    optional NKikimrBlobDepot.TChannelKind.E ChannelKind = 1;
    optional uint32 Count = 2;
}

message TEvAllocateIdsResult {
    optional NKikimrBlobDepot.TChannelKind.E ChannelKind = 1;
    optional uint32 Generation = 2; // executor generation, for validation purposes
    optional TGivenIdRange GivenIdRange = 3;
}

message TEvBlock {
    optional fixed64 TabletId = 1;
    optional uint32 BlockedGeneration = 2;
    optional uint64 IssuerGuid = 3;
}

message TEvBlockResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 2;
    optional uint32 TimeToLiveMs = 3;
}

message TEvPushNotify {
    message TBlockedTablet {
        optional fixed64 TabletId = 1;
        optional uint32 BlockedGeneration = 2;
    }
    message TInvalidatedStep {
        optional uint32 Channel = 1;
        optional uint32 Generation = 2; // for validation purposes
        optional uint32 InvalidatedStep = 3;
    }
    repeated TBlockedTablet BlockedTablets = 1;
    repeated TInvalidatedStep InvalidatedSteps = 2;
}

message TEvPushNotifyResult {
    repeated TBlobSeqId WritesInFlight = 1;
}

message TEvQueryBlocks {
    repeated fixed64 TabletIds = 1;
}

message TEvQueryBlocksResult {
    repeated uint32 BlockedGenerations = 1;
    optional uint32 TimeToLiveMs = 2; // TTL starting since sending TEvQueryBlocks at agent
}

message TEvCollectGarbage {
    repeated NKikimrProto.TLogoBlobID Keep = 1;
    repeated NKikimrProto.TLogoBlobID DoNotKeep = 2;
    optional uint64 TabletId = 3;
    optional uint32 Generation = 4;
    optional uint32 PerGenerationCounter = 5;
    optional uint32 Channel = 6;
    optional bool Hard = 7;
    optional uint32 CollectGeneration = 8;
    optional uint64 CollectStep = 9;
}

message TEvCollectGarbageResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 2;
}

message TEvCommitBlobSeq {
    message TItem {
        optional TBlobLocator BlobLocator = 1; // GroupId and Generation are for validation purposes
        optional bytes Key = 2;
        optional bytes Meta = 3;
    }

    repeated TItem Items = 1;
}

message TEvCommitBlobSeqResult {
    message TItem {
        optional NKikimrProto.EReplyStatus Status = 1;
        optional string ErrorReason = 2;
    }

    repeated TItem Items = 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TEvResolve -- lookup key in the Data table (and apply noncommitted changes if necessary) and return value chain for
// each of the found entries.

message TEvResolve {
    message TItem {
        optional bytes BeginningKey = 1; // start from the very first key (if not set)
        optional bool IncludeBeginning = 2 [default = true];
        optional bytes EndingKey = 3; // end with the key beyond the last one (if not set)
        optional bool IncludeEnding = 4 [default = false];
        optional uint32 MaxKeys = 5 [default = 0]; // zero or unset value means infinite amount
        optional bool ReturnMeta = 6 [default = false];
        optional bool ReturnOwners = 7 [default = false];
        optional bool Reverse = 8 [default = false]; // reverse output
        optional uint64 Cookie = 9; // request cookie to match response item
    }

    repeated TItem Items = 1;
}

message TEvResolveResult {
    message TResolvedKey {
        optional uint64 Cookie = 1;
        optional bytes Key = 2;
        repeated TValueChain ValueChain = 3;
        optional bytes Meta = 4;
        repeated uint64 Owners = 5;
    }
    optional NKikimrProto.EReplyStatus Status = 1; // OVERRUN means there are more messages on the way
    optional string ErrorReason = 2;
    repeated TResolvedKey ResolvedKeys = 3;
}
