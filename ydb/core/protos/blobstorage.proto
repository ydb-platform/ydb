import "ydb/library/actors/protos/actors.proto";
import "ydb/library/actors/protos/interconnect.proto";
import "ydb/core/protos/base.proto";
import "ydb/core/protos/blobstorage_base.proto";
import "ydb/core/protos/blobstorage_base3.proto";
import "ydb/core/protos/blobstorage_vdisk_config.proto";
import "ydb/core/protos/blobstorage_pdisk_config.proto";
import "ydb/core/protos/blobstorage_config.proto";
import "ydb/core/protos/blobstorage_disk.proto";
import "ydb/core/protos/blobstorage_disk_color.proto";
import "ydb/core/protos/node_whiteboard.proto";

package NKikimrBlobStorage;
option java_package = "ru.yandex.kikimr.proto";

message TMessageId {
    // (SequenceId, MsgId) pair identifies message order, used to implement flow control (i.e. windows)
    optional uint64 SequenceId = 1;
    optional uint64 MsgId = 2;
}

message TVDiskCostSettings {
    optional uint64 SeekTimeUs = 1;
    optional uint64 ReadSpeedBps = 2;
    optional uint64 WriteSpeedBps = 3;
    optional uint64 ReadBlockSize = 4;
    optional uint64 WriteBlockSize = 5;
    optional uint32 MinREALHugeBlobInBytes = 6;
};

message TWindowFeedback {
    enum EStatus {
        Unknown = 0;
        Success = 1;                // successful operation
        WindowUpdate = 2;           // window boundaries update because global state has changed
        Processed = 3;              // request was processed and this is status update after processed item
        IncorrectMsgId = 4;         // client sent incorrect client id
        HighWatermarkOverflow = 5;  // message is rejected because of queue overflow
    }

    optional EStatus Status = 1;
    optional uint64 ActualWindowSize = 2;
    optional uint64 MaxWindowSize = 3;
    optional TMessageId ExpectedMsgId = 4;
    optional TMessageId FailedMsgId = 5;
}

// execution stats for different kinds of BlobStorage requests; all durations are measured in Âµs
message TExecTimeStats {
    // dsproxy (i.e. sender) stats
    optional uint64 SubmitTimestamp = 1; // local timestamp of request submission
    optional uint64 InSenderQueue = 2; // time spent in BS_QUEUE or something like that

    // vdisk (i.e. executor) stats
    optional uint64 ReceivedTimestamp = 3; // local (to vdisk node) timestamp of request reception
    optional uint64 Total = 4; // total time since reception of query until transmission of reply
    optional uint64 InQueue = 5; // time spent in queue (time spent since reception of query until it was transferred to executor)
    optional uint64 Execution = 6; // time spent while actually executing request

    // detailed stats
    optional uint64 HugeWriteTime = 7; // time spent while writing Huge Blob (included in Execution time)
};

message TMsgQoS {
    optional uint32 DeadlineSeconds = 1;
    optional TMessageId MsgId = 2;
    optional uint64 Cost = 3;
    optional NKikimrBlobStorage.EVDiskQueueId ExtQueueId = 5;
    optional NKikimrBlobStorage.EVDiskInternalQueueId IntQueueId = 6;
    optional TVDiskCostSettings CostSettings = 7;
    optional bool SendMeCostSettings = 8;
    optional TWindowFeedback Window = 9;
    oneof ClientId {
        uint32 ProxyNodeId = 10; // set when client is DS Proxy from specific node
        uint32 ReplVDiskId = 11; // set when client is replication actor from specific vdisk
        uint64 VDiskLoadId = 13; // set when client is load test with specific tag
        uint32 VPatchVDiskId = 14; // set when client is vpatch actor from specific vdisk
        uint32 BalancingVDiskId = 17; // set when client is balancing actor from specific vdisk
    }
    optional TExecTimeStats ExecTimeStats = 12;
    optional NActorsProto.TActorId SenderActorId = 15;
    optional uint64 InternalMessageId = 16; // for in-process use
}

// message VDisk sends to the client, when backpressure window changes
message TEvVWindowChange {
    optional NKikimrBlobStorage.EVDiskQueueId FrontQueueId = 1;
    optional TWindowFeedback Window = 2;
    optional bool DropConnection = 3; // emergency connection drop
}

message TTimestamps {
    optional uint64 SentByDSProxyUs = 1 [default = 0];
    optional uint64 ReceivedByVDiskUs = 2 [default = 0];
    optional uint64 SentByVDiskUs = 3 [default = 0];
    optional uint64 ReceivedByDSProxyUs = 4 [default = 0];
}

enum EEntityStatus {
    INITIAL = 1; // entity was generated from the current state by the configuration request
    CREATE  = 2; // entity was just created and notification is being pushed to the warden
    DESTROY = 3; // entity was just destroyed and the notification is being pushed to the warden
    RESTART = 4; // entity has changed config or changed environment and should be restarted by warden
}

message TGroupInfo {
    message TFailRealm {
        message TFailDomain {
            repeated TVDiskLocation VDiskLocations = 1;
        }
        repeated TFailDomain FailDomains = 1;
    }

    optional uint32 GroupID = 1;
    optional uint32 GroupGeneration = 2;
    optional uint32 ErasureSpecies = 3;
    repeated TFailRealm Rings = 4; // name "Rings" for textual compatibility
    optional EEntityStatus EntityStatus = 5;
    optional uint32 EncryptionMode = 6 [default = 0];
    optional uint32 LifeCyclePhase = 7 [default = 0];
    optional bytes MainKeyId = 8 [default = ""];
    optional bytes EncryptedGroupKey = 9 [default = ""];
    optional uint64 GroupKeyNonce = 10 [default = 0];
    optional uint64 MainKeyVersion = 11 [default = 0];
    optional NActorsInterconnect.TScopeId AcceptedScope = 12; // some kind of ACL for scopes; empty = no restrictions
    optional string StoragePoolName = 13;
    optional EPDiskType DeviceType = 14;
    optional uint64 BlobDepotId = 15; // if filled, then this is virtual group
    optional NKikimrBlobStorage.TGroupDecommitStatus.E DecommitStatus = 16;
}

message TEvVPatchStart {
    optional NKikimrProto.TLogoBlobID OriginalBlobId = 1;
    optional NKikimrProto.TLogoBlobID PatchedBlobId = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;

    optional bool NotifyIfNotReady = 4;
    optional uint64 Cookie = 5;

    optional NKikimrBlobStorage.EGetHandleClass HandleClass = 6;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
}

message TEvVPatchFoundParts {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200; // textual description of error
    optional NKikimrProto.TLogoBlobID OriginalBlobId = 2;
    optional NKikimrProto.TLogoBlobID PatchedBlobId = 3;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;

    optional uint64 Cookie = 5;
    repeated uint32 OriginalParts = 6;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TDiffBlock {
    optional uint64 Offset = 1;
    optional bytes Buffer = 2;
}

message TXorDiffReceiver {
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional uint32 PartId = 2;
}

message TEvVPatchDiff {
    optional NKikimrProto.TLogoBlobID OriginalPartBlobId = 1;
    optional NKikimrProto.TLogoBlobID PatchedPartBlobId = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    repeated TDiffBlock Diffs = 4;
    optional uint64 Cookie = 5;

    repeated TXorDiffReceiver XorReceivers= 6;
    optional uint32 ExpectedXorDiffs = 7;
    optional bool ForceEnd = 8;
    optional bool NotifyIfNotReady = 9;

    optional NKikimrBlobStorage.EPutHandleClass HandleClass = 11;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
}

message TEvVPatchXorDiff {
    optional NKikimrProto.TLogoBlobID OriginalPartBlobId = 1;
    optional NKikimrProto.TLogoBlobID PatchedPartBlobId = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    repeated TDiffBlock Diffs = 4;
    optional uint64 Cookie = 5;
    optional uint32 FromPartId = 6;
    optional bool NotifyIfNotReady = 7;

    optional NKikimrBlobStorage.EPutHandleClass HandleClass = 8;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
}

message TEvVPatchXorDiffResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
};

message TEvVPatchResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200; // textual description of error
    optional NKikimrProto.TLogoBlobID OriginalPartBlobId = 2;
    optional NKikimrProto.TLogoBlobID PatchedPartBlobId = 3;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;

    optional uint64 Cookie = 5;
    optional uint32 StatusFlags = 6;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    optional float ApproximateFreeSpaceShare = 25 [default = 0]; // 0 is a special value for 'unknown
    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVMovedPatch {
    optional NKikimrProto.TLogoBlobID OriginalBlobId = 1;
    optional NKikimrProto.TLogoBlobID PatchedBlobId = 2;
    optional uint32 OriginalGroupId = 3;
    optional uint32 PatchedGroupId = 4;
    repeated TDiffBlock Diffs = 5;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 6;

    optional bool IgnoreBlock = 7;
    optional bool NotifyIfNotReady = 8;
    optional uint64 Cookie = 9;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
}

message TEvVMovedPatchResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200; // textual description of error
    optional NKikimrProto.TLogoBlobID OriginalBlobId = 2;
    optional NKikimrProto.TLogoBlobID PatchedBlobId = 3;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;
    optional uint64 Cookie = 5;
    optional uint32 StatusFlags = 6;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    optional float ApproximateFreeSpaceShare = 25 [default = 0]; // 0 is a special value for 'unknown'
    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVInplacePatch {
    optional NKikimrProto.TLogoBlobID OriginalBlobId = 1;
    optional NKikimrProto.TLogoBlobID PatchedBlobId = 2;
    optional uint32 OriginalGroupId = 3;
    optional uint32 PatchedGroupId = 4;
    repeated TDiffBlock Diffs = 5;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 6;

    optional bool IgnoreBlock = 7;
    optional bool NotifyIfNotReady = 8;
    optional uint64 Cookie = 9;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
}

message TEvVInplacePatchResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200; // textual description of error
    optional NKikimrProto.TLogoBlobID OriginalBlobId = 2;
    optional NKikimrProto.TLogoBlobID PatchedBlobId = 3;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;
    optional uint64 Cookie = 5;
    optional uint32 StatusFlags = 6;

    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    optional float ApproximateFreeSpaceShare = 25 [default = 0]; // 0 is a special value for 'unknown'
    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVPut {
    message TExtraBlockCheck {
        optional fixed64 TabletId = 1;
        optional uint32 Generation = 2;
    }

    optional NKikimrProto.TLogoBlobID BlobID = 1;
    optional bytes Buffer = 2;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;

    optional uint64 FullDataSize = 4;
    optional bool IgnoreBlock = 5;
    optional bool NotifyIfNotReady = 6;
    optional uint64 Cookie = 7;
    optional NKikimrBlobStorage.EPutHandleClass HandleClass = 9;
    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    repeated TExtraBlockCheck ExtraBlockChecks = 11;
}

message TEvVPutResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200; // textual description of error
    optional NKikimrProto.TLogoBlobID BlobID = 2;
    optional bool WrittenBeyondBarrier = 6;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    optional uint64 Cookie = 4;
    optional uint32 StatusFlags = 5;
    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    optional float ApproximateFreeSpaceShare = 25 [default = 0]; // 0 is a special value for 'unknown'
    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TVMultiPutItem {
    optional NKikimrProto.TLogoBlobID BlobID = 1;
    optional bytes Buffer = 2;

    optional uint64 FullDataSize = 3;
    optional uint64 Cookie = 4;

    repeated TEvVPut.TExtraBlockCheck ExtraBlockChecks = 5;

    optional NActorsProto.TTraceId TraceId = 6;
}

message TEvVMultiPut {
    repeated TVMultiPutItem Items = 1;

    optional TVDiskID VDiskID = 2;

    optional bool IgnoreBlock = 3 [default = false];
    optional bool NotifyIfNotReady = 4;
    optional uint64 Cookie = 5;
    optional NKikimrBlobStorage.EPutHandleClass HandleClass = 6;
    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;
}

message TVMultiPutResultItem {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200;
    optional NKikimrProto.TLogoBlobID BlobID = 2;
    optional bool WrittenBeyondBarrier = 5;

    optional uint64 Cookie = 3;
    optional uint32 StatusFlags = 4 [default = 0];
}

message TEvVMultiPutResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 200;
    repeated TVMultiPutResultItem Items = 2;

    optional TVDiskID VDiskID = 3;
    optional uint64 Cookie = 4;
    optional uint32 StatusFlags = 5 [default = 0];
    optional TMsgQoS MsgQoS = 10;
    optional TTimestamps Timestamps = 23;

    optional float ApproximateFreeSpaceShare = 25 [default = 0]; // 0 is a special value for 'unknown'
    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TRangeQuery {
    optional NKikimrProto.TLogoBlobID From = 1;
    optional NKikimrProto.TLogoBlobID To = 2;

    optional uint64 Cookie = 6;

    optional uint32 MaxResults = 7;
}

message TExtremeQuery {
    optional NKikimrProto.TLogoBlobID Id = 1;

    optional uint64 Shift = 2;
    optional uint64 Size = 3;

    optional uint64 Cookie = 4;
}

message TEvVGet {
    optional TRangeQuery RangeQuery = 5;
    repeated TExtremeQuery ExtremeQueries = 6;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;
    optional bool NotifyIfNotReady = 3;
    optional bool ShowInternals = 4;
    optional uint64 Cookie = 9;
    optional TMsgQoS MsgQoS = 10;
    optional bool IndexOnly = 12 [default = false];
    optional NKikimrBlobStorage.EGetHandleClass HandleClass = 13;

    optional bool SuppressBarrierCheck = 20 [default = false]; // set to true to prevent hull from validating barriers

    optional uint64 TabletId = 21 [default = 0]; // tabletId to get the blocked generation for
    optional bool AcquireBlockedGeneration = 22 [default = false]; // set to true to get the blocked generation
    optional TTimestamps Timestamps = 23;
    optional uint32 ForceBlockedGeneration = 24 [default = 0]; // non-zero means a successfull block must be done first

    message TTabletData {
        optional uint64 Id = 1;
        optional uint32 Generation = 2;
    }

    optional TTabletData ReaderTabletData = 25;
    optional TTabletData ForceBlockTabletData = 26;

    optional bytes SnapshotId = 30; // read data from specific snapshot (if set)
    optional bool EnablePayload = 31; // reply with payload out of protobuf
}

message TQueryResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional NKikimrProto.TLogoBlobID BlobID = 2;

    optional uint64 Shift = 3;
    optional uint64 Size = 4;

    oneof Payload {
        bytes BufferData = 5;
        uint32 PayloadId = 12;
    }
    optional uint64 Cookie = 6;

    optional uint64 FullDataSize = 7;
    optional uint64 Ingress = 8;

    repeated uint32 Parts = 9; // part id's (>0) residing on this disk; returned only through index range queries

    optional bool Keep = 10;
    optional bool DoNotKeep = 11;
}

message TEvVGetResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    repeated TQueryResult Result = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    optional string ErrorReason = 4;

    optional uint64 Cookie = 5;
    optional TMsgQoS MsgQoS = 10;

    optional uint32 BlockedGeneration = 11 [default = 0];
    optional TTimestamps Timestamps = 23;

    optional bool IsRangeOverflow = 24 [default = false]; // true if RangeQuery response is too large and is cut
    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVBlock {
    optional uint64 TabletId = 1;
    optional uint32 Generation = 2;
    optional uint64 IssuerGuid = 5;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    optional bool NotifyIfNotReady = 4;
    optional TMsgQoS MsgQoS = 10;
}

message TEvVBlockResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional uint64 TabletId = 2;
    optional uint32 Generation = 3;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;
    optional TMsgQoS MsgQoS = 10;

    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVGetBlock {
    optional uint64 TabletId = 1;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;

    optional bool NotifyIfNotReady = 3;
    optional TMsgQoS MsgQoS = 10;
}

message TEvVGetBlockResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional uint64 TabletId = 2;
    optional uint32 Generation = 3;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;
    optional TMsgQoS MsgQoS = 10;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVAssimilate {
    message TBarrierKey {
        optional fixed64 TabletId = 1;
        optional uint32 Channel = 2;
    }

    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;

    optional fixed64 SkipBlocksUpTo = 10; // return keys strictly greater than this; if not set, return since the first one
    optional TBarrierKey SkipBarriersUpTo = 11; // the same behaviour
    optional NKikimrProto.TLogoBlobID SkipBlobsUpTo = 12; // the same behaviour

    optional bool IgnoreDecommitState = 13 [default = false]; // do not check if VDisk belongs to a being-decommitted group
}

message TEvVAssimilateResult {
    message TBlock {
        optional fixed64 TabletId = 1;
        optional uint32 BlockedGeneration = 2;
    }

    message TBarrier {
        message TValue {
            optional uint32 RecordGeneration = 1;
            optional uint32 PerGenerationCounter = 2;
            optional uint32 CollectGeneration = 3;
            optional uint32 CollectStep = 4;
        }

        optional fixed64 TabletId = 1;
        optional uint32 Channel = 2;
        optional TValue Soft = 3;
        optional TValue Hard = 4;
    }

    message TBlob {
        // incremental blob encoding
        optional fixed64 RawX1 = 1;
        optional fixed64 RawX2 = 2;
        optional fixed64 RawX3 = 3;
        optional uint64 DiffX1 = 4;
        optional uint64 DiffX2 = 5;
        optional uint64 DiffX3 = 6;

        optional uint64 Ingress = 7;
    }

    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;

    repeated TBlock Blocks = 10;
    repeated TBarrier Barriers = 11;
    repeated TBlob Blobs = 12;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVTakeSnapshot {
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
    optional bytes SnapshotId = 3;
    optional uint32 TimeToLiveSec = 4;
}

message TEvVTakeSnapshotResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
}

message TEvVReleaseSnapshot {
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
    optional bytes SnapshotId = 3;
}

message TEvVReleaseSnapshotResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
}

message TEvVCollectGarbage {
    optional uint64 TabletId = 1;
    optional uint32 RecordGeneration = 2;
    optional uint32 PerGenerationCounter = 11; // monotone increasing cmd counter for RecordGeneration
    optional uint32 Channel = 3;
    optional uint32 CollectGeneration = 4;
    optional uint32 CollectStep = 5;
    optional bool Hard = 12 [default = false];

    repeated NKikimrProto.TLogoBlobID Keep = 6;
    repeated NKikimrProto.TLogoBlobID DoNotKeep = 7;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 8;
    optional bool NotifyIfNotReady = 9;
    optional TMsgQoS MsgQoS = 10;
}

message TEvVCollectGarbageResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional uint64 TabletId = 2;
    optional uint32 RecordGeneration = 3;
    optional uint32 Channel = 4;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 5;
    optional TMsgQoS MsgQoS = 10;

    optional fixed64 IncarnationGuid = 30;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TBarrierKey {
    optional uint64 TabletId = 1;
    optional uint32 Channel = 2;
    optional uint32 RecordGeneration = 3;
    optional uint32 PerGenerationCounter = 4;
    optional bool Hard = 5;
}

message TBarrierVal {
    optional uint32 CollectGen = 1;
    optional uint32 CollectStep = 2;

    // Ingress is filled in by vdisk only when ShowInternals option is specified;
    // when making a request to vdisk keep Ingress clear
    optional uint32 Ingress = 5;
}

message TEvVGetBarrier {
    optional TBarrierKey From = 1;
    optional TBarrierKey To = 2;
    optional uint32 MaxResults = 3;

    optional NKikimrBlobStorage.TVDiskID VDiskID = 4;
    optional bool NotifyIfNotReady = 5;
    optional bool ShowInternals = 6;
    optional TMsgQoS MsgQoS = 10;
}

message TEvVGetBarrierResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    repeated TBarrierKey Keys = 2;
    repeated TBarrierVal Values = 4;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    optional TMsgQoS MsgQoS = 10;

    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

// check if disk is ready or not (i.e. will return NOTREADY in reply to next request)
message TEvVCheckReadiness {
    optional bool NotifyIfNotReady = 1;
    //optional bool SupportProtoWithPayload = 2;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 3;
    optional TGroupInfo RecentGroup = 4;
    optional TMsgQoS QoS = 5; // queue and client identification is required
}

message TEvVCheckReadinessResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    //optional bool SupportProtoWithPayload = 2;
    optional TMessageId ExpectedMsgId = 3;
    optional TVDiskCostSettings CostSettings = 4;
    optional bool ExtraBlockChecksSupport = 5;
    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

message TEvVReadyNotify {
}

message TSyncState {
    optional uint64 Guid = 1;
    optional uint64 SyncedLsn = 2;
}

// Every VDisk saves information about guid to every VDisk in Blobstorage Group;
// this message represents this info
message TSyncGuidInfo {
    enum EState {
        Empty = 1;              // vdisk doesn't have records about Guid
        InProgress = 2;         // vdisk has status in-progress
        Final = 3;              // vdisk knows final state of Guid
    };
    optional uint64 Guid = 1;   // Guid value
    optional EState State = 2;  // Our confidence about given Guid
}

// Every VDisk saves information about guid locally; this message represents
// this info
message TLocalGuidInfo {
    enum EState {
        Empty = 1;
        Selected = 2;
        Lost = 3;
        Final = 4;
    };
    optional uint64 Guid = 1;   // Guid value
    optional EState State = 2;  // Our confidence about given Guid
    // DbBirthLsn is the lsn that other VDisks in the group start syncing from with
    // the current VDisk.
    // When VDisk is initialized for the first time this lsn is zero.
    // When VDisk looses its data and starts from scratch, it syncs with other VDisks
    // from the group and restores its metabase. During this sync VDisk modifies its
    // local database (Hull DB), so its CurrentLsn takes some value different from zero.
    // When sync is done and VDisk enters the BlobStorage group, other VDisks start
    // syncing with our local VDisk, and they start doing this from DbBirthLsn, because
    // they are not enterested in previous records (they already have them).
    optional uint64 DbBirthLsn = 3;
}

message TEvVSyncGuid {
    optional NKikimrBlobStorage.TVDiskID SourceVDiskID = 2; // sync this vdisk with ...
    optional NKikimrBlobStorage.TVDiskID TargetVDiskID = 3; // ... this vdisk
    optional bool NotifyIfNotReady = 4;

    // if Info is absent ==> we send TEvVSyncGuid to read remote vdisk state
    // if Info is present ==> we write it to remote vdisk
    optional TSyncGuidInfo Info = 7;
}

message TEvVSyncGuidResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;

    // if we answer to read request ==> ReadInfo contains result
    // if we answer to write request ==> ReadInfo is empty
    optional TSyncGuidInfo ReadInfo = 7;
}

message TEvVSync {
    optional TSyncState SyncState = 1;

    optional NKikimrBlobStorage.TVDiskID SourceVDiskID = 2; // sync this vdisk with ...
    optional NKikimrBlobStorage.TVDiskID TargetVDiskID = 3; // ... this vdisk
    optional bool NotifyIfNotReady = 4;
}

message TEvVSyncResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional TSyncState OldSyncState = 2; // depricated, doesn't used
    optional TSyncState NewSyncState = 3;
    optional bool Finished = 4;

    optional bytes Data = 5;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 6;

    message TStat {
        optional uint32 DiskReads = 1;
    }
    optional TStat Stat = 7;
    optional uint32 StatusFlags = 8;
}

enum ESyncFullStage {
    LogoBlobs = 1;
    Blocks = 2;
    Barriers = 3;
}

message TEvVSyncFull {
    optional TSyncState SyncState = 1;

    optional NKikimrBlobStorage.TVDiskID SourceVDiskID = 2; // sync this vdisk with ...
    optional NKikimrBlobStorage.TVDiskID TargetVDiskID = 3; // ... this vdisk
    optional bool NotifyIfNotReady = 4;

    optional uint64 Cookie = 5;

    optional ESyncFullStage Stage = 11;
    optional NKikimrProto.TLogoBlobID LogoBlobFrom = 12;
    optional uint64 BlockTabletFrom = 13;
    optional TBarrierKey BarrierFrom = 14;
}

message TEvVSyncFullResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional TSyncState SyncState = 2;
    optional bool Finished = 4;

    optional bytes Data = 5;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 6;
    optional uint64 Cookie = 7;

    optional ESyncFullStage Stage = 11;
    optional NKikimrProto.TLogoBlobID LogoBlobFrom = 12;
    optional uint64 BlockTabletFrom = 13;
    optional TBarrierKey BarrierFrom = 14;
}

message THandoffDelLogoBlob {
    optional NKikimrProto.TLogoBlobID BlobID = 1;
    optional uint64 Ingress = 2;
}

message THullDbStatus {
    optional bool Compacted = 1;
}

message TSyncerStatus {
    enum EPhase {
        PhaseNone = 1;
        PhaseSyncGuid = 2;
        PhaseRecoverLostData = 3;
        PhaseStandardMode = 4;
        PhaseInconsistency = 5;
    };
    optional EPhase Phase = 2;
    repeated TSyncState SyncState = 1;
}

message TSyncLogStatus {
    optional uint64 LogStartLsn = 1;
    optional bool   MemLogEmpty = 2;
    optional bool   DiskLogEmpty = 3;
    optional uint64 FirstMemLsn = 4;
    optional uint64 LastMemLsn = 5;
    optional uint64 FirstDiskLsn = 6;
    optional uint64 LastDiskLsn = 7;
}

message TLocalRecoveryInfo {
    optional uint64 StartLsn = 1;
    optional bool   SuccessfulRecovery = 5;
    optional bool   EmptyLogoBlobsDb = 11;
    optional bool   EmptyBlocksDb = 12;
    optional bool   EmptyBarriersDb = 13;
    optional bool   EmptySyncLog = 14;
    optional bool   EmptySyncer = 15;
    optional bool   EmptyHuge = 16;

    optional uint64 RecoveryLogFirstLsn = 41;
    optional uint64 RecoveryLogLastLsn = 42;
}

message TEvVStatus {
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
}

message TEvVStatusResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional THullDbStatus LogoBlobs = 2;
    optional THullDbStatus Blocks = 3;
    optional THullDbStatus Barriers = 4;
    optional TSyncerStatus SyncerStatus = 5;
    optional TSyncLogStatus SyncLogStatus = 6;
    optional TLocalRecoveryInfo LocalRecoveryInfo = 7;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 8;
    optional uint32 StatusFlags = 9; // flags from EStatusFlags
    optional bool JoinedGroup = 10;
    optional bool Replicated = 11 [default = false];
    optional float ApproximateFreeSpaceShare = 12; // must contain valid value if set
    optional fixed64 IncarnationGuid = 30;
    optional TGroupInfo RecentGroup = 100; // filled in by VDisk on RACE when VDisk has newer generation
}

// what db we address our query to
enum EDbStatType {
    StatLogoBlobs = 1;
    StatBlocks = 2;
    StatBarriers = 3;
    StatTabletType = 4;
    StatHugeType = 5;
}

// what action to perform with the requested db
enum EDbStatAction {
    DumpDb = 1;
    StatDb = 2;
    StatTabletAction = 3;
    StatHugeAction = 4;
}

message TEvVDbStat {
    message TDumpDbConstraint {
        optional fixed64 TabletId = 1;
        optional uint32 Channel = 2;
    }

    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
    optional EDbStatType Type = 3;
    optional EDbStatAction Action = 4;
    optional bool PrettyPrint = 5;
    optional fixed64 TabletId = 6; // set up for EDbStatType=StatTablet
    optional TDumpDbConstraint Constraint = 7; // constraint for dump db
}

message TEvVDbStatResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;
    optional EDbStatType Type = 3;
    optional EDbStatAction Action = 4;

    optional string Data = 10;
}

// intentionally compact VDisk
message TEvVCompact {
    enum EOpType {
        // for compatibility, works as ASYNC
        UNKNOWN = 0;
        // run compaction, return result when the command accepted, don't wait until compaction finished
        ASYNC = 1;
        // run compaction, return result when compaction finished (can take some time)
        SYNC = 2;
        // get compaction status
        STATUS = 3;
    }
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
    optional EOpType OpType = 3  [default = UNKNOWN];
    // select databases to compact:
    optional bool CompactLogoBlobs = 4 [default = true];
    optional bool CompactBlocks = 5 [default = true];
    optional bool CompactBarriers = 6 [default = true];
}

message TEvVCompactResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;
}

// run manual huge heap defrag
message TEvVDefrag {
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
    optional bool Full = 3;
}

message TEvVDefragResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;

    // found chunks to defrag/free, can be larger than actual chunks freed
    optional uint64 FoundChunksToDefrag = 11 [default = 0];
    // number of huge blob recs rewritten
    optional uint64 RewrittenRecs = 12 [default = 0];
    // number of bytes rewritten
    optional uint64 RewrittenBytes = 13 [default = 0];
    // have we got the best possible state of Huge Heap?
    optional bool Eof = 14 [default = false];
    // actually freed chunks
    repeated uint32 FreedChunks = 15;
}

// Say SyncLog to cut its log; for test/debug purposes only
message TEvVBaldSyncLog {
    optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
    optional bool NotifyIfNotReady = 2;
}

message TEvVBaldSyncLogResult {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional NKikimrBlobStorage.TVDiskID VDiskID = 2;
}

message TVDiskLocation {
    optional uint32 NodeID = 1;
    optional uint32 PDiskID = 2;
    optional uint32 VDiskSlotID = 3;
    optional uint64 PDiskGuid = 4;
}

message TNodeWardenServiceSet {
    message TPDisk {
        optional uint32 NodeID = 1; // optional parameter for static configuration
        optional uint32 PDiskID = 2;
        optional string Path = 3;
        optional uint64 PDiskGuid = 5;
        optional uint64 PDiskCategory = 6;

        optional TPDiskConfig PDiskConfig = 7; // optional, pdisk will use the default config if not set

        optional EEntityStatus EntityStatus = 9;

        optional uint64 InMemoryForTestsBufferBytes = 10 [default = 0]; // non zero == force in-memory pdisk use
        optional string ExpectedSerial = 11; // optional, used for serial number check in PDisk

        optional TSerialManagementStage.E ManagementStage = 12;
        optional TPDiskSpaceColor.E SpaceColorBorder = 13;
    }

    message TVDisk {
        message TDonor {
            optional NKikimrBlobStorage.TVDiskID VDiskId = 1;
            optional TVDiskLocation VDiskLocation = 2;
        }
        message TDonorMode {
            optional uint32 NumFailRealms = 1;
            optional uint32 NumFailDomainsPerFailRealm = 2;
            optional uint32 NumVDisksPerFailDomain = 3;
            optional uint32 ErasureSpecies = 4;
        }
        optional NKikimrBlobStorage.TVDiskID VDiskID = 1;
        optional TVDiskLocation VDiskLocation = 2;
        optional TVDiskKind.EVDiskKind VDiskKind = 3;
        optional bool DoDestroy = 4 [default = false];
        optional bool DoWipe = 5 [default = false];
        optional EEntityStatus EntityStatus = 6;
        optional string StoragePoolName = 8;
        optional TDonorMode DonorMode = 9; // vdisk runs in read-only limited mode without interaction with other disks of group
        repeated TDonor Donors = 10; // a set of donor disks used to accelerate replication
        optional bool ReadOnly = 11;
    }

    message TReplBrokerConfig {
        message TMediaTypeQuota {
            optional EPDiskType Type = 1;
            optional uint64 ReadBytesPerSecond = 2; // quota to be enforced on VDisk measured at VDisk/PDisk border
            optional uint64 WriteBytesPerSecond = 3; // quota for VDisk-issued PDisk writes (huge blobs and replicated SSTs)
        }

        optional uint64 RateBytesPerSecond = 1 [default = 10000000000]; // bytes per second, 10 GB/s
        optional uint64 CapacityMilliseconds = 2 [default = 100]; // 100 ms
        optional uint64 MaxInFlightReadBytes = 3 [default = 335544320]; // 320 MiB
        repeated TMediaTypeQuota MediaTypeQuota = 4;
        optional uint64 TotalRequestBytesPerSecond = 5; // quota for generated requests measured at network layer
        optional uint64 TotalResponseBytesPerSecond = 6; // quota for generated responses at network layer
    }

    repeated TPDisk PDisks = 1;
    repeated TVDisk VDisks = 2;
    repeated TGroupInfo Groups = 3;
    repeated uint64 AvailabilityDomains = 4;
    optional TReplBrokerConfig ReplBrokerConfig = 5;
    // optional NActorsInterconnect.TNodeLocation PhysicalLocation = 6; // DEPRECATED
    optional bool EnableProxyMock = 7;
}

message TNodeWardenCache {
    optional uint64 AvailDomain = 1;
    optional string InstanceId = 2;
    optional TNodeWardenServiceSet ServiceSet = 3;
}

message TMockDevicesConfig {
    repeated TDriveData Devices = 1;
}

message TDriveData {
    optional string Path = 1;
    optional string SerialNumber = 2;
    optional string FirmwareRevision = 3;
    optional string ModelNumber = 4;
    optional uint64 Size = 6;
    optional bool IsMock = 7 [default = false];
    optional EPDiskType DeviceType = 5;
}

message TEvControllerRegisterNode {
    reserved 1;
    optional uint32 NodeID = 2;
    repeated uint32 Groups = 4;
    repeated uint32 GroupGenerations = 5; // must be zero entries (for old nodes) and the same number as in Groups for new ones
    repeated TVDiskStatus VDiskStatus = 6; // actual status for currently operating VDisks
    repeated TDriveData DrivesData = 7;
    optional bool DeclarativePDiskManagement = 8;
}

message TEvControllerUpdateNodeDrives {
    optional uint32 NodeId = 1;
    repeated TDriveData DrivesData = 2;
}

message TEvControllerNodeServiceSetUpdate {
    message TGroupMetadata {
        optional uint32 GroupId = 1;
        optional uint32 CurrentGeneration = 2; // current state in the database
    }

    optional NKikimrProto.EReplyStatus Status = 1;
    optional uint32 NodeID = 2;
    optional TNodeWardenServiceSet ServiceSet = 3;
    repeated TGroupMetadata GroupMetadata = 4;
    optional string InstanceId = 5;
    optional bool Comprehensive = 6; // if this flag is set to true, then there will be no any other entities than elisted in the ServiceSet
    optional uint64 AvailDomain = 7; // availability domain of the controller
}

message TEvControllerConfigRequest {
    reserved 1;
    optional NKikimrBlobStorage.TConfigRequest Request = 2;
    reserved 3;
}

message TEvControllerConfigResponse {
    optional NKikimrBlobStorage.TConfigResponse Response = 1;
    reserved 2;
}

message TEvControllerGetGroup {
    optional uint32 NodeID = 1;
    repeated uint32 GroupIDs = 2;
}

message TEvControllerProposeGroupKey {
    optional uint32 NodeId = 1 [default = 0];
    optional uint32 GroupId = 2 [default = 0];
    optional uint32 LifeCyclePhase = 3 [default = 0];
    optional bytes MainKeyId = 4 [default = ""];
    optional bytes EncryptedGroupKey = 5 [default = ""];
    optional uint64 MainKeyVersion = 6 [default = 0];
    optional uint64 GroupKeyNonce = 7 [default = 0];
}

message TStorageOwnerGroupInfo {
    optional uint32 GroupID = 1;
    optional uint64 ReadThroughput = 2; // bytes per second
    optional uint64 WriteThroughput = 3; // bytes per second
    optional uint64 DataSize = 4;
}

message TStorageOwnerInfo {
    optional uint64 OwnerID = 1;
    repeated TStorageOwnerGroupInfo GroupInfo = 2;
    optional uint64 DataSize = 3;
}

message TEvControllerSelectGroups {
    message TStoragePoolSpecifier {
        optional string Name = 1; // filter by name if set
        optional string Kind = 2; // filter by kind if set
    }
    message TGroupParameters {
        optional uint32 ErasureSpecies = 1;
        optional uint64 DesiredPDiskCategory = 2;
        optional uint64 DesiredVDiskCategory = 3;
        optional float RequiredIOPS = 4;
        optional uint64 RequiredThroughput = 5;
        optional uint64 RequiredDataSize = 6;
        optional TStoragePoolSpecifier StoragePoolSpecifier = 7;

    }
    reserved 1;
    reserved 2;
    repeated TGroupParameters GroupParameters = 3;
    optional TStorageOwnerInfo StorageOwnerInfo = 4;
    optional uint64 ObjectId = 5; // scheme object id
    optional bool ReturnAllMatchingGroups = 6; // when true, then all matching groups are returned
    optional bool BlockUntilAllResourcesAreComplete = 7; // do not respond unless resources for all groups are filled up
    optional bool OnlySeenOperational = 8; // report only those groups which were seen working at any time
}

// VDiskStatus ordering is assumed to be lower for bad statuses and higher for good ones
enum EVDiskStatus {
    ERROR = 0; // the disk is not operational at all
    INIT_PENDING = 1; // initialization in process
    REPLICATING = 2; // the disk accepts queries, but not all the data was replicated
    READY = 3; // the disk is fully operational and does not affect group fault tolerance
}

message TVDiskStatus {
    // identification part
    optional NKikimrBlobStorage.TVDiskID VDiskId = 1;
    optional uint32 NodeId = 2;
    optional uint32 PDiskId = 3;
    optional uint32 VSlotId = 4;
    optional uint64 PDiskGuid = 5;

    // payload
    optional EVDiskStatus Status = 6;
    optional bool OnlyPhantomsRemain = 7; // substate of REPLICATING status
}

message TEvControllerUpdateDiskStatus {
    repeated NKikimrBlobStorage.TVDiskMetrics VDisksMetrics = 1;
    repeated NKikimrBlobStorage.TPDiskMetrics PDisksMetrics = 2;
    repeated TVDiskStatus VDiskStatus = 3;
}

message TEvGroupStatReport {
    message TLatencyHistogram {
        repeated uint32 Buckets = 1;
    }
    optional uint32 GroupId = 1;
    optional NActorsProto.TActorId VDiskServiceId = 2;
    optional TLatencyHistogram PutTabletLog = 10;
    optional TLatencyHistogram PutUserData = 11;
    optional TLatencyHistogram GetFast = 12;
}

message TEvControllerUpdateGroupStat {
    repeated TEvGroupStatReport PerGroupReport = 1;
}

message TEvControllerSelectGroupsResult {
    message TGroupParameters {
        optional uint32 ErasureSpecies = 1;
        optional uint32 GroupID = 2;
        optional string StoragePoolName = 3; // if it was selected from the storage pool
        optional bool PhysicalGroup = 12; // related to TChannelBind.PhysicalGroupsOnly
        optional bool Decommitted = 13;

        reserved 4;

        // group resourcs (as seen by user, that is, including erasure encoding and so on)
        message TResources {
            optional uint64 Space = 1; // bytes
            optional double IOPS = 2; // operations per second
            optional uint64 ReadThroughput = 3; // bytes per second
            optional uint64 WriteThroughput = 4; // bytes per second
            optional double Occupancy = 5; // part of full slot size of the worst VDisk of group
        }

        // assured part of group metrics -- when the underlying PDisks have all possible VSlots created; these metrics
        // are expected not to degrade over time, including vdisk movement; however, everything is possible :)
        optional TResources AssuredResources = 7;

        // instant part of group metrics -- with current VSlot count over PDisks
        optional TResources CurrentResources = 8;

        // VDisk metrics for this group
        optional uint64 AvailableSize = 9; // bytes as reported by VDisk metrics (pessimistic case)
        optional uint64 AllocatedSize = 10; // the same basis
        optional NKikimrBlobStorage.TPDiskSpaceColor.E SpaceColor = 11;
    }
    message TMatchingGroupList {
        repeated TGroupParameters Groups = 1;
    }
    optional NKikimrProto.EReplyStatus Status = 1;
    optional uint64 Cookie = 2;
    //repeated TGroupParameters Groups = 3; // deprecated
    optional bool NewStyleQuerySupported = 4; // must be set to true
    repeated TMatchingGroupList MatchingGroups = 5; // when ReturnAllMatchingGroups is set to true
}

message TEvControllerScrubQueryStartQuantum {
    optional NKikimrBlobStorage.TVSlotId VSlotId = 1;
}

message TEvControllerScrubStartQuantum {
    optional NKikimrBlobStorage.TVSlotId VSlotId = 1;
    optional bytes State = 2; // serialized state; if not set, then scrub is not in progress
}

message TEvControllerScrubQuantumFinished {
    optional NKikimrBlobStorage.TVSlotId VSlotId = 1;
    oneof Outcome {
        bytes State = 2; // intermediate scrub state or ...
        bool Success = 3; // successful (or unsuccessful) result
    }
}

message TEvControllerScrubReportQuantumInProgress {
    optional NKikimrBlobStorage.TVSlotId VSlotId = 1;
}

message TEvRequestBSControllerInfo {
    optional uint32 GroupId = 1;
}

message TEvResponseBSControllerInfo {
    message TVDiskInfo {
        optional NKikimrBlobStorage.TVDiskID VDiskId = 1;
        optional uint32 PDiskId = 2;
        optional uint32 NodeId = 3;
        optional uint64 PDiskCategory = 4;
        optional uint64 VDiskCategory = 5; // Kind
    }
    message TBSGroupInfo {
        optional uint32 GroupId = 1;
        optional uint32 ErasureSpecies = 2;
        repeated TVDiskInfo VDiskInfo = 3;
        //optional uint64 ReadThroughput = 4; // bytes per second
        //optional uint64 WriteThroughput = 5; // bytes per second
        optional uint64 DataSize = 6;
        //optional uint64 Counter = 7; // usage counter
    }
    repeated TBSGroupInfo BSGroupInfo = 1;
}

message TEvControllerNodeReport {
    enum EVDiskPhase {
        UNKNOWN = 0;
        reserved 1;
        WIPED = 2;
        DESTROYED = 3;
        OPERATION_ERROR = 4;
        reserved 5;
    }
    message TVDiskReport {
        optional NKikimrBlobStorage.TVSlotId VSlotId = 1;
        optional NKikimrBlobStorage.TVDiskID VDiskId = 2;
        optional EVDiskPhase Phase = 3;
    }

    enum EPDiskPhase {
        PD_UNKNOWN = 0;
        PD_RESTARTED = 1;
    }
    message TPDiskReport {
        optional uint32 PDiskId = 1;
        optional EPDiskPhase Phase = 2;
    }

    optional uint32 NodeId = 1;
    repeated TVDiskReport VDiskReports = 2;
    repeated TPDiskReport PDiskReports = 3;
}

message TEvControllerGroupDecommittedNotify {
    optional uint32 GroupId = 1;
}

message TEvControllerGroupDecommittedResponse {
    optional NKikimrProto.EReplyStatus Status = 1;
    optional string ErrorReason = 2;
}

message TGroupMetrics {
    optional fixed64 GroupId = 1;
    optional TEvControllerSelectGroupsResult.TGroupParameters GroupParameters = 2;
}

message TEvControllerGroupMetricsExchange {
    repeated TGroupMetrics GroupMetrics = 1;
    repeated fixed32 GroupsToQuery = 2; // filled in by entities asking BSC to report some metrics in return
    optional NKikimrWhiteboard.TBSGroupStateInfo WhiteboardUpdate = 3;
}

message TEvNodeWardenQueryGroupInfo {
    optional uint32 GroupId = 1;
}

message TEvNodeWardenGroupInfo {
    optional TGroupInfo Group = 1;
    repeated uint32 StartedGroupIds = 2;
}
