syntax = "proto3";

package NKikimrBlobStorage.NDDisk;

message TReplyStatus {
    enum E {
        UNKNOWN = 0;
        OK = 1;
        ERROR = 2;
        BLOCKED = 3;
        LOST_DATA = 4;
        SESSION_MISMATCH = 5;
        INCORRECT_REQUEST = 6;
        MISSING_RECORD = 7;
        OUTDATED = 8;
    }
}

// DDisk identifier (used for interfacing DDisk actor) determines the location of DDisk.

message TDDiskId {
    uint32 NodeId = 1;
    uint32 PDiskId = 2;
    uint32 DDiskSlotId = 3;
}

// DDisk query credentials define who asks for an operation: tablet identifier, its generation (to prevent races with
// obsolete instances) and DDiskInstanceGuid to identify cases when DDisk data was lost.

message TQueryCredentials {
    uint64 TabletId = 1;
    uint32 Generation = 2;
    optional fixed64 DDiskInstanceGuid = 3;
    bool FromPersistentBuffer = 4;
}

// DDisk block selector defines the range of blocks we are operating at; it includes through-numbered vChunk index and
// offset/size in that chunks measured in bytes.

message TBlockSelector {
    uint64 VChunkIndex = 1;
    uint32 OffsetInBytes = 2;
    uint32 Size = 3;
}

// DDisk write instruction contains information about data being written. It can contain information about rope passing
// along with event, or, say, an RDMA pointer to get that data from the sender.

message TWriteInstruction {
    oneof Payload {
        uint32 PayloadId = 1; // payload is attached to event as a rope
        // <-- add RDMA here
    }
}

// DDisk read instruction says how to perform read and where to store the result.

message TReadInstruction {
    bool ReturnInRopePayload = 1;
    // <-- add RDMA here
}

// DDisk read result contains information about read data.

message TReadResult {
    oneof Payload {
        uint32 PayloadId = 1;
        // <-- add RDMA here
    }
}

// This message is issued by Partition Tablet on start to establish connection with specific DDisk. Connection stands
// until node is disconnected or DDisk is terminated as an actor. EVERY message to DDisk MUST be sent through
// InterconnectSession mentioned in TEvConnectResult message.

message TEvConnect {
    TQueryCredentials Credentials = 1;
}

message TEvConnectResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    fixed64 DDiskInstanceGuid = 3; // instance guid gets changed every time DDisk loses its data
}

// DDisk disconnect query is issued when tablet is going to be stopped gracefully and don't need DDisk to keep any
// context about that tablet anymore.

message TEvDisconnect {
    TQueryCredentials Credentials = 1;
}

message TEvDisconnectResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvWrite {
    TQueryCredentials Credentials = 1;
    TBlockSelector Selector = 2;
    TWriteInstruction Instruction = 3;
}

message TEvWriteResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvRead {
    TQueryCredentials Credentials = 1;
    TBlockSelector Selector = 2;
    TReadInstruction Instruction = 3;
}

message TEvReadResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    TReadResult ReadResult = 3;
}

message TEvWritePersistentBuffer {
    TQueryCredentials Credentials = 1;
    TBlockSelector Selector = 2;
    uint64 Lsn = 3;
    TWriteInstruction Instruction = 4;
}

message TEvWritePersistentBufferResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    optional double FreeSpace = 3;
}

message TEvReadPersistentBuffer {
    TQueryCredentials Credentials = 1;
    TBlockSelector Selector = 2;
    uint64 Lsn = 3;
    TReadInstruction Instruction = 4;
}

message TEvReadPersistentBufferResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    TReadResult ReadResult = 3;
}

message TSegmentResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvSyncWithPersistentBuffer {
    message TSegment {
        TBlockSelector Selector = 1;
        uint64 Lsn = 2;
    }

    TQueryCredentials Credentials = 1;
    repeated TSegment Segments = 2;
    TDDiskId DDiskId = 3;
    fixed64 DDiskInstanceGuid = 4;
}

message TEvSyncWithPersistentBufferResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;

    repeated TSegmentResult SegmentResults = 3;
}

message TEvSyncWithDDisk {
    message TSegment {
        TBlockSelector Selector = 1;
    }

    TQueryCredentials Credentials = 1;
    repeated TSegment Segments = 2;
    TDDiskId DDiskId = 3;
    fixed64 DDiskInstanceGuid = 4;
}

message TEvSyncWithDDiskResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;

    repeated TSegmentResult SegmentResults = 3;
}

message TEvErasePersistentBuffer {
    TQueryCredentials Credentials = 1;
    TBlockSelector Selector = 2;
    uint64 Lsn = 3;
}


message TEvBatchErasePersistentBuffer {
    message TEraseInfo {
        TBlockSelector Selector = 1;
        uint64 Lsn = 2;
    }
    
    TQueryCredentials Credentials = 1;
    repeated TEvErasePersistentBuffer Erases = 2;
}

message TEvErasePersistentBufferResult {
    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    optional double FreeSpace = 3;
}

message TEvListPersistentBuffer {
    TQueryCredentials Credentials = 1;
}

message TEvListPersistentBufferResult {
    message TPersistentBufferRecord {
        TBlockSelector Selector = 1;
        uint64 Lsn = 2;
    }

    TReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    repeated TPersistentBufferRecord Records = 3;
}

message TDirectBlockGroupAllocation {
    repeated TDDiskId DDiskId = 1;
    repeated TDDiskId PersistentBufferDDiskId = 2;
}
