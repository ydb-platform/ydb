syntax = "proto3";

package NKikimrBlobStorage;

message TDDiskReplyStatus {
    enum E {
        UNKNOWN = 0;
        OK = 1;
        ERROR = 2;
        BLOCKED = 3;
        LOST_DATA = 4;
        SESSION_MISMATCH = 5;
        INCORRECT_REQUEST = 6;
        MISSING_RECORD = 7;
    }
}

// DDisk identifier (used for interfacing DDisk actor) determines the location of DDisk.

message TDDiskId {
    uint32 NodeId = 1;
    uint32 PDiskId = 2;
    uint32 DDiskSlotId = 3;
}

// DDisk query credentials define who asks for an operation: tablet identifier, its generation (to prevent races with
// obsolete instances) and DDiskInstanceGuid to identify cases when DDisk data was lost.

message TDDiskQueryCredentials {
    uint64 TabletId = 1;
    uint32 Generation = 2;
    optional fixed64 DDiskInstanceGuid = 3;
    bool FromPersistentBuffer = 4;
}

// DDisk block selector defines the range of blocks we are operating at; it includes through-numbered vChunk index and
// offset/size in that chunks measured in bytes.

message TDDiskBlockSelector {
    uint64 VChunkIndex = 1;
    uint32 OffsetInBytes = 2;
    uint32 Size = 3;
}

// DDisk write instruction contains information about data being written. It can contain information about rope passing
// along with event, or, say, an RDMA pointer to get that data from the sender.

message TDDiskWriteInstruction {
    oneof Payload {
        uint32 PayloadId = 1; // payload is attached to event as a rope
        // <-- add RDMA here
    }
}

// DDisk read instruction says how to perform read and where to store the result.

message TDDiskReadInstruction {
    bool ReturnInRopePayload = 1;
    // <-- add RDMA here
}

// DDisk read result contains information about read data.

message TDDiskReadResult {
    oneof Payload {
        uint32 PayloadId = 1;
        // <-- add RDMA here
    }
}

// This message is issued by Partition Tablet on start to establish connection with specific DDisk. Connection stands
// until node is disconnected or DDisk is terminated as an actor. EVERY message to DDisk MUST be sent through
// InterconnectSession mentioned in TEvDDiskConnectResult message.

message TEvDDiskConnect {
    TDDiskQueryCredentials Credentials = 1;
}

message TEvDDiskConnectResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    fixed64 DDiskInstanceGuid = 3; // instance guid gets changed every time DDisk loses its data
}

// DDisk disconnect query is issued when tablet is going to be stopped gracefully and don't need DDisk to keep any
// context about that tablet anymore.

message TEvDDiskDisconnect {
    TDDiskQueryCredentials Credentials = 1;
}

message TEvDDiskDisconnectResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvDDiskWrite {
    TDDiskQueryCredentials Credentials = 1;
    TDDiskBlockSelector Selector = 2;
    TDDiskWriteInstruction Instruction = 3;
}

message TEvDDiskWriteResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvDDiskRead {
    TDDiskQueryCredentials Credentials = 1;
    TDDiskBlockSelector Selector = 2;
    TDDiskReadInstruction Instruction = 3;
}

message TEvDDiskReadResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    TDDiskReadResult ReadResult = 3;
}

message TEvDDiskWritePersistentBuffer {
    TDDiskQueryCredentials Credentials = 1;
    TDDiskBlockSelector Selector = 2;
    uint64 Lsn = 3;
    TDDiskWriteInstruction Instruction = 4;
}

message TEvDDiskWritePersistentBufferResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvDDiskReadPersistentBuffer {
    TDDiskQueryCredentials Credentials = 1;
    TDDiskBlockSelector Selector = 2;
    uint64 Lsn = 3;
    TDDiskReadInstruction Instruction = 4;
}

message TEvDDiskReadPersistentBufferResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    TDDiskReadResult ReadResult = 3;
}

message TEvDDiskFlushPersistentBuffer {
    TDDiskQueryCredentials Credentials = 1;
    TDDiskBlockSelector Selector = 2;
    uint64 Lsn = 3;
    TDDiskId DDiskId = 4; // when this entry is not filled, record is just deleted from the buffer
    optional fixed64 DDiskInstanceGuid = 5;
}

message TEvDDiskFlushPersistentBufferResult {
    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
}

message TEvDDiskListPersistentBuffer {
    TDDiskQueryCredentials Credentials = 1;
}

message TEvDDiskListPersistentBufferResult {
    message TPersistentBufferRecord {
        TDDiskBlockSelector Selector = 1;
        uint64 Lsn = 2;
    }

    TDDiskReplyStatus.E Status = 1;
    optional string ErrorReason = 2;
    repeated TPersistentBufferRecord Records = 3;
}

message TDirectBlockGroupAllocation {
    repeated TDDiskId DDiskId = 1;
    repeated TDDiskId PersistentBufferDDiskId = 2;
}
