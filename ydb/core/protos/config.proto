import "google/protobuf/descriptor.proto";
import "ydb/core/config/protos/marker.proto";
import "ydb/core/fq/libs/config/protos/fq_config.proto";
import "ydb/core/protos/alloc.proto";
import "ydb/core/protos/auth.proto";
import "ydb/core/protos/blobstorage.proto";
import "ydb/core/protos/blobstorage_base3.proto";
import "ydb/core/protos/blobstorage_config.proto";
import "ydb/core/protos/blobstorage_pdisk_config.proto";
import "ydb/core/protos/blobstorage_vdisk_config.proto";
import "ydb/core/protos/bootstrap.proto";
import "ydb/core/protos/cms.proto";
import "ydb/core/protos/compaction.proto";
import "ydb/core/protos/config_metrics.proto";
import "ydb/core/protos/config_units.proto";
import "ydb/core/protos/counters_schemeshard.proto";
import "ydb/core/protos/data_integrity_trails.proto";
import "ydb/core/protos/datashard_config.proto";
import "ydb/core/protos/drivemodel.proto";
import "ydb/core/protos/feature_flags.proto";
import "ydb/core/protos/flat_scheme_op.proto";
import "ydb/core/protos/hive.proto";
import "ydb/core/protos/http_config.proto";
import "ydb/core/protos/key.proto";
import "ydb/core/protos/kqp.proto";
import "ydb/core/protos/local.proto";
import "ydb/core/protos/memory_controller_config.proto";
import "ydb/core/protos/netclassifier.proto";
import "ydb/core/protos/node_broker.proto";
import "ydb/core/protos/pqconfig.proto";
import "ydb/core/protos/recoveryshard_config.proto";
import "ydb/core/protos/replication.proto";
import "ydb/core/protos/resource_broker.proto";
import "ydb/core/protos/shared_cache.proto";
import "ydb/core/protos/stream.proto";
import "ydb/core/protos/table_service_config.proto";
import "ydb/core/protos/tablet.proto";
import "ydb/core/protos/tenant_pool.proto";
import "ydb/core/protos/tenant_slot_broker.proto";
import "ydb/core/protos/workload_manager_config.proto";
import "ydb/core/protos/nbs/blockstore.proto";
import "ydb/library/actors/protos/interconnect.proto";
import "yql/essentials/core/file_storage/proto/file_storage.proto";
import "yql/essentials/providers/common/proto/gateways_config.proto";
import "ydb/core/protos/s3_settings.proto";
import "ydb/public/api/protos/annotations/sensitive.proto";

package NKikimrConfig;
option java_package = "ru.yandex.kikimr.proto";

message TAffinity {
    repeated uint32 X = 1; // DEPRECATED: Use `CpuList` instead

    // Numerical list of processors. The numbers are separated by commas and may include ranges. For example: 0,5,7,9-11
    optional string CpuList = 2; // Processors to include. Use all processor if not set.
    optional string ExcludeCpuList = 3; // Exclude specified processors from `CpuList` (or all processors if not set)
}

message TActorSystemConfig {
    enum ENodeType {
        STORAGE = 1;
        COMPUTE = 2;
        HYBRID = 3;
    }

    enum EActorSystemProfile {
        DEFAULT = 1;
        LOW_CPU_CONSUMPTION = 2;
        LOW_LATENCY = 3;
    }

    message TExecutor {
        enum EType {
            BASIC = 1;
            IO = 2;
        };

        optional EType Type = 1;
        optional uint32 Threads = 2;
        optional uint64 SpinThreshold = 3;
        optional TAffinity Affinity = 4;
        optional uint32 InjectMadSquirrels = 5; // Obsolete, no more mad squirrels anymore
        optional string Name = 6;
        optional uint32 TimePerMailboxMicroSecs = 7;
        optional uint32 EventsPerMailbox = 8;
        optional uint32 RealtimePriority = 9;

        // Actorsystem 1.4
        optional uint32 MinThreads = 12; // Lower balancing bound, should be at least 1, and not greater than `Threads`
        optional uint32 MaxThreads = 13; // Higher balancing bound, should be not lower than `Threads`
        optional int32 Priority = 16;
        optional int32 MaxAvgPingDeviation = 17;

        optional bool HasSharedThread = 18;
        optional uint32 MaxLocalQueueSize = 20;
        optional uint32 MinLocalQueueSize = 21;

        // Tiny YDB
        repeated uint32 AdjacentPools = 22;
        optional uint32 ForcedForeignSlots = 23;
    }

    message TScheduler {
        optional uint64 Resolution = 1;
        optional uint64 SpinThreshold = 2;
        optional uint64 ProgressThreshold = 3;
        optional TAffinity Affinity = 4;
        optional bool UseSchedulerActor = 5;
    }

    repeated TExecutor Executor = 1;
    optional TScheduler Scheduler = 2;

    optional uint32 SysExecutor = 3;
    optional uint32 UserExecutor = 4;
    optional uint32 IoExecutor = 5;
    optional uint32 BatchExecutor = 6;

    message TServiceExecutor {
        required string ServiceName = 1;
        required uint32 ExecutorId = 2;
    }

    repeated TServiceExecutor ServiceExecutor = 7;
    optional uint32 TimePerMailboxMicroSecs = 8;
    optional uint32 EventsPerMailbox = 9;
    optional uint32 SelfPingInterval = 10; // in microseconds

    optional bool UseAutoConfig = 12;

    // Used only with UseAutoConfig;
    optional uint32 CpuCount = 13;
    optional ENodeType NodeType = 14 [default = COMPUTE];
    optional uint32 ForceIOPoolThreads = 17;
    optional bool UseSharedThreads = 18;
    optional bool UseRingQueue = 19 [default = true];

    optional bool MonitorStuckActors = 15;
    optional EActorSystemProfile ActorSystemProfile = 16;

    optional uint32 MinLocalQueueSize = 20;
    optional uint32 MaxLocalQueueSize = 21;
}

message TStaticNameserviceConfig {

    enum ENameserviceType {
        NS_DEFAULT = 0;     // default (nodebroker)
        NS_FIXED = 1;       // static table lookup
        NS_NODE_BROKER = 2; // nodebroker based
        NS_EXTERNAL = 3;    // may be paired with external discovery
    }

    enum EDnsResolverType {
        ARES = 0;
        LIBC = 1;
    }

    message TEndpoint {
        optional string Name = 1;
        optional string Address = 2;
    }

    message TNode { // todo: multiple networks
        optional uint32 NodeId = 1;

        optional string Address = 2;
        optional uint32 Port = 3;

        optional string Host = 4;
        optional string InterconnectHost = 5;

        optional NActorsInterconnect.TNodeLocation Location = 6;

        repeated TEndpoint Endpoint = 7;

        optional NActorsInterconnect.TNodeLocation WalleLocation = 8 [deprecated=true];
    }

    repeated TNode Node = 1;

    optional string ClusterUUID = 2;
    repeated string AcceptUUID = 3;
    optional bool SuppressVersionCheck = 4;
    optional ENameserviceType Type = 5;
    optional bool KeepSocket = 6 [default = true];
    optional bool ForceTcp = 7 [default = false];
    optional EDnsResolverType DnsResolverType = 8 [default = ARES];
    optional bool AddTrailingDot = 9 [default = false];
}

message TDynamicNameserviceConfig {
    optional uint32 MaxStaticNodeId = 1 [default = 1000];
    optional uint32 MaxDynamicNodeId = 2 [default = 200000];
    optional uint64 LeaseDuration = 3 [default = 3600000000]; // DEPRECATED
    // Soft limit, new dynamic nodes will be registered in range [MinDynamicNodeId, MaxDynamicNodeId],
    // but already existing dynamic nodes in range (MaxStaticNodeId, MaxDynamicNodeId) will be handled properly
    optional uint32 MinDynamicNodeId = 4 [default = 50000];
}

message TDomainsConfig {
    message TStateStorage {
        enum EPileState {
            DISCONNECTED = 0; // this pile is disconnected from primary one
            NOT_SYNCHRONIZED = 1; // this pile is connected to primary pile, but not yet fully synchronized
            SYNCHRONIZED = 2; // this pile is connected to primary pile and in sync
            PRIMARY = 3; // this is the primary pile
            PROMOTED = 4; // this is the synchronized pile which is being promoted to become primary
            DEMOTED = 5; // this is currently primary pile which is being demoted
        }

        message TRing {
            optional uint32 NToSelect = 1;
            repeated TRing Ring = 2;
            repeated uint32 Node = 3;
            optional bool UseSingleNodeActorId = 4;
            optional bool UseRingSpecificNodeSelection = 5;
            optional bool IsDisabled = 6 [default = false]; // used in the intermediate reconfiguration step
            optional bool WriteOnly = 7 [default = false]; // used for ring groups
            optional uint32 RingGroupActorIdOffset = 8 [default = 0]; // used for ActorId difference for multiple replicas on one node
            optional uint32 BridgePileId = 9; // bridge pile id for this ring group when bridge mode is enabled
            optional EPileState PileState = 10; // state for this ring group's pile
        }

        optional uint32 SSId = 1 [default = 1];
        optional TRing Ring = 2; // for compatibility, use RingGroups
        optional uint32 StateStorageVersion = 3 [default = 0];
        repeated uint32 CompatibleVersions = 4;
        repeated TRing RingGroups = 5;
        optional uint64 ClusterStateGeneration = 6; // generation from current ClusterState
        optional fixed64 ClusterStateGuid = 7;
    }

    message TStoragePoolType {
        optional string Kind = 1;
        optional NKikimrBlobStorage.TDefineStoragePool PoolConfig = 2;
    }

    message TDomain {
        message TTxLimits {
            optional uint64 PerRequestDataSizeLimit = 1;
            optional uint64 PerShardReadSizeLimit = 2;
            optional uint64 PerShardIncomingReadSetSizeLimit = 3;
        }

        optional uint32 DomainId = 1;
        optional fixed64 SchemeRoot = 2;
        repeated uint64 Coordinator = 3;
        repeated uint64 Mediator = 4;
        repeated uint64 Proxy = 5;
        repeated uint32 SSId = 6;
        repeated uint32 HiveUid = 7;
        optional uint64 PlanResolution = 8;
        optional string Name = 9;
        optional TTxLimits TxLimits = 10; // DEPRECATED
        repeated TStoragePoolType StoragePoolTypes = 11;
        repeated fixed64 ExplicitMediators = 12;
        repeated fixed64 ExplicitCoordinators = 13;
        repeated fixed64 ExplicitAllocators = 14;
        optional uint32 SchemeBoardSSId = 15;
    }

    message THiveConfig { // look for another THiveConfig later in this file
        optional uint32 HiveUid = 1 [default = 1];
        optional fixed64 Hive = 2;
    }

    message TExecLevel {
    }

    message TNamedCompactionPolicy {
        optional string Name = 1;
        optional NKikimrCompaction.TCompactionPolicy Policy = 2;
    }

    message TSecurityConfig {
        optional bool EnforceUserTokenRequirement = 1 [default = false];
        optional bool EnforceUserTokenCheckRequirement = 7 [default = false]; // Check if a token was specified // If not, or if the token was incorrect or access was denied, the request will be handled as if no token was provided
        repeated string MonitoringAllowedSIDs = 2;
        repeated string AdministrationAllowedSIDs = 3;
        repeated string DefaultUserSIDs = 4;
        optional string AllAuthenticatedUsers = 5 [default = "all-users@well-known"];
        repeated string ViewerAllowedSIDs = 6;
        repeated string RegisterDynamicNodeAllowedSIDs = 8;
        repeated string BootstrapAllowedSIDs = 9;
        repeated string DatabaseAllowedSIDs = 10;

        message TUser {
            optional string Name = 1;
            optional string Password = 2;
        }

        message TGroup {
            optional string Name = 1;
            repeated string Members = 2;
        }

        repeated TUser DefaultUsers = 15;
        repeated TGroup DefaultGroups = 16;
        repeated string DefaultAccess = 17;
        optional string AllUsersGroup = 18;
        optional bool DisableBuiltinSecurity = 19;
        optional bool DisableBuiltinGroups = 20;
        optional bool DisableBuiltinAccess = 21;
    }

    repeated TDomain Domain = 1;
    repeated TStateStorage StateStorage = 2;
    repeated TExecLevel ExecLevel = 3;
    repeated THiveConfig HiveConfig = 4;
    repeated TNamedCompactionPolicy NamedCompactionPolicy = 5;
    optional TSecurityConfig SecurityConfig = 6;
    optional bool ForbidImplicitStoragePools = 7 [default = true];

    // then these configs are set, they override the default StateStorage config for each kind of entity
    optional TStateStorage ExplicitStateStorageConfig = 8;
    optional TStateStorage ExplicitStateStorageBoardConfig = 9;
    optional TStateStorage ExplicitSchemeBoardConfig = 10;
}

message TBlobStorageConfig {
    optional NKikimrBlobStorage.TNodeWardenServiceSet ServiceSet = 1;
    optional bool EnableOverseerLsnReporting = 2 [default = false]; // deprecated
    optional string CacheFilePath = 3;
    optional bool CachePDisks = 4 [default = true];
    optional bool CacheVDisks = 5 [default = true];

    reserved 6; // AutoconfigSettings previously here

    message TVDiskPerformanceConfig {
        optional NKikimrBlobStorage.EPDiskType PDiskType = 1;
        optional uint32 MinHugeBlobSizeInBytes = 4;
    }

    message TVDiskPerformanceSettings {
        repeated TVDiskPerformanceConfig VDiskTypes = 1;
    };

    message TVDiskBalancingConfig {
        optional bool EnableSend = 1 [default=false];
        optional bool EnableDelete = 2 [default=false];

        optional bool BalanceOnlyHugeBlobs = 3 [default=true];
        optional uint64 JobGranularityUs = 4 [default=1000];

        optional uint64 BatchSize = 5 [default=32];
        optional uint64 MaxToSendPerEpoch = 6 [default=1000];
        optional uint64 MaxToDeletePerEpoch = 7 [default=1000];

        optional uint64 ReadBatchTimeoutMs = 8 [default=10000];
        optional uint64 SendBatchTimeoutMs = 9 [default=10000];
        optional uint64 RequestBlobsOnMainTimeoutMs = 10 [default=10000];
        optional uint64 DeleteBatchTimeoutMs = 11 [default=10000];
        optional uint64 EpochTimeoutMs = 12 [default=60000];

        optional uint64 SecondsToSleepIfNothingToDo = 13 [default=600];
    }

    reserved 7;  // TCostMetricsSettings, moved to ICB
    optional TVDiskPerformanceSettings VDiskPerformanceSettings = 8;
    optional TVDiskBalancingConfig VDiskBalancingConfig = 9;

    // filled in by config parser, not by user; required for correct distconf operation
    repeated NKikimrBlobStorage.TDefineHostConfig DefineHostConfig = 10;
    optional NKikimrBlobStorage.TDefineBox DefineBox = 11;

    optional NKikimrBlobStorage.TBscConfig BscSettings = 12;

    optional uint64 BridgeSyncRateBytesPerSecond = 13 [default = 500000000]; // default 500 MB/s per node
 }

message TSelfManagementConfig {
    // whether the self management is enabled (through distconf)? (mandatory field)
    optional bool Enabled = 1;

    // generation of the config; when set, one can automatically apply in-filesystem config
    optional uint64 Generation = 2;

    // subset of DefineStoragePool command
    optional string ErasureSpecies = 11;
    optional NKikimrBlobStorage.TGroupGeometry Geometry = 12;
    repeated NKikimrBlobStorage.TPDiskFilter PDiskFilter = 13;
    optional NKikimrBlobStorage.EPDiskType PDiskType = 14;

    // some extra settings
    optional bool AutomaticBoxManagement = 21 [default = true]; // invoke BSC DefineHostConfig/DefineBox automatically
    optional bool AutomaticBootstrap = 22; // whether bootstrap should be performed automatically; PROHIBITED for production
    optional bool AutomaticStaticGroupManagement = 23; // whether distconf/SelfHeal can change static group on its behalf
    optional bool AutomaticStateStorageManagement = 24; // the same for state storage
    optional bool AutomaticStateStorageBoardManagement = 25; // the same for state storage board
    optional bool AutomaticSchemeBoardManagement = 26; // the same for scheme board
}

message TBlobStorageFormatConfig {
    message TDrive {
        optional uint64 RackId = 1;
        optional uint32 NodeId = 2;
        optional string Hostname = 3;
        optional string Type = 4;
        optional string Path = 5;
        optional uint64 Guid = 6;
        optional uint64 PDiskId = 7;
        optional uint64 DataCenterId = 8;
        optional uint64 RoomId = 9;
        optional uint64 BodyId = 10;
        optional NKikimrBlobStorage.TPDiskConfig PDiskConfig = 11;
    }

    repeated TDrive Drive = 1;
}

message TUAClientConfig {
    optional string Uri = 1;
    optional string SharedSecretKey = 2 [(Ydb.sensitive) = true];
    optional uint64 MaxInflightBytes = 3 [default = 100000000];
    optional uint64 GrpcReconnectDelayMs = 4;
    optional uint64 GrpcSendDelayMs = 5;
    optional uint64 GrpcMaxMessageSize = 6;
    optional string ClientLogFile = 7;
    optional uint32 ClientLogPriority = 8;
    optional string LogName = 9;
}

message TLogConfig {
    message TEntry {
        optional bytes Component = 1;
        optional uint32 Level = 2;
        optional uint32 SamplingLevel = 3;
        optional uint32 SamplingRate = 4;
    }

    repeated TEntry Entry = 1;
    optional bool   SysLog = 2 [default = false];
    optional uint32 DefaultLevel = 3 [default = 5]; // NActors::NLog::PRI_NOTICE
    optional uint32 DefaultSamplingLevel = 4 [default = 7]; // NActors::NLog::PRI_DEBUG
    optional uint32 DefaultSamplingRate = 5 [default = 0];
    optional string Format = 6 [default = "full"]; // "full" | "short" | "json"
    optional string ClusterName = 7;
    optional bool AllowDropEntries = 8 [default = true];
    optional bool UseLocalTimestamps = 9 [default = false];
    optional string BackendFileName = 10;
    optional string SysLogService = 11;
    optional bool SysLogToStdErr = 12; // writes logs to stderr as well as in syslog/file
    optional TUAClientConfig UAClientConfig = 13;
    optional uint64 TimeThresholdMs = 14 [default = 1000];
    optional bool IgnoreUnknownComponents = 15 [default = true];
    optional string TenantName = 16;
}

message TInterconnectConfig {
    message TChannel {
        optional uint32 Index = 1;
        optional uint32 Quota = 2; // deprecated
        optional uint32 Weight = 3; // use this instead of field "Quota"
    }

    enum EMergeMode {
        AUTO = 0;
        PER_PEER = 1;
        PER_DATA_CENTER = 2;
        NO_MERGE = 3;
    }

    enum EEncryptionMode {
        DISABLED = 0;
        OPTIONAL = 1;
        REQUIRED = 2;
    };

    enum ESocketSendOptimization {
        IC_SO_DISABLED = 0;
        IC_SO_MSG_ZEROCOPY = 1;
    };

    enum ERdmaCqMode {
        CQ_POLLING = 0;
        CQ_EVENT = 1;
    };

    repeated TChannel Channel = 1;
    optional bool FirstTryBeforePoll = 2; // DEPRECATED
    optional bool StartTcp = 3 [default = false];
    optional uint32 SelfKickDelay = 4; // DEPRECATED
    optional uint32 HandshakeTimeout = 5;
    optional uint32 HeartbeatInterval = 6;
    optional uint32 DeadPeerTimeout = 7;
    optional uint32 SendBufferDieLimitInMB = 8;
    optional uint32 CloseOnIdleTimeout = 9;
    optional uint32 MaxInflightAmountOfDataInKB = 10;
    optional bool MergePerPeerCounters = 11;
    optional EMergeMode CounterMergeMode = 15 [default = AUTO];
    optional uint32 TCPSocketBufferSize = 12;
    optional uint32 MaxTimePerEventInMks = 13;
    optional bool BindOnAllAddresses = 16 [default = true];
    optional EEncryptionMode EncryptionMode = 17 [default = DISABLED];
    optional bool TlsAuthOnly = 38; // do not encrypt traffic
    repeated string ForbiddenSignatureAlgorithms = 50;
    optional bool EnforceScopeValidation = 18;
    optional bytes Certificate = 30 [(Ydb.sensitive) = true]; // in PEM format
    optional bytes PrivateKey = 31 [(Ydb.sensitive) = true]; // in PEM format
    optional string PathToCertificateFile = 35;
    optional string PathToPrivateKeyFile = 36;
    optional string PathToCaFile = 37;
    optional string CipherList = 34;
    optional NKikimrConfigUnits.TDuration MessagePendingTimeout = 32;
    optional uint64 MessagePendingSize = 33;
    optional bool SuppressConnectivityCheck = 39 [default = false];
    optional uint32 PreallocatedBufferSize = 40;
    optional uint32 NumPreallocatedBuffers = 41;
    optional bool EnableExternalDataChannel = 42 [default = true];
    optional bool ValidateIncomingPeerViaDirectLookup = 44;
    optional uint32 SocketBacklogSize = 45; // SOMAXCONN if not set or zero
    optional ESocketSendOptimization SocketSendOptimization = 51 [default = IC_SO_DISABLED];
    optional bool UseRdma = 52;
    optional uint32 RdmaMaxWr = 53 [default = 4096];
    optional bool RdmaChecksum = 54 [default = true];
    optional ERdmaCqMode RdmaCqMode = 55;
    optional uint32 RdmaMemPoolSizeLimitMb = 56 [default = 4096];

    // ballast is added to IC handshake frames to ensure correctness of jumbo frames transmission over network
    optional uint32 HandshakeBallastSize = 14;

    // new-style definitions for various timeouts; when defined, they silently override values above
    optional NKikimrConfigUnits.TDuration SelfKickDelayDuration = 20; // DEPRECATED
    optional NKikimrConfigUnits.TDuration HandshakeTimeoutDuration = 21;
    optional NKikimrConfigUnits.TDuration HeartbeatIntervalDuration = 22;
    optional NKikimrConfigUnits.TDuration DeadPeerTimeoutDuration = 23;
    optional NKikimrConfigUnits.TDuration CloseOnIdleTimeoutDuration = 24;

    optional uint64 TotalInflightAmountOfData = 25;
    optional NKikimrConfigUnits.TDuration PingPeriodDuration = 26;
    optional NKikimrConfigUnits.TDuration ForceConfirmPeriodDuration = 27;
    optional NKikimrConfigUnits.TDuration LostConnectionDuration = 28;
    optional NKikimrConfigUnits.TDuration BatchPeriodDuration = 29;

    optional NKikimrConfigUnits.TDuration FirstErrorSleep = 46;
    optional NKikimrConfigUnits.TDuration MaxErrorSleep = 47;
    optional double ErrorSleepRetryMultiplier = 48;

    optional uint32 OutgoingHandshakeInflightLimit = 43;

    optional uint64 EventDelayMicrosec = 49;
}

message TChannelProfileConfig {
    message TProfile {
        message TChannel {
            optional string ErasureSpecies = 1;
            optional uint64 PDiskCategory = 2;
            optional NKikimrBlobStorage.TVDiskKind.EVDiskKind VDiskCategory = 3 [default = Default];

            // this option uses new BS configuration interface to obtain matching groups, and it must not be provided
            // with any of the above fields
            optional string StoragePoolKind = 5;
        }

        optional uint32 ProfileId = 1;
        repeated TChannel Channel = 2;
    }

    repeated TProfile Profile = 1;
}

message TMonitoringConfig {
    message TDatabaseLabels {
        optional bool Enabled = 1 [default = true];
        // If labels are enabled and services list is empty
        // then GetTenantSensorServices is used to get it.
        repeated string Services = 2;
        // Custom database label is not currently supported.
        // optional string DatabaseLabel = 3 [default = "database"];
        optional string NoneDatabasetLabelValue = 4 [default = "<none>"];
        optional string MultipleDatabaseLabelValue = 5 [default = "<multiple>"];
        // Custom slot label is not currently supported.
        // optional string SlotLabel = 6 [default = "slot"];
        optional string StaticSlotLabelValue = 7 [default = "static"];
        optional string DynamicSlotLabelValue = 8 [default = "dynamic"];
        optional string MultipleSlotLabelValue = 9 [default = "<multiple>"];
        optional bool GroupAllMetrics = 10;
    };

    message TDatabaseAttributeLabels {
        message TAttributeGroup {
            // Currently custom list of attributes is not
            // supported. GetTenantAttributeLabels is used
            // to get default list.
            //repeated string Attributes = 1;
            repeated string Services = 2;
        }

        optional bool Enabled = 1 [default = true];
        // If labels are enabled and no attribute group
        // is specified then default one is built using
        // GetTenantAttributeSensorServices and
        // GetTenantAttributeLabels.
        repeated TAttributeGroup AttributeGroups = 2;
    };

    optional uint32 MonitoringPort = 1 [default = 0];
    optional uint32 MonitoringThreads = 2 [default = 10];
    optional string MonitoringCaption = 3 [default = "YDB Developer UI"];
    optional uint32 TabletMonitoringRetries = 4 [default = 1];
    optional bool ForceDatabaseLabels = 5 [default = false];
    optional string MonitoringAddress = 6;
    optional TDatabaseLabels DatabaseLabels = 7;
    optional TDatabaseAttributeLabels DatabaseAttributeLabels = 8;
    optional string DataCenter = 9;
    optional string HostLabelOverride = 10;
    optional string ProcessLocation = 11;
    optional string AllowOrigin = 12;
    optional string RedirectMainPageTo = 13 [default = "monitoring/"];
    optional string MonitoringCertificate = 14 [(Ydb.sensitive) = true];
    optional string MonitoringCertificateFile = 15;
    optional string MonitoringPrivateKeyFile = 20;
    optional string MemAllocDumpPathPrefix = 16;
    optional uint32 MaxRequestsPerSecond = 17 [default = 0];
    optional string InactivityTimeout = 18 [default = "2m"];
    optional bool HideHttpEndpoint = 19 [default = false];
}

message TRestartsCountConfig {
    optional string RestartsCountFile = 1 [default = ""];
}

message TMessageBusConfig {

    message TBusQueueConfig {
        optional string Name = 1;
        optional uint32 NumWorkers = 2 [default = 1];
    }

    message TBusSessionConfig {
        optional string Name = 1 [default = ""];
        optional uint32 NumRetries = 2 [default = 0];
        optional uint32 RetryInterval = 3 [default = 1000];
        optional bool   ReconnectWhenIdle = 4 [default = false];
        optional uint64 MaxInFlight = 5 [default = 1000];
        optional uint32 PerConnectionMaxInFlight = 6 [default = 0];
        optional uint32 PerConnectionMaxInFlightBySize = 7 [default = 0];
        optional int64  MaxInFlightBySize = 8 [default = -1];
        optional int64  TotalTimeout = 9 [default = 0];
        optional int64  SendTimeout = 10 [default = 0];
        optional int64  ConnectTimeout = 11 [default = 0];
        optional uint64 DefaultBufferSize = 12 [default = 10240];
        optional uint64 MaxBufferSize = 13 [default = 1048576];
        optional uint32 SocketRecvBufferSize = 14 [default = 0];
        optional uint32 SocketSendBufferSize = 15 [default = 0];
        optional int32  SocketToS = 16 [default = -1];
        optional uint64 SendThreshold = 17 [default = 10240];
        optional uint64 Cork = 18 [default = 0]; // milliseconds
        optional uint32 MaxMessageSize = 19 [default = 0x01A00000];
        optional bool   TcpNoDelay = 20 [default = false];
        optional bool   TcpCork = 21 [default = false];
        optional bool   ExecuteOnMessageInWorkerPool = 22 [default = true];
        optional bool   ExecuteOnReplyInWorkerPool = 23 [default = true];
        optional uint32 ListenPort = 24 [default = 0];
    }

    optional bool   StartBusProxy = 1 [default = false];
    optional uint32 BusProxyPort = 2 [default = 14505];
    optional TBusQueueConfig ProxyBusQueueConfig = 3;
    optional TBusSessionConfig ProxyBusSessionConfig = 4;
    repeated uint64 ProxyBindToProxy = 5;
    optional bool   StartTracingBusProxy = 6 [default = true]; // move to TMessageBusTraceServiceConfig
    optional string TracePath = 7;
    optional uint64 CompileInflightLimit_Depricated = 8 [default = 100000];
}

message TTabletsConfig {

    message TTablet {
        optional string Type = 1;
        repeated uint32 Node = 2;
        optional NKikimrTabletBase.TTabletStorageInfo Info = 3;
        optional bool StandBy = 4;
        optional uint64 WatchThreshold = 5;
    }

    repeated TTablet Tablet = 1;
}

message TKQPConfig {
    optional bool Enable = 1 [default = true];

    repeated NKikimrKqp.TKqpSetting Settings = 10;
}

message TInternalRequestConfig {
    optional uint32 RetryPeriodStartSeconds = 1 [default = 3];
    optional uint32 RetryPeriodFinishSeconds = 2 [default = 30];
}

message TConveyorConfig {
    optional bool Enabled = 1 [default = true];
    optional uint32 WorkersCount = 2;
    optional uint32 QueueSizeLimit = 3;
    optional double DefaultFractionOfThreadsCount = 4;
    optional double WorkersCountDouble = 5;
}

message TCompositeConveyorConfig {
    message TCategory {
        optional string Name = 1;
        optional uint64 QueueSizeLimit = 2;
    }

    message TWorkerPoolCategoryLink {
        optional string Category = 1;
        optional double Weight = 2;
    }

    message TWorkersPool {
        optional double WorkersCount = 1;
        optional double DefaultFractionOfThreadsCount = 2;
        repeated TWorkerPoolCategoryLink Links = 3;
        optional string Name = 4;
        optional uint64 MaxBatchSize = 5;
    }

    optional bool Enabled = 1 [default = true];
    repeated TWorkersPool WorkerPools = 2;
    repeated TCategory Categories = 3;
}

message TPrioritiesQueueConfig {
    optional bool Enabled = 1 [default = true];
    optional uint32 Limit = 2 [default = 32];
}

message TLimiterConfig {
    optional bool Enabled = 1 [default = true];
    optional uint64 Limit = 2;
    optional uint64 PeriodMilliSeconds = 3 [default = 1000];
}

message TGroupedMemoryLimiterConfig {
    optional bool Enabled = 1 [default = true];
    optional uint64 MemoryLimit = 2;
    optional uint64 HardMemoryLimit = 3;
    optional uint64 CountBuckets = 4;
}

message TExternalIndexConfig {
    optional bool Enabled = 1 [default = true];
    optional TInternalRequestConfig RequestConfig = 2;
    optional string InternalTablePath = 3;
}

message TMetadataProviderConfig {
    optional bool Enabled = 1 [default = true];
    optional uint32 RefreshPeriodSeconds = 2 [default = 10];
    optional TInternalRequestConfig RequestConfig = 3;
    optional string Path = 4;
}

message TBackgroundTasksConfig {
    optional bool Enabled = 1 [default = true];
    optional TInternalRequestConfig RequestConfig = 2;
    optional uint32 PullPeriodSeconds = 3 [default = 10];
    optional uint32 PingPeriodSeconds = 4 [default = 2];
    optional uint32 PingCheckPeriodSeconds = 5 [default = 20];
    optional uint32 MaxInFlight = 6 [default = 8];
    optional string InternalTablePath = 7;
}

message TMemoryLogConfig {
    optional uint64 LogBufferSize = 1;
    optional uint64 LogGrainSize = 2;
}

message TGRpcConfig {
    optional bool   StartGRpcProxy = 1 [default = true];
    optional string Host = 2 [default = "[::]"];
    optional uint32 Port = 3;
    optional uint32 WorkerThreads = 4 [default = 2];
    optional uint64 GRpcMemoryQuotaBytes = 5 [default = 1073741824]; // 1 GB default; 0 == unlimited
    optional uint64 MaxMessageSize = 6; // default = DEFAULT_GRPC_MESSAGE_SIZE_LIMIT
    optional uint32 MaxInFlight = 7; // 0 == unlimited [default]
    optional NKikimrStream.TStreamingConfig StreamingConfig = 8;
    // Ssl part
    optional uint32 SslPort = 9;
    optional string CA = 10 [(Ydb.sensitive) = true];
    optional string Cert = 11 [(Ydb.sensitive) = true];
    optional string Key = 12 [(Ydb.sensitive) = true];
    optional string PathToCertificateFile = 27;
    optional string PathToPrivateKeyFile = 28;
    optional string PathToCaFile = 29;

    // public host/port for publishing
    optional string PublicHost = 13;
    optional uint32 PublicPort = 14;
    optional uint32 PublicSslPort = 15;

    // public addresses for publishing
    repeated string PublicAddressesV4 = 16;
    repeated string PublicAddressesV6 = 17;
    optional string PublicTargetNameOverride = 18;

    // empty service list is 'run most services "what means 'most' in unspecified"'
    repeated string Services = 20;
    optional bool ServeRootDomains = 21 [default = true];
    repeated string ServicesEnabled = 22;
    repeated string ServicesDisabled = 23;

    optional bool SkipSchemeCheck = 24 [default = false];

    repeated string RatelimiterServicesEnabled = 25;
    repeated string RatelimiterServicesDisabled = 26;

    enum YdbGrpcCompressionAlgorithm {
        YDB_GRPC_COMPRESS_NONE = 0;
        YDB_GRPC_COMPRESS_DEFLATE = 1;
        YDB_GRPC_COMPRESS_GZIP = 2;
    };

    optional YdbGrpcCompressionAlgorithm DefaultCompressionAlgorithm = 30 [default = YDB_GRPC_COMPRESS_NONE];

    enum YdbGrpcCompressionLevel {
        YDB_GRPC_COMPRESS_LEVEL_NONE = 0;
        YDB_GRPC_COMPRESS_LEVEL_LOW = 1;
        YDB_GRPC_COMPRESS_LEVEL_MED = 2;
        YDB_GRPC_COMPRESS_LEVEL_HIGH = 3;
    }

    optional YdbGrpcCompressionLevel DefaultCompressionLevel = 31 [default = YDB_GRPC_COMPRESS_LEVEL_NONE];
    optional TXdsBootstrap XdsBootstrap = 32;

    // server socket options
    optional bool   KeepAliveEnable = 100 [default = true]; // SO_KEEPALIVE
    optional uint32 KeepAliveIdleTimeoutTriggerSec = 101 [default = 90]; // TCP_KEEPIDLE
    optional uint32 KeepAliveMaxProbeCount = 102 [default = 3]; // TCP_KEEPCNT
    optional uint32 KeepAliveProbeIntervalSec = 103 [default = 10]; // TCP_KEEPINTVL

    optional uint32 WorkersPerCompletionQueue = 104 [default = 1];
    optional uint32 HandlersPerCompletionQueue = 105 [default = 10];

    optional uint32 GRpcProxyCount = 106 [default = 2];
    optional bool EnableGRpcMemoryQuota = 107 [default = false];
    optional string EndpointId = 108;

    repeated TGRpcConfig ExtEndpoints = 200; // run specific services on separate endpoints

    // TXdsBootstrap is used to configure XDS (Envoy's discovery service) support for gRPC endpoints.
    // This enables dynamic service discovery, load balancing, and configuration via an XDS server.
    // Configure these fields when you want your gRPC endpoints to use XDS for advanced traffic management.
    // For more details, see: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/bootstrap/v3/bootstrap.proto
    // Format XDS bootstrap file: https://grpc.github.io/grpc/core/md_doc_grpc_xds_bootstrap_format.html
    message TXdsBootstrap {
        // TXdsServer describes an XDS server to connect to for configuration and service discovery.
        message TXdsServer {
            // TChannelCred specifies the credentials used to connect to the XDS server.
            message TChannelCred {
                optional string Type = 1; // Type of channel credentials (e.g., "insecure", "tls")
                optional string Config = 2; // String in JSON format containing config for the type
            }

            optional string ServerUri = 1; // URI of the XDS server (e.g., "xds.example.com:443")
            repeated TChannelCred ChannelCreds = 2; // Credentials for connecting to the XDS server
            repeated string ServerFeatures = 3; // List of supported XDS server features (e.g., "xds_v3")
        }

        // TNode describes the node identity and locality information sent to the XDS server.
        message TNode {
            // TLocality specifies the region, zone, and subzone of the node.
            message TLocality {
                optional string Region = 1;
                optional string Zone = 2;
                optional string SubZone = 3;
            }

            optional string Id = 1; // Unique node identifier (e.g., "node-123")
            optional string Cluster = 2; // Cluster name (e.g., "my-grpc-cluster")
            optional TLocality Locality = 3; // Locality information for the node
            optional string Meta = 4; // String in JSON format containing opaque metadata extending the node identifier. This field will be converted to 'metadata' in XDS bootstrap config
        }

        repeated TXdsServer XdsServers = 1; // List of XDS servers to connect to
        optional TNode Node = 2; // Node identity and locality information
    }
}

message TDynamicNodeConfig {
    optional string NodeBrokerAddress = 1; //DEPRECATED
    optional string DomainName = 2; //DEPRECATED
    optional uint32 InterconnectPort = 3; //DEPRECATED
    optional NKikimrNodeBroker.TNodeInfo NodeInfo = 4;
    optional string NodeAddress = 5; //DEPRECATED
    optional string NodeHost = 6; //DEPRECATED
    repeated NKikimrLocal.TTabletAvailability TabletAvailability = 7;
}

message THttpProxyConfig {
    optional bool Enabled = 1;
    optional uint32 Port = 2;
    optional bool Secure = 3;
    optional string CA = 4 [(Ydb.sensitive) = true];
    optional string Cert = 5 [(Ydb.sensitive) = true];
    optional string Key = 6 [(Ydb.sensitive) = true];

    repeated string YandexCloudServiceRegion = 7;
    optional string IamTokenServiceEndpoint = 8;
    optional string AccessServiceEndpoint = 9;

    optional string JwtFile = 10;

    optional bool YandexCloudMode = 11 [default = false];
    optional bool DataStreamsEnabled = 12 [default = true];
    optional bool YmqEnabled = 13 [default = false];
    optional bool SqsTopicEnabled = 14 [default = false];
}

message TS3ProxyResolverConfig {
    message THttpResolverConfig {
        // resolve proxy host to connect to that endpoint using this url
        optional string ResolveUrl = 1;
        // use resolved proxy through these ports
        optional uint32 HttpPort = 2;
        optional uint32 HttpsPort = 3;
    }

    message TEndpoint {
        // S3 endpoint
        optional string Endpoint = 1;
        oneof Resolver {
            THttpResolverConfig HttpResolver = 2;
        }
    }

    repeated TEndpoint Endpoints = 1;
}

message TSqsConfig {
    optional bool EnableSqs = 5;
    optional string Root = 1 [default = "/Root/SQS"];
    // optional uint32 HttpPort = 2 [default = 8771]; // moved to HttpServerConfig

    // URL that must be specified as an entry point to SQS cluster.
    // It must be used if SQS nodes are placed behind the balancer.
    // If this field is not specified, every node uses its own
    // fqdn here.
    optional string Endpoint = 3;

    optional THttpServerConfig HttpServerConfig = 4;

    // Turn on queue leaders option
    optional bool EnableQueueMaster = 6 [default = true]; // TODO: remove
    optional bool EnableQueueLeader = 68 [default = true];

    // Time to live for queue attributes cache
    optional uint64 QueueAttributesCacheTimeMs = 8 [default = 60000];

    // Effective query execution time that is treated as slow query
    optional uint64 SlowRequestTimeMs = 9 [default = 2500];

    // Max time value for long polling (param WaitTimeSeconds for ReceiveMessage)
    optional uint64 MaxWaitTimeoutMs = 10 [default = 20000];

    optional uint32 SchemeCacheSoftRefreshTimeSeconds = 11 [default = 5];
    optional uint32 SchemeCacheHardRefreshTimeSeconds = 12 [default = 10];

    optional bool ForceAccessControl = 13 [default = false];
    repeated string AccountsWithoutMandatoryAuth = 14;

    optional bool YandexCloudMode = 15 [default = false];
    optional uint32 YandexCloudServiceId = 16; // only 15 lesser bits should be used!
    optional string YandexCloudAccessServiceAddress = 29; // host:port
    optional string YandexCloudFolderServiceAddress = 30; // host:port
    optional string YandexCloudResourceManagerServiceAddress = 72; // host:port
    optional string YandexCloudServiceRegion = 39 [default = "ru-central1"];

    optional uint32 MeteringFlushingIntervalMs = 51 [default = 5000];
    optional string MeteringLogFilePath = 52;

    repeated string MeteringCloudNetCidr = 53;
    repeated string MeteringYandexNetCidr = 54;

    // TODO: remove both
    optional uint32 MastersDescriberUpdateTimeMs = 17 [default = 10000];
    optional uint32 MasterConnectTimeoutMs = 18 [default = 10000];

    optional uint32 LeadersDescriberUpdateTimeMs = 69 [default = 10000];
    optional uint32 LeaderConnectTimeoutMs = 70 [default = 10000];

    optional uint64 MinMessageRetentionPeriodMs = 19 [default = 60000];

    // DB requests retries
    optional uint64 TransactionTimeoutMs = 20 [default = 20000]; // If this amount of time elapsed, we don't retry
    optional uint64 TransactionRetryWaitDurationMs = 21 [default = 500]; // First wait time before next retry (+ random component). Then - 2 * TransactionRetryWaitDurationMs and etc
    optional uint64 TransactionMaxRetryWaitDurationMs = 22 [default = 2500]; // Max wait before next retry

    optional uint64 BackgroundMetricsUpdateTimeMs = 23 [default = 10000];

    optional uint64 MaxNumberOfReceiveMessages = 24 [default = 10]; // MaxNumberOfMessages parameter in ReceiveMessage

    optional uint64 RequestTimeoutMs = 25 [default = 600000];

    optional bool ForceQueueCreationV2 = 26 [default = true]; // deprecated, TODO: remove from config
    optional bool ForceQueueDeletionV2 = 27 [default = true]; // deprecated, TODO: remove from config
    optional bool EnableDeadLetterQueues = 41 [default = false];

    optional bool CreateLegacyDurationCounters = 28;

    optional uint64 MinTimeLeftForReceiveMessageWaitMs = 31 [default = 64]; // if wait deadline - now is less than this time, we don't wait in receive message

    optional bool CheckAllShardsInReceiveMessage = 32; // Check all shards in receive message event if deadline is expired now (setting for test)

    optional uint64 CleanupPeriodMs = 33 [default = 150000];
    optional uint64 CleanupBatchSize = 34 [default = 1000]; // Batch size for cleanup queries // Don't set big values

    optional uint64 DeduplicationPeriodMs = 35 [default = 300000]; // Period of time for which deduplication in fifo queues acts
    optional uint64 GroupsReadAttemptIdsPeriodMs = 36 [default = 300000]; // Period of time for which group read attempt ids in fifo queues act
    optional uint64 GroupSelectionBatchSize = 38 [default = 1000];

    optional bool DoAutomaticMigration = 37 [default = true]; // Check and add new columns to queue tables during queue master start

    optional uint64 AddMesagesToInflyBatchSize = 40 [default = 2000];

    message TBatchingPolicy {
        // Optimal parameters: SQS-479
        optional uint64 BatchSize = 1 [default = 200];
        optional uint64 TransactionsMaxInflyPerShard = 2 [default = 20];
    }

    optional TBatchingPolicy StdQueueSendBatchingPolicy = 42;
    optional TBatchingPolicy FifoQueueSendBatchingPolicy = 43;
    optional TBatchingPolicy StdQueueDeleteBatchingPolicy = 44;
    optional TBatchingPolicy FifoQueueDeleteBatchingPolicy = 45;
    optional TBatchingPolicy StdQueueLoadBatchingPolicy = 46;

    message TQuotingConfig {
        // Settings for quoting.
        optional bool EnableQuoting = 1;
        optional uint64 QuotaDeadlineMs = 2;

        message TDefaultActionsRates {
            // Per queue
            optional uint32 StdSendMessageRate = 1; // send message (+batch)
            optional uint32 StdReceiveMessageRate = 2; // receive message
            optional uint32 StdDeleteMessageRate = 3; // delete message (+batch)
            optional uint32 StdChangeMessageVisibilityRate = 4; // change message visibility (+batch)

            optional uint32 FifoSendMessageRate = 5; // send message (+batch)
            optional uint32 FifoReceiveMessageRate = 6; // receive message
            optional uint32 FifoDeleteMessageRate = 7; // delete message (+batch)
            optional uint32 FifoChangeMessageVisibilityRate = 8; // change message visibility (+batch)

            // Per user
            optional uint32 CreateObjectsRate = 9; // create queue, create user
            optional uint32 DeleteObjectsRate = 10; // delete queue, delete user

            optional uint32 OtherRequestsRate = 11; // control requests: get/set queue attributes, list queues, permissions modification, etc
        }

        message TLocalRateLimiterConfig {
            optional TDefaultActionsRates Rates = 1;
        }

        message TKesusQuoterConfig {
            // Not implemented
            optional TDefaultActionsRates DefaultLimits = 1;
        }

        // Only one of quoter configs could be set
        optional TLocalRateLimiterConfig LocalRateLimiterConfig = 3;
        optional TKesusQuoterConfig KesusQuoterConfig = 4;
    }

    optional TQuotingConfig QuotingConfig = 47;
    optional bool EnableQueueAttributesValidation = 48 [default = true];

    message TAccountSettingsDefaults {
        optional int64 MaxQueuesCount = 1 [default = 50];
    }

    optional TAccountSettingsDefaults AccountSettingsDefaults = 49;

    optional bool AllowYandexAttributePrefix = 50;

    optional uint64 QueueCountersExportDelayMs = 55; // Export queue counters after queue creation with delay (milliseconds).
    optional bool CreateLazyCounters = 56 [default = true];

    optional uint64 UserSettingsUpdateTimeMs = 57 [default = 60000];
    optional uint64 UserSettingsReadBatchSize = 58 [default = 1000];
    optional uint64 QueuesListReadBatchSize = 59 [default = 1000];

    optional bool ValidateMessageBody = 60;

    optional uint64 DlqNotificationGracePeriodMs = 61 [default = 60000];

    optional uint64 AddMessagesToInflyCheckPeriodMs = 62 [default = 30000];
    optional uint64 AddMessagesToInflyMinCheckAttempts = 63 [default = 10];

    optional uint64 MinimumGarbageAgeSeconds = 64 [default = 3600];

    optional bool MeteringByNetClassifierOnly = 65 [default = false];

    message TYcSearchEventsConfig {
        optional bool EnableYcSearch = 1 [default = false];
        oneof OutputMethod {
            string UnifiedAgentUri = 10;
            string OutputFileName = 11;
        }
        optional uint64 RescanIntervalSeconds = 3 [default = 60];
        optional uint64 ReindexIntervalSeconds = 4 [default = 14400];
        optional bool TenantMode = 5 [default = false];
    }
    message TOauthTokenConfig {
        required string TokenFile = 1;
    }

    message TJwtConfig {
        required string JwtFile = 1;
        optional string IamEndpoint = 2;
    }

    message TYdbAuthConfig {
        oneof LocalAuthConfig {
            TOauthTokenConfig OauthToken = 1;
            TJwtConfig Jwt = 2;
        }
    }

    message TCloudEventsConfig {
        optional bool EnableCloudEvents = 1 [default = false];
        optional bool TenantMode = 2 [default = false];
        optional uint64 RetryTimeoutSeconds = 3;
        optional string UnifiedAgentUri = 4;
    }

    optional TYcSearchEventsConfig YcSearchEventsConfig = 66;
    optional TYdbAuthConfig AuthConfig = 67;
    optional uint64 StartLocalLeaderInflightMax = 71 [default = 500];
    optional TCloudEventsConfig CloudEventsConfig = 73;
}

message TConfigsDispatcherConfig {
}

message TCompactionPolicy {
    optional string Name = 1;
    optional NKikimrCompaction.TCompactionPolicy CompactionPolicy = 2;
}

message TExecutionPolicy {
    optional string Name = 1;

    optional NKikimrSchemeOp.TPipelineConfig PipelineConfig = 2;
    optional string ResourceProfile = 3;
    optional bool EnableFilterByKey = 4 [default = false];
    optional bool ExecutorFastLogPolicy = 5 [default  = true];
    optional uint64 TxReadSizeLimit = 6;

    optional bool EnableEraseCache = 7;
    optional uint32 EraseCacheMinRows = 8;
    optional uint32 EraseCacheMaxBytes = 9;
}

message TPartitioningPolicy {
    optional string Name = 1;

    optional uint32 UniformPartitionsCount = 2;
    optional bool AutoSplit = 3;
    optional bool AutoMerge = 4;
    optional uint64 SizeToSplit = 5;
    optional uint64 MaxPartitionsCount = 6;
}

message TStoragePolicy {
    optional string Name = 1;
    repeated NKikimrSchemeOp.TFamilyDescription ColumnFamilies = 2;
}

message TReplicationPolicy {
    optional string Name = 1;

    optional uint64 FollowerCount = 2;
    optional bool AllowFollowerPromotion = 3 [default = true];
    optional bool CrossDataCenter = 4;
}

message TCachingPolicy {
    optional string Name = 1;

    optional uint64 ExecutorCacheSize = 2;
}

message TTableProfile {
    optional string Name = 1;
    optional string CompactionPolicy = 2;
    optional string ExecutionPolicy = 3;
    optional string PartitioningPolicy = 4;
    optional string StoragePolicy = 5;
    optional string ReplicationPolicy = 6;
    optional string CachingPolicy = 7;
}

message TTableProfilesConfig {
    repeated TTableProfile TableProfiles = 1;
    repeated TCompactionPolicy CompactionPolicies = 2;
    repeated TExecutionPolicy ExecutionPolicies = 3;
    repeated TPartitioningPolicy PartitioningPolicies = 4;
    repeated TStoragePolicy StoragePolicies = 5;
    repeated TReplicationPolicy ReplicationPolicies = 6;
    repeated TCachingPolicy CachingPolicies = 7;
}

message TFinalizeScriptServiceConfig {
    optional uint64 ScriptFinalizationTimeoutSeconds = 1 [default = 60];
    optional uint32 MaxInFlightFinalizationsCount = 2 [default = 10];
};

message TStreamingQueriesConfig {
    message TExternalStorageConfig {
        message TConnectionSettings {
            optional string Endpoint = 1;
            optional string Database = 2;
            optional string TokenFile = 3;
            optional string SaKeyFile = 4;
            optional bool UseLocalMetadataService = 5;
            optional bool UseSsl = 6;
            optional string CaCertFile = 7;
            optional string IamEndpoint = 8;
            optional string Login = 9;
            optional string PasswordFile = 10;
        }

        optional uint32 QueryTimeoutSec = 1;
        optional uint32 MaxActiveQuerySessions = 2;
        optional string PathPrefix = 3;
        optional TConnectionSettings DatabaseConnection = 4;
    }

    message TExternalTopicsSettings {
        optional string DiscoveryCommonHostnamePrefixPatch = 1; // Added to discovered hostnames if original hostname starts with this prefix
    }

    optional TExternalStorageConfig ExternalStorage = 1;
    optional TExternalTopicsSettings TopicSdkSettings = 2;
}

message TQueryServiceConfig {
    optional uint64 ScriptOperationTimeoutDefaultSeconds = 1 [default = 604800]; // default = 1 week
    optional uint64 ScriptForgetAfterDefaultSeconds = 2 [default = 31536000]; // default = 1 year; 0 = infinity
    optional uint64 ScriptResultsTtlDefaultSeconds = 3 [default = 2592000];  // default = 1 month; 0 = infinity
    optional uint64 ScriptResultSizeLimit = 4 [default = 0]; // 0 = infinity
    optional uint64 ScriptResultRowsLimit = 5 [default = 0]; // 0 = infinity
    repeated string HostnamePatterns = 13; // List of hostname regexps for external data sources; disabled if empty
    optional string QueryArtifactsCompressionMethod = 17;
    optional uint64 QueryArtifactsCompressionMinSize = 18 [default = 10485760]; // default = 10 MiB

    optional NYql.TS3GatewayConfig S3 = 6;
    optional NYql.TYtGatewayConfig Yt = 15;
    optional NYql.TSolomonGatewayConfig Solomon = 21;
    optional NYql.TFileStorageConfig FileStorage = 16;
    optional NYql.THttpGatewayConfig HttpGateway = 7;
    optional NYql.TGenericConnectorConfig Connector = 8 [deprecated=true];
    optional string MdbGateway = 9 [deprecated=true];
    optional bool MdbTransformHost = 10;
    optional NYql.TGenericGatewayConfig Generic = 11;
    optional TFinalizeScriptServiceConfig FinalizeScriptServiceConfig = 12;
    optional uint64 ProgressStatsPeriodMs = 14 [default = 0]; // 0 = disabled
    optional uint32 QueryTimeoutDefaultSeconds = 19 [default = 7200];
    optional bool EnableMatchRecognize = 20 [default = false];
    repeated string AvailableExternalDataSources = 22;                  // Ignored if AllExternalDataSourcesAreAvailable is true
    optional bool AllExternalDataSourcesAreAvailable = 23 [default = true];
    reserved 24;
    reserved 25;
    reserved 26;
    optional TStreamingQueriesConfig StreamingQueries = 27;
}

// Config describes immediate controls and allows
// to manage their values (not variety and limits)
// via CMS. All fields should be either [u]int64 or
// another message.
//
// Control names match field names. For embedded
// messages field names are concatenated via '.'
// symbol. E.g. "DataShardControls.MaxTxInFly".
//
// Min, max and default values are specified in
// field options.
message TImmediateControlOptions {
    optional string Description = 1;
    optional int64 MinValue = 2;
    optional uint64 MaxValue = 3;
    optional uint64 DefaultValue = 4;
}

extend google.protobuf.FieldOptions {
    optional TImmediateControlOptions ControlOptions = 61001;
}

message TImmediateControlsConfig {
    message TDataShardControls {
        message TExecutionProfileOptions {
            optional uint64 LogThresholdMs = 1 [(ControlOptions) = {
                Description: "Log execution profile for slow operations",
                MinValue: 0,
                MaxValue: 86400000,
                DefaultValue: 0 }];
            optional uint64 BufferThresholdMs = 2 [(ControlOptions) = {
                Description: "Store execution profile for slow operations",
                MinValue: 0,
                MaxValue: 86400000,
                DefaultValue: 0 }];
            optional uint64 BufferSize = 3 [(ControlOptions) = {
                Description: "Slow operation profiles buffer size",
                MinValue: 0,
                MaxValue: 1000,
                DefaultValue: 100 }];
        }

        optional uint64 MaxTxInFly = 1 [(ControlOptions) = {
            Description: "Maximum tx queue size for single shard",
            MinValue: 0,
            MaxValue: 100000,
            DefaultValue: 15000 }];
        optional uint64 DisableByKeyFilter = 2 [(ControlOptions) = {
            Description: "Disable bloom filter usage on row selects",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 MaxTxLagMilliseconds = 3 [(ControlOptions) = {
            Description: "Max lag in tx plan execution before shard becomes overloaded",
            MinValue: 0,
            MaxValue: 2592000000,
            DefaultValue: 300000 }];
        optional uint64 CanCancelROWithReadSets = 4 [(ControlOptions) = {
            Description: "Allow to cancel RO tx with output read sets by timeout",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional TExecutionProfileOptions DataTxProfile = 5;

        optional uint64 BackupReadAheadLo = 6 [(ControlOptions) = {
            Description: "Override for backup readahead (low watermark)",
            MinValue: 0,
            MaxValue: 67108864,
            DefaultValue: 0 }];
        optional uint64 BackupReadAheadHi = 7 [(ControlOptions) = {
            Description: "Override for backup readahead (high watermark)",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 0 }];

        // Note: these settings are deprecated (always enabled)
        optional uint64 PrioritizedMvccSnapshotReads = 8 [(ControlOptions) = {
            Description: "Enables prioritized mvcc snapshot reads over immediate writes (deprecated, always enabled)",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 UnprotectedMvccSnapshotReads = 9 [(ControlOptions) = {
            Description: "Enables unprotected (fully readonly) mvcc snapshot reads (deprecated, always enabled)",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];

        optional uint64 EnableLeaderLeases = 10 [(ControlOptions) = {
            Description: "Enables leader leases for processing read-only queries",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 MinLeaderLeaseDurationUs = 11 [(ControlOptions) = {
            Description: "The minimum leader lease duration in microseconds",
            MinValue: 1000,
            MaxValue: 5000000,
            DefaultValue: 250000 }];

        optional uint64 TtlReadAheadLo = 12 [(ControlOptions) = {
            Description: "Override for ttl readahead (low watermark)",
            MinValue: 0,
            MaxValue: 67108864,
            DefaultValue: 0 }];
        optional uint64 TtlReadAheadHi = 13 [(ControlOptions) = {
            Description: "Override for ttl readahead (high watermark)",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 0 }];

        optional uint64 EnableLockedWrites = 14 [(ControlOptions) = {
            Description: "Enables experimental persistent locked writes",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 MaxLockedWritesPerKey = 15 [(ControlOptions) = {
            Description: "Maximum number of uncommitted locked writes per key",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 1000 }];

        optional uint64 ChangeRecordDebugPrint = 16 [(ControlOptions) = {
            Description: "Enables debug printing of change records",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];

        optional uint64 IncrementalRestoreReadAheadLo = 17 [(ControlOptions) = {
            Description: "Override for incremental restore readahead (low watermark)",
            MinValue: 0,
            MaxValue: 67108864,
            DefaultValue: 0 }];
        optional uint64 IncrementalRestoreReadAheadHi = 18 [(ControlOptions) = {
            Description: "Override for incremental restore readahead (high watermark)",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 0 }];

        optional uint64 CdcInitialScanReadAheadLo = 19 [(ControlOptions) = {
            Description: "Override for CDC initial scan readahead (low watermark)",
            MinValue: 0,
            MaxValue: 67108864,
            DefaultValue: 0 }];
        optional uint64 CdcInitialScanReadAheadHi = 20 [(ControlOptions) = {
            Description: "Override for CDC initial scan readahead (high watermark)",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 0 }];

        optional uint64 ReadIteratorKeysExtBlobsPrecharge = 21 [(ControlOptions) = {
          Description: "Enable external blobs precharge for DataShard read iterator keys requests",
          MinValue: 0,
          MaxValue: 1,
          DefaultValue: 0 }];

        optional int64 CpuUsageReportThresholdPercent = 22 [(ControlOptions) = {
          Description: "Cpu usage threshold about high datashard load",
          MinValue: -1,
          MaxValue: 146,
          DefaultValue: 60 }];
        optional uint64 CpuUsageReportIntervalSeconds = 23 [(ControlOptions) = {
          Description: "Cpu usage report interval in seconds about high datashard load",
          MinValue: 0,
          MaxValue: 31536000, // 365 * 86400
          DefaultValue: 60 }];
        optional int64 HighDataSizeReportThresholdBytes = 24 [(ControlOptions) = {
          Description: "Data size threshold about high data shard load",
          MinValue: -1,
          MaxValue: 9223372036854775807, // 2 ** 63 - 1
          DefaultValue: 10737418240 }]; // 10 << 30
        optional uint64 HighDataSizeReportIntervalSeconds = 25 [(ControlOptions) = {
          Description: "Data size report interval about high data shard load",
          MinValue: 0,
          MaxValue: 31536000, // 365 * 86400
          DefaultValue: 60 }];
    }

    message TTxLimitControls {
        optional uint64 PerRequestDataSizeLimit = 1 [(ControlOptions) = {
            Description: "Maximum read data size per transaction",
            MinValue: 0,
            MaxValue: 256000000000000,
            DefaultValue: 53687091200 }];
        optional uint64 PerShardReadSizeLimit = 2 [(ControlOptions) = {
            Description: "Maximum read data size per transaction per shard",
            MinValue: 0,
            MaxValue: 107374182400,
            DefaultValue: 5368709120 }];
        optional uint64 PerShardIncomingReadSetSizeLimit = 3 [(ControlOptions) = {
            Description: "Maximum input read sets size per transaction per shard",
            MinValue: 0,
            MaxValue: 5368709120,
            DefaultValue: 209715200 }];
        optional uint64 DefaultTimeoutMs = 4 [(ControlOptions) = {
            Description: "Default execution timeout for transactions",
            MinValue: 0,
            MaxValue: 3600000,
            DefaultValue: 60000 }];
        optional uint64 MaxShardCount = 5 [(ControlOptions) = {
            Description: "Maximum number of shards  in transaction",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 10000}];
        optional uint64 MaxReadSetCount = 6 [(ControlOptions) = {
            Description: "Maximum number of readsets in transaction",
            MinValue: 0,
            MaxValue: 10000000,
            DefaultValue: 100000}];
    }

    message TCoordinatorControls {
        optional uint64 EnableLeaderLeases = 1 [(ControlOptions) = {
            Description: "Enables leader leases for processing read-only queries",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 MinLeaderLeaseDurationUs = 2 [(ControlOptions) = {
            Description: "The minimum leader lease duration in microseconds",
            MinValue: 1000,
            MaxValue: 5000000,
            DefaultValue: 250000 }];
        optional uint64 VolatilePlanLeaseMs = 3 [(ControlOptions) = {
            Description: "Lease in milliseconds for faster volatile transaction planning",
            MinValue: 0,
            MaxValue: 10000,
            DefaultValue: 250 }];
        optional uint64 PlanAheadTimeShiftMs = 4 [(ControlOptions) = {
            Description: "Wall-clock time shift in milliseconds when planning ahead (50ms for compatibility with older versions)",
            MinValue: 0,
            MaxValue: 86400000,
            DefaultValue: 50 }];
        optional uint64 MinPlanResolutionMs = 5 [(ControlOptions) = {
            Description: "Minimum plan resolution override in milliseconds, which includes volatile planning (0 when not overridden)",
            MinValue: 0,
            MaxValue: 1000,
            DefaultValue: 0 }];
    }

    message TSchemeShardControls {
        optional uint64 ForceShardSplitDataSize = 1 [(ControlOptions) = {
            Description: "Forces shards to split when reaching the given data size (2 GiB by default)",
            MinValue: 10485760, // 10 MiB
            MaxValue: 17179869184, // 16 GiB
            DefaultValue: 2147483648 }]; // 2GiB
        optional uint64 DisableForceShardSplit = 2 [(ControlOptions) = {
            Description: "Disables forced shard splits, for special cases only",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 AllowDataColumnForIndexTable = 3 [(ControlOptions) = {
            Description: "Allow data column for index table",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 AllowConditionalEraseOperations = 4 [(ControlOptions) = {
            Description: "Allows conditional erase",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 AllowServerlessStorageBilling = 5 [(ControlOptions) = {
            Description: "Allows serverless storage billing",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 DisablePublicationsOfDropping = 6 [(ControlOptions) = {
            Description: "Disable publications of dropping",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 FillAllocatePQ = 7 [(ControlOptions) = {
            Description: "Fill allocate persqueue",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional int64 SplitMergePartCountLimit = 8 [(ControlOptions) = {
            Description: "Max count of SplitMerge actions for part",
            MinValue: -1,
            MaxValue: 1000000,
            DefaultValue: 2000 }];
        optional uint64 FastSplitSizeThreshold = 9 [(ControlOptions) = {
            Description: "FastSplitSize Threshold",
            MinValue: 100000,
            MaxValue: 411000000000,
            DefaultValue: 4000000 }];
        optional uint64 FastSplitRowCountThreshold = 10 [(ControlOptions) = {
            Description: "Disable publications of dropping",
            MinValue: 1000,
            MaxValue: 111000000000,
            DefaultValue: 100000 }];
        optional uint64 FastSplitCpuPercentageThreshold = 11 [(ControlOptions) = {
            Description: "Max Fast split cpu usage",
            MinValue: 1,
            MaxValue: 146,
            DefaultValue: 50 }];
        optional uint64 SplitByLoadEnabled = 12 [(ControlOptions) = {
            Description: "Enables split by load",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 SplitByLoadMaxShardsDefault = 13 [(ControlOptions) = {
            Description: "Max shards that cant be split by load",
            MinValue: 0,
            MaxValue: 10000,
            DefaultValue: 50 }];
        optional uint64 MergeByLoadMinUptimeSec = 14 [(ControlOptions) = {
            Description: "Min uptime to merge by load in seconds",
            MinValue: 0,
            MaxValue: 411000000000,
            DefaultValue: 600 }];
        optional uint64 MergeByLoadMinLowLoadDurationSec = 15 [(ControlOptions) = {
            Description: "Min low load duration in sec to merge by load",
            MinValue: 0,
            MaxValue: 411000000000,
            DefaultValue: 3600 }];
    }

    message TTCMallocControls {
        optional uint64 ProfileSamplingRate = 1 [(ControlOptions) = {
            Description: "Sets the sampling rate for heap profiles. TCMalloc samples approximately every rate bytes allocated.",
            MinValue: 65536,
            MaxValue: 4294967296,
            DefaultValue: 2097152 }];
        optional uint64 GuardedSamplingRate = 2 [(ControlOptions) = {
            Description: "Sets the guarded sampling rate for sampled allocations. TCMalloc samples approximately every rate bytes allocated, subject to implementation limitations in GWP-ASan.",
            MinValue: 65536,
            MaxValue: 4294967296,
            DefaultValue: 4294967296 }];

        reserved 3; // was MemoryLimit

        optional uint64 PageCacheTargetSize = 4 [(ControlOptions) = {
            Description: "Page Cache Target Size.",
            MinValue: 0,
            MaxValue: 137438953472,
            DefaultValue: 536870912 }];
        optional uint64 PageCacheReleaseRate = 5 [(ControlOptions) = {
            Description: "Page Cache Release Rate.",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 8388608 }];
    }

    message TVDiskControls {
        optional uint64 EnableLocalSyncLogDataCutting = 1 [(ControlOptions) = {
            Description: "Allow cutting large TEvLocalSyncLogData messages into smaller chunks",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 EnableSyncLogChunkCompressionHDD = 2 [(ControlOptions) = {
            Description: "Compress SyncLog chunks before writing to log, setting for HDD",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 EnableSyncLogChunkCompressionSSD = 3 [(ControlOptions) = {
            Description: "Compress SyncLog chunks before writing to log, setting for SSD",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 MaxSyncLogChunksInFlightHDD = 4 [(ControlOptions) = {
            Description: "Maximum number of SyncLog chunks written simultaneously to log, setting for HDD",
            MinValue: 1,
            MaxValue: 1024,
            DefaultValue: 10 }];
        optional uint64 MaxSyncLogChunksInFlightSSD = 5 [(ControlOptions) = {
            Description: "Maximum number of SyncLog chunks written simultaneously to log, setting for SSD",
            MinValue: 1,
            MaxValue: 1024,
            DefaultValue: 10 }];

        optional uint64 BurstThresholdNsHDD = 6 [(ControlOptions) = {
            Description: "Minumum operation queue size that is considered a burst, setting for HDD",
            MinValue: 1,
            MaxValue: 1000000000000,
            DefaultValue: 200000000 }];
        optional uint64 BurstThresholdNsSSD = 7 [(ControlOptions) = {
            Description: "Minumum operation queue size that is considered a burst, setting for SSD",
            MinValue: 1,
            MaxValue: 1000000000000,
            DefaultValue: 50000000 }];
        optional uint64 BurstThresholdNsNVME = 8 [(ControlOptions) = {
            Description: "Minumum operation queue size that is considered a burst, setting for NVME",
            MinValue: 1,
            MaxValue: 1000000000000,
            DefaultValue: 32000000 }];
        optional uint64 DiskTimeAvailableScaleHDD = 9 [(ControlOptions) = {
            Description: "Scale coefficient DiskTimeAvailableScale metric, this parameter will be converted to float and divided by 1'000, setting for HDD",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
        optional uint64 DiskTimeAvailableScaleSSD = 10 [(ControlOptions) = {
            Description: "Scale coefficient for DiskTimeAvailableScale metric, this parameter will be converted to float and divided by 1'000, setting for SSD",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
        optional uint64 DiskTimeAvailableScaleNVME = 11 [(ControlOptions) = {
            Description: "Scale coefficient DiskTimeAvailableScale metric, this parameter will be converted to float and divided by 1'000, setting for NVME",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
        optional uint64 DefaultHugeGarbagePerMille = 12 [(ControlOptions) = {
            Description: "Default threshold of huge chunk garbage per mille which triggers huge chunk defragmentation",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 300 }];
        optional uint64 HugeDefragFreeSpaceBorderPerMille = 13 [(ControlOptions) = {
            Description: "Huge garbage threshold = DefaultHugeGarbagePerMille * min((free space share) / (this param), 1)",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 260 }];
        optional uint64 MaxChunksToDefragInflight = 21 [(ControlOptions) = {
            Description: "Max inflight defragmentation chunks per one chunk size per vdisk",
            MinValue: 1,
            MaxValue: 50,
            DefaultValue: 10 }];
        optional uint64 GarbageThresholdToRunFullCompactionPerMille = 36 [(ControlOptions) = {
            Description: "Maximal allowed fraction from vdisk fare share of garbage before compaction would be triggered. If value = 0 - compaction would run after every defragmentation quantum",
            MinValue: 0,
            MaxValue: 300,
            DefaultValue: 0 }];

        reserved 14;
        optional uint64 ThrottlingDryRun = 26 [(ControlOptions) = {
            Description: "0 - working mode, 1 - dry run mode",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 ThrottlingMinLevel0SstCount = 15 [(ControlOptions) = {
            Description: "Minimum level 0 SST count - throttling is turned on",
            MinValue: 1,
            MaxValue: 100000,
            DefaultValue: 100 }];
        optional uint64 ThrottlingMaxLevel0SstCount = 16 [(ControlOptions) = {
            Description: "Maximum level 0 SST count - throttling speed is zero",
            MinValue: 1,
            MaxValue: 100000,
            DefaultValue: 250 }];
        optional uint64 ThrottlingMinInplacedSizeHDD = 17 [(ControlOptions) = {
            Description: "Minimum size of all inplaced blobs (HDD) - throttling is turned on",
            MinValue: 1048576,
            MaxValue: 549755813888000,
            DefaultValue: 21474836480 }];
        optional uint64 ThrottlingMaxInplacedSizeHDD = 18 [(ControlOptions) = {
            Description: "Maximum size of all inplaced blobs (HDD) - throttling speed is zero",
            MinValue: 1048576,
            MaxValue: 549755813888000,
            DefaultValue: 64424509440 }];
        optional uint64 ThrottlingMinInplacedSizeSSD = 24 [(ControlOptions) = {
            Description: "Minimum size of all inplaced blobs (SSD) - throttling is turned on",
            MinValue: 1048576,
            MaxValue: 549755813888000,
            DefaultValue: 21474836480 }];
        optional uint64 ThrottlingMaxInplacedSizeSSD = 25 [(ControlOptions) = {
            Description: "Maximum size of all inplaced blobs (SSD) - throttling speed is zero",
            MinValue: 1048576,
            MaxValue: 549755813888000,
            DefaultValue: 64424509440 }];
        optional uint64 ThrottlingMinOccupancyPerMille = 19 [(ControlOptions) = {
            Description: "Minimum occupancy of disk per mille - throttling is turned on",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 900 }];
        optional uint64 ThrottlingMaxOccupancyPerMille = 20 [(ControlOptions) = {
            Description: "Maximum occupancy of disk per mille - throttling speed is zero",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 950 }];
        optional uint64 ThrottlingMinLogChunkCount = 22 [(ControlOptions) = {
            Description: "Minimum pdisk log chunk count - throttling is turned on",
            MinValue: 1,
            MaxValue: 100000,
            DefaultValue: 100 }];
        optional uint64 ThrottlingMaxLogChunkCount = 23 [(ControlOptions) = {
            Description: "Maximum pdisk log chunk count - throttling speed is zero",
            MinValue: 1,
            MaxValue: 100000,
            DefaultValue: 130 }];

        optional uint64 MaxInProgressSyncCount = 27 [(ControlOptions) = {
            Description: "Maximum number of simultaneous VDisk sync processes; 0 means no limit",
            MinValue: 0,
            MaxValue: 1000,
            DefaultValue: 0 }];

        reserved 28;

        optional uint64 FreshCompMaxInFlightWrites = 29 [(ControlOptions) = {
            Description: "Max writes inflight for fresh level compaction",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 10 }];

        optional uint64 FreshCompMaxInFlightReads = 30 [(ControlOptions) = {
            Description: "Max reads inflight for fresh level compaction",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 10 }];

        optional uint64 HullCompMaxInFlightWrites = 31 [(ControlOptions) = {
            Description: "Max writes inflight for level compaction",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 10 }];

        optional uint64 HullCompMaxInFlightReads = 32 [(ControlOptions) = {
            Description: "Max reads inflight for level compaction",
            MinValue: 1,
            MaxValue: 1000,
            DefaultValue: 20 }];

        optional uint64 EnableDeepScrubbing = 33 [(ControlOptions) = {
            Description: "Run CheckIntegrity requests during Scrub process instead of usual scrubbing",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];

        optional uint64 HullCompFullCompPeriodSec = 34 [(ControlOptions) = {
            Description: "Full compaction will start no more than once during this interval",
            MinValue: 0,
            MaxValue: 604800, // 1 week
            DefaultValue: 0 }];

        optional uint64 HullCompThrottlerBytesRate = 35 [(ControlOptions) = {
            Description: "Rate bytes in 1 second for requests (sum of write and read) in compaction throttler",
            MinValue: 0,
            MaxValue: 10000000000, // 10 GB/s
            DefaultValue: 0 }];

        optional uint64 DefragThrottlerBytesRate = 37 [(ControlOptions) = {
            Description: "Rate bytes in 1 second for requests (sum of write and read) in defragmentation throttler",
            MinValue: 0,
            MaxValue: 10000000000, // 10 GB/s
            DefaultValue: 0 }];

        optional uint64 EnablePhantomFlagStorage = 38 [(ControlOptions) = {
            Description: "Enable new FullSync protocol which allows to send PhantomFlags",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0,
        }];

        optional uint64 PhantomFlagStorageLimitPerVDiskBytes = 39 [(ControlOptions) = {
            Description: "Maximum size in bytes of in-memory structures of PhantomFlagStorage per VDisk",
            MinValue: 0,
            MaxValue: 100000000000, // 100 GB
            DefaultValue: 10000000, // 10 MB
        }];
    }

    message TTabletControls {
        optional uint64 MaxCommitRedoMB = 1 [(ControlOptions) = {
            Description: "Maximum redo size per commit in megabytes",
            MinValue: 8,
            MaxValue: 4096,
            DefaultValue: 256 }];

        optional uint64 MaxTxInFly = 2 [(ControlOptions) = {
            Description: "Maximum tx queue size for all tablets",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 10000 }];
    }

    message TDSProxyControls {
        message TRequestReportingSettings {
            optional uint64 BucketSize = 1 [(ControlOptions) = {
                Description: "Capacity for Leaky Bucket algorithm",
                MinValue: 1,
                MaxValue: 100000,
                DefaultValue: 1 }];
            optional uint64 LeakDurationMs = 2 [(ControlOptions) = {
                Description: "Leak interval (ms) for Leaky Bucket algorithm",
                MinValue: 1,
                MaxValue: 3600000,
                DefaultValue: 60000 }];
            optional uint64 LeakRate = 3 [(ControlOptions) = {
                Description: "Leak size for Leaky Bucket algorithm",
                MinValue: 1,
                MaxValue: 100000,
                DefaultValue: 1 }];
        }

        optional uint64 SlowDiskThreshold = 1 [(ControlOptions) = {
            Description: "The minimum ratio of slowest and second slowest disks, required to accelerate, promille",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 2000 }];
        optional uint64 PredictedDelayMultiplier = 2 [(ControlOptions) = {
            Description: "Predicted time of VDisk's response multiplier, promille",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
        optional uint64 LongRequestThresholdMs = 3 [(ControlOptions) = {
            Description: "The amount of time (ms) to process DSProxy request, beyond which request is considered long and being reported to log",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 50000 }];
        reserved 4;
        optional uint64 MaxNumOfSlowDisks = 5 [(ControlOptions) = {
            Description: "Maximum number of slow disks, which DSProxy can skip with Accelerations",
            MinValue: 1,
            MaxValue: 2,
            DefaultValue: 2 }];

        optional uint64 SlowDiskThresholdHDD = 6 [(ControlOptions) = {
            Description: "The minimum ratio of slowest and second slowest disks, required to accelerate, promille, option for HDD",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 2000 }];
        optional uint64 PredictedDelayMultiplierHDD = 7 [(ControlOptions) = {
            Description: "Predicted time of VDisk's response multiplier, promille, option for HDD",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
        optional uint64 MaxNumOfSlowDisksHDD = 8 [(ControlOptions) = {
            Description: "Maximum number of slow disks, which DSProxy can skip with Accelerations, option for HDD",
            MinValue: 1,
            MaxValue: 2,
            DefaultValue: 1 }];

        optional uint64 SlowDiskThresholdSSD = 9 [(ControlOptions) = {
            Description: "The minimum ratio of slowest and second slowest disks, required to accelerate, promille, option for SSD",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 2000 }];
        optional uint64 PredictedDelayMultiplierSSD = 10 [(ControlOptions) = {
            Description: "Predicted time of VDisk's response multiplier, promille, option for SSD",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
        optional uint64 MaxNumOfSlowDisksSSD = 11 [(ControlOptions) = {
            Description: "Maximum number of slow disks, which DSProxy can skip with Accelerations, option for SSD",
            MinValue: 1,
            MaxValue: 2,
            DefaultValue: 2 }];

        optional TRequestReportingSettings RequestReportingSettings = 12;

        optional uint64 MaxPutTimeoutSeconds = 13 [(ControlOptions) = {
            Description: "Maximum amount of time TEvPut request can work until it is terminated with DEADLINE status by DSProxy",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 60 }]; // 1 minute
    }

    message TPDiskControls {
        optional uint64 MaxCommonLogChunksHDD = 1 [(ControlOptions) = {
            Description: "Regulate the maximum of log chunks on the PDisk, setting for HDD",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 200 }];
        optional uint64 MaxCommonLogChunksSSD = 2 [(ControlOptions) = {
            Description: "Regulate the maximum of log chunks on the PDisk, setting for SSD, NVME",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 200 }];
        optional uint64 UseNoopSchedulerHDD = 3 [(ControlOptions) = {
            Description: "Enables noop scheduler for HDD disks only",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 UseNoopSchedulerSSD = 4 [(ControlOptions) = {
            Description: "Enables noop scheduler for SSD, NVME",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 SemiStrictSpaceIsolation = 5 [(ControlOptions) = {
            Description: "If not 0, override PDiskConfig.SpaceColorBorder: 1 - LightYellowMove, 2 - YellowStop",
            MinValue: 0,
            MaxValue: 2,
            DefaultValue: 0 }];
        optional uint64 CommonStaticLogChunks = 6 [(ControlOptions) = {
            Description: "Special reserve of log chunks on the PDisk with static groups",
            MinValue: 1,
            MaxValue: 1000000,
            DefaultValue: 70 }];
    }

    message TBlobStorageControllerControls {
        optional uint64 EnableSelfHealWithDegraded = 1 [(ControlOptions) = {
            Description: "Should SelfHeal automatically process groups that are in DEGRADED status (one step from nonworking)",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
    }

    message TTableServiceControls {
        optional uint64 EnableMergeDatashardReads = 1 [(ControlOptions) = {
            Description: "Merge reading tasks on the same node",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
    }

    message TTestShardControls {
        optional uint64 DisableWrites = 1 [(ControlOptions) = {
            Description: "Disable write load in all node TestShard tablets",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0
        }];
    }

    message TGRpcControls {
        message TRequestConfig {
            optional uint64 MaxInFlight = 1 [(ControlOptions) = {
                Description: "Max in flight requests",
                MinValue: 0,
                MaxValue: 1000000,
                DefaultValue: 0
            }];
        }
        map<string, TRequestConfig> RequestConfigs = 1;
    }

    message TKeyValueVolumeControls {
        optional uint64 ReadRequestsInFlightLimit = 1 [(ControlOptions) = {
            Description: "Maximum number of simultaneous read requests",
            MinValue: 1,
            MaxValue: 4096,
            DefaultValue: 3
        }];
    }

    message TKQPSessionControls {
        optional uint64 MkqlInitialMemoryLimit = 1 [(ControlOptions) = {
            Description: "Initial memory limit for mkql queries",
            MinValue: 1,
            MaxValue: 9223372036854775807, // 2 ** 63 -1
            DefaultValue: 2097152 // 2 MiB
        }];
        optional uint64 MkqlMaxMemoryLimit = 2 [(ControlOptions) = {
            Description: "Max memory limit for mkql queries",
            MinValue: 1,
            MaxValue: 9223372036854775807, // 2 ** 63 -1
            DefaultValue: 1073741824 // 1 GiB
        }];
    }

    message TColumnShardControls {
        optional uint64 BlobWriteGrouppingEnabled = 1 [(ControlOptions) = {
            Description: "Enables blobs groupping on write",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1
        }];

        optional uint64 CacheDataAfterIndexing = 2 [(ControlOptions) = {
            Description: "Enables data caching after indexing",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1
        }];
        optional uint64 CacheDataAfterCompaction = 3 [(ControlOptions) = {
            Description: "Enables data caching after compaction",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1
        }];
        optional uint64 MinBytesToIndex = 4 [(ControlOptions) = {
            Description: "Min bytes to start indexing",
            MinValue: 1,
            MaxValue: 33554432, // 32MiB
            DefaultValue: 4194304 // 4 MiB
        }];
        optional uint64 MaxBytesToIndex = 5 [(ControlOptions) = {
            Description: "Min bytes to start indexing",
            MinValue: 0,
            MaxValue: 503316480, // 480MiB
            DefaultValue: 251658240 // 240 MiB
        }];
        optional uint64 InsertTableCommittedSize = 6 [(ControlOptions) = {
            Description: "Min small blobs to insert",
            MinValue: 0,
            MaxValue: 200,
            DefaultValue: 1000
        }];
        optional uint64 IndexGoodBlobSize = 7 [(ControlOptions) = {
            Description: "Blob size to index",
            MinValue: 262144, // 256KiB
            MaxValue: 8388608, // 8MiB
            DefaultValue: 262144 // 256KiB
        }];
        optional uint64 GranuleOverloadBytes = 8 [(ControlOptions) = {
            Description: "Min blob size to overload",
            MinValue: 8388608, // 8MiB
            MaxValue: 838860800, // 800MiB
            DefaultValue: 167772160 // 160MiB
        }];
        optional uint64 CompactionDelaySec = 9 [(ControlOptions) = {
            Description: "Compaction delay in seconds",
            MinValue: 10,
            MaxValue: 120,
            DefaultValue: 3600
        }];
        optional uint64 GranuleIndexedPortionsSizeLimit = 10 [(ControlOptions) = {
            Description: "Max indexed bytes in granule",
            MinValue: 0,
            MaxValue: 9223372036854775807, // 2 ** 63 - 1
            DefaultValue: 20971520 // 20 MiB
        }];
        optional uint64 GranuleIndexedPortionsCountLimit = 11 [(ControlOptions) = {
            Description: "Max number of Indexed portions in Granule",
            MinValue: 0,
            MaxValue: 9223372036854775807, // 2 ** 63 - 1
            DefaultValue: 100
        }];
    }

    message TGroupMapperControls {
        optional uint64 GroupSizeInUnitsLargerThanPDiskPenalty = 1 [(ControlOptions) = {
            Description: "Group size in units larger than pdisk penalty",
            MinValue: -1000,
            MaxValue: 1000,
            DefaultValue: 10
        }];

        optional uint64 GroupSizeInUnitsSmallerThanPDiskPenalty = 2 [(ControlOptions) = {
            Description: "Group size in units smaller than penalty in pdisk",
            MinValue: -1000,
            MaxValue: 1000,
            DefaultValue: 20
        }];
    }

    optional TDataShardControls DataShardControls = 1;
    optional TTxLimitControls TxLimitControls = 2;
    optional TCoordinatorControls CoordinatorControls = 3;
    optional TSchemeShardControls SchemeShardControls = 4;
    optional TTCMallocControls TCMallocControls = 5;
    reserved 6;
    optional TVDiskControls VDiskControls = 7;
    optional TTabletControls TabletControls = 8;
    optional TDSProxyControls DSProxyControls = 9;
    optional TPDiskControls PDiskControls = 10;
    optional TBlobStorageControllerControls BlobStorageControllerControls = 11;
    optional TTableServiceControls TableServiceControls = 12;
    optional TTestShardControls TestShardControls = 13;
    optional TGRpcControls GRpcControls = 14;
    optional TKeyValueVolumeControls KeyValueVolumeControls = 15;
    optional TKQPSessionControls KQPSessionControls = 16;
    optional TColumnShardControls ColumnShardControls = 17;
    optional TGroupMapperControls GroupMapperControls = 18;
};

message TMeteringConfig {
    optional string MeteringFilePath = 1;
    repeated string SystemBackupSIDs = 2;
    optional string LogName = 3;
    optional bool UnifiedAgentEnable = 4 [default = false];
};

message TAuditConfig {
    // For each new format, we need to register the audit event conversion function
    // See  ydb/core/audit/audit_log_impl.cpp for details
    enum EFormat {
        JSON = 1;                       // Outputs audit log in format: "<time>: {"k1": "v1", "k2": "v2", ...}" where <time> is ISO 8601 format time string, k1, k2, ..., kn - fields of audit log message and v1, v2, ..., vn are their values
        TXT = 2;                        // Outputs audit log in format: "<time>: k1=v1, k2=v2, ..." where <time> is ISO 8601 format time string, k1, k2, ..., kn - fields of audit log message and v1, v2, ..., vn are their values
        JSON_LOG_COMPATIBLE = 3;        // Outputs audit log in format: "{"@timestamp": "<ISO 8601 time>", "@log_type": "audit", "k1": "v1", "k2": "v2", ...}" where @timestamp is ISO 8601 format time string, k1, k2, ..., kn - fields of audit log message and v1, v2, ..., vn are their values // Suitable for output both debug log and audit log to the same destination (stderr)
        FORMAT_4 = 4;                   // Reserved
    }

    message TStderrBackend {
        optional EFormat Format = 1 [default = JSON];
        optional string LogJsonEnvelope = 2; // Json template with text field containing %message% placeholder. For example {"my_enveloped_message": "%message%"}. %message% will be replaced with real audit log message
    }

    message TFileBackend {
        optional EFormat Format = 1 [default = JSON];
        optional string FilePath = 2;
        optional string LogJsonEnvelope = 3; // Json template with text field containing %message% placeholder. For example {"my_enveloped_message": "%message%"}. %message% will be replaced with real audit log message
    }

    message TUnifiedAgentBackend {
        optional EFormat Format = 1 [default = JSON];
        optional string LogName = 2;
        optional string LogJsonEnvelope = 3; // Json template with text field containing %message% placeholder. For example {"my_enveloped_message": "%message%"}. %message% will be replaced with real audit log message
        optional TUAClientConfig UAClientConfig = 4; // If not specified, the configuration is taken from common TLogConfig section
    }

    message TLogClassConfig {
        enum ELogClass {
            ClusterAdmin = 1;
            DatabaseAdmin = 2;
            Login = 3;
            NodeRegistration = 4;
            Ddl = 5;
            Dml = 6;
            Operations = 7; // Operations API. See ydb/public/api/grpc/ydb_operation_v1.proto
            ExportImport = 8;
            Acl = 9;
            AuditHeartbeat = 10;
            Default = 1000; // For default settings for all other nonconfigured log classes
        }

        enum EAccountType {
            Anonymous = 1;
            User = 2;
            Service = 3;
            ServiceImpersonatedFromUser = 4;
        }

        enum ELogPhase {
            Received = 1;  // A request is received and the initial checks and authentication are made // "status" field of audit log record is equal to "IN-PROCESS"
            Completed = 2; // A request is completely finished and has final status // "status"/"detailed_status" fields of audit log record are equal to request's final status
        }

        optional ELogClass LogClass = 1; // Log class selector. Default is used for all log classes that were not included in config
        optional bool EnableLogging = 2; // Enables audit logging for specified log class
        repeated EAccountType ExcludeAccountType = 3; // If audit logging for log class is enabled, excludes logging for these account types
        repeated ELogPhase LogPhase = 4; // The phases of requests execution where audit log records are written
    }

    // Settings for heartbeat audit messages
    // Heartbeat messages are messages that are written in
    // a time interval that is set up in this config.
    // Audit messages are written from AuditHeartbeat log class
    // and Anonymous account type and also can be set up using its setting
    message THeartbeatSettings {
        optional uint32 IntervalSeconds = 5; // Make heartbeat records to audit log every HeartbeatInterval seconds. 0 means that heartbeat is disabled
    }

    optional TStderrBackend StderrBackend = 1;
    optional TFileBackend FileBackend = 2;
    optional TUnifiedAgentBackend UnifiedAgentBackend = 3;
    repeated TLogClassConfig LogClassConfig = 4;
    optional THeartbeatSettings Heartbeat = 5;
};

message THiveTabletLimit {
    optional NKikimrTabletBase.TTabletTypes.EType Type = 1;
    optional uint64 MaxCount = 2 [default = 1000000]; // Default value here should match the one in NkikimrLocal.TTabletAvailability
}

message THiveTabletPreference {
    optional NKikimrTabletBase.TTabletTypes.EType Type = 1;
    optional NKikimrHive.TDataCentersPreference DataCentersPreference = 10;
}

message THiveConfig {
    enum EHiveStorageBalanceStrategy {
        HIVE_STORAGE_BALANCE_STRATEGY_AUTO = 0;
        HIVE_STORAGE_BALANCE_STRATEGY_IOPS = 1;
        HIVE_STORAGE_BALANCE_STRATEGY_THROUGHPUT = 2;
        HIVE_STORAGE_BALANCE_STRATEGY_SIZE = 3;
    }

    enum EHiveStorageSelectStrategy {
        HIVE_STORAGE_SELECT_STRATEGY_WEIGHTED_RANDOM = 0;
        HIVE_STORAGE_SELECT_STRATEGY_EXACT_MIN = 1;
        HIVE_STORAGE_SELECT_STRATEGY_RANDOM_MIN_7P = 2;
        HIVE_STORAGE_SELECT_STRATEGY_ROUND_ROBIN = 3;
        HIVE_STORAGE_SELECT_STRATEGY_RANDOM = 4;
    }

    enum EHiveNodeBalanceStrategy {
        HIVE_NODE_BALANCE_STRATEGY_OLD_WEIGHTED_RANDOM = 0;
        HIVE_NODE_BALANCE_STRATEGY_HEAVIEST = 1;
        HIVE_NODE_BALANCE_STRATEGY_RANDOM = 2;
        HIVE_NODE_BALANCE_STRATEGY_WEIGHTED_RANDOM = 3;
    }

    enum EHiveTabletBalanceStrategy {
        HIVE_TABLET_BALANCE_STRATEGY_OLD_WEIGHTED_RANDOM = 0;
        HIVE_TABLET_BALANCE_STRATEGY_HEAVIEST = 1;
        HIVE_TABLET_BALANCE_STRATEGY_RANDOM = 2;
        HIVE_TABLET_BALANCE_STRATEGY_WEIGHTED_RANDOM = 3;
    }

    enum EHiveChannelBalanceStrategy {
        HIVE_CHANNEL_BALANCE_STRATEGY_HEAVIEST = 0;
        HIVE_CHANNEL_BALANCE_STRATEGY_RANDOM = 1;
        HIVE_CHANNEL_BALANCE_STRATEGY_WEIGHTED_RANDOM = 2;
    }

    enum EHiveNodeSelectStrategy {
        HIVE_NODE_SELECT_STRATEGY_WEIGHTED_RANDOM = 0;
        HIVE_NODE_SELECT_STRATEGY_EXACT_MIN = 1;
        HIVE_NODE_SELECT_STRATEGY_RANDOM_MIN_7P = 2;
        HIVE_NODE_SELECT_STRATEGY_RANDOM = 3;
    }

    enum EHiveBootStrategy {
        HIVE_BOOT_STRATEGY_BALANCED = 0;
        HIVE_BOOT_STRATEGY_FAST = 1;
    }

    message TBootPriority {
        optional NKikimrTabletBase.TTabletTypes.EType TabletType = 1;
        optional double Priority = 2;
    }

    optional uint64 MaxTabletsScheduled = 2 [default = 100];
    optional uint64 MaxResourceCounter = 3 [default = 100000000];
    optional uint64 MaxResourceCPU = 4 [default = 10000000];
    optional uint64 MaxResourceMemory = 5 [default = 512000000000];
    optional uint64 MaxResourceNetwork = 6 [default = 1000000000];
    optional double MinScatterToBalance = 7 [default = 0.5]; // Does not affect Counter. For other resources can be overriden with resource-specific settings bellow
    optional bool SpreadNeighbours = 8 [default = true];
    optional uint64 MaxBootBatchSize = 9 [default = 1000];
    optional uint64 DrainInflight = 10 [default = 10];
    optional double DefaultUnitIOPS = 11 [default = 1]; // operations/sec
    optional uint64 DefaultUnitThroughput = 12 [default = 1000]; // bytes/sec
    optional uint64 DefaultUnitSize = 13 [default = 100000000]; // bytes
    optional double StorageOvercommit = 14 [default = 1.00];
    optional EHiveStorageBalanceStrategy StorageBalanceStrategy = 15 [default = HIVE_STORAGE_BALANCE_STRATEGY_SIZE];
    optional bool StorageSafeMode = 16 [default = true];
    optional EHiveStorageSelectStrategy StorageSelectStrategy = 17 [default = HIVE_STORAGE_SELECT_STRATEGY_WEIGHTED_RANDOM];
    optional uint64 RequestSequenceSize = 18 [default = 1000];
    optional uint64 MinRequestSequenceSize = 19 [default = 1000];
    optional uint64 MaxRequestSequenceSize = 20 [default = 1000000];
    optional uint64 MetricsWindowSize = 21 [default = 60000]; // milliseconds
    optional double MaxNodeUsageToKick = 22 [default = 0.9];
    optional uint64 ResourceChangeReactionPeriod = 23 [default = 10]; // seconds
    optional uint64 TabletKickCooldownPeriod = 24 [default = 600]; // seconds
    optional double ResourceOvercommitment = 25 [default = 3.00];
    optional uint64 BalancerInflight = 26 [default = 1]; // tablets
    optional EHiveNodeBalanceStrategy NodeBalanceStrategy = 27 [default = HIVE_NODE_BALANCE_STRATEGY_HEAVIEST];
    optional EHiveTabletBalanceStrategy TabletBalanceStrategy = 28 [default = HIVE_TABLET_BALANCE_STRATEGY_WEIGHTED_RANDOM];
    optional double MinPeriodBetweenBalance = 29 [default = 0.2]; // seconds
    optional uint64 MaxMovementsOnAutoBalancer = 30 [default = 1]; // tablets
    optional bool ContinueAutoBalancer = 31 [default = true];
    optional double MinNodeUsageToBalance = 32 [default = 0.1];
    optional double MinPeriodBetweenReassign = 33 [default = 300.0]; // seconds
    optional double TabletRestartWatchPeriod = 34 [default = 3600.0]; // seconds, period used for statistics, not to be confused with TabletRestartsPeriod
    optional double NodeRestartWatchPeriod = 35 [default = 3600.0]; // seconds
    optional uint64 NodeDeletePeriod = 36 [default = 3600]; // seconds
    repeated THiveTabletLimit DefaultTabletLimit = 37;
    repeated THiveTabletPreference DefaultTabletPreference = 38;
    optional uint64 SystemTabletCategoryId = 39 [default = 1];
    optional bool EnableFastTabletMove = 40 [default = true];
    optional uint64 TabletRestartsPeriod = 42 [default = 1000]; // milliseconds, period checked for penalties - not to be confused with TabletRestartWatchPeriod
    optional uint64 TabletRestarsMaxCount = 43 [default = 2]; // deprecated, use TabletRestartsMaxCount instead
    optional uint64 PostponeStartPeriod = 44 [default = 1000]; // milliseconds
    optional EHiveNodeSelectStrategy NodeSelectStrategy = 45 [default = HIVE_NODE_SELECT_STRATEGY_RANDOM_MIN_7P];
    optional bool CheckMoveExpediency = 46 [default = true];
    optional uint64 StoragePoolFreshPeriod = 47 [default = 60000]; // milliseconds
    optional string PoolsToMonitorForUsage = 48 [default = "System,User,IC"];
    repeated NKikimrTabletBase.TTabletTypes.EType BalancerIgnoreTabletTypes = 49;
    optional double SpaceUsagePenaltyThreshold = 53 [default  = 1.1]; // number > 1
    optional double SpaceUsagePenalty = 54 [default = 0.2]; // number <= 1
    optional uint64 WarmUpBootWaitingPeriod = 50  [default = 30000]; // milliseconds, time to wait for known nodes on cluster restart
    optional uint64 NodeRestartsToIgnoreInWarmup = 51 [default = 10];
    optional double MaxWarmUpPeriod = 52 [default = 600.0]; // seconds
    optional bool WarmUpEnabled = 55 [default = true];
    optional uint64 EmergencyBalancerInflight = 56 [default = 1]; // tablets
    optional uint64 MaxMovementsOnEmergencyBalancer = 57 [default = 2];
    optional bool ContinueEmergencyBalancer = 58 [default = true];
    optional double MinPeriodBetweenEmergencyBalance = 59 [default = 0.1]; // seconds
    optional EHiveBootStrategy BootStrategy = 60 [default = HIVE_BOOT_STRATEGY_BALANCED];
    optional uint64 TabletRestartsMaxCount = 61 [default = 2];
    optional double MinCPUScatterToBalance = 62 [default = 0.5];
    optional double MinMemoryScatterToBalance = 63 [default = 0.5];
    optional double MinNetworkScatterToBalance = 64 [default = 0.5];
    optional double MinCounterScatterToBalance = 65 [default = 0.02];
    reserved 66;
    optional double ObjectImbalanceToBalance = 67 [default = 0.02];
    optional EHiveChannelBalanceStrategy ChannelBalanceStrategy = 68 [default = HIVE_CHANNEL_BALANCE_STRATEGY_WEIGHTED_RANDOM];
    optional uint64 MaxChannelHistorySize = 69 [default = 10];
    optional uint64 StorageInfoRefreshFrequency = 70 [default = 600000]; // send a query to BSC every x milliseconds
    optional double MinStorageScatterToBalance = 71 [default = 0.5]; // storage balancer trigger threshold (enabled by default)
    optional double MinGroupUsageToBalance = 72 [default = 0.05];
    optional uint64 StorageBalancerInflight = 73 [default = 1];
    optional bool EnableDestroyOperations = 74 [default = false];
    optional double NodeUsageRangeToKick = 75 [default = 0.2];
    optional bool LessSystemTabletsMoves = 77 [default = true];
    optional uint64 MaxPingsInFlight = 78 [default = 1000];
    optional string CutHistoryDenyList = 76 [default = "ColumnShard,KeyValue,PersQueue,BlobDepot"];
    optional string CutHistoryAllowList = 79 [default = "DataShard"];
    optional uint64 ScaleRecommendationRefreshFrequency = 80 [default = 60000]; // calculate scale recommendation every x milliseconds
    optional uint64 ScaleOutWindowSize = 81 [default = 10]; // buckets
    optional uint64 ScaleInWindowSize = 82 [default = 60]; // buckets
    optional double TargetTrackingCPUMargin = 83 [default = 0.1]; // percent
    optional double DryRunTargetTrackingCPU = 84; // percent
    optional uint64 NodeRestartsForPenalty = 85 [default = 3];
    optional bool UseTabletUsageEstimate = 86 [default = true];
    repeated TBootPriority TabletTypeToBootPriority = 87;
    optional uint64 BalanceCountersRefreshFrequency = 88 [default = 15000]; // milliseconds
    optional bool LockedTabletsSendMetrics = 89 [default = false]; // if true then hive will process metrics from locked tablets
    optional uint64 MaxDeleteTabletInProgress = 90 [default = 100];
}

message THealthCheckConfig {
    message TThresholds {
        optional uint32 NodeRestartsYellow = 1 [default = 10]; // per period, see HiveConfig.NodeRestartWatchPeriod
        optional uint32 NodeRestartsOrange = 2 [default = 30]; // per period, see HiveConfig.NodeRestartWatchPeriod
        optional uint64 NodesTimeDifferenceYellow = 3 [default = 5000]; // microseconds
        optional uint64 NodesTimeDifferenceOrange = 4 [default = 25000]; // microseconds
        optional uint32 TabletsRestartsOrange = 5 [default = 30]; // per period, see HiveConfig.TabletRestartWatchPeriod
    }
    optional TThresholds Thresholds = 1;
    optional uint32 Timeout = 2 [default = 20000]; // milliseconds
}

message TBlobCacheConfig {
    optional uint64 MaxSizeBytes = 1 [default = 1073741824];
}

message TColumnShardConfig {
    message TTablesStorageLayoutPolicy {
        message TMinimalTablesCountPolicy {
        };

        message TIdentityGroupsPolicy {
        };

        oneof Policy {
            TMinimalTablesCountPolicy MinimalTables = 1;
            TIdentityGroupsPolicy IdentityGroups = 2;
        }
    }
    optional TTablesStorageLayoutPolicy TablesStorageLayoutPolicy = 1;
    optional bool DisabledOnSchemeShard = 2 [default = false];
    optional bool IndexationEnabled = 4 [default = true];
    optional bool CompactionEnabled = 5 [default = true];
    optional bool TTLEnabled = 6 [default = true];
    optional bool WritingEnabled = 7 [default = true];
    optional uint32 WritingBufferDurationMs = 8 [default = 1000];
    optional uint64 CompactionMemoryLimit = 10 [default = 536870912];
    optional uint64 TieringsMemoryLimit = 11 [default = 536870912];
    message TIndexMetadataMemoryLimit {
        oneof Value {
            double TotalRatio = 1 [default = 0.3];
            uint64 AbsoluteValue = 2;
        }
    }

    optional TIndexMetadataMemoryLimit IndexMetadataMemoryLimit = 12;
    optional bool CleanupEnabled = 13 [default = true];

    message TRepairInfo {
        optional string ClassName = 1;
        optional string Description = 2;
        optional bool DryRun = 3;
    }
    repeated TRepairInfo Repairs = 15;

    enum EJsonDoubleOutOfRangeHandlingPolicy {
        REJECT = 0;
        CAST_TO_INFINITY = 1;
    }

    optional uint32 MaxInFlightIntervalsOnRequest = 16;
    optional uint32 MaxReadStaleness_ms = 18 [default = 1800000];
    optional uint32 GCIntervalMs = 19 [default = 30000];
    optional uint32 CompactionActualizationLagMs = 20 [default = 1000];
    optional uint32 ActualizationTasksLagMs = 21 [default = 1000];
    optional uint32 LagForCompactionBeforeTieringsMs = 22 [default = 3600000];
    optional uint32 OptimizerFreshnessCheckDurationMs = 23 [default = 300000];
    optional uint32 SmallPortionDetectSizeLimit = 24 [default = 1048576];  // 1 << 20
    optional bool ColumnChunksV0Usage = 25 [default = false];
    optional bool ColumnChunksV1Usage = 26 [default = false];
    optional uint64 MemoryLimitScanPortion = 27 [default = 100000000];
    optional string ReaderClassName = 28;
    optional bool AllowNullableColumnsInPK = 29 [default = false];
    optional uint32 RestoreDataOnWriteTimeoutSeconds = 30;
    optional bool UseSlicesFilter = 31 [default = true];
    optional uint32 LimitForPortionsMetadataAsk = 32 [default = 1000];
    optional uint64 WritingBufferVolumeMb = 33 [default = 32, deprecated = true];
    optional uint64 WritingInFlightRequestsCountLimit = 34;
    optional uint64 WritingInFlightRequestBytesLimit = 35;
    optional NKikimrSchemeOp.EColumnCodec DefaultCompression = 36;
    optional int32 DefaultCompressionLevel = 37;
    optional uint64 MemoryLimitMergeOnCompactionRawData = 38 [default = 512000000];
    optional bool AlterObjectEnabled = 39 [default = false];
    optional EJsonDoubleOutOfRangeHandlingPolicy DoubleOutOfRangeHandling = 40 [default = REJECT];
    optional bool PortionMetaV0Usage = 41 [default = true];
    optional uint32 PeriodicWakeupActivationPeriodMs = 42 [default = 60000];
    optional bool GenerateInternalPathId = 43 [default = true];
    optional bool ProxyWritingEnabled = 44 [default = true];
    optional bool AllowExtraSymbolsForColumnTableColumns = 45 [default = false];
    optional bool DeduplicationEnabled = 46 [default = true];
    optional bool BulkUpsertRequireAllColumns = 47 [default = true];
    optional uint64 ProxyMemoryInFlightLimit = 48;
    optional uint64 WritingBufferVolumeBytes = 49 [default = 524288];
    optional bool OnlyBulkUpsertWritingBuffer = 50 [default = true];
    optional uint64 BadPortionSizeLimit = 51 [default = 524288];
    optional uint64 BadPortionsLimit = 52;
    optional uint64 InFlightLocksRangesBytesLimit = 53 [default = 1073741824];
    optional bool CombineChunksInResult = 54 [default = true];
    optional bool EnableDiagnostics = 55 [default = true];
    optional bool EnableParallelCompaction = 56 [default = true];

    message TStatistics {
        optional uint32 ReportBaseStatisticsPeriodMs = 1 [default = 60000];
        optional uint32 ReportExecutorStatisticsPeriodMs = 2 [default = 60000];
    }

    optional TStatistics Statistics = 57;
    optional NKikimrSchemeOp.TS3Settings S3Client = 58;
    optional string DefaultCompaction = 59;
}

message TSchemeShardConfig {
    message TInFlightCounterConfig {
        optional NKikimr.NSchemeShard.ESimpleCounters Type = 1;
        // after this amount scheme shard begin to abort the operations
        // to disable set to 0
        optional uint32 InFlightLimit = 2 [default = 10000];
    }
    // after this amount of time we forcely write full stats to local DB
    // to disable set to 0
    optional uint32 StatsBatchTimeoutMs = 1 [default = 100];

    // number of shards stats to batch together
    // to disable set to 0
    optional uint32 StatsMaxBatchSize = 2 [default = 100];

    optional uint32 StatsMaxExecuteMs = 3 [default = 10];

    repeated TInFlightCounterConfig InFlightCounterConfig = 4;

    // number of shards per table
    optional uint32 MaxCdcInitialScanShardsInFlight = 5 [default = 32];

    // number of shards per table
    // 0 means default - NKikimrIndexBuilder.TIndexBuildSettings.max_shards_in_flight
    optional uint32 MaxRestoreBuildIndexShardsInFlight = 6 [default = 1000];
}

message TCompactionConfig {
    message TBackgroundCompactionConfig {
        optional double MaxRate = 1 [default = 1]; // 1 compaction / s
        optional uint64 InflightLimit = 2 [default = 1];

        // After this interval started compaction is considered as finished,
        // retry is possible only within MinCompactionRepeatDelaySeconds
        optional uint64 TimeoutSeconds = 3 [default = 600];

        // How often schemeshard is waken up to check if it should
        // start any compaction. It is used only when there are no
        // running compactions, otherwise compaction queue logic
        // is triggered either by finished compactions (event from DS)
        // or by timeouts (set via TimeoutSeconds)
        optional uint64 WakeupIntervalSeconds = 4 [default = 60];

        // When shard has been compacted, it will be considered for
        // compaction only after this amount of time
        optional uint64 MinCompactionRepeatDelaySeconds = 5 [default = 600];

        optional uint32 SearchHeightThreshold = 6 [default = 5];

        // TODO: enable, when schemeshard receive proper stat
        optional uint32 RowDeletesThreshold = 7 [default = 4294967295];

        // for tests: to allow compaction requests to empty shards
        // shards below this threshold are not background compacted
        // at all even when searchHeight or deleted rows match
        // corresponding thresholds
        optional uint32 RowCountThreshold = 8 [default = 1];

        // When this option specified, schemeshard calculates compaction rate
        // to compact QueueSize shards within this interval.
        // CompactionRate = Min(QueueSize / RoundSeconds, MaxRate).
        //
        // Note that compaction queue is round robin over three queues:
        // 1. By last full compaction time (all shards)
        // 2. By search height (some shards, depends on SearchHeightThreshold)
        // 3. By row deletes (some shards, depends on RowDeletesThreshold)
        // In queues 2 and 3 same shard can be compacted again after
        // MinCompactionRepeatDelaySeconds depending on its state.
        //
        // Thus when there are items in all queues, RoundSeconds gives the only
        // guarantee, that at least 1/3 unique shards will be compacted, the
        // rest 2/3 can be shards compacted multiple times, i.e. all shards
        // must be compacted within at most RoundSeconds*3.
        optional uint64 RoundSeconds = 9 [default = 172800]; // 2 days

        // Compact even if shard has single part and empty memtable
        optional bool CompactSinglePartedShards = 10 [default = false];

        // Do not wakeup earlier, than this interval
        optional uint64 MinWakeupIntervalMs = 11 [default = 10];
    }

    message TBorrowedCompactionConfig {
        optional double MaxRate = 1 [default = 0]; // unlimitted
        optional uint64 InflightLimit = 2 [default = 10]; // TODO: consider more?

        // After this interval we will try to restart
        optional uint64 TimeoutSeconds = 3 [default = 15];

        // Do not wakeup earlier, than this interval
        optional uint64 MinWakeupIntervalMs = 4 [default = 10];
    }

    optional TBackgroundCompactionConfig BackgroundCompactionConfig = 1;
    optional TBorrowedCompactionConfig BorrowedCompactionConfig = 2;
}

message TBackgroundCleaningConfig {
    optional double MaxRate = 1 [default = 0]; // unlimitted
    optional uint64 InflightLimit = 2 [default = 10]; // TODO: consider more?

    // After this interval we will try to restart
    optional uint64 TimeoutSeconds = 3 [default = 15];

    // Do not wakeup earlier, than this interval
    optional uint64 MinWakeupIntervalMs = 4 [default = 10];

    message TRetrySettings {
        optional uint32 StartDelayMs = 1 [default = 1000];
        optional uint32 MaxDelayMs = 2 [default = 256000];
        optional uint32 MaxRetryNumber = 3 [default = 8];
    }

    // after MaxRetryNumber retries to connect to the node, we will send the table to the BackgroundCleaningQueue,
    // that is, after 2^(MaxRetryNumber + 1) - 1 = 511 seconds

    optional TRetrySettings RetrySettings = 5;
}


message TDataErasureConfig {
    message TTenantDataErasureConfig {
        optional double MaxRate = 1 [default = 1]; // unlimited
        optional uint64 InflightLimit = 2 [default = 10];
        // After this interval started data erasure in shard is considered as finished
        optional uint64 TimeoutSeconds = 3 [default = 15];
    }

    optional double MaxRate = 1 [default = 0]; // unlimited
    optional uint64 InflightLimit = 2 [default = 10];
    // After this interval started data erasure in tenant is considered as finished
    optional uint64 TimeoutSeconds = 3 [default = 600];
    // Run data erasure every week
    optional uint64 DataErasureIntervalSeconds = 4 [default = 604800];
    // Every 10 m do request to BSC
    optional uint64 BlobStorageControllerRequestIntervalSeconds = 5 [default = 600];
    optional TTenantDataErasureConfig TenantDataErasureConfig = 6;
}

message TGraphConfig {
    message TAggregationSettings {
        optional uint64 PeriodToStartSeconds = 1;
        optional uint64 SampleSizeSeconds = 2;
        optional uint64 MinimumStepSeconds = 3;
    }
    optional string BackendType = 1;
    optional uint64 AggregateCheckPeriodSeconds = 5;
    repeated TAggregationSettings AggregationSettings = 10;
}

message TTracingConfig {
    message TBackendConfig {
        message TAuthConfig {
            message TTvmAuth {
                optional string Url = 1;

                optional uint32 SelfTvmId = 2;
                optional uint32 TracingTvmId = 3;

                optional string DiskCacheDir = 4;

                oneof Secret {
                    string PlainTextSecret = 5;
                    string SecretFile = 6;
                    string SecretEnvironmentVariable = 7;
                }
            }

            oneof Method {
                TTvmAuth Tvm = 1;
            }
        }

        message TOpentelemetryBackend {
            optional string CollectorUrl = 1;
            optional string ServiceName = 2;
            map<string, string> Headers = 3;
        }


        oneof Backend {
            TOpentelemetryBackend Opentelemetry = 1;
        }
        optional TAuthConfig AuthConfig = 2;
    }

    message TSelectors {
        reserved 1;
        repeated string RequestTypes = 3;
        optional string Database = 2;
    }

    message TSamplingRule {
        // scope to which the rule applies
        optional TSelectors Scope = 1;
        // fraction of requests sampled by this rule
        optional float Fraction = 2;
        // detalisation of traces sampled by this rule
        optional uint32 Level = 3;
        // maximum average amount of traces sampled by this rule
        optional uint64 MaxTracesPerMinute = 4;
        // maximum burst of traces sampled by this rule
        optional uint64 MaxTracesBurst = 5;
    }

    // field meaning is the same as in TSamplingRule
    message TExternalThrottlingRule {
        optional TSelectors Scope = 1;
        optional uint32 Level = 4;
        optional uint64 MaxTracesPerMinute = 2;
        optional uint64 MaxTracesBurst = 3;
    }

    message TUploaderConfig {
        // maximum average amount of spans uploaded from the node
        optional uint64 MaxExportedSpansPerSecond = 1;
        // maximum batch size in spans
        optional uint64 MaxSpansInBatch = 2;
        // maximum batch size in bytes
        optional uint64 MaxBytesInBatch = 3;
        // maximum batch accumulation time
        optional uint64 MaxBatchAccumulationMilliseconds = 4;
        // time after which generated span will be discarded and will
        // not be sent to the collector
        optional uint32 SpanExportTimeoutSeconds = 5;
        // maximum batch export requests being run simultaneously
        optional uint64 MaxExportRequestsInflight = 6;
    }

    reserved 1 to 5;

    optional TBackendConfig Backend = 6;
    repeated TSamplingRule Sampling = 7;
    repeated TExternalThrottlingRule ExternalThrottling = 8;
    optional TUploaderConfig Uploader = 9;
}

message TFailureInjectionConfig {
    // approximate time in seconds between self terminations
    optional uint32 ApproximateTerminationInterval = 1 [default = 0]; // disabled by default
}

// This message is used to upload custom service configs
// to CMS. Config name is used to identify owner and
// data format.
// Custom config validators should b8e used to detect name
// conflicts and check config consistency.
message TNamedConfig {
    optional string Name = 1;
    optional bytes Config = 2;
}

message TConfigItemVersion {
    optional uint32 Kind = 1;
    optional uint64 Id = 2;
    optional uint64 Generation = 3;
}

message TConfigVersion {
    repeated TConfigItemVersion Items = 1;
}

message TClientCertificateAuthorization {
    message TSubjectTerm {
        optional string ShortName = 1;
        repeated string Values = 2;
        repeated string Suffixes = 3;
    }

    // Matches subject alternative names (DNS) and Common Name (CN) in certificate
    message TSubjectDns {
        repeated string Values = 1;
        repeated string Suffixes = 2;
    }

    message TClientCertificateDefinition {
        repeated TSubjectTerm SubjectTerms = 1;
        optional TSubjectDns SubjectDns = 5;
        optional bool CanCheckNodeHostByCN = 2 [default = false];
        repeated string MemberGroups = 3;
        optional bool RequireSameIssuer = 4 [default = true];
    }

    repeated TClientCertificateDefinition ClientCertificateDefinitions = 1;
    optional bool RequestClientCertificate = 2 [default = false];
    optional string DefaultGroup = 3 [default = "DefaultClientAuth@cert"];
}

message TLocalPgWireConfig {
    optional int32 ListeningPort = 1 [default = 5432];
    optional string SslCertificate = 5 [(Ydb.sensitive) = true];
    optional string Address = 6 [default = "::"];
    optional bool TcpNotDelay = 7 [default = true];
}

message TKafkaProxyConfig {
    optional bool EnableKafkaProxy = 1 [default = false];

    optional int32 ListeningPort = 2 [default = 9092];

    // You can either specify the path to the certificate, which will contain both the certificate and the private key,
    // or specify them separately in parameters Cert and Key.
    optional string SslCertificate = 3 [(Ydb.sensitive) = true];
    optional string Cert = 8 [(Ydb.sensitive) = true];
    optional string Key = 9 [(Ydb.sensitive) = true];

    optional uint64 MaxMessageSize = 4 [default = 16777216];
    optional uint64 MaxInflightSize = 5 [default = 16777216];
    optional uint64 PacketSize = 6 [default = 1500];

    message TProxy {
        optional string Hostname = 1;
        optional int32 Port = 2 [default = 9092];
    }

    optional TProxy Proxy = 7;
    optional bool MeteringV2Enabled = 10 [default = true];
    optional bool AuthViaApiKey = 11 [default = true];
    optional uint32 TransactionTimeoutMs = 12 [default = 300000]; // 5 minutes (same as in kafka)
    optional bool AutoCreateTopicsEnable = 13 [default = false];
    optional uint32 TopicCreationDefaultPartitions = 14 [default = 1];
    optional bool AutoCreateConsumersEnable = 15 [default = true];
    optional string PublicHost = 16;
}

message TAwsCompatibilityConfig {
    optional string AwsRegion = 1;
}

message TAwsClientConfig {
    message TLogConfig {
        // Equivalent of Aws::Utils::Logging::LogLevel.
        // Off = 0 (default)
        // Fatal = 1
        // Error = 2
        // Warn = 3
        // Info = 4
        // Debug = 5
        // Trace = 6
        optional int32 LogLevel = 1;

        // By default, logs will be written to standard output if they are enabled.
        // To write to a file in the format YYYY-MM-DD-HH.log, specify the filename prefix.
        // The resulting log file is '<FilenamePrefix> + YYYY-MM-DD-HH.log'
        optional string FilenamePrefix = 2;
    }

    // Logging options
    optional TLogConfig LogConfig = 1;
}

message TMetadataCacheConfig {
    optional uint64 RefreshPeriodMs = 1 [default = 15000];
}

message TShutdownConfig {
    optional uint32 MinDelayBeforeShutdownSeconds = 1;
    optional uint32 DrainTimeoutSeconds = 2;
    optional uint32 CheckForStopIntervalMilliseconds = 3;
}

message TBridgeConfig {
    message TPile {
        optional string Name = 1; // name (to be matched with node's BridgePileName)
    }
    repeated TPile Piles = 1; // order of realms must not change during config updates
}

message TLabel {
    optional string Name = 1;
    optional string Value = 2;
}

message TGeneralCacheConfig {
    optional uint64 MemoryLimit = 1;
    optional uint64 DirectInflightSourceLimit = 2;
    optional uint64 DirectInflightGlobalLimit = 3;
}

message TStatisticsConfig {
    // Interval for base statistics send requests from SchemeShard to StatisticsAggregator.
    // Serverless interval should be higher because many SchemeShards send data to one aggregator.
    optional uint32 BaseStatsSendIntervalSecondsDedicated = 1 [default = 5];
    optional uint32 BaseStatsSendIntervalSecondsServerless = 2 [default = 240];

    // Interval for base statistics propagate requests from StatisticsAggregator to StatisticsService.
    // Serverless interval should be higher because in each iteration we need to propagate more data
    // from many SchemeShards.
    optional uint32 BaseStatsPropagateIntervalSecondsDedicated = 3 [default = 5];
    optional uint32 BaseStatsPropagateIntervalSecondsServerless = 4 [default = 180];

    optional bool EnableBackgroundColumnStatsCollection = 5 [default = false];
};

message TSystemTabletBackupConfig {
    message TFilesystemBackend {
        optional string Path = 1;
    }

    oneof Backend {
        TFilesystemBackend Filesystem = 1;
    }
    repeated fixed64 ExcludeTabletIds = 2;
    optional uint64 NewBackupChangelogMinBytes = 3 [default = 524288000]; // 500 MB
}

message TAppConfig {
    option (NMarkers.Root) = true;
    optional TActorSystemConfig ActorSystemConfig = 1;
    optional TLogConfig LogConfig = 2;
    optional TStaticNameserviceConfig NameserviceConfig = 3;
    optional TInterconnectConfig InterconnectConfig = 4;
    optional TDomainsConfig DomainsConfig = 5;
    optional TBlobStorageConfig BlobStorageConfig = 6;
    optional TChannelProfileConfig ChannelProfileConfig = 7;
    optional TBootstrap BootstrapConfig = 8;
    optional TMonitoringConfig MonitoringConfig = 10;
    optional TRestartsCountConfig RestartsCountConfig = 11;
    optional TMessageBusConfig MessageBusConfig = 12;
    optional TTabletsConfig TabletsConfig = 13; // alternative bootstrapper configuration
    optional NKikimrBlobStorage.TAllVDiskKinds VDiskConfig = 14;
    optional NKikimrBlobStorage.TDriveModelList DriveModelConfig = 31;
    optional NKikimrBlobStorage.TIncrHugeConfig IncrHugeConfig = 18;
    optional string UDFsDir = 15;
    repeated string UDFsPaths = 16;
    optional TKQPConfig KQPConfig = 17;
    optional TMemoryLogConfig MemoryLogConfig = 19;
    optional TGRpcConfig GRpcConfig = 20;
    optional TDynamicNameserviceConfig DynamicNameserviceConfig = 22;
    //optional TLocalConfig LocalConfig = 23; DEPRECATED
    optional TDynamicNodeConfig DynamicNodeConfig = 24;
    optional NKikimrCms.TCmsConfig CmsConfig = 25;
    optional TFeatureFlags FeatureFlags = 26 [(NMarkers.AllowInDatabaseConfig) = true];
    optional TSqsConfig SqsConfig = 27;
    optional NKikimrPQ.TPQConfig PQConfig = 28;
    optional NKikimrTenantPool.TTenantPoolConfig TenantPoolConfig = 29;
    optional NKikimrProto.TAuthConfig AuthConfig = 30;
    optional NKikimrTenantSlotBroker.TConfig TenantSlotBrokerConfig = 32;
    optional TConfigsDispatcherConfig ConfigsDispatcherConfig = 33;
    optional TTableProfilesConfig TableProfilesConfig = 34;
    optional NKikimrProto.TKeyConfig KeyConfig = 35;
    optional NKikimrProto.TKeyConfig PDiskKeyConfig = 51;
    optional NKikimrNodeBroker.TConfig NodeBrokerConfig = 36;
    optional TTableServiceConfig TableServiceConfig = 37 [(NMarkers.AllowInDatabaseConfig) = true];
    optional NKikimrSharedCache.TSharedCacheConfig SharedCacheConfig = 38; // dynamic configuration via cms
    optional TImmediateControlsConfig ImmediateControlsConfig = 39;
    optional TAllocatorConfig AllocatorConfig = 40;
    optional NKikimrPQ.TPQClusterDiscoveryConfig PQClusterDiscoveryConfig = 41;
    optional NKikimrNetClassifier.TNetClassifierConfig NetClassifierConfig = 42;
    optional NKikimrNetClassifier.TNetClassifierDistributableConfig NetClassifierDistributableConfig = 43; // also dynamic via cms
    optional NKikimrResourceBroker.TResourceBrokerConfig ResourceBrokerConfig = 44;
    optional TMeteringConfig MeteringConfig = 45;
    optional THiveConfig HiveConfig = 46;
    optional TDataShardConfig DataShardConfig = 49;
    optional TGraphConfig GraphConfig = 50;
    optional NFq.NConfig.TConfig FederatedQueryConfig = 58;
    optional TCompactionConfig CompactionConfig = 52;
    optional THttpProxyConfig HttpProxyConfig = 53;
    optional TSchemeShardConfig SchemeShardConfig = 54;
    optional TTracingConfig TracingConfig = 55;
    optional TFailureInjectionConfig FailureInjectionConfig = 56;
    optional THttpProxyConfig PublicHttpConfig = 57;
    optional TMetadataProviderConfig MetadataProviderConfig = 59;
    optional TBackgroundTasksConfig BackgroundTasksConfig = 60;
    optional TAuditConfig AuditConfig = 61;
    optional TClientCertificateAuthorization ClientCertificateAuthorization = 62;
    optional TExternalIndexConfig ExternalIndexConfig = 63;
    optional bool YamlConfigEnabled = 64;
    optional TConveyorConfig ScanConveyorConfig = 65;
    optional TColumnShardConfig ColumnShardConfig = 66;
    optional TLocalPgWireConfig LocalPgWireConfig = 69;
    optional TAwsCompatibilityConfig AwsCompatibilityConfig = 70;
    optional TKafkaProxyConfig KafkaProxyConfig = 71;
    optional TConveyorConfig CompConveyorConfig = 72;
    optional TQueryServiceConfig QueryServiceConfig = 73;
    optional TConveyorConfig InsertConveyorConfig = 74;
    optional bool AllowEditYamlInUi = 75;
    optional TS3ProxyResolverConfig S3ProxyResolverConfig = 76;
    optional TBackgroundCleaningConfig BackgroundCleaningConfig = 77;
    optional TBlobCacheConfig BlobCacheConfig = 78;
    optional TLimiterConfig CompDiskLimiterConfig = 79;
    optional TMetadataCacheConfig MetadataCacheConfig = 80;
    optional TMemoryControllerConfig MemoryControllerConfig = 81;
    optional TGroupedMemoryLimiterConfig ScanGroupedMemoryLimiterConfig = 82;
    optional NKikimrReplication.TReplicationDefaults ReplicationConfig = 83;
    optional TShutdownConfig ShutdownConfig = 84;
    optional TPrioritiesQueueConfig CompPrioritiesConfig = 85;
    optional TSelfManagementConfig SelfManagementConfig = 86;
    optional NKikimrProto.TDataIntegrityTrailsConfig DataIntegrityTrailsConfig = 87;
    optional TDataErasureConfig DataErasureConfig = 88;
    optional THealthCheckConfig HealthCheckConfig = 89;
    optional TWorkloadManagerConfig WorkloadManagerConfig = 90;
    optional TBridgeConfig BridgeConfig = 91;
    optional TGroupedMemoryLimiterConfig CompGroupedMemoryLimiterConfig = 92;
    optional TBlockstoreConfig BlockstoreConfig = 93;

    repeated TNamedConfig NamedConfigs = 100;
    optional string ClusterYamlConfig = 101;

    optional TConfigVersion Version = 102;
    repeated TLabel Labels = 103;

    optional string ConfigDirPath = 104;
    optional NKikimrBlobStorage.TYamlConfig StoredConfigYaml = 105;
    optional string StartupConfigYaml = 107;
    optional string StartupStorageYaml = 108;
    optional TCompositeConveyorConfig CompositeConveyorConfig = 109;
    optional TGeneralCacheConfig PortionsMetadataCache = 110;
    optional TGeneralCacheConfig ColumnDataCache = 111;
    optional TGroupedMemoryLimiterConfig DeduplicationGroupedMemoryLimiterConfig = 112;
    optional TStatisticsConfig StatisticsConfig = 113;
    optional TMetricsConfig MetricsConfig = 114;
    optional TSystemTabletBackupConfig SystemTabletBackupConfig = 115;

    // Built-in AWS client options (used, for example, to interact with S3).
    optional TAwsClientConfig AwsClientConfig = 116;

    optional TRecoveryShardConfig RecoveryShardConfig = 117;
}

message TYdbVersion {
    optional uint32 Year = 1;
    optional uint32 Major = 2;
    optional uint32 Minor = 3;
    optional uint32 Patch = 5;
    optional uint32 Hotfix = 4;
}

message TCompatibilityRule {
    enum EComponentId {
        Any = 0;
        Test1 = 1;
        Test2 = 2;
        Interconnect = 3;
        PDisk = 4;
        VDisk = 5;
        BlobStorageController = 6;
        ComponentsCount = 7;
    }

    optional string Application = 1;
    optional TYdbVersion LowerLimit = 2;
    optional TYdbVersion UpperLimit = 3;

    // don't use enum, because stored data can have values from newer YDB versions,
    // which are not included in current version
    optional uint32 ComponentId = 4;

    // don't use Forbidden until it's absolutely necessary
    optional bool Forbidden = 5 [default = false];
}

message TCurrentCompatibilityInfo {
    required string Application = 1;

    // if Version is empty, build is assumed to be non-stable
    optional TYdbVersion Version = 2;

    repeated TCompatibilityRule CanLoadFrom = 3;
    repeated TCompatibilityRule StoresReadableBy = 4;
    repeated TCompatibilityRule CanConnectTo = 5;
}

message TStoredCompatibilityInfo {
    required string Application = 1;

    // if Version is empty, build is assumed to be non-stable
    optional TYdbVersion Version = 2;

    repeated TCompatibilityRule ReadableBy = 3;
}
