import "google/protobuf/descriptor.proto";
import "ydb/library/actors/protos/interconnect.proto";
import "ydb/core/protos/blobstorage.proto";
import "ydb/core/protos/blobstorage_config.proto";
import "ydb/core/protos/blobstorage_vdisk_config.proto";
import "ydb/core/protos/blobstorage_pdisk_config.proto";
import "ydb/core/protos/cms.proto";
import "ydb/core/protos/config_units.proto";
import "ydb/core/protos/counters_schemeshard.proto";
import "ydb/core/protos/datashard_config.proto";
import "ydb/core/protos/drivemodel.proto";
import "ydb/core/protos/feature_flags.proto";
import "ydb/core/protos/flat_scheme_op.proto";
import "ydb/core/protos/http_config.proto";
import "ydb/core/protos/hive.proto";
import "ydb/core/protos/kqp.proto";
import "ydb/core/protos/local.proto";
import "ydb/core/protos/netclassifier.proto";
import "ydb/core/protos/node_broker.proto";
import "ydb/core/protos/pqconfig.proto";
import "ydb/core/protos/resource_broker.proto";
import "ydb/core/protos/shared_cache.proto";
import "ydb/core/protos/stream.proto";
import "ydb/core/protos/table_service_config.proto";
import "ydb/core/protos/tablet.proto";
import "ydb/core/protos/tablet_database.proto";
import "ydb/core/protos/tenant_pool.proto";
import "ydb/core/protos/tenant_slot_broker.proto";
import "ydb/core/protos/auth.proto";
import "ydb/core/protos/key.proto";
import "ydb/core/protos/alloc.proto";
import "ydb/core/protos/node_limits.proto";
import "ydb/core/fq/libs/config/protos/fq_config.proto";
import "ydb/library/yql/providers/common/proto/gateways_config.proto";

package NKikimrConfig;
option java_package = "ru.yandex.kikimr.proto";

message TAffinity {
    repeated uint32 X = 1; // DEPRECATED: Use `CpuList` instead

    // Numerical list of processors. The numbers are separated by commas and may include ranges. For example: 0,5,7,9-11
    optional string CpuList = 2; // Processors to include. Use all processor if not set.
    optional string ExcludeCpuList = 3; // Exclude specified processors from `CpuList` (or all processors if not set)
}

message TActorSystemConfig {
    enum ENodeType {
        STORAGE = 1;
        COMPUTE = 2;
        HYBRID = 3;
    }

    enum EActorSystemProfile {
        DEFAULT = 1;
        LOW_CPU_CONSUMPTION = 2;
        LOW_LATENCY = 3;
    }

    message TExecutor {
        enum EType {
            BASIC = 1;
            IO = 2;
        };

        optional EType Type = 1;
        optional uint32 Threads = 2;
        optional uint64 SpinThreshold = 3;
        optional TAffinity Affinity = 4;
        optional uint32 InjectMadSquirrels = 5;
        optional string Name = 6;
        optional uint32 TimePerMailboxMicroSecs = 7;
        optional uint32 EventsPerMailbox = 8;
        optional uint32 RealtimePriority = 9;

        // Actorsystem 1.4
        optional uint32 MinThreads = 12; // Lower balancing bound, should be at least 1, and not greater than `Threads`
        optional uint32 MaxThreads = 13; // Higher balancing bound, should be not lower than `Threads`
        optional int32 Priority = 16;
        optional int32 MaxAvgPingDeviation = 17;
    }

    message TScheduler {
        optional uint64 Resolution = 1;
        optional uint64 SpinThreshold = 2;
        optional uint64 ProgressThreshold = 3;
        optional TAffinity Affinity = 4;
        optional bool UseSchedulerActor = 5;
    }

    repeated TExecutor Executor = 1;
    optional TScheduler Scheduler = 2;

    optional uint32 SysExecutor = 3;
    optional uint32 UserExecutor = 4;
    optional uint32 IoExecutor = 5;
    optional uint32 BatchExecutor = 6;

    message TServiceExecutor {
        required string ServiceName = 1;
        required uint32 ExecutorId = 2;
    }

    repeated TServiceExecutor ServiceExecutor = 7;
    optional uint32 TimePerMailboxMicroSecs = 8;
    optional uint32 EventsPerMailbox = 9;
    optional uint32 SelfPingInterval = 10; // in microseconds

    optional bool UseAutoConfig = 12;

    // Used only with UseAutoConfig;
    optional uint32 CpuCount = 13;
    optional ENodeType NodeType = 14 [default = COMPUTE];

    optional bool MonitorStuckActors = 15;
    optional EActorSystemProfile ActorSystemProfile = 16;
}

message TStaticNameserviceConfig {

    enum ENameserviceType {
        NS_DEFAULT = 0;     // default (nodebroker)
        NS_FIXED = 1;       // static table lookup
        NS_NODE_BROKER = 2; // nodebroker based
        NS_EXTERNAL = 3;    // may be paired with external discovery
    }

    message TEndpoint {
        optional string Name = 1;
        optional string Address = 2;
    }

    message TNode { // todo: multiple networks
        optional uint32 NodeId = 1;

        optional string Address = 2;
        optional uint32 Port = 3;

        optional string Host = 4;
        optional string InterconnectHost = 5;

        optional NActorsInterconnect.TNodeLocation Location = 6;

        repeated TEndpoint Endpoint = 7;

        optional NActorsInterconnect.TNodeLocation WalleLocation = 8 [deprecated=true];
    }

    repeated TNode Node = 1;

    optional string ClusterUUID = 2;
    repeated string AcceptUUID = 3;
    optional bool SuppressVersionCheck = 4;
    optional ENameserviceType Type = 5;
}

message TDynamicNameserviceConfig {
    optional uint32 MaxStaticNodeId = 1 [default = 1000];
    optional uint32 MaxDynamicNodeId = 2 [default = 200000];
    optional uint64 LeaseDuration = 3 [default = 3600000000]; // DEPRECATED
    // Soft limit, new dynamic nodes will be registered in range [MinDynamicNodeId, MaxDynamicNodeId],
    // but already existing dynamic nodes in range (MaxStaticNodeId, MaxDynamicNodeId) will be handled properly
    optional uint32 MinDynamicNodeId = 4 [default = 50000];
}

message TDomainsConfig {
    message TStateStorage {
        message TRing {
            optional uint32 NToSelect = 1;
            repeated TRing Ring = 2;
            repeated uint32 Node = 3;
            optional bool UseSingleNodeActorId = 4;
            optional bool UseRingSpecificNodeSelection = 5;
            optional bool IsDisabled = 6 [default = false]; // used in the intermediate reconfiguration step
        }

        optional uint32 SSId = 1;
        optional TRing Ring = 2;
        optional uint32 StateStorageVersion = 3 [default = 0];
        repeated uint32 CompatibleVersions = 4;
    }

    message TStoragePoolType {
        optional string Kind = 1;
        optional NKikimrBlobStorage.TDefineStoragePool PoolConfig = 2;
    }

    message TDomain {
        message TTxLimits {
            optional uint64 PerRequestDataSizeLimit = 1;
            optional uint64 PerShardReadSizeLimit = 2;
            optional uint64 PerShardIncomingReadSetSizeLimit = 3;
        }

        optional uint32 DomainId = 1;
        optional fixed64 SchemeRoot = 2;
        repeated uint64 Coordinator = 3;
        repeated uint64 Mediator = 4;
        repeated uint64 Proxy = 5;
        repeated uint32 SSId = 6;
        repeated uint32 HiveUid = 7;
        optional uint64 PlanResolution = 8;
        optional string Name = 9;
        optional TTxLimits TxLimits = 10; // DEPRECATED
        repeated TStoragePoolType StoragePoolTypes = 11;
        repeated fixed64 ExplicitMediators = 12;
        repeated fixed64 ExplicitCoordinators = 13;
        repeated fixed64 ExplicitAllocators = 14;
        optional uint32 SchemeBoardSSId = 15;
    }

    message THiveConfig { // look for another THiveConfig later in this file
        optional uint32 HiveUid = 1;
        optional fixed64 Hive = 2;
    }

    message TExecLevel {
    }

    message TNamedCompactionPolicy {
        optional string Name = 1;
        optional NKikimrSchemeOp.TCompactionPolicy Policy = 2;
    }

    message TSecurityConfig {
        optional bool EnforceUserTokenRequirement = 1 [default = false];
        repeated string MonitoringAllowedSIDs = 2;
        repeated string AdministrationAllowedSIDs = 3;
        repeated string DefaultUserSIDs = 4;
        optional string AllAuthenticatedUsers = 5;
        repeated string ViewerAllowedSIDs = 6;

        message TUser {
            optional string Name = 1;
            optional string Password = 2;
        }

        message TGroup {
            optional string Name = 1;
            repeated string Members = 2;
        }

        repeated TUser DefaultUsers = 15;
        repeated TGroup DefaultGroups = 16;
        repeated string DefaultAccess = 17;
        optional string AllUsersGroup = 18;
    }

    repeated TDomain Domain = 1;
    repeated TStateStorage StateStorage = 2;
    repeated TExecLevel ExecLevel = 3;
    repeated THiveConfig HiveConfig = 4;
    repeated TNamedCompactionPolicy NamedCompactionPolicy = 5;
    optional TSecurityConfig SecurityConfig = 6;
    optional bool ForbidImplicitStoragePools = 7 [default = true];
}

message TBlobStorageConfig {
    optional NKikimrBlobStorage.TNodeWardenServiceSet ServiceSet = 1;
    optional bool EnableOverseerLsnReporting = 2 [default = false]; // deprecated
    optional string CacheFilePath = 3;
    optional bool CachePDisks = 4 [default = true];
    optional bool CacheVDisks = 5 [default = true];

    // Automatic configuration: when not filled in, then the autoconfig feature is disabled. When multiple nodes are
    // negotiating about this feature, the disabled one overrides others.
    message TAutoconfigSettings {
        // subset of DefineStoragePool command
        optional string ErasureSpecies = 1;
        optional NKikimrBlobStorage.TGroupGeometry Geometry = 2;
        repeated NKikimrBlobStorage.TPDiskFilter PDiskFilter = 3;

        // some extra settings
        optional bool AutomaticBoxManagement = 4; // invoke BSC DefineHostConfig/DefineBox automatically

        // filled in by config parser, not by user; required for automatic static group creation
        repeated NKikimrBlobStorage.TDefineHostConfig DefineHostConfig = 5;
        optional NKikimrBlobStorage.TDefineBox DefineBox = 6;
    }

    optional TAutoconfigSettings AutoconfigSettings = 6;
 }

message TBlobStorageFormatConfig {
    message TDrive {
        optional uint64 RackId = 1;
        optional uint32 NodeId = 2;
        optional string Hostname = 3;
        optional string Type = 4;
        optional string Path = 5;
        optional uint64 Guid = 6;
        optional uint64 PDiskId = 7;
        optional uint64 DataCenterId = 8;
        optional uint64 RoomId = 9;
        optional uint64 BodyId = 10;
        optional NKikimrBlobStorage.TPDiskConfig PDiskConfig = 11;
    }

    repeated TDrive Drive = 1;
}

message TUAClientConfig {
    optional string Uri = 1;
    optional string SharedSecretKey = 2;
    optional uint64 MaxInflightBytes = 3 [default = 100000000];
    optional uint64 GrpcReconnectDelayMs = 4;
    optional uint64 GrpcSendDelayMs = 5;
    optional uint64 GrpcMaxMessageSize = 6;
    optional string ClientLogFile = 7;
    optional uint32 ClientLogPriority = 8;
    optional string LogName = 9;
}

message TLogConfig {
    message TEntry {
        optional bytes Component = 1;
        optional uint32 Level = 2;
        optional uint32 SamplingLevel = 3;
        optional uint32 SamplingRate = 4;
    }

    repeated TEntry Entry = 1;
    optional bool   SysLog = 2 [default = false];
    optional uint32 DefaultLevel = 3 [default = 5]; // NActors::NLog::PRI_NOTICE
    optional uint32 DefaultSamplingLevel = 4 [default = 7]; // NActors::NLog::PRI_DEBUG
    optional uint32 DefaultSamplingRate = 5 [default = 0];
    optional string Format = 6 [default = "full"]; // "full" | "short" | "json"
    optional string ClusterName = 7;
    optional bool AllowDropEntries = 8 [default = true];
    optional bool UseLocalTimestamps = 9 [default = false];
    optional string BackendFileName = 10;
    optional string SysLogService = 11;
    optional bool SysLogToStdErr = 12; // writes logs to stderr as well as in syslog
    optional TUAClientConfig UAClientConfig = 13;
    optional uint64 TimeThresholdMs = 14 [default = 1000];
    optional bool IgnoreUnknownComponents = 15 [default = true];
}

message TCompileServiceConfig {
    optional uint32 InflightLimit = 1 [default = 100000];
}

message TBootstrap {
    enum ETabletType {
        TX_DUMMY = 0;

        HIVE = 1;

        TX_COORDINATOR = 10;
        TX_MEDIATOR = 11;
        TX_PROXY = 12;
        FLAT_TX_COORDINATOR = 13;
        FLAT_HIVE = 14;
        FLAT_BS_CONTROLLER = 15;
        FLAT_TX_PROXY = 17;
        TX_ALLOCATOR = 18;

        BS_DOMAINCONTROLLER = 20;

        SCHEMESHARD = 30;
        DATASHARD = 31;
        FLAT_SCHEMESHARD = 32;
        KEYVALUEFLAT = 33;

        JOBRUNNER_POOL_MANAGER = 40;
        FLAT_JOBRUNNER_POOL_MANAGER = 41;

        CMS = 51;
        NODE_BROKER = 52;

        TENANT_SLOT_BROKER = 53;
        CONSOLE = 54;

        FAKE_DATASHARD = 700;
    }

    message TTablet {
        optional ETabletType Type = 1;
        repeated uint32 Node = 2;
        optional NKikimrTabletBase.TTabletStorageInfo Info = 3;
        optional bool StandBy = 4;
        optional uint64 WatchThreshold = 5;
        optional bool StartFollowers = 6;
        optional bool AllowDynamicConfiguration = 7 [default = false];
    }

    repeated TTablet Tablet = 1;

    optional uint64 ProxySchemeCacheNodes = 2;
    optional uint64 ProxySchemeCacheDistNodes = 3;
    optional NKikimrTablet.TCompactionBroker CompactionBroker = 4;
    optional NKikimrNodeLimits.TNodeLimitsConfig NodeLimits = 5;
    optional NKikimrResourceBroker.TResourceBrokerConfig ResourceBroker = 6;
    optional NKikimrSharedCache.TSharedCacheConfig SharedCacheConfig = 7;
    repeated NKikimrSchemeOp.TResourceProfile ResourceProfiles = 8;
    optional TCompileServiceConfig CompileServiceConfig = 9; //may be need special file with resource limits?
    optional bool EnableIntrospection = 10;
}

message TInterconnectConfig {
    message TChannel {
        optional uint32 Index = 1;
        optional uint32 Quota = 2; // deprecated
        optional uint32 Weight = 3; // use this instead of field "Quota"
    }

    enum EMergeMode {
        AUTO = 0;
        PER_PEER = 1;
        PER_DATA_CENTER = 2;
        NO_MERGE = 3;
    }

    enum EEncryptionMode {
        DISABLED = 0;
        OPTIONAL = 1;
        REQUIRED = 2;
    };

    repeated TChannel Channel = 1;
    optional bool FirstTryBeforePoll = 2; // DEPRECATED
    optional bool StartTcp = 3 [default = false];
    optional uint32 SelfKickDelay = 4; // DEPRECATED
    optional uint32 HandshakeTimeout = 5;
    optional uint32 HeartbeatInterval = 6;
    optional uint32 DeadPeerTimeout = 7;
    optional uint32 SendBufferDieLimitInMB = 8;
    optional uint32 CloseOnIdleTimeout = 9;
    optional uint32 MaxInflightAmountOfDataInKB = 10;
    optional bool MergePerPeerCounters = 11;
    optional EMergeMode CounterMergeMode = 15 [default = AUTO];
    optional uint32 TCPSocketBufferSize = 12;
    optional uint32 MaxTimePerEventInMks = 13;
    optional bool BindOnAllAddresses = 16 [default = true];
    optional EEncryptionMode EncryptionMode = 17 [default = DISABLED];
    optional bool TlsAuthOnly = 38; // do not encrypt traffic
    optional bool EnforceScopeValidation = 18;
    optional bytes Certificate = 30; // in PEM format
    optional bytes PrivateKey = 31; // in PEM format
    optional string PathToCertificateFile = 35;
    optional string PathToPrivateKeyFile = 36;
    optional string PathToCaFile = 37;
    optional string CipherList = 34;
    optional NKikimrConfigUnits.TDuration MessagePendingTimeout = 32;
    optional uint64 MessagePendingSize = 33;
    optional bool SuppressConnectivityCheck = 39 [default = false];
    optional uint32 PreallocatedBufferSize = 40;
    optional uint32 NumPreallocatedBuffers = 41;
    optional bool EnableExternalDataChannel = 42;
    optional bool ValidateIncomingPeerViaDirectLookup = 44;
    optional uint32 SocketBacklogSize = 45; // SOMAXCONN if not set or zero

    // ballast is added to IC handshake frames to ensure correctness of jumbo frames transmission over network
    optional uint32 HandshakeBallastSize = 14;

    // new-style definitions for various timeouts; when defined, they silently override values above
    optional NKikimrConfigUnits.TDuration SelfKickDelayDuration = 20; // DEPRECATED
    optional NKikimrConfigUnits.TDuration HandshakeTimeoutDuration = 21;
    optional NKikimrConfigUnits.TDuration HeartbeatIntervalDuration = 22;
    optional NKikimrConfigUnits.TDuration DeadPeerTimeoutDuration = 23;
    optional NKikimrConfigUnits.TDuration CloseOnIdleTimeoutDuration = 24;

    optional uint64 TotalInflightAmountOfData = 25;
    optional NKikimrConfigUnits.TDuration PingPeriodDuration = 26;
    optional NKikimrConfigUnits.TDuration ForceConfirmPeriodDuration = 27;
    optional NKikimrConfigUnits.TDuration LostConnectionDuration = 28;
    optional NKikimrConfigUnits.TDuration BatchPeriodDuration = 29;

    optional uint32 OutgoingHandshakeInflightLimit = 43;
}

message TChannelProfileConfig {
    message TProfile {
        message TChannel {
            optional string ErasureSpecies = 1;
            optional uint64 PDiskCategory = 2;
            optional NKikimrBlobStorage.TVDiskKind.EVDiskKind VDiskCategory = 3 [default = Default];

            // this option uses new BS configuration interface to obtain matching groups, and it must not be provided
            // with any of the above fields
            optional string StoragePoolKind = 5;
        }

        optional uint32 ProfileId = 1;
        repeated TChannel Channel = 2;
    }

    repeated TProfile Profile = 1;
}

message TMonitoringConfig {
    message TDatabaseLabels {
        optional bool Enabled = 1 [default = true];
        // If labels are enabled and services list is empty
        // then GetTenantSensorServices is used to get it.
        repeated string Services = 2;
        // Custom database label is not currently supported.
        // optional string DatabaseLabel = 3 [default = "database"];
        optional string NoneDatabasetLabelValue = 4 [default = "<none>"];
        optional string MultipleDatabaseLabelValue = 5 [default = "<multiple>"];
        // Custom slot label is not currently supported.
        // optional string SlotLabel = 6 [default = "slot"];
        optional string StaticSlotLabelValue = 7 [default = "static"];
        optional string DynamicSlotLabelValue = 8 [default = "dynamic"];
        optional string MultipleSlotLabelValue = 9 [default = "<multiple>"];
        optional bool GroupAllMetrics = 10;
    };

    message TDatabaseAttributeLabels {
        message TAttributeGroup {
            // Currently custom list of attributes is not
            // supported. GetTenantAttributeLabels is used
            // to get default list.
            //repeated string Attributes = 1;
            repeated string Services = 2;
        }

        optional bool Enabled = 1 [default = true];
        // If labels are enabled and no attribute group
        // is specified then default one is built using
        // GetTenantAttributeSensorServices and
        // GetTenantAttributeLabels.
        repeated TAttributeGroup AttributeGroups = 2;
    };

    optional uint32 MonitoringPort = 1 [default = 0];
    optional uint32 MonitoringThreads = 2 [default = 10];
    optional string MonitoringCaption = 3 [default = "YDB Developer UI"];
    optional uint32 TabletMonitoringRetries = 4 [default = 1];
    optional bool ForceDatabaseLabels = 5 [default = false];
    optional string MonitoringAddress = 6;
    optional TDatabaseLabels DatabaseLabels = 7;
    optional TDatabaseAttributeLabels DatabaseAttributeLabels = 8;
    optional string DataCenter = 9;
    optional string HostLabelOverride = 10;
    optional string ProcessLocation = 11;
    optional string AllowOrigin = 12;
    optional string RedirectMainPageTo = 13 [default = "monitoring/"];
    optional string MonitoringCertificate = 14;
    optional string MonitoringCertificateFile = 15;
    optional string MemAllocDumpPathPrefix = 16;
}

message TRestartsCountConfig {
    optional string RestartsCountFile = 1 [default = ""];
}

message TMessageBusConfig {

    message TBusQueueConfig {
        optional string Name = 1;
        optional uint32 NumWorkers = 2 [default = 1];
    }

    message TBusSessionConfig {
        optional string Name = 1 [default = ""];
        optional uint32 NumRetries = 2 [default = 0];
        optional uint32 RetryInterval = 3 [default = 1000];
        optional bool   ReconnectWhenIdle = 4 [default = false];
        optional uint64 MaxInFlight = 5 [default = 1000];
        optional uint32 PerConnectionMaxInFlight = 6 [default = 0];
        optional uint32 PerConnectionMaxInFlightBySize = 7 [default = 0];
        optional int64  MaxInFlightBySize = 8 [default = -1];
        optional int64  TotalTimeout = 9 [default = 0];
        optional int64  SendTimeout = 10 [default = 0];
        optional int64  ConnectTimeout = 11 [default = 0];
        optional uint64 DefaultBufferSize = 12 [default = 10240];
        optional uint64 MaxBufferSize = 13 [default = 1048576];
        optional uint32 SocketRecvBufferSize = 14 [default = 0];
        optional uint32 SocketSendBufferSize = 15 [default = 0];
        optional int32  SocketToS = 16 [default = -1];
        optional uint64 SendThreshold = 17 [default = 10240];
        optional uint64 Cork = 18 [default = 0]; // milliseconds
        optional uint32 MaxMessageSize = 19 [default = 0x01A00000];
        optional bool   TcpNoDelay = 20 [default = false];
        optional bool   TcpCork = 21 [default = false];
        optional bool   ExecuteOnMessageInWorkerPool = 22 [default = true];
        optional bool   ExecuteOnReplyInWorkerPool = 23 [default = true];
        optional uint32 ListenPort = 24 [default = 0];
    }

    optional bool   StartBusProxy = 1 [default = false];
    optional uint32 BusProxyPort = 2 [default = 14505];
    optional TBusQueueConfig ProxyBusQueueConfig = 3;
    optional TBusSessionConfig ProxyBusSessionConfig = 4;
    repeated uint64 ProxyBindToProxy = 5;
    optional bool   StartTracingBusProxy = 6 [default = true]; // move to TMessageBusTraceServiceConfig
    optional string TracePath = 7;
    optional uint64 CompileInflightLimit_Depricated = 8 [default = 100000];
}

message TTabletsConfig {

    message TTablet {
        optional string Type = 1;
        repeated uint32 Node = 2;
        optional NKikimrTabletBase.TTabletStorageInfo Info = 3;
        optional bool StandBy = 4;
        optional uint64 WatchThreshold = 5;
    }

    repeated TTablet Tablet = 1;
}

message TKQPConfig {
    optional bool Enable = 1 [default = true];

    repeated NKikimrKqp.TKqpSetting Settings = 10;
}

message TInternalRequestConfig {
    optional uint32 RetryPeriodStartSeconds = 1 [default = 3];
    optional uint32 RetryPeriodFinishSeconds = 2 [default = 30];
}

message TConveyorConfig {
    optional bool Enabled = 1 [default = true];
    optional uint32 WorkersCount = 2;
    optional uint32 QueueSizeLimit = 3;
    optional double DefaultFractionOfThreadsCount = 4;
}

message TExternalIndexConfig {
    optional bool Enabled = 1 [default = true];
    optional TInternalRequestConfig RequestConfig = 2;
    optional string InternalTablePath = 3;
}

message TMetadataProviderConfig {
    optional bool Enabled = 1 [default = true];
    optional uint32 RefreshPeriodSeconds = 2 [default = 10];
    optional TInternalRequestConfig RequestConfig = 3;
    optional string Path = 4;
}

message TBackgroundTasksConfig {
    optional bool Enabled = 1 [default = true];
    optional TInternalRequestConfig RequestConfig = 2;
    optional uint32 PullPeriodSeconds = 3 [default = 10];
    optional uint32 PingPeriodSeconds = 4 [default = 2];
    optional uint32 PingCheckPeriodSeconds = 5 [default = 20];
    optional uint32 MaxInFlight = 6 [default = 8];
    optional string InternalTablePath = 7;
}

message TMemoryLogConfig {
    optional uint64 LogBufferSize = 1;
    optional uint64 LogGrainSize = 2;
}

message TGRpcConfig {
    optional bool   StartGRpcProxy = 1 [default = true];
    optional string Host = 2 [default = "[::]"];
    optional uint32 Port = 3;
    optional uint32 WorkerThreads = 4 [default = 2];
    optional uint64 GRpcMemoryQuotaBytes = 5 [default = 1073741824]; // 1 GB default; 0 == unlimited
    optional uint64 MaxMessageSize = 6; // default = DEFAULT_GRPC_MESSAGE_SIZE_LIMIT
    optional uint32 MaxInFlight = 7; // 0 == unlimited [default]
    optional NKikimrStream.TStreamingConfig StreamingConfig = 8;
    // Ssl part
    optional uint32 SslPort = 9;
    optional string CA = 10;
    optional string Cert = 11;
    optional string Key = 12;
    optional string PathToCertificateFile = 27;
    optional string PathToPrivateKeyFile = 28;
    optional string PathToCaFile = 29;

    // public host/port for publishing
    optional string PublicHost = 13;
    optional uint32 PublicPort = 14;
    optional uint32 PublicSslPort = 15;

    // public addresses for publishing
    repeated string PublicAddressesV4 = 16;
    repeated string PublicAddressesV6 = 17;
    optional string PublicTargetNameOverride = 18;

    // empty service list is 'run most services "what means 'most' in unspecified"'
    repeated string Services = 20;
    optional bool ServeRootDomains = 21 [default = true];
    repeated string ServicesEnabled = 22;
    repeated string ServicesDisabled = 23;

    optional bool SkipSchemeCheck = 24 [default = false];

    repeated string RatelimiterServicesEnabled = 25;
    repeated string RatelimiterServicesDisabled = 26;

    // server socket options
    optional bool   KeepAliveEnable = 100 [default = true]; // SO_KEEPALIVE
    optional uint32 KeepAliveIdleTimeoutTriggerSec = 101 [default = 90]; // TCP_KEEPIDLE
    optional uint32 KeepAliveMaxProbeCount = 102 [default = 3]; // TCP_KEEPCNT
    optional uint32 KeepAliveProbeIntervalSec = 103 [default = 10]; // TCP_KEEPINTVL

    optional uint32 WorkersPerCompletionQueue = 104 [default = 1];
    optional uint32 HandlersPerCompletionQueue = 105 [default = 10];

    optional uint32 GRpcProxyCount = 106 [default = 2];
    optional bool EnableGRpcMemoryQuota = 107 [default = false];

    repeated TGRpcConfig ExtEndpoints = 200; // run specific services on separate endpoints
}

message TDynamicNodeConfig {
    optional string NodeBrokerAddress = 1; //DEPRECATED
    optional string DomainName = 2; //DEPRECATED
    optional uint32 InterconnectPort = 3; //DEPRECATED
    optional NKikimrNodeBroker.TNodeInfo NodeInfo = 4;
    optional string NodeAddress = 5; //DEPRECATED
    optional string NodeHost = 6; //DEPRECATED
    repeated NKikimrLocal.TTabletAvailability TabletAvailability = 7;
}

message THttpProxyConfig {
    optional bool Enabled = 1;
    optional uint32 Port = 2;
    optional bool Secure = 3;
    optional string CA = 4;
    optional string Cert = 5;
    optional string Key = 6;

    repeated string YandexCloudServiceRegion = 7;
    optional string IamTokenServiceEndpoint = 8;
    optional string AccessServiceEndpoint = 9;

    optional string JwtFile = 10;
}

message TS3ProxyResolverConfig {
    message THttpResolverConfig {
        // resolve proxy host to connect to that endpoint using this url
        optional string ResolveUrl = 1;
        // use resolved proxy through these ports
        optional uint32 HttpPort = 2;
        optional uint32 HttpsPort = 3;
    }

    message TEndpoint {
        // S3 endpoint
        optional string Endpoint = 1;
        oneof Resolver {
            THttpResolverConfig HttpResolver = 2;
        }
    }

    repeated TEndpoint Endpoints = 1;
}

message TSqsConfig {
    optional bool EnableSqs = 5;
    optional string Root = 1 [default = "/Root/SQS"];
    // optional uint32 HttpPort = 2 [default = 8771]; // moved to HttpServerConfig

    // URL that must be specified as an entry point to SQS cluster.
    // It must be used if SQS nodes are placed behind the balancer.
    // If this field is not specified, every node uses its own
    // fqdn here.
    optional string Endpoint = 3;

    optional THttpServerConfig HttpServerConfig = 4;

    // Turn on queue leaders option
    optional bool EnableQueueMaster = 6 [default = true]; // TODO: remove
    optional bool EnableQueueLeader = 68 [default = true];

    // Time to live for queue attributes cache
    optional uint64 QueueAttributesCacheTimeMs = 8 [default = 60000];

    // Effective query execution time that is treated as slow query
    optional uint64 SlowRequestTimeMs = 9 [default = 2500];

    // Max time value for long polling (param WaitTimeSeconds for ReceiveMessage)
    optional uint64 MaxWaitTimeoutMs = 10 [default = 20000];

    optional uint32 SchemeCacheSoftRefreshTimeSeconds = 11 [default = 5];
    optional uint32 SchemeCacheHardRefreshTimeSeconds = 12 [default = 10];

    optional bool ForceAccessControl = 13 [default = false];
    repeated string AccountsWithoutMandatoryAuth = 14;

    optional bool YandexCloudMode = 15 [default = false];
    optional uint32 YandexCloudServiceId = 16; // only 15 lesser bits should be used!
    optional string YandexCloudAccessServiceAddress = 29; // host:port
    optional string YandexCloudFolderServiceAddress = 30; // host:port
    optional string YandexCloudResourceManagerServiceAddress = 72; // host:port
    optional string YandexCloudServiceRegion = 39 [default = "ru-central1"];

    optional uint32 MeteringFlushingIntervalMs = 51 [default = 5000];
    optional string MeteringLogFilePath = 52;

    repeated string MeteringCloudNetCidr = 53;
    repeated string MeteringYandexNetCidr = 54;

    // TODO: remove both
    optional uint32 MastersDescriberUpdateTimeMs = 17 [default = 10000];
    optional uint32 MasterConnectTimeoutMs = 18 [default = 10000];

    optional uint32 LeadersDescriberUpdateTimeMs = 69 [default = 10000];
    optional uint32 LeaderConnectTimeoutMs = 70 [default = 10000];

    optional uint64 MinMessageRetentionPeriodMs = 19 [default = 60000];

    // DB requests retries
    optional uint64 TransactionTimeoutMs = 20 [default = 20000]; // If this amount of time elapsed, we don't retry
    optional uint64 TransactionRetryWaitDurationMs = 21 [default = 500]; // First wait time before next retry (+ random component). Then - 2 * TransactionRetryWaitDurationMs and etc
    optional uint64 TransactionMaxRetryWaitDurationMs = 22 [default = 2500]; // Max wait before next retry

    optional uint64 BackgroundMetricsUpdateTimeMs = 23 [default = 10000];

    optional uint64 MaxNumberOfReceiveMessages = 24 [default = 10]; // MaxNumberOfMessages parameter in ReceiveMessage

    optional uint64 RequestTimeoutMs = 25 [default = 600000];

    optional bool ForceQueueCreationV2 = 26 [default = true]; // deprecated, TODO: remove from config
    optional bool ForceQueueDeletionV2 = 27 [default = true]; // deprecated, TODO: remove from config
    optional bool EnableDeadLetterQueues = 41 [default = false];

    optional bool CreateLegacyDurationCounters = 28;

    optional uint64 MinTimeLeftForReceiveMessageWaitMs = 31 [default = 64]; // if wait deadline - now is less than this time, we don't wait in receive message

    optional bool CheckAllShardsInReceiveMessage = 32; // Check all shards in receive message event if deadline is expired now (setting for test)

    optional uint64 CleanupPeriodMs = 33 [default = 150000];
    optional uint64 CleanupBatchSize = 34 [default = 1000]; // Batch size for cleanup queries // Don't set big values

    optional uint64 DeduplicationPeriodMs = 35 [default = 300000]; // Period of time for which deduplication in fifo queues acts
    optional uint64 GroupsReadAttemptIdsPeriodMs = 36 [default = 300000]; // Period of time for which group read attempt ids in fifo queues act
    optional uint64 GroupSelectionBatchSize = 38 [default = 1000];

    optional bool DoAutomaticMigration = 37 [default = true]; // Check and add new columns to queue tables during queue master start

    optional uint64 AddMesagesToInflyBatchSize = 40 [default = 2000];

    message TBatchingPolicy {
        // Optimal parameters: SQS-479
        optional uint64 BatchSize = 1 [default = 200];
        optional uint64 TransactionsMaxInflyPerShard = 2 [default = 20];
    }

    optional TBatchingPolicy StdQueueSendBatchingPolicy = 42;
    optional TBatchingPolicy FifoQueueSendBatchingPolicy = 43;
    optional TBatchingPolicy StdQueueDeleteBatchingPolicy = 44;
    optional TBatchingPolicy FifoQueueDeleteBatchingPolicy = 45;
    optional TBatchingPolicy StdQueueLoadBatchingPolicy = 46;

    message TQuotingConfig {
        // Settings for quoting.
        optional bool EnableQuoting = 1;
        optional uint64 QuotaDeadlineMs = 2;

        message TDefaultActionsRates {
            // Per queue
            optional uint32 StdSendMessageRate = 1; // send message (+batch)
            optional uint32 StdReceiveMessageRate = 2; // receive message
            optional uint32 StdDeleteMessageRate = 3; // delete message (+batch)
            optional uint32 StdChangeMessageVisibilityRate = 4; // change message visibility (+batch)

            optional uint32 FifoSendMessageRate = 5; // send message (+batch)
            optional uint32 FifoReceiveMessageRate = 6; // receive message
            optional uint32 FifoDeleteMessageRate = 7; // delete message (+batch)
            optional uint32 FifoChangeMessageVisibilityRate = 8; // change message visibility (+batch)

            // Per user
            optional uint32 CreateObjectsRate = 9; // create queue, create user
            optional uint32 DeleteObjectsRate = 10; // delete queue, delete user

            optional uint32 OtherRequestsRate = 11; // control requests: get/set queue attributes, list queues, permissions modification, etc
        }

        message TLocalRateLimiterConfig {
            optional TDefaultActionsRates Rates = 1;
        }

        message TKesusQuoterConfig {
            // Not implemented
            optional TDefaultActionsRates DefaultLimits = 1;
        }

        // Only one of quoter configs could be set
        optional TLocalRateLimiterConfig LocalRateLimiterConfig = 3;
        optional TKesusQuoterConfig KesusQuoterConfig = 4;
    }

    optional TQuotingConfig QuotingConfig = 47;
    optional bool EnableQueueAttributesValidation = 48 [default = true];

    message TAccountSettingsDefaults {
        optional int64 MaxQueuesCount = 1 [default = 50];
    }

    optional TAccountSettingsDefaults AccountSettingsDefaults = 49;

    optional bool AllowYandexAttributePrefix = 50;

    optional uint64 QueueCountersExportDelayMs = 55; // Export queue counters after queue creation with delay (milliseconds).
    optional bool CreateLazyCounters = 56 [default = true];

    optional uint64 UserSettingsUpdateTimeMs = 57 [default = 60000];
    optional uint64 UserSettingsReadBatchSize = 58 [default = 1000];
    optional uint64 QueuesListReadBatchSize = 59 [default = 1000];

    optional bool ValidateMessageBody = 60;

    optional uint64 DlqNotificationGracePeriodMs = 61 [default = 60000];

    optional uint64 AddMessagesToInflyCheckPeriodMs = 62 [default = 30000];
    optional uint64 AddMessagesToInflyMinCheckAttempts = 63 [default = 10];

    optional uint64 MinimumGarbageAgeSeconds = 64 [default = 3600];

    optional bool MeteringByNetClassifierOnly = 65 [default = false];

    message TYcSearchEventsConfig {
        optional bool EnableYcSearch = 1 [default = false];
        oneof OutputMethod {
            string UnifiedAgentUri = 10;
            string OutputFileName = 11;
        }
        optional uint64 RescanIntervalSeconds = 3 [default = 60];
        optional uint64 ReindexIntervalSeconds = 4 [default = 14400];
        optional bool TenantMode = 5 [default = false];
    }
    message TOauthTokenConfig {
        required string TokenFile = 1;
    }

    message TJwtConfig {
        required string JwtFile = 1;
        optional string IamEndpoint = 2;
    }

    message TYdbAuthConfig {
        oneof LocalAuthConfig {
            TOauthTokenConfig OauthToken = 1;
            TJwtConfig Jwt = 2;
        }
    }

    optional TYcSearchEventsConfig YcSearchEventsConfig = 66;
    optional TYdbAuthConfig AuthConfig = 67;
    optional uint64 StartLocalLeaderInflightMax = 71 [default = 500];
}

message TConfigsDispatcherConfig {
}

message TCompactionPolicy {
    optional string Name = 1;
    optional NKikimrSchemeOp.TCompactionPolicy CompactionPolicy = 2;
}

message TExecutionPolicy {
    optional string Name = 1;

    optional NKikimrSchemeOp.TPipelineConfig PipelineConfig = 2;
    optional string ResourceProfile = 3;
    optional bool EnableFilterByKey = 4 [default = false];
    optional bool ExecutorFastLogPolicy = 5 [default  = true];
    optional uint64 TxReadSizeLimit = 6;

    optional bool EnableEraseCache = 7;
    optional uint32 EraseCacheMinRows = 8;
    optional uint32 EraseCacheMaxBytes = 9;
}

message TPartitioningPolicy {
    optional string Name = 1;

    optional uint32 UniformPartitionsCount = 2;
    optional bool AutoSplit = 3;
    optional bool AutoMerge = 4;
    optional uint64 SizeToSplit = 5;
    optional uint64 MaxPartitionsCount = 6;
}

message TStoragePolicy {
    optional string Name = 1;
    repeated NKikimrSchemeOp.TFamilyDescription ColumnFamilies = 2;
}

message TReplicationPolicy {
    optional string Name = 1;

    optional uint64 FollowerCount = 2;
    optional bool AllowFollowerPromotion = 3 [default = true];
    optional bool CrossDataCenter = 4;
}

message TCachingPolicy {
    optional string Name = 1;

    optional uint64 ExecutorCacheSize = 2;
}

message TTableProfile {
    optional string Name = 1;
    optional string CompactionPolicy = 2;
    optional string ExecutionPolicy = 3;
    optional string PartitioningPolicy = 4;
    optional string StoragePolicy = 5;
    optional string ReplicationPolicy = 6;
    optional string CachingPolicy = 7;
}

message TTableProfilesConfig {
    repeated TTableProfile TableProfiles = 1;
    repeated TCompactionPolicy CompactionPolicies = 2;
    repeated TExecutionPolicy ExecutionPolicies = 3;
    repeated TPartitioningPolicy PartitioningPolicies = 4;
    repeated TStoragePolicy StoragePolicies = 5;
    repeated TReplicationPolicy ReplicationPolicies = 6;
    repeated TCachingPolicy CachingPolicies = 7;
}

message TFinalizeScriptServiceConfig {
    optional uint64 ScriptFinalizationTimeoutSeconds = 1 [default = 60];
    optional uint32 MaxInFlightFinalizationsCount = 2 [default = 10];
};

message TQueryServiceConfig {
    optional uint64 ScriptOperationTimeoutDefaultSeconds = 1 [default = 604800]; // default = 1 week
    optional uint64 ScriptForgetAfterDefaultSeconds = 2 [default = 31536000]; // default = 1 year; 0 = infinity
    optional uint64 ScriptResultsTtlDefaultSeconds = 3 [default = 2592000];  // default = 1 month; 0 = infinity
    optional uint64 ScriptResultSizeLimit = 4 [default = 0]; // 0 = infinity
    optional uint64 ScriptResultRowsLimit = 5 [default = 0]; // 0 = infinity
    repeated string HostnamePatterns = 13; // List of hostname regexps for external data sources; disabled if empty

    optional NYql.TS3GatewayConfig S3 = 6;
    optional NYql.THttpGatewayConfig HttpGateway = 7;
    optional NYql.TGenericConnectorConfig Connector = 8 [deprecated=true];
    optional string MdbGateway = 9 [deprecated=true];
    optional bool MdbTransformHost = 10;
    optional NYql.TGenericGatewayConfig Generic = 11;
    optional TFinalizeScriptServiceConfig FinalizeScriptServiceConfig = 12;
    optional uint64 ProgressStatsPeriodMs = 14 [default = 0]; // 0 = disabled
}

// Config describes immediate controls and allows
// to manage their values (not variety and limits)
// via CMS. All fields should be either [u]int64 or
// another message.
//
// Control names match field names. For embedded
// messages field names are concatenated via '.'
// symbol. E.g. "DataShardControls.MaxTxInFly".
//
// Min, max and default values are specified in
// field options.
message TImmediateControlOptions {
    optional string Description = 1;
    optional uint64 MinValue = 2;
    optional uint64 MaxValue = 3;
    optional uint64 DefaultValue = 4;
}

extend google.protobuf.FieldOptions {
    optional TImmediateControlOptions ControlOptions = 61001;
}

message TImmediateControlsConfig {
    message TDataShardControls {
        message TExecutionProfileOptions {
            optional uint64 LogThresholdMs = 1 [(ControlOptions) = {
                Description: "Log execution profile for slow operations",
                MinValue: 0,
                MaxValue: 86400000,
                DefaultValue: 0 }];
            optional uint64 BufferThresholdMs = 2 [(ControlOptions) = {
                Description: "Store execution profile for slow operations",
                MinValue: 0,
                MaxValue: 86400000,
                DefaultValue: 0 }];
            optional uint64 BufferSize = 3 [(ControlOptions) = {
                Description: "Slow operation profiles buffer size",
                MinValue: 0,
                MaxValue: 1000,
                DefaultValue: 100 }];
        }

        optional uint64 MaxTxInFly = 1 [(ControlOptions) = {
            Description: "Maximum tx queue size for single shard",
            MinValue: 0,
            MaxValue: 100000,
            DefaultValue: 15000 }];
        optional uint64 DisableByKeyFilter = 2 [(ControlOptions) = {
            Description: "Disable bloom filter usage on row selects",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional uint64 MaxTxLagMilliseconds = 3 [(ControlOptions) = {
            Description: "Max lag in tx plan execution before shard becomes overloaded",
            MinValue: 0,
            MaxValue: 2592000000,
            DefaultValue: 300000 }];
        optional uint64 CanCancelROWithReadSets = 4 [(ControlOptions) = {
            Description: "Allow to cancel RO tx with output read sets by timeout",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
        optional TExecutionProfileOptions DataTxProfile = 5;

        optional uint64 BackupReadAheadLo = 6 [(ControlOptions) = {
            Description: "Override for backup readahead (low watermark)",
            MinValue: 0,
            MaxValue: 67108864,
            DefaultValue: 0 }];
        optional uint64 BackupReadAheadHi = 7 [(ControlOptions) = {
            Description: "Override for backup readahead (high watermark)",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 0 }];

        // Note: these settings are deprecated (always enabled)
        optional uint64 PrioritizedMvccSnapshotReads = 8 [(ControlOptions) = {
            Description: "Enables prioritized mvcc snapshot reads over immediate writes (deprecated, always enabled)",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 UnprotectedMvccSnapshotReads = 9 [(ControlOptions) = {
            Description: "Enables unprotected (fully readonly) mvcc snapshot reads (deprecated, always enabled)",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];

        optional uint64 EnableLeaderLeases = 10 [(ControlOptions) = {
            Description: "Enables leader leases for processing read-only queries",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 MinLeaderLeaseDurationUs = 11 [(ControlOptions) = {
            Description: "The minimum leader lease duration in microseconds",
            MinValue: 1000,
            MaxValue: 5000000,
            DefaultValue: 250000 }];

        optional uint64 TtlReadAheadLo = 12 [(ControlOptions) = {
            Description: "Override for ttl readahead (low watermark)",
            MinValue: 0,
            MaxValue: 67108864,
            DefaultValue: 0 }];
        optional uint64 TtlReadAheadHi = 13 [(ControlOptions) = {
            Description: "Override for ttl readahead (high watermark)",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 0 }];

        optional uint64 EnableLockedWrites = 14 [(ControlOptions) = {
            Description: "Enables experimental persistent locked writes",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 MaxLockedWritesPerKey = 15 [(ControlOptions) = {
            Description: "Maximum number of uncommitted locked writes per key",
            MinValue: 0,
            MaxValue: 1000000,
            DefaultValue: 1000 }];
    }

    message TTxLimitControls {
        optional uint64 PerRequestDataSizeLimit = 1 [(ControlOptions) = {
            Description: "Maximum read data size per transaction",
            MinValue: 0,
            MaxValue: 256000000000000,
            DefaultValue: 53687091200 }];
        optional uint64 PerShardReadSizeLimit = 2 [(ControlOptions) = {
            Description: "Maximum read data size per transaction per shard",
            MinValue: 0,
            MaxValue: 107374182400,
            DefaultValue: 5368709120 }];
        optional uint64 PerShardIncomingReadSetSizeLimit = 3 [(ControlOptions) = {
            Description: "Maximum input read sets size per transaction per shard",
            MinValue: 0,
            MaxValue: 5368709120,
            DefaultValue: 209715200 }];
        optional uint64 DefaultTimeoutMs = 4 [(ControlOptions) = {
            Description: "Default execution timeout for transactions",
            MinValue: 0,
            MaxValue: 3600000,
            DefaultValue: 60000 }];
    }

    message TCoordinatorControls {
        optional uint64 EnableLeaderLeases = 1 [(ControlOptions) = {
            Description: "Enables leader leases for processing read-only queries",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 1 }];
        optional uint64 MinLeaderLeaseDurationUs = 2 [(ControlOptions) = {
            Description: "The minimum leader lease duration in microseconds",
            MinValue: 1000,
            MaxValue: 5000000,
            DefaultValue: 250000 }];
        optional uint64 VolatilePlanLeaseMs = 3 [(ControlOptions) = {
            Description: "Lease in milliseconds for faster volatile transaction planning",
            MinValue: 0,
            MaxValue: 10000,
            DefaultValue: 250 }];
        optional uint64 PlanAheadTimeShiftMs = 4 [(ControlOptions) = {
            Description: "Wall-clock time shift in milliseconds when planning ahead (50ms for compatibility with older versions)",
            MinValue: 0,
            MaxValue: 86400000,
            DefaultValue: 50 }];
    }

    message TSchemeShardControls {
        optional uint64 ForceShardSplitDataSize = 1 [(ControlOptions) = {
            Description: "Forces shards to split when reaching the given data size (2 GiB by default)",
            MinValue: 10485760, // 10 MiB
            MaxValue: 17179869184, // 16 GiB
            DefaultValue: 2147483648 }];
        optional uint64 DisableForceShardSplit = 2 [(ControlOptions) = {
            Description: "Disables forced shard splits, for special cases only",
            MinValue: 0,
            MaxValue: 1,
            DefaultValue: 0 }];
    }

    message TTCMallocControls {
        optional uint64 ProfileSamplingRate = 1 [(ControlOptions) = {
            Description: "Sets the sampling rate for heap profiles. TCMalloc samples approximately every rate bytes allocated.",
            MinValue: 65536,
            MaxValue: 4294967296,
            DefaultValue: 2097152 }];
        optional uint64 GuardedSamplingRate = 2 [(ControlOptions) = {
            Description: "Sets the guarded sampling rate for sampled allocations. TCMalloc samples approximately every rate bytes allocated, subject to implementation limitations in GWP-ASan.",
            MinValue: 65536,
            MaxValue: 4294967296,
            DefaultValue: 4294967296 }];
        optional uint64 MemoryLimit = 3 [(ControlOptions) = {
            Description: "Make a best effort attempt to prevent more than limit bytes of memory from being allocated by the system.",
            MinValue: 0,
            MaxValue: 9223372036854775807,
            DefaultValue: 0 }];
        optional uint64 PageCacheTargetSize = 4 [(ControlOptions) = {
            Description: "Page Cache Target Size.",
            MinValue: 0,
            MaxValue: 137438953472,
            DefaultValue: 536870912 }];
        optional uint64 PageCacheReleaseRate = 5 [(ControlOptions) = {
            Description: "Page Cache Release Rate.",
            MinValue: 0,
            MaxValue: 134217728,
            DefaultValue: 8388608 }];
    }

    message TTracingControls {
        message TSamplingThrottlingOptions {
            message TThrottlingOptions {
                optional uint64 MaxRatePerMinute = 1 [(ControlOptions) = {
                    Description: "Maximum amount of traced requests per minute",
                    MinValue: 0,
                    MaxValue: 300,
                    DefaultValue: 0,
                }];
                optional uint64 MaxBurst = 2 [(ControlOptions) = {
                    Description: "Maximum burst of traced events",
                    MinValue: 0,
                    MaxValue: 300, 
                    DefaultValue: 0,
                }];
            }

            message TSamplingOptions {
                optional uint64 PPM = 1 [(ControlOptions) = {
                    Description: "Average amount of sampled requests per one million",
                    MinValue: 0,
                    MaxValue: 1000000,
                    DefaultValue: 0,
                }];
                optional uint64 Level = 2 [(ControlOptions) = {
                    Description: "Tracing level of sampled requests",
                    MinValue: 1,
                    MaxValue: 15,
                    DefaultValue: 15,
                }];
            }

            optional TSamplingOptions Sampling = 1;
            optional TThrottlingOptions SampledThrottling = 2;
            optional TThrottlingOptions ExternalThrottling = 3;
        }

        message TKeyValue {
            optional TSamplingThrottlingOptions AcquireLock = 1;
            optional TSamplingThrottlingOptions ExecuteTransaction = 2;
            optional TSamplingThrottlingOptions Read = 3;
            optional TSamplingThrottlingOptions ReadRange = 4;
            optional TSamplingThrottlingOptions ListRange = 5;
            optional TSamplingThrottlingOptions GetStorageChannelStatus = 6;
        }

        optional TKeyValue KeyValue = 1;
    }

    optional TDataShardControls DataShardControls = 1;
    optional TTxLimitControls TxLimitControls = 2;
    optional TCoordinatorControls CoordinatorControls = 3;
    optional TSchemeShardControls SchemeShardControls = 4;
    optional TTCMallocControls TCMallocControls = 5;
    optional TTracingControls TracingControls = 6;
};

message TMeteringConfig {
    optional string MeteringFilePath = 1;
    repeated string SystemBackupSIDs = 2;
    optional string LogName = 3;
    optional bool UnifiedAgentEnable = 4 [default = false];
};

message TAuditConfig {
    enum EFormat {
        JSON = 1;
        TXT = 2;
    }

    message TStderrBackend {
        optional EFormat Format = 1 [default = JSON];
    }

    message TFileBackend {
        optional EFormat Format = 1 [default = JSON];
        optional string FilePath = 2;
    }

    message TUnifiedAgentBackend {
        optional EFormat Format = 1 [default = JSON];
        optional string LogName = 2;
    }

    optional TStderrBackend StderrBackend = 1;
    optional TFileBackend FileBackend = 2;
    optional TUnifiedAgentBackend UnifiedAgentBackend = 3;
};

message THiveTabletLimit {
    optional NKikimrTabletBase.TTabletTypes.EType Type = 1;
    optional uint64 MaxCount = 2 [default = 1000000]; // Default value here should match the one in NkikimrLocal.TTabletAvailability
}

message THiveTabletPreference {
    optional NKikimrTabletBase.TTabletTypes.EType Type = 1;
    optional NKikimrHive.TDataCentersPreference DataCentersPreference = 10;
}

message THiveConfig {
    enum EHiveStorageBalanceStrategy {
        HIVE_STORAGE_BALANCE_STRATEGY_AUTO = 0;
        HIVE_STORAGE_BALANCE_STRATEGY_IOPS = 1;
        HIVE_STORAGE_BALANCE_STRATEGY_THROUGHPUT = 2;
        HIVE_STORAGE_BALANCE_STRATEGY_SIZE = 3;
    }

    enum EHiveStorageSelectStrategy {
        HIVE_STORAGE_SELECT_STRATEGY_WEIGHTED_RANDOM = 0;
        HIVE_STORAGE_SELECT_STRATEGY_EXACT_MIN = 1;
        HIVE_STORAGE_SELECT_STRATEGY_RANDOM_MIN_7P = 2;
        HIVE_STORAGE_SELECT_STRATEGY_ROUND_ROBIN = 3;
        HIVE_STORAGE_SELECT_STRATEGY_RANDOM = 4;
    }

    enum EHiveNodeBalanceStrategy {
        HIVE_NODE_BALANCE_STRATEGY_OLD_WEIGHTED_RANDOM = 0;
        HIVE_NODE_BALANCE_STRATEGY_HEAVIEST = 1;
        HIVE_NODE_BALANCE_STRATEGY_RANDOM = 2;
        HIVE_NODE_BALANCE_STRATEGY_WEIGHTED_RANDOM = 3;
    }

    enum EHiveTabletBalanceStrategy {
        HIVE_TABLET_BALANCE_STRATEGY_OLD_WEIGHTED_RANDOM = 0;
        HIVE_TABLET_BALANCE_STRATEGY_HEAVIEST = 1;
        HIVE_TABLET_BALANCE_STRATEGY_RANDOM = 2;
        HIVE_TABLET_BALANCE_STRATEGY_WEIGHTED_RANDOM = 3;
    }

    enum EHiveChannelBalanceStrategy {
        HIVE_CHANNEL_BALANCE_STRATEGY_HEAVIEST = 1;
        HIVE_CHANNEL_BALANCE_STRATEGY_RANDOM = 2;
        HIVE_CHANNEL_BALANCE_STRATEGY_WEIGHTED_RANDOM = 3;
    }

    enum EHiveNodeSelectStrategy {
        HIVE_NODE_SELECT_STRATEGY_WEIGHTED_RANDOM = 0;
        HIVE_NODE_SELECT_STRATEGY_EXACT_MIN = 1;
        HIVE_NODE_SELECT_STRATEGY_RANDOM_MIN_7P = 2;
        HIVE_NODE_SELECT_STRATEGY_RANDOM = 3;
    }

    enum EHiveBootStrategy {
        HIVE_BOOT_STRATEGY_BALANCED = 0;
        HIVE_BOOT_STRATEGY_FAST = 1;
    }

    optional uint64 MaxTabletsScheduled = 2 [default = 100];
    optional uint64 MaxResourceCounter = 3 [default = 100000000];
    optional uint64 MaxResourceCPU = 4 [default = 10000000];
    optional uint64 MaxResourceMemory = 5 [default = 512000000000];
    optional uint64 MaxResourceNetwork = 6 [default = 1000000000];
    optional double MinScatterToBalance = 7 [default = 0.5]; // Does not affect Counter. For other resources can be overriden with resource-specific settings bellow
    optional bool SpreadNeighbours = 8 [default = true];
    optional uint64 MaxBootBatchSize = 9 [default = 1000];
    optional uint64 DrainInflight = 10 [default = 10];
    optional double DefaultUnitIOPS = 11 [default = 1]; // operations/sec
    optional uint64 DefaultUnitThroughput = 12 [default = 1000]; // bytes/sec
    optional uint64 DefaultUnitSize = 13 [default = 100000000]; // bytes
    optional double StorageOvercommit = 14 [default = 1.00];
    optional EHiveStorageBalanceStrategy StorageBalanceStrategy = 15 [default = HIVE_STORAGE_BALANCE_STRATEGY_SIZE];
    optional bool StorageSafeMode = 16 [default = true];
    optional EHiveStorageSelectStrategy StorageSelectStrategy = 17 [default = HIVE_STORAGE_SELECT_STRATEGY_WEIGHTED_RANDOM];
    optional uint64 RequestSequenceSize = 18 [default = 1000];
    optional uint64 MinRequestSequenceSize = 19 [default = 1000];
    optional uint64 MaxRequestSequenceSize = 20 [default = 1000000];
    optional uint64 MetricsWindowSize = 21 [default = 60000]; // milliseconds
    optional double MaxNodeUsageToKick = 22 [default = 0.9];
    optional uint64 ResourceChangeReactionPeriod = 23 [default = 10]; // seconds
    optional uint64 TabletKickCooldownPeriod = 24 [default = 600]; // seconds
    optional double ResourceOvercommitment = 25 [default = 3.00];
    optional uint64 BalancerInflight = 26 [default = 1]; // tablets
    optional EHiveNodeBalanceStrategy NodeBalanceStrategy = 27 [default = HIVE_NODE_BALANCE_STRATEGY_HEAVIEST];
    optional EHiveTabletBalanceStrategy TabletBalanceStrategy = 28 [default = HIVE_TABLET_BALANCE_STRATEGY_WEIGHTED_RANDOM];
    optional double MinPeriodBetweenBalance = 29 [default = 0.2]; // seconds
    optional uint64 MaxMovementsOnAutoBalancer = 30 [default = 1]; // tablets
    optional bool ContinueAutoBalancer = 31 [default = true];
    optional double MinNodeUsageToBalance = 32 [default = 0.1];
    optional double MinPeriodBetweenReassign = 33 [default = 300.0]; // seconds
    optional double TabletRestartWatchPeriod = 34 [default = 3600.0]; // seconds
    optional double NodeRestartWatchPeriod = 35 [default = 3600.0]; // seconds
    optional uint64 NodeDeletePeriod = 36 [default = 14400]; // seconds
    repeated THiveTabletLimit DefaultTabletLimit = 37;
    repeated THiveTabletPreference DefaultTabletPreference = 38;
    optional uint64 SystemTabletCategoryId = 39 [default = 1];
    optional bool EnableFastTabletMove = 40 [default = true];
    optional uint64 TabletRestartsPeriod = 42 [default = 1000]; // milliseconds
    optional uint64 TabletRestarsMaxCount = 43 [default = 2]; // deprecated, use TabletRestartsMaxCount instead
    optional uint64 PostponeStartPeriod = 44 [default = 1000]; // milliseconds
    optional EHiveNodeSelectStrategy NodeSelectStrategy = 45 [default = HIVE_NODE_SELECT_STRATEGY_RANDOM_MIN_7P];
    optional bool CheckMoveExpediency = 46 [default = true];
    optional uint64 StoragePoolFreshPeriod = 47 [default = 60000]; // milliseconds
    optional string PoolsToMonitorForUsage = 48 [default = "System,User,IC"];
    repeated NKikimrTabletBase.TTabletTypes.EType BalancerIgnoreTabletTypes = 49;
    optional double SpaceUsagePenaltyThreshold = 53 [default  = 1.1]; // number > 1
    optional double SpaceUsagePenalty = 54 [default = 0.2]; // number <= 1
    optional uint64 WarmUpBootWaitingPeriod = 50  [default = 30000]; // milliseconds, time to wait for known nodes on cluster restart
    optional uint64 NodeRestartsToIgnoreInWarmup = 51 [default = 10];
    optional double MaxWarmUpPeriod = 52 [default = 600.0]; // seconds
    optional bool WarmUpEnabled = 55 [default = true];
    optional uint64 EmergencyBalancerInflight = 56 [default = 1]; // tablets
    optional uint64 MaxMovementsOnEmergencyBalancer = 57 [default = 2];
    optional bool ContinueEmergencyBalancer = 58 [default = true];
    optional double MinPeriodBetweenEmergencyBalance = 59 [default = 0.1]; // seconds
    optional EHiveBootStrategy BootStrategy = 60 [default = HIVE_BOOT_STRATEGY_BALANCED];
    optional uint64 TabletRestartsMaxCount = 61 [default = 2];
    optional double MinCPUScatterToBalance = 62 [default = 0.5];
    optional double MinMemoryScatterToBalance = 63 [default = 0.5];
    optional double MinNetworkScatterToBalance = 64 [default = 0.5];
    optional double MinCounterScatterToBalance = 65 [default = 0.02];
    reserved 66;
    optional double ObjectImbalanceToBalance = 67 [default = 0.02];
    optional EHiveChannelBalanceStrategy ChannelBalanceStrategy = 68 [default = HIVE_CHANNEL_BALANCE_STRATEGY_WEIGHTED_RANDOM];
    optional uint64 MaxChannelHistorySize = 69 [default = 200];
    optional uint64 StorageInfoRefreshFrequency = 70 [default = 600000]; // send a query to BSC every x milliseconds
    optional double MinStorageScatterToBalance = 71 [default = 0.5];
    optional double MinGroupUsageToBalance = 72 [default = 0.1];
}

message TColumnShardConfig {
    message TTablesStorageLayoutPolicy {
        message TMinimalTablesCountPolicy {
        };

        message TIdentityGroupsPolicy {
        };

        oneof Policy {
            TMinimalTablesCountPolicy MinimalTables = 1;
            TIdentityGroupsPolicy IdentityGroups = 2;
        }

    }
    optional TTablesStorageLayoutPolicy TablesStorageLayoutPolicy = 1;
    optional bool DisabledOnSchemeShard = 2 [default = true];
    optional bool SkipOldGranules = 3 [default = true];
    optional bool IndexationEnabled = 4 [default = true];
    optional bool CompactionEnabled = 5 [default = true];
    optional bool TTLEnabled = 6 [default = true];
    optional bool WritingEnabled = 7 [default = true];
    optional uint32 WritingBufferDurationMs = 8 [default = 0];
    optional bool UseChunkedMergeOnCompaction = 9 [default = true];
    optional uint64 CompactionMemoryLimit = 10 [default = 536870912];
}

message TSchemeShardConfig {
    message TInFlightCounterConfig {
        optional NKikimr.NSchemeShard.ESimpleCounters Type = 1;
        // after this amount scheme shard begin to abort the operations
        // to disable set to 0
        optional uint32 InFlightLimit = 2 [default = 10000];
    }
    // after this amount of time we forcely write full stats to local DB
    // to disable set to 0
    optional uint32 StatsBatchTimeoutMs = 1 [default = 100];

    // number of shards stats to batch together
    // to disable set to 0
    optional uint32 StatsMaxBatchSize = 2 [default = 100];

    optional uint32 StatsMaxExecuteMs = 3 [default = 10];

    repeated TInFlightCounterConfig InFlightCounterConfig = 4;
}

message TCompactionConfig {
    message TBackgroundCompactionConfig {
        optional double MaxRate = 1 [default = 1]; // 1 compaction / s
        optional uint64 InflightLimit = 2 [default = 1];

        // After this interval started compaction is considered as finished,
        // retry is possible only within MinCompactionRepeatDelaySeconds
        optional uint64 TimeoutSeconds = 3 [default = 600];

        // How often schemeshard is waken up to check if it should
        // start any compaction. It is used only when there are no
        // running compactions, otherwise compaction queue logic
        // is triggered either by finished compactions (event from DS)
        // or by timeouts (set via TimeoutSeconds)
        optional uint64 WakeupIntervalSeconds = 4 [default = 60];

        // When shard has been compacted, it will be considered for
        // compaction only after this amount of time
        optional uint64 MinCompactionRepeatDelaySeconds = 5 [default = 600];

        optional uint32 SearchHeightThreshold = 6 [default = 5];

        // TODO: enable, when schemeshard receive proper stat
        optional uint32 RowDeletesThreshold = 7 [default = 4294967295];

        // for tests: to allow compaction requests to empty shards
        // shards below this threshold are not background compacted
        // at all even when searchHeight or deleted rows match
        // corresponding thresholds
        optional uint32 RowCountThreshold = 8 [default = 1];

        // When this option specified, schemeshard calculates compaction rate
        // to compact QueueSize shards within this interval.
        // CompactionRate = Min(QueueSize / RoundSeconds, MaxRate).
        //
        // Note that compaction queue is round robin over three queues:
        // 1. By last full compaction time (all shards)
        // 2. By search height (some shards, depends on SearchHeightThreshold)
        // 3. By row deletes (some shards, depends on RowDeletesThreshold)
        // In queues 2 and 3 same shard can be compacted again after
        // MinCompactionRepeatDelaySeconds depending on its state.
        //
        // Thus when there are items in all queues, RoundSeconds gives the only
        // guarantee, that at least 1/3 unique shards will be compacted, the
        // rest 2/3 can be shards compacted multiple times, i.e. all shards
        // must be compacted within at most RoundSeconds*3.
        optional uint64 RoundSeconds = 9 [default = 172800]; // 2 days

        // Compact even if shard has single part and empty memtable
        optional bool CompactSinglePartedShards = 10 [default = false];

        // Do not wakeup earlier, than this interval
        optional uint64 MinWakeupIntervalMs = 11 [default = 10];
    }

    message TBorrowedCompactionConfig {
        optional double MaxRate = 1 [default = 0]; // unlimitted
        optional uint64 InflightLimit = 2 [default = 10]; // TODO: consider more?

        // After this interval we will try to restart
        optional uint64 TimeoutSeconds = 3 [default = 15];

        // Do not wakeup earlier, than this interval
        optional uint64 MinWakeupIntervalMs = 4 [default = 10];
    }

    optional TBackgroundCompactionConfig BackgroundCompactionConfig = 1;
    optional TBorrowedCompactionConfig BorrowedCompactionConfig = 2;
}

message TTracingConfig {
    message TAuthConfig {
        message TTvm {
            optional string Host = 1;
            optional uint32 Port = 2;

            required uint32 SelfTvmId = 3;
            required uint32 TracingTvmId = 4;

            optional string DiskCacheDir = 5;

            oneof Secret {
                string PlainTextSecret = 6;
                string SecretFile = 7;
                string SecretEnvironmentVariable = 8;
            }
        }

        oneof Method {
            TTvm Tvm = 1;
        }
    }

    optional string Host = 1;
    optional uint32 Port = 2;
    optional string RootCA = 3;
    optional string ServiceName = 4;
    optional TAuthConfig AuthConfig = 5;
}

message TFailureInjectionConfig {
    // approximate time in seconds between self terminations
    optional uint32 ApproximateTerminationInterval = 1 [default = 0]; // disabled by default
}

// This message is used to upload custom service configs
// to CMS. Config name is used to identify owner and
// data format.
// Custom config validators should b8e used to detect name
// conflicts and check config consistency.
message TNamedConfig {
    optional string Name = 1;
    optional bytes Config = 2;
}

message TConfigItemVersion {
    optional uint32 Kind = 1;
    optional uint64 Id = 2;
    optional uint64 Generation = 3;
}

message TConfigVersion {
    repeated TConfigItemVersion Items = 1;
}

message TClientCertificateAuthorization {
    message TSubjectTerm {
        optional string ShortName = 1;
        repeated string Values = 2;
        repeated string Suffixes = 3;
    }

    message TDynamicNodeDefinition {
        repeated TSubjectTerm SubjectTerms = 1;
        optional bool CanCheckNodeHostByCN = 2 [default = false];
    }

    optional TDynamicNodeDefinition DynamicNodeAuthorization = 1;
}

message TLocalPgWireConfig {
    optional int32 ListeningPort = 1 [default = 5432];
    optional string SslCertificate = 5;
    optional string Address = 6 [default = "::"];
}

message TKafkaProxyConfig {
    optional bool EnableKafkaProxy = 1 [default = false];

    optional int32 ListeningPort = 2 [default = 9092];

    // You can either specify the path to the certificate, which will contain both the certificate and the private key,
    // or specify them separately in parameters Cert and Key.
    optional string SslCertificate = 3;
    optional string Cert = 8;
    optional string Key = 9;

    optional uint64 MaxMessageSize = 4 [default = 16777216];
    optional uint64 MaxInflightSize = 5 [default = 16777216];
    optional uint64 PacketSize = 6 [default = 1500];

    message TProxy {
        optional string Hostname = 1;
        optional int32 Port = 2 [default = 9092];
    }

    optional TProxy Proxy = 7;
}

message TAwsCompatibilityConfig {
    optional string AwsRegion = 1;
}

message TLabel {
    optional string Name = 1;
    optional string Value = 2;
}

message TAppConfig {
    optional TActorSystemConfig ActorSystemConfig = 1;
    optional TLogConfig LogConfig = 2;
    optional TStaticNameserviceConfig NameserviceConfig = 3;
    optional TInterconnectConfig InterconnectConfig = 4;
    optional TDomainsConfig DomainsConfig = 5;
    optional TBlobStorageConfig BlobStorageConfig = 6;
    optional TChannelProfileConfig ChannelProfileConfig = 7;
    optional TBootstrap BootstrapConfig = 8;
    optional TMonitoringConfig MonitoringConfig = 10;
    optional TRestartsCountConfig RestartsCountConfig = 11;
    optional TMessageBusConfig MessageBusConfig = 12;
    optional TTabletsConfig TabletsConfig = 13; // alternative bootstrapper configuration
    optional NKikimrBlobStorage.TAllVDiskKinds VDiskConfig = 14;
    optional NKikimrBlobStorage.TDriveModelList DriveModelConfig = 31;
    optional NKikimrBlobStorage.TIncrHugeConfig IncrHugeConfig = 18;
    optional string UDFsDir = 15;
    repeated string UDFsPaths = 16;
    optional TKQPConfig KQPConfig = 17;
    optional TMemoryLogConfig MemoryLogConfig = 19;
    optional TGRpcConfig GRpcConfig = 20;
    optional TDynamicNameserviceConfig DynamicNameserviceConfig = 22;
    //optional TLocalConfig LocalConfig = 23; DEPRECATED
    optional TDynamicNodeConfig DynamicNodeConfig = 24;
    optional NKikimrCms.TCmsConfig CmsConfig = 25;
    optional TFeatureFlags FeatureFlags = 26;
    optional TSqsConfig SqsConfig = 27;
    optional NKikimrPQ.TPQConfig PQConfig = 28;
    optional NKikimrTenantPool.TTenantPoolConfig TenantPoolConfig = 29;
    optional NKikimrProto.TAuthConfig AuthConfig = 30;
    optional NKikimrTenantSlotBroker.TConfig TenantSlotBrokerConfig = 32;
    optional TConfigsDispatcherConfig ConfigsDispatcherConfig = 33;
    optional TTableProfilesConfig TableProfilesConfig = 34;
    optional NKikimrProto.TKeyConfig KeyConfig = 35;
    optional NKikimrProto.TKeyConfig PDiskKeyConfig = 51;
    optional NKikimrNodeBroker.TConfig NodeBrokerConfig = 36;
    optional TTableServiceConfig TableServiceConfig = 37;
    optional NKikimrSharedCache.TSharedCacheConfig SharedCacheConfig = 38; // dynamic configuration via cms
    optional TImmediateControlsConfig ImmediateControlsConfig = 39;
    optional TAllocatorConfig AllocatorConfig = 40;
    optional NKikimrPQ.TPQClusterDiscoveryConfig PQClusterDiscoveryConfig = 41;
    optional NKikimrNetClassifier.TNetClassifierConfig NetClassifierConfig = 42;
    optional NKikimrNetClassifier.TNetClassifierDistributableConfig NetClassifierDistributableConfig = 43; // also dynamic via cms
    optional NKikimrResourceBroker.TResourceBrokerConfig ResourceBrokerConfig = 44;
    optional TMeteringConfig MeteringConfig = 45;
    optional THiveConfig HiveConfig = 46;
    optional TDataShardConfig DataShardConfig = 49;
    optional NFq.NConfig.TConfig FederatedQueryConfig = 58;
    optional TCompactionConfig CompactionConfig = 52;
    optional THttpProxyConfig HttpProxyConfig = 53;
    optional TSchemeShardConfig SchemeShardConfig = 54;
    optional TTracingConfig TracingConfig = 55;
    optional TFailureInjectionConfig FailureInjectionConfig = 56;
    optional THttpProxyConfig PublicHttpConfig = 57;
    optional TMetadataProviderConfig MetadataProviderConfig = 59;
    optional TBackgroundTasksConfig BackgroundTasksConfig = 60;
    optional TAuditConfig AuditConfig = 61;
    optional TClientCertificateAuthorization ClientCertificateAuthorization = 62;
    optional TExternalIndexConfig ExternalIndexConfig = 63;
    optional bool YamlConfigEnabled = 64;
    optional TConveyorConfig ScanConveyorConfig = 65;
    optional TColumnShardConfig ColumnShardConfig = 66;
    optional TLocalPgWireConfig LocalPgWireConfig = 69;
    optional TAwsCompatibilityConfig AwsCompatibilityConfig = 70;
    optional TKafkaProxyConfig KafkaProxyConfig = 71;
    optional TConveyorConfig CompConveyorConfig = 72;
    optional TQueryServiceConfig QueryServiceConfig = 73;
    optional TConveyorConfig InsertConveyorConfig = 74;
    optional bool AllowEditYamlInUi = 75;
    optional TS3ProxyResolverConfig S3ProxyResolverConfig = 76;

    repeated TNamedConfig NamedConfigs = 100;
    optional string ClusterYamlConfig = 101;

    optional TConfigVersion Version = 102;
    repeated TLabel Labels = 103;
}

message TYdbVersion {
    optional uint32 Year = 1;
    optional uint32 Major = 2;
    optional uint32 Minor = 3;
    optional uint32 Hotfix = 4;
}

message TCompatibilityRule {
    enum EComponentId {
        Any = 0;
        Test1 = 1;
        Test2 = 2;
        Interconnect = 3;
        PDisk = 4;
        VDisk = 5;
        BlobStorageController = 6;
        ComponentsCount = 7;
    }

    optional string Application = 1;
    optional TYdbVersion LowerLimit = 2;
    optional TYdbVersion UpperLimit = 3;

    // don't use enum, because stored data can have values from newer YDB versions,
    // which are not included in current version
    optional uint32 ComponentId = 4;

    // don't use Forbidden until it's absolutely necessary
    optional bool Forbidden = 5 [default = false];
}

message TCurrentCompatibilityInfo {
    required string Application = 1;

    // if Version is empty, build is assumed to be non-stable
    optional TYdbVersion Version = 2;

    repeated TCompatibilityRule CanLoadFrom = 3;
    repeated TCompatibilityRule StoresReadableBy = 4;
    repeated TCompatibilityRule CanConnectTo = 5;
}

message TStoredCompatibilityInfo {
    required string Application = 1;

    // if Version is empty, build is assumed to be non-stable
    optional TYdbVersion Version = 2;

    repeated TCompatibilityRule ReadableBy = 3;
}
