import "ydb/core/scheme/protos/type_info.proto";
import "ydb/core/scheme/protos/pathid.proto";
import "ydb/core/protos/bind_channel_storage_pool.proto";
import "ydb/core/protos/pqconfig.proto";
import "ydb/core/protos/replication.proto";
import "ydb/core/protos/table_stats.proto";
import "ydb/core/protos/tablet.proto";
import "ydb/core/protos/subdomains.proto";
import "ydb/core/protos/blockstore_config.proto";
import "ydb/core/protos/filestore_config.proto";
import "ydb/core/protos/channel_purpose.proto";
import "ydb/core/protos/follower_group.proto";
import "ydb/core/protos/blob_depot_config.proto";
import "ydb/public/api/protos/ydb_coordination.proto";
import "ydb/public/api/protos/ydb_export.proto";
import "ydb/public/api/protos/ydb_value.proto";
import "ydb/library/actors/protos/actors.proto";
import "ydb/library/mkql_proto/protos/minikql.proto";
import "ydb/core/protos/index_builder.proto";
import "ydb/core/tx/columnshard/engines/scheme/statistics/protos/data.proto";
import "ydb/core/tx/columnshard/common/protos/snapshot.proto";

import "google/protobuf/empty.proto";

package NKikimrSchemeOp;
option java_package = "ru.yandex.kikimr.proto";

message TMkDir {
    optional string Name = 1;
}

enum EDropWaitPolicy {
    EDropFailOnChanges = 0;
    EDropAbortChanges = 1; //depricated
    EDropWaitChanges = 2;
}

message TDrop {
    optional string Name = 1;
    optional EDropWaitPolicy WaitPolicy = 2;
    optional uint64 Id = 3;
}

enum EColumnCodec {
    ColumnCodecPlain = 0;
    ColumnCodecLZ4 = 1; // lz4fast
    // TODO: there're 3 variants of LZ4 in Arrow: Lz4Frame, Lz4HadoopRaw, Lz4Raw. ColumnCodecLZ4 points to Lz4Frame.
    ColumnCodecZSTD = 2;
}

enum EColumnCache {
    ColumnCacheNone = 0;
    ColumnCacheOnce = 1;
    ColumnCacheEver = 2;
}

enum EColumnStorage {
    ColumnStorage1 = 0;
    ColumnStorage2 = 1;
    ColumnStorage1Ext1 = 2;
    ColumnStorage1Ext2 = 3;
    ColumnStorage2Ext1 = 4;
    ColumnStorage2Ext2 = 5;
    ColumnStorage1Med2Ext2 = 6;
    ColumnStorage2Med2Ext2 = 7;
    ColumnStorageTest_1_2_1k = 999;
}

enum EFreezeState {
    Unspecified = 0;
    Freeze = 1;
    Unfreeze = 2;
}

enum EMvccState {
    MvccUnspecified = 0;
    MvccEnabled = 1;
    MvccDisabled = 2;
}

message TColumnDescription {
    optional string Name = 1;
    optional string Type = 2;
    optional uint32 TypeId = 3;
    optional NKikimrProto.TTypeInfo TypeInfo = 9;
    optional uint32 Id = 4;
    optional uint32 Family = 5; // On default place column to default(0) family
    optional string FamilyName = 6; // set Family by name (0 - "default")
    oneof DefaultValue {
        string DefaultFromSequence = 7; // Path to sequence for default values
        Ydb.TypedValue DefaultFromLiteral = 10; // Literal default value
    }
    optional bool NotNull = 8;
    // flag that indicates that column is currently under the build
    // operation.
    optional bool IsBuildInProgress = 11 [default = false];
}

message TStorageSettings {
    optional string PreferredPoolKind = 1;
    optional bool AllowOtherKinds = 2 [default = true];
}

message TStorageConfig {
    optional TStorageSettings SysLog = 1;
    optional TStorageSettings Log = 2;
    optional TStorageSettings Data = 3;
    optional TStorageSettings External = 4;
    optional uint32 DataThreshold = 5;
    optional uint32 ExternalThreshold = 6;
}

message TKeyValueStorageConfig {
    repeated TStorageSettings Channel = 3;
}

message TFamilyDescription {
    optional uint32 Id = 1;
    optional uint32 Room = 2; // Used by datashard, must not be used by users
    optional uint32 Codec = 3; // DEPRECATED: use ColumnCodec
    optional bool InMemory = 4; // DEPRECATED: use ColumnCache
    optional string Name = 5;
    optional EColumnCodec ColumnCodec = 6;
    optional EColumnCache ColumnCache = 7;
    optional EColumnStorage Storage = 8; // DEPRECATED: use StorageConfig
    optional TStorageConfig StorageConfig = 9;
}

enum ECompactionStrategy {
    CompactionStrategyUnset = 0;
    CompactionStrategyGenerational = 1;
    CompactionStrategySharded = 2; // DEPRECATED: use CompactionStrategyGenerational
}

message TCompactionPolicy {
    message TBackgroundPolicy {
        // How much (in %) of forced compaction criteria should be met to submit background task.
        optional uint32 Threshold = 1 [default = 101]; // no background compaction by default
        // Base background compaction priority value (less priority means more important task).
        // Value is used to compute real task priority basing on compaction criteria, time
        // in queue etc.
        optional uint32 PriorityBase = 2 [default = 100];
        // Submitted background task may become more prioritized over time.
        // New priority is computed as priority /= max(log(elapsed_seconds) * factor, 1);
        optional double TimeFactor = 3 [default = 1.0];
        optional uint32 TaskType = 4 [default = 5]; // DEPRECATED
        optional string ResourceBrokerTask = 5;
    }

    message TGenerationPolicy {
        optional uint32 GenerationId = 1;
        optional uint64 SizeToCompact = 2;
        optional uint32 CountToCompact = 3;
        optional uint32 ForceCountToCompact = 4; // OR one of force limits happend
        optional uint64 ForceSizeToCompact = 5;
        optional uint32 CompactionBrokerQueue = 6; // DEPRECATED
        optional bool KeepInCache = 7;
        optional TBackgroundPolicy BackgroundCompactionPolicy = 8;
        optional string ResourceBrokerTask = 9;
        optional uint32 ExtraCompactionPercent = 10;
        optional uint64 ExtraCompactionMinSize = 11;
        optional uint32 ExtraCompactionExpPercent = 12;
        optional uint64 ExtraCompactionExpMaxSize = 13;
        optional uint64 UpliftPartSize = 14;
    }

    message TShardPolicy {
        // Adjacent shards smaller than this will be merged
        optional uint64 MinShardSize = 1 [default = 33554432];

        // Shards bigger than this will split in two or more pieces
        optional uint64 MaxShardSize = 2 [default = 134217728];

        // Slices smaller than this will get prioritized compaction
        optional uint64 MinSliceSize = 3 [default = 2097152];

        // Level will be compacted when there are more than this number of slices
        optional uint32 MaxSlicesPerLevel = 4 [default = 256];

        // Shard will be compacted when there are more than this number of levels
        optional uint32 MaxTotalLevels = 5 [default = 16];

        // Shard will avoid compacting less than this number of levels
        optional uint32 MinLevelsToCompact = 6 [default = 2];

        // Level will be compacted when it has X% of its data in upper levels
        optional uint32 NewDataPercentToCompact = 7 [default = 100];

        // Level will be compacted when it has X% of its rows in upper levels
        optional uint32 NewRowsPercentToCompact = 8 [default = 0];

        // Resource broker task type for compactions
        optional string ResourceBrokerTask = 9 [default = "compaction_gen1"];

        // Base priority for compaction tasks
        optional uint32 TaskPriorityBase = 10 [default = 1000];

        // Task priority will be increased for every N levels over the minimum
        optional uint32 TaskPriorityLevelsBoost = 11 [default = 1];

        // Task priority will be decreased for every N bytes of input
        optional uint64 TaskPrioritySizePenalty = 12 [default = 4194304];

        // Part data may be reused, unless it would leave this much garbage
        optional uint32 MaxGarbagePercentToReuse = 13 [default = 20];

        // Minimum slice that that may be reused
        optional uint64 MinSliceSizeToReuse = 14 [default = 524288];
    }

    optional uint64 InMemSizeToSnapshot = 1;
    optional uint32 InMemStepsToSnapshot = 2; // snapshot inmem state when size AND steps from last snapshot passed
    optional uint32 InMemForceStepsToSnapshot = 3; // OR steps passed
    optional uint64 InMemForceSizeToSnapshot = 4; // OR size reached
    optional uint32 InMemCompactionBrokerQueue = 5 [default = 0]; // DEPRECATED
    optional uint64 ReadAheadHiThreshold = 6 [default = 67108864];
    optional uint64 ReadAheadLoThreshold = 7 [default = 16777216];
    optional uint32 MinDataPageSize = 8 [default = 7168];   // 7KB is smallest optimal for 512 byte sectors
    optional uint32 SnapBrokerQueue = 9 [default = 0]; // DEPRECATED
    optional uint32 BackupBrokerQueue = 11 [default = 1]; // DEPRECATED
    optional uint32 DefaultTaskPriority = 12 [default = 5];
    optional TBackgroundPolicy BackgroundSnapshotPolicy = 13;
    optional string InMemResourceBrokerTask = 14;
    optional string SnapshotResourceBrokerTask = 15;
    optional string BackupResourceBrokerTask = 16;
    optional uint64 LogOverheadSizeToSnapshot = 17;
    optional uint32 LogOverheadCountToSnapshot = 18;
    optional uint32 DroppedRowsPercentToCompact = 19;
    optional ECompactionStrategy CompactionStrategy = 20 [default = CompactionStrategyUnset];
    optional TShardPolicy ShardPolicy = 21;
    optional bool KeepEraseMarkers = 22;
    optional uint32 MinBTreeIndexNodeSize = 23 [default = 7168];
    optional uint32 MinBTreeIndexNodeKeys = 24 [default = 6];

    repeated TGenerationPolicy Generation = 10;
}

message TFastSplitSettings {
    optional uint64 SizeThreshold = 1;
    optional uint64 RowCountThreshold = 2;
    optional uint32 CpuPercentageThreshold = 3;
}

message TSplitByLoadSettings {
    optional bool Enabled = 1;
    optional uint32 CpuPercentageThreshold = 2;
    // TODO: optional uint32 KeySampleSize = 3;
    // TODO: optional uint32 KeySampleCollectTimeSec = 4;
}

message TPartitioningPolicy {
    optional uint64 SizeToSplit = 1;    // Partition gets split when this threshold is exceeded

    optional uint32 MinPartitionsCount = 2;
    optional uint32 MaxPartitionsCount = 3;

    optional TFastSplitSettings FastSplitSettings = 4;
    optional TSplitByLoadSettings SplitByLoadSettings = 5;
}

message TPipelineConfig {
    optional uint32 NumActiveTx = 1 [default = 8];
    optional uint32 DataTxCacheSize = 2;
    optional bool EnableOutOfOrder = 3 [default = true];
    optional bool DisableImmediate = 4;
    optional bool EnableSoftUpdates = 5;
}

message TPartitionConfig {
    optional string NamedCompactionPolicy = 1; // One of the predefined policies
    optional TCompactionPolicy CompactionPolicy = 2; // Customized policy
    optional uint64 FollowerCount = 3;
    optional uint64 ExecutorCacheSize = 4; // (DEPRECATED) Cache size for the whole tablet including all user and system tables
    optional bool AllowFollowerPromotion = 5 [default = true]; // if true followers can upgrade to leader, if false followers only handle reads
    optional uint64 TxReadSizeLimit = 6; // Maximum size in bytes that is allowed to be read by a single Tx
    //optional bool CrossDataCenterFollowers = 7; // deprecated -> CrossDataCenterFollowerCount
    optional uint32 CrossDataCenterFollowerCount = 8; // deprecated -> FollowerGroups
    optional uint32 ChannelProfileId = 9;   // for configuring erasure and disk categories
    optional TPartitioningPolicy PartitioningPolicy = 10;
    optional TPipelineConfig PipelineConfig = 11;
    repeated TFamilyDescription ColumnFamilies = 12;
    optional string ResourceProfile = 13;
    optional bool DisableStatisticsCalculation = 14; // KIKIMR-3861 hotfix
    optional bool EnableFilterByKey = 15 [default = false]; // Build and use per-part bloom filter for fast key non-existence check
    optional bool ExecutorFastLogPolicy = 16 [default  = true]; // Commit log faster at the expense of bandwidth for cross-DC
    repeated NKikimrStorageSettings.TStorageRoom StorageRooms = 17;
    optional bool EnableEraseCache = 18 [default = true]; // Use erase cache for faster iteration over erased rows
    optional uint32 EraseCacheMinRows = 19; // Minimum number of erased rows worth caching (default 16)
    optional uint32 EraseCacheMaxBytes = 20; // Maximum number of bytes to use for cached rows (default 1MB)
    optional EFreezeState FreezeState = 21;
    optional bool ShadowData = 22; // Table has separate shadow data for later merging
    repeated NKikimrHive.TFollowerGroup FollowerGroups = 23;
    reserved 24; // EMvccState MvccState = 24; no longer used
    optional uint64 KeepSnapshotTimeout = 25; // milliseconds
}

message TSplitBoundary {
    optional NKikimrMiniKQL.TValue KeyPrefix = 1; // A tuple representing full key or key prefix
    optional bytes SerializedKeyPrefix = 2;       // Or same as above but already serialized
}

message TShardIdx {
    optional uint64 OwnerId = 1;
    optional uint64 LocalId = 2;
}

message TTTLSettings {
    enum EUnit {
        UNIT_AUTO = 0;
        UNIT_SECONDS = 1;
        UNIT_MILLISECONDS = 2;
        UNIT_MICROSECONDS = 3;
        UNIT_NANOSECONDS = 4;
    }

    message TSysSettings {
        optional uint64 RunInterval = 1 [default = 3600000000]; // 1 hour
        optional uint64 RetryInterval = 2 [default = 300000000]; // 5 minutes
        optional uint32 BatchMaxBytes = 3 [default = 512000];
        optional uint32 BatchMinKeys = 4 [default = 1];
        optional uint32 BatchMaxKeys = 5 [default = 256];
        optional uint32 MaxShardsInFlight = 6 [default = 0]; // zero means no limit
    }

    message TEnabled {
        optional string ColumnName = 1;
        optional uint32 ExpireAfterSeconds = 2;
        optional EUnit ColumnUnit = 3;
        optional TSysSettings SysSettings = 4;
    }

    message TDisabled {
    }

    oneof Status {
        TEnabled Enabled = 1;
        TDisabled Disabled = 2;
    }

    optional string UseTiering = 3;
}

message TTableReplicationConfig {
    enum EReplicationMode {
        REPLICATION_MODE_NONE = 0;
        REPLICATION_MODE_READ_ONLY = 1;
    }

    enum EConsistency {
        CONSISTENCY_UNKNOWN = 0;
        CONSISTENCY_STRONG = 1;
        CONSISTENCY_WEAK = 2;
    }

    optional EReplicationMode Mode = 1;
    optional EConsistency Consistency = 2;
}

message TTableDescription {
    optional string Name = 1;
    optional uint64 Id_Deprecated = 2; // LocalPathId, deprecated
    repeated TColumnDescription Columns = 3;
    repeated string KeyColumnNames = 4;
    repeated uint32 KeyColumnIds = 5;
    optional uint32 UniformPartitionsCount = 6;     // Describes uniform partitioning on first key column into
                                                    // N ranges. The first key column must be of integer type

    optional TPartitionConfig PartitionConfig = 7;
    repeated TColumnDescription DropColumns = 8;
    optional string Path = 9;

    // It shouldn't be there
    optional bytes PartitionRangeBegin = 20;
    optional bytes PartitionRangeEnd = 21;
    optional bool PartitionRangeBeginIsInclusive = 22;
    optional bool PartitionRangeEndIsInclusive = 23;

    optional string CopyFromTable = 30;
    repeated TSplitBoundary SplitBoundary = 31;     // Boundaries for non-uniform split

    repeated TIndexDescription TableIndexes = 32;

    optional uint64 TableSchemaVersion = 33;

    optional NKikimrProto.TPathID PathId = 34; // TPathId, owerride Id = 2

    optional TTTLSettings TTLSettings = 35;

    optional bool OmitFollowers = 36 [default = false]; // used with CopyFromTable
    optional bool IsBackup = 37 [default = false];

    repeated TCdcStreamDescription CdcStreams = 38;
    repeated TSequenceDescription Sequences = 39;

    optional TTableReplicationConfig ReplicationConfig = 40;

    optional bool Temporary = 41;
}

message TDictionaryEncodingSettings {
   optional bool Enabled = 1;
}

message TCompressionOptions {
    optional EColumnCodec Codec = 2; // LZ4 (in arrow LZ4_FRAME variant) if not set
    optional int32 Level = 3; // Use default compression level if not set (0 != not set)
}

message TOlapColumn {

    message TSerializer {
        optional string ClassName = 1;
        oneof Implementation {
            TCompressionOptions ArrowCompression = 40;
        }
    }
}

message TOlapColumnDiff {
    optional string Name = 1;
    optional TDictionaryEncodingSettings DictionaryEncoding = 4;
    optional TOlapColumn.TSerializer Serializer = 5;
    optional string StorageId = 6;
}

message TOlapColumnDescription {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    // Column name is required, some column names are reserved
    optional string Name = 2;

    optional string Type = 3;
    optional uint32 TypeId = 4; // TypeId cannot be set explicitly, use Type
    optional NKikimrProto.TTypeInfo TypeInfo = 6;
    optional bool NotNull = 7;

    optional TCompressionOptions Compression = 8[deprecated = true];
    optional TDictionaryEncodingSettings DictionaryEncoding = 9;
    optional TOlapColumn.TSerializer Serializer = 10;
    optional string StorageId = 11;
}

message TRequestedBloomFilter {
    optional double FalsePositiveProbability = 1 [default = 0.1];
    repeated string ColumnNames = 3;
}

message TOlapIndexRequested {
    optional string Name = 1;
    optional TCompressionOptions Compression = 3;
    optional string StorageId = 4;

    optional string ClassName = 39;
    oneof Implementation {
        TRequestedBloomFilter BloomFilter = 40;
    }
}

message TBloomFilter {
    optional double FalsePositiveProbability = 1 [default = 0.1];
    optional uint64 MaxBytesCount = 2 [default = 8196];
    repeated uint32 ColumnIds = 3;
}

message TOlapIndexDescription {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    optional string Name = 2;
    optional TCompressionOptions Compression = 3;

    optional string StorageId = 4;

    optional string ClassName = 40;
    oneof Implementation {
        TBloomFilter BloomFilter = 41;
    }
}

enum EColumnTableEngine {
    COLUMN_ENGINE_NONE = 0;
    COLUMN_ENGINE_REPLACING_TIMESERIES = 1;
}

enum EOlapProgramType {
    OLAP_PROGRAM_SSA_PROGRAM = 1;
    OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS = 2;
}

message TStorageTierConfig {
    optional string Name = 1;
    optional TS3Settings ObjectStorage = 2;
    optional TCompressionOptions Compression = 3;
}

message TCompactionPlannerConstructorContainer {
    optional string ClassName = 1;

    message TLOptimizer {

    }

    message TSOptimizer {
        optional string LogicName = 1;
        optional uint32 FreshnessCheckDurationSeconds = 2 [default = 300];
    }

    oneof Implementation {
        TLOptimizer LBuckets = 20;
        TSOptimizer SBuckets = 21;
    }
}

message TColumnTableSchemeOptions {
    optional bool SchemeNeedActualization = 1 [default = false];
    optional bool ExternalGuaranteeExclusivePK = 2 [default = false];
    optional TCompactionPlannerConstructorContainer CompactionPlannerConstructor = 3;
}

message TColumnTableSchema {
    // A list of columns for tables with this schema
    repeated TOlapColumnDescription Columns = 1;
    repeated string KeyColumnNames = 2;

    // A type of engine used by the table
    optional EColumnTableEngine Engine = 3;

    // Internal fields
    optional uint32 NextColumnId = 4;

    // Incremented on each schema change
    optional uint64 Version = 5 [default = 1];

    //optional EColumnCodec DefaultCompressionCodec = 6; // deprecated, not used before replace
    //optional int32 DefaultCompressionLevel = 7; // deprecated, not used before replace
    optional TCompressionOptions DefaultCompression = 8;

    optional bool CompositeMarksDeprecated = 9 [ default = false ];
    repeated TOlapIndexDescription Indexes = 10;
    repeated NKikimrColumnShardStatisticsProto.TOperatorContainer Statistics = 11;
    optional TColumnTableSchemeOptions Options = 12;
}

message TColumnTableRequestedOptions {
    optional bool SchemeNeedActualization = 1 [default = false];
    optional bool ExternalGuaranteeExclusivePK = 2;
    optional TCompactionPlannerConstructorContainer CompactionPlannerConstructor = 3;
}

message TAlterColumnTableSchema {
    repeated TOlapColumnDescription AddColumns = 1;
    //optional TCompressionOptions DefaultCompression = 5;
    repeated TOlapColumnDescription DropColumns = 6;
    repeated TOlapColumnDiff AlterColumns = 7;
    repeated TOlapIndexRequested UpsertIndexes = 8;
    repeated string DropIndexes = 9;
    repeated NKikimrColumnShardStatisticsProto.TConstructorContainer UpsertStatistics = 10;
    repeated string DropStatistics = 11;
    optional TColumnTableRequestedOptions Options = 12;
}

// Schema presets are used to manage multiple tables with the same schema
// Tables may be created without an explicit list of columns, linking to the
// same schema preset. Later schema presets may be altered, effectively
// altering all tables that have the same preset.
message TColumnTableSchemaPreset {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    // Preset name is required, preset named "default" will be used by default
    optional string Name = 2;

    optional TColumnTableSchema Schema = 3;
}

message TAlterColumnTableSchemaPreset {
    // Existing preset name to alter
    optional string Name = 1;

    optional TAlterColumnTableSchema AlterSchema = 2;
}

message TRemoveColumnTableSchemaPreset {
    // Existing preset name to remove
    optional string Name = 1;
}

// TTL and external storage eviction policies
message TColumnDataLifeCycle {
    message TTtl {
        optional string ColumnName = 1;
        oneof Expire {
            uint32 ExpireAfterSeconds = 2;
            uint64 ExpireAfterBytes = 4;
        }
        optional TTTLSettings.EUnit ColumnUnit = 3;
    }

    message TDisabled {
    }

    oneof Status {
        TTtl Enabled = 1;
        TDisabled Disabled = 2;
    }

    // Incremented on each settings change
    optional uint64 Version = 3 [default = 1];

    optional string UseTiering = 5;
}

message TColumnTableTtlSettingsPreset {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    // Preset name is required, preset named "default" will be used by default
    optional string Name = 2;

    optional TColumnDataLifeCycle TtlSettings = 3;
}

message TAlterColumnTableTtlSettingsPreset {
    // Existing preset name to alter
    optional string Name = 1;

    optional TColumnDataLifeCycle AlterTtlSettings = 2;
}

message TRemoveColumnTableTtlSettingsPreset {
    // Existing preset name to remove
    optional string Name = 1;
}

message TColumnStorageConfig {
    optional TStorageSettings SysLog = 1;
    optional TStorageSettings Log = 2;
    optional TStorageSettings Data = 3;
    optional uint32 DataChannelCount = 4;
}

// This is used internally by schemeshard
message TColumnStoreSharding {
    repeated TShardIdx ColumnShards = 2;
}

message TColumnStoreDescription {
    optional string Name = 1;
    optional uint32 RESERVED_MetaShardCount = 2;
    optional uint32 ColumnShardCount = 3;
    repeated uint64 RESERVED_MetaShards = 4;
    repeated uint64 ColumnShards = 5;
    repeated TColumnTableSchemaPreset SchemaPresets = 6;
    repeated TColumnTableTtlSettingsPreset RESERVED_TtlSettingsPresets = 7;
    optional TColumnStorageConfig StorageConfig = 10;

    // Internal fields
    optional uint32 NextSchemaPresetId = 8;
    optional uint32 NextTtlSettingsPresetId = 9;
}

message TAlterColumnStore {
    optional string Name = 1;
    repeated TColumnTableSchemaPreset AddSchemaPresets = 2;
    repeated TAlterColumnTableSchemaPreset AlterSchemaPresets = 3;
    repeated TRemoveColumnTableSchemaPreset RemoveSchemaPresets = 4;
    repeated TColumnTableTtlSettingsPreset RESERVED_AddTtlSettingsPresets = 5;
    repeated TAlterColumnTableTtlSettingsPreset RESERVED_AlterTtlSettingsPresets = 6;
    repeated TRemoveColumnTableTtlSettingsPreset RESERVED_RemoveTtlSettingsPresets = 7;
}

message TConsistencyShardingTablet {
    optional uint64 TabletId = 1;
    optional uint64 HashIntervalLeftClosed = 2;
    optional uint64 HashIntervalRightOpened = 3;
}

message TModuloShardingTablet {
    optional uint64 TabletId = 1;
    repeated uint32 AppropriateMods = 2;
}

message THashShardingInfo {
    repeated string ColumnNames = 1;
}

message TGranuleConsistencyShardingInfo {
    optional THashShardingInfo Hashing = 1;
    optional TConsistencyShardingTablet ShardInfo = 2;
}

message TGranuleModuloShardingInfo {
    optional THashShardingInfo Hashing = 1;
    optional TModuloShardingTablet ShardInfo = 2;
    optional uint64 ModuloPartsCount = 3;
}

message TGranuleShardingLogicContainer {
    optional string ClassName = 1;
    oneof Implementation {
        TGranuleConsistencyShardingInfo Consistency = 20;
        TGranuleModuloShardingInfo Modulo = 21;
    }
}

message TGranuleShardingInfo {
    optional uint64 PathId = 1;
    optional uint64 VersionId = 2;
    optional TGranuleShardingLogicContainer Container = 3;
}

message TGranuleShardInfo {
    optional uint64 TabletId = 1;
    optional uint32 SequenceIdx = 2;
    optional bool IsOpenForRead = 3;
    optional bool IsOpenForWrite = 4;
    optional NKikimrColumnShardProto.TSnapshot OpenForWriteSnapshot = 5;
    optional uint64 ShardingVersion = 6;
}

message TColumnTableSharding {
    // An ordered list of currently used column shards
    // This field is managed by the system.
    repeated uint64 ColumnShards = 2;

    // Random sharding chooses a random shard for new data at write time
    message TRandomSharding {
        // No additional fields
    }

    // Hash sharding is based on a hash of specified columns' values at write time.
    message THashSharding {
        enum EHashFunction {
            // A simple hash modulo number of shards
            HASH_FUNCTION_MODULO_N = 0;
            HASH_FUNCTION_CLOUD_LOGS = 1;
            HASH_FUNCTION_CONSISTENCY_64 = 2;
        }

        // Hash function used for mapping column values to a column shard
        optional EHashFunction Function = 1 [default = HASH_FUNCTION_MODULO_N];

        // A list of columns used for hashing, must not be empty
        repeated string Columns = 2;

        // Argument for HASH_FUNCTION_CLOUD_LOGS
        optional uint32 ActiveShardsCount = 4;
        repeated TConsistencyShardingTablet TabletsForConsistency = 5;

        optional uint32 ModuloPartsCount = 6;
        repeated TModuloShardingTablet TabletsForModulo = 7;
    }

    oneof Method {
        TRandomSharding RandomSharding = 5;
        THashSharding HashSharding = 6;
    }

    repeated TGranuleShardInfo ShardsInfo = 7;
}

message TColumnTableDescription {
    optional string Name = 1;

    // When creating a table these may be omitted, then ttl preset will be
    // used instead. When describing current schema and settings are always
    // returned.
    optional TColumnTableSchema Schema = 2;
    optional TColumnDataLifeCycle TtlSettings = 3;

    // Table may be created using presets specific to the olap store.
    optional uint32 SchemaPresetId = 4;
    optional string SchemaPresetName = 6;

    // Associated olap store id, initialized by schemeshard
    // May be missing for tables that are not part of an ColumnStore
    optional NKikimrProto.TPathID ColumnStorePathId = 8;

    // Specifies the desired number of ColumnShards for this table
    optional uint32 ColumnShardCount = 9;

    // Sharding schema used by this table, may be used for specifying sharding settings
    optional TColumnTableSharding Sharding = 10;

    // Internal fields that make sure versions always increase when presets are switched
    optional uint64 SchemaPresetVersionAdj = 11;
    optional uint64 TtlSettingsPresetVersionAdj = 12;

    // Channels for standalone column table
    optional TColumnStorageConfig StorageConfig = 13;
}

message TAlterColumnTable {
    optional string Name = 1;

    optional TAlterColumnTableSchema AlterSchema = 2;
    optional TColumnDataLifeCycle AlterTtlSettings = 3;

    optional string AlterSchemaPresetName = 4;
    optional string RESERVED_AlterTtlSettingsPresetName = 5;

    optional TAlterShards AlterShards = 6;
    optional TReshardColumnTable ReshardColumnTable = 7;
}

message TReshardColumnTable {
    optional bool Increase = 1;
}

message TLoginCreateUser {
    optional string User = 1;
    optional string Password = 2;
}

message TLoginModifyUser {
    optional string User = 1;
    optional string Password = 2;
}

message TLoginRemoveUser {
    optional string User = 1;
    optional bool MissingOk = 2;
}

message TLoginCreateGroup {
    optional string Group = 1;
}

message TLoginAddGroupMembership {
    optional string Group = 1;
    optional string Member = 2;
}

message TLoginRemoveGroupMembership {
    optional string Group = 1;
    optional string Member = 2;
}

message TLoginRenameGroup {
    optional string Group = 1;
    optional string NewName = 2;
}

message TLoginRemoveGroup {
    optional string Group = 1;
    optional bool MissingOk = 2;
}

message TAlterLogin {
    oneof Alter {
        TLoginCreateUser CreateUser = 1;
        TLoginModifyUser ModifyUser = 2;
        TLoginRemoveUser RemoveUser = 3;
        TLoginCreateGroup CreateGroup = 4;
        TLoginAddGroupMembership AddGroupMembership = 5;
        TLoginRemoveGroupMembership RemoveGroupMembership = 6;
        TLoginRemoveGroup RemoveGroup = 7;
        TLoginRenameGroup RenameGroup = 8;
    }
}

enum ECdcStreamState {
    ECdcStreamStateInvalid = 0;
    ECdcStreamStateReady = 1;
    ECdcStreamStateDisabled = 2;
    ECdcStreamStateScan = 3;
}

enum ECdcStreamMode {
    ECdcStreamModeInvalid = 0;
    ECdcStreamModeKeysOnly = 1;
    ECdcStreamModeUpdate = 2;
    ECdcStreamModeNewImage = 3;
    ECdcStreamModeOldImage = 4;
    ECdcStreamModeNewAndOldImages = 5;
}

enum ECdcStreamFormat {
    ECdcStreamFormatInvalid = 0;
    ECdcStreamFormatProto = 1;
    ECdcStreamFormatJson = 2;
    ECdcStreamFormatDynamoDBStreamsJson = 3;
    ECdcStreamFormatDebeziumJson = 4;
}

message TCdcStreamDescription {
    optional string Name = 1;
    optional ECdcStreamMode Mode = 2;
    optional ECdcStreamFormat Format = 6;
    optional bool VirtualTimestamps = 7;
    optional NKikimrProto.TPathID PathId = 3;
    optional ECdcStreamState State = 4;
    optional uint64 SchemaVersion = 5;
    repeated TUserAttribute UserAttributes = 8;
    // AwsRegion used to mark records in DynamoDB-compatible mode (FormatDynamoDBStreamsJson)
    optional string AwsRegion = 9;
    // Set to '0' to disable resolved timestamps
    optional uint64 ResolvedTimestampsIntervalMs = 10;
}

message TCreateCdcStream {
    optional string TableName = 1;
    optional TCdcStreamDescription StreamDescription = 2;
    optional uint64 RetentionPeriodSeconds = 3 [default = 86400]; // 1d by default
    optional uint32 TopicPartitions = 4;
    oneof IndexMode {
        google.protobuf.Empty AllIndexes = 5; // Create topic per each index
        string IndexName = 6;
    }
}

message TAlterCdcStream {
    optional string TableName = 1;
    optional string StreamName = 2;

    message TDisable {
    }

    message TGetReady {
        optional uint64 LockTxId = 1;
    }

    oneof Action {
        TDisable Disable = 3;
        TGetReady GetReady = 4;
    }
}

message TDropCdcStream {
    optional string TableName = 1;
    optional string StreamName = 2;
}

message TContinuousBackupDescription {
}

message TCreateContinuousBackup {
    optional string TableName = 1;
    optional TContinuousBackupDescription ContinuousBackupDescription = 2;
}

message TAlterContinuousBackup {
    optional string TableName = 1;

    message TStop {
    }

    message TTakeIncrementalBackup {
    }

    oneof Action {
        TStop Stop = 2;
        TTakeIncrementalBackup TakeIncrementalBackup = 3;
    }
}

message TDropContinuousBackup {
    optional string TableName = 1;
}

enum EIndexType {
    EIndexTypeInvalid = 0;
    EIndexTypeGlobal = 1;
    EIndexTypeGlobalAsync = 2;
    EIndexTypeGlobalUnique = 3;
}

enum EIndexState {
    EIndexStateInvalid = 0;
    EIndexStateReady = 1;
    EIndexStateNotReady = 2;
    EIndexStateWriteOnly = 3;
}

message TIndexDescription {
    optional string Name = 1;
    optional uint64 LocalPathId = 2;

    optional EIndexType Type = 3;
    optional EIndexState State = 4;

    repeated string KeyColumnNames = 5;

    optional uint64 SchemaVersion = 6; // Schema version of abstract index (not impl table)

    optional uint64 PathOwnerId = 7;

    repeated string DataColumnNames = 8;
    // DataSize + IndexSize of indexImplTable
    optional uint64 DataSize = 9;
}

message TIndexCreationConfig {
    optional string Name = 1;
    repeated string KeyColumnNames = 2;
    optional EIndexType Type = 3;
    optional TTableDescription IndexImplTableDescription = 4; //description for index impl table
    optional EIndexState State = 5; //state of index at the creation time
    repeated string DataColumnNames = 6; //columns to be denormalized to read data just from index
}

message TIndexAlteringConfig {
    optional string Name = 1;
    optional EIndexState State = 2;
}

message TIndexedTableCreationConfig {
    optional TTableDescription TableDescription = 1;
    repeated TIndexCreationConfig IndexDescription = 2;
    repeated TSequenceDescription SequenceDescription = 3;
}

message TInitiateBuildIndexMainTable {
    optional string TableName = 1;
}

message TBuildIndexOutcome {
    message TCancel {
        // Path id of the index whose creation was cancelled
        optional NKikimrProto.TPathID IndexPathId = 1;
    }

    oneof Result {
        google.protobuf.Empty Apply = 1;
        TCancel Cancel = 2;
    }
}

message TFinalizeBuildIndexMainTable {
    optional string TableName = 1;
    optional uint64 SnapshotTxId = 2;
    optional uint64 BuildIndexId = 3;
    optional TBuildIndexOutcome Outcome = 4;
}

message TCopyTableConfig { //TTableDescription implemets copying a table in original and full way
    optional string SrcPath = 1;
    optional string DstPath = 2;

    optional bool OmitIndexes = 3 [default = false];
    optional bool OmitFollowers = 4 [default = false];
    optional bool IsBackup = 5 [default = false];
}

message TConsistentTableCopyingConfig {
    repeated TCopyTableConfig CopyTableDescriptions = 1;
}

message TYTSettings {
    optional string Host = 1;
    optional string TablePattern = 2;
    optional string Token = 3;
    optional uint32 Port = 4 [default = 80];

    reserved 5; // YSONasText
    reserved 6; // AddScheme
    reserved 7; // CreateYTTable

    optional bool UseTypeV3 = 8;
};

message TSecretId {
    optional string Id = 1;
    optional string OwnerId = 2;
}

message TSecretValue {
    optional string Data = 1;
}

message TSecretableVariable {
    oneof Data {
        TSecretId SecretId = 1;
        TSecretValue Value = 2;
    }
}

message TS3Settings {
    enum EScheme {
        HTTP = 0;
        HTTPS = 1;
    }

    optional string Endpoint = 1;
    optional EScheme Scheme = 2 [default = HTTPS];
    optional string Bucket = 3;
    optional string ObjectKeyPattern = 4; // dst for backup, src for restore
    optional string AccessKey = 5;
    optional string SecretKey = 6;
    optional Ydb.Export.ExportToS3Settings.StorageClass StorageClass = 7 [default = STANDARD];
    optional bool VerifySSL = 8;
    optional string ProxyHost = 9;
    optional uint32 ProxyPort = 10;
    optional EScheme ProxyScheme = 11;
    optional string Region = 12;
    optional TSecretableVariable SecretableAccessKey = 13;
    optional TSecretableVariable SecretableSecretKey = 14;
    optional bool UseVirtualAddressing = 15 [default = true];

    message TLimits {
        optional uint32 ReadBatchSize = 1 [default = 8388608]; // 8 MB
        optional uint32 MinWriteBatchSize = 2 [default = 5242880]; // 5 MB
        reserved 3; // ReadBufferSizeLimit
    };

    optional TLimits Limits = 100;
    optional uint32 RequestTimeoutMs = 101;
    optional uint32 HttpRequestTimeoutMs = 102;
    optional uint32 ConnectionTimeoutMs = 103;

    optional uint32 ExecutorThreadsCount = 104 [default = 32];
    optional uint32 MaxConnectionsCount = 105 [default = 32];
};

message TTaskCleaner {
    optional uint64 PathId = 1;
    optional TS3Settings StorageSettings = 2;
    optional string TieringId = 3;
}

message TBackupTask {
    optional string TableName = 1;
    optional uint64 TableId = 2;
    optional uint32 ShardNum = 3;
    optional uint32 NumberOfRetries = 5;

    reserved 6; // IfFailedBeforeTxId
    reserved 7; // UserProvidedId
    reserved 8; // UserProvidedComment

    oneof Settings {
        TYTSettings YTSettings = 4;
        TS3Settings S3Settings = 9;
    }

    optional TPathDescription Table = 10; // for further restore

    message TScanSettings {
        optional uint64 RowsBatchSize = 1 [default = 0]; // no limit
        optional uint64 BytesBatchSize = 2 [default = 33554432]; // 32 MB
    }

    optional TScanSettings ScanSettings = 11;
    optional bool NeedToBill = 12;

    message TCompressionOptions {
        optional string Codec = 1;
        optional int32 Level = 2;
    }

    optional TCompressionOptions Compression = 13; // currently available for s3

    optional uint64 SnapshotStep = 14;
    optional uint64 SnapshotTxId = 15;
}

message TRestoreTask {
    optional string TableName = 1;
    optional uint64 TableId = 2;
    optional TTableDescription TableDescription = 3;
    optional uint32 ShardNum = 4;
    optional uint32 NumberOfRetries = 5;

    oneof Settings {
        TS3Settings S3Settings = 6;
    }
}

message TPersQueueGroupAllocate {
    message TPartition {
        optional uint32 PartitionId = 1;
        optional uint64 GroupId = 2;
        optional uint64 TabletId = 3;

        optional uint64 OwnerId = 4;
        optional uint64 ShardId = 5;

        optional NKikimrPQ.ETopicPartitionStatus Status = 6;
        repeated uint32 ParentPartitionIds = 7;
        optional NKikimrPQ.TPartitionKeyRange KeyRange = 10;
    }

    optional string Name = 1;
    optional uint64 AlterVersion = 2;

    optional uint32 TotalGroupCount = 3;
    optional uint32 NextPartitionId = 4;
    optional uint32 PartitionPerTablet = 5;

    optional NKikimrPQ.TPQTabletConfig PQTabletConfig = 6;
    repeated TPartition Partitions = 7;

    optional uint64 BalancerTabletID = 8;
    optional uint64 BalancerOwnerId = 9;
    optional uint64 BalancerShardId = 10;
}

message TPersQueueGroupDeallocate {
    optional string Name = 1;
}

message TPersQueueGroupDescription {

    message TPartition {
        optional uint32 PartitionId = 1;
        optional uint64 TabletId = 2;
        optional NKikimrPQ.TPartitionKeyRange KeyRange = 3;
        optional NKikimrPQ.ETopicPartitionStatus Status = 4;
        repeated uint32 ParentPartitionIds = 5;
        repeated uint32 ChildPartitionIds = 6;
    }

    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint32 TotalGroupCount = 3; // mandatory
    message TPartitionToAdd {
        optional uint32 PartitionId = 1;
        optional uint32 GroupId = 2;
    }
    repeated TPartitionToAdd PartitionsToAdd = 9;
    repeated uint32 PartitionsToDelete = 10;
    optional uint32 NextPartitionId = 11;
    optional uint32 PartitionPerTablet = 4; // default = 10
    optional NKikimrPQ.TPQTabletConfig PQTabletConfig = 5; // mandatory
    repeated TPartition Partitions = 6; // do not set
    optional uint64 AlterVersion = 7;
    optional uint64 BalancerTabletID = 8;

    // Can be passed upon creation.
    // PQTabletConfig.PartitionKeySchema must be set.
    // Size must be equal to TotalGroupCount - 1
    repeated NKikimrMiniKQL.TValue PartitionBoundaries = 12;

    // Can be passed upon creation
    optional NKikimrPQ.TBootstrapConfig BootstrapConfig = 13;

    optional TPersQueueGroupAllocate Allocate = 14;

    message TPartitionSplit {
        required uint32 Partition = 1;
        required bytes SplitBoundary = 2;
    }
    repeated TPartitionSplit Split = 15;

    message TPartitionMerge {
        required uint32 Partition = 1;
        required uint32 AdjacentPartition = 2;
    }
    repeated TPartitionMerge Merge = 16;
}

message TRtmrVolumeDescription {
    message TPartition {
        optional bytes PartitionId = 1;
        optional uint64 BusKey = 2;
        optional uint64 TabletId = 3;
    }

    optional string Name = 1;
    optional uint64 PathId = 2;
    optional uint64 PartitionsCount = 3;
    repeated TPartition Partitions = 4;
}

message TBlockStoreVolumeDescription {
    message TPartition {
        optional uint32 PartitionId = 1;
        optional uint64 TabletId = 2;
    }

    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional NKikimrBlockStore.TVolumeConfig VolumeConfig = 3; // mandatory
    repeated TPartition Partitions = 4; // do not set
    optional uint64 VolumeTabletId = 5; // do not set
    optional uint64 AlterVersion = 6; // do not set
    optional string MountToken = 7; // do not set
    optional uint64 TokenVersion = 8; // do not set
}

message TFileStoreDescription {
    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint64 IndexTabletId = 3; // do not set
    optional NKikimrFileStore.TConfig Config = 4; // mandatory
    optional uint64 Version = 5; // do not set
}

message TKesusDescription {
    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint64 KesusTabletId = 3; // do not set
    optional Ydb.Coordination.Config Config = 4;
    optional uint64 Version = 5; // do not set
}

message TSolomonVolumeDescription {
    message TPartition {
        optional uint64 PartitionId = 1;
        optional uint64 TabletId = 2;
        optional uint64 ShardIdx = 3;
        repeated NKikimrStoragePool.TChannelBind BoundChannels = 4;
    }

    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint64 PartitionCount = 3;
    repeated TPartition Partitions = 4;
}

message TCreateSolomonVolume {
    message TAdoptedPartition {
        optional uint64 OwnerId = 1;
        optional uint64 ShardIdx = 2;
        optional uint64 TabletId = 3;
    }

    optional string Name = 1; // mandatory
    optional uint32 ChannelProfileId = 2;

    optional uint64 PartitionCount = 3;                // it is a mutually exclusive parametr
    repeated TAdoptedPartition AdoptedPartitions = 4; // with this one

    optional TKeyValueStorageConfig StorageConfig = 5;
}

message TAlterSolomonVolume {
    optional string Name = 1; // mandatory

    optional uint32 ChannelProfileId = 2;

    optional uint64 PartitionCount = 3;

    optional bool UpdateChannelsBinding = 4 [default = false];

    optional TKeyValueStorageConfig StorageConfig = 5;
}

message TBlockStoreAssignOp {
    optional string Name = 1; // mandatory
    optional string NewMountToken = 2; // unset to unassign
    optional uint64 TokenVersion = 3;
}

message TDropBlockStoreVolume {
    optional uint64 FillGeneration = 1;
}

message TModifyACL {
    optional string Name = 1;
    optional bytes DiffACL = 2; // NACLibProto.TDiffACL
    optional string NewOwner = 3;
}

message TSplitMergeTablePartitions {
    optional uint64 TxId = 1;
    optional string TablePath = 2;
    optional uint64 TableLocalId = 3;
    repeated uint64 SourceTabletId = 4;
    repeated TSplitBoundary SplitBoundary = 5;  // Points of split (there will be N+1 parts)
    optional uint64 SchemeshardId = 6;          // Only needed if TableId is used instead of path
    optional uint64 TableOwnerId = 7;
}

message TUserAttribute {
    optional string Key = 1;
    optional string Value = 2;
}

message TAlterUserAttributes {
    optional string PathName = 1;
    repeated TUserAttribute UserAttributes = 2;
}

message TMove { // private description of the operation
    optional string SrcPath = 1;
    optional string DstPath = 2;
}

message TMoveIndex {
    optional string TablePath = 1;
    optional string SrcPath = 2;
    optional string DstPath = 3;
    optional bool AllowOverwrite = 4;
}

message TSequenceDescription {
    message TSetVal {
        optional sint64 NextValue = 1;
        optional bool NextUsed = 2;
    }
    optional string Name = 1; // mandatory
    optional NKikimrProto.TPathID PathId = 2; // sequence path id, assigned by schemeshard
    optional uint64 Version = 3; // incremented every time sequence is altered
    optional uint64 SequenceShard = 4; // current sequenceshard, assigned by schemeshard

    optional sint64 MinValue = 5; // minimum value, defaults to 1 or Min<i64>
    optional sint64 MaxValue = 6; // maximum value, defaults to Max<i64> or -1
    optional sint64 StartValue = 7; // start value, defaults to MinValue
    optional uint64 Cache = 8; // number of items to cache, defaults to 1
    optional sint64 Increment = 9; // increment at each call, defaults to 1
    optional bool Cycle = 10; // true when cycle on overflow is allowed
    optional TSetVal SetVal = 11; // SetVal(NextValue, NextUsed) is executed atomically when creating
}

message TSequenceSharding {
    // The last shard is the one currently active
    repeated TShardIdx SequenceShards = 1;
}

message TReplicationDescription {
    optional string Name = 1;
    optional NKikimrReplication.TReplicationConfig Config = 2;
    optional NKikimrProto.TPathID PathId = 3; // path id assigned by schemeshard
    optional uint64 Version = 4;
    optional uint64 ControllerId = 5; // replication controller's tablet id
    optional NKikimrReplication.TReplicationState State = 6;
}

message TBlobDepotDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional NKikimrBlobDepot.TBlobDepotConfig Config = 4;
    optional fixed64 TabletId = 5; // for unsharded mode
}

enum EOperationType {
    ESchemeOpMkDir = 1;
    ESchemeOpCreateTable = 2;
    ESchemeOpCreatePersQueueGroup = 3;
    ESchemeOpDropTable = 4;
    ESchemeOpDropPersQueueGroup = 5;
    ESchemeOpAlterTable = 6;
    ESchemeOpAlterPersQueueGroup = 7;
    ESchemeOpModifyACL = 8;
    ESchemeOpRmDir = 9;
    ESchemeOpSplitMergeTablePartitions = 10;
    ESchemeOpBackup = 11;
    ESchemeOpCreateSubDomain = 12;
    ESchemeOpDropSubDomain = 13;
    ESchemeOpCreateRtmrVolume = 14;
    ESchemeOpCreateBlockStoreVolume = 15;
    ESchemeOpAlterBlockStoreVolume = 16;
    ESchemeOpAssignBlockStoreVolume = 17;
    ESchemeOpDropBlockStoreVolume = 18;
    ESchemeOpCreateKesus = 19;
    ESchemeOpDropKesus = 20;
    ESchemeOpForceDropSubDomain = 21;
    ESchemeOpCreateSolomonVolume = 22;
    ESchemeOpDropSolomonVolume = 23;
    ESchemeOpAlterKesus = 24;
    ESchemeOpAlterSubDomain = 25;
    ESchemeOpAlterUserAttributes = 26;

    // *************
    // Unsafe operation. Nornally it is used for deleting database. It called by CMS, and CMS takes care of remaining resourses.
    // If you apply it manually to an ordinary path in cases of emergenses, be aware of:
    // 1 -- data transactions are ignored. Distributed transactions colud be broken so progress on other shards would be blocked forever
    // 2 -- boorowed/loans blobs could be lost forever.
    //
    ESchemeOpForceDropUnsafe = 27;
    //
    // *************

    ESchemeOpCreateIndexedTable = 28;
    ESchemeOpCreateTableIndex = 29;
    ESchemeOpCreateConsistentCopyTables = 30;
    ESchemeOpDropTableIndex = 31;
    ESchemeOpCreateExtSubDomain = 32;
    ESchemeOpAlterExtSubDomain = 33;
    ESchemeOpForceDropExtSubDomain = 34;
    ESchemeOp_DEPRECATED_35 = 35;
    ESchemeOpUpgradeSubDomain = 36;
    ESchemeOpUpgradeSubDomainDecision = 37;
    ESchemeOpCreateIndexBuild = 38;
    ESchemeOpInitiateBuildIndexMainTable = 39;
    ESchemeOpCreateLock = 40;
    ESchemeOpApplyIndexBuild = 41;
    ESchemeOpFinalizeBuildIndexMainTable = 42;
    ESchemeOpAlterTableIndex = 43;
    ESchemeOpAlterSolomonVolume = 44;
    ESchemeOpDropLock = 45;

    ESchemeOpFinalizeBuildIndexImplTable = 46;
    ESchemeOpInitiateBuildIndexImplTable = 47;

    ESchemeOpDropIndex = 48;
    ESchemeOpDropTableIndexAtMainTable = 49;

    ESchemeOpCancelIndexBuild = 50;

    ESchemeOpCreateFileStore = 51;
    ESchemeOpAlterFileStore = 52;
    ESchemeOpDropFileStore = 53;

    ESchemeOpRestore = 54;

    ESchemeOpCreateColumnStore = 55;
    ESchemeOpAlterColumnStore = 56;
    ESchemeOpDropColumnStore = 57;
    ESchemeOpCreateColumnTable = 58;
    ESchemeOpAlterColumnTable = 59;
    ESchemeOpDropColumnTable = 60;

    ESchemeOpAlterLogin = 61;

    /// CDC
    // Create
    ESchemeOpCreateCdcStream = 62;
    ESchemeOpCreateCdcStreamImpl = 63;
    ESchemeOpCreateCdcStreamAtTable = 64;
    // Alter
    ESchemeOpAlterCdcStream = 65;
    ESchemeOpAlterCdcStreamImpl = 66;
    ESchemeOpAlterCdcStreamAtTable = 67;
    // Drop
    ESchemeOpDropCdcStream = 68;
    ESchemeOpDropCdcStreamImpl = 69;
    ESchemeOpDropCdcStreamAtTable = 70;

    ESchemeOpMoveTable = 71;
    ESchemeOpMoveTableIndex = 72;

    // Sequences
    ESchemeOpCreateSequence = 73;
    ESchemeOpAlterSequence = 74;
    ESchemeOpDropSequence = 75;

    // Replication
    ESchemeOpCreateReplication = 76;
    ESchemeOpAlterReplication = 77;
    ESchemeOpDropReplicationCascade = 78;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // BlobDepot
    ESchemeOpCreateBlobDepot = 79;
    ESchemeOpAlterBlobDepot = 80;
    ESchemeOpDropBlobDepot = 81;

    // Move index
    ESchemeOpMoveIndex = 82;

    ESchemeOpAllocatePersQueueGroup = 83;
    ESchemeOpDeallocatePersQueueGroup = 84;

    // AlterExtSubDomain suboperations
    ESchemeOpAlterExtSubDomainCreateHive = 85;

    // External Table
    ESchemeOpCreateExternalTable = 86;
    ESchemeOpDropExternalTable = 87;
    ESchemeOpAlterExternalTable = 88;

    // External Data Source
    ESchemeOpCreateExternalDataSource = 89;
    ESchemeOpDropExternalDataSource = 90;
    ESchemeOpAlterExternalDataSource = 91;

    ESchemeOpCreateColumnBuild = 92;

    // View
    ESchemeOpCreateView = 93;
    ESchemeOpAlterView = 94;
    ESchemeOpDropView = 95;

    ESchemeOpDropReplication = 96;

    /// ContinuousBackup
    // Create
    ESchemeOpCreateContinuousBackup = 97;
    // Alter
    ESchemeOpAlterContinuousBackup = 98;
    // Drop
    ESchemeOpDropContinuousBackup = 99;
}

message TApplyIf {
    optional uint64 PathId = 1;
    optional uint64 PathVersion = 2;
    optional uint64 LockedTxId = 3;
    optional bool CheckEntityVersion = 4 [default = false];
}

message TUpgradeSubDomain {
    optional string Name = 1;

    enum EDecision {
        Invalid = 0;
        Undo = 2;
        Commit = 3;
    }

    optional EDecision Decision = 2;
}

message TIndexBuildConfig {
    optional string Table = 1;
    optional TIndexCreationConfig Index = 2;
}

message TIndexBuildControl {
    optional string TablePath = 1;
    optional string IndexName = 2;
    optional uint64 SnaphotTxId = 3;
    optional uint64 BuildIndexId = 4;
}

message TLockConfig {
    optional string Name = 1;
    optional bool AllowIndexImplLock = 2;
}

message TLockGuard {
    optional uint64 OwnerTxId = 1;
}

message TDropIndex {
    optional string TableName = 1;
    optional string IndexName = 2;
}

message TConsistencyShardsModification {
    repeated TConsistencyShardingTablet Shards = 1;
}

message TModuloShardsModification {
    repeated TModuloShardingTablet Shards = 1;
    optional uint32 PartsCount = 2;
}

message TShardingModification {
    repeated uint64 NewShardIds = 1;
    repeated uint64 DeleteShardIds = 2;

    repeated uint64 CloseWriteIds = 3;
    repeated uint64 CloseReadIds = 4;
    repeated uint64 OpenWriteIds = 5;
    repeated uint64 OpenReadIds = 6;

    oneof Implementation {
        TConsistencyShardsModification Consistency = 20;
        TModuloShardsModification Modulo = 21;
    }
}

message TShardingTransfer {
    optional uint64 DestinationTabletId = 1;
    repeated uint64 SourceTabletIds = 2;
    optional bool Moving = 3 [default = false];
}

message TShardingTransfers {
    repeated TShardingTransfer Transfers = 1;
}

message TAlterShards {
    oneof Implementation {
        TShardingModification Modification = 20;
        TShardingTransfers Transfer = 21;
    }
}

// Request for scheme modification
// Has only one of the operations
message TModifyScheme {
    optional string WorkingDir = 1;
    optional EOperationType OperationType = 2;
    optional bool Internal = 36 [default = false]; // internal operations are not generated directly by the user
    optional bool FailOnExist = 50 [default = false]; // as a replacement for TEvModifySchemeTransaction.FailOnExist
    optional bool AllowAccessToPrivatePaths = 53 [default = false];

    optional TMkDir MkDir = 3;
    optional TTableDescription CreateTable = 4;
    optional TPersQueueGroupDescription CreatePersQueueGroup = 5;
    optional TPersQueueGroupDescription AlterPersQueueGroup = 6;
    optional TDrop Drop = 7;
    optional TModifyACL ModifyACL = 8;
    optional TTableDescription AlterTable = 9;
    optional TSplitMergeTablePartitions SplitMergeTablePartitions = 10;
    optional TBackupTask Backup = 11;
    optional NKikimrSubDomains.TSubDomainSettings SubDomain = 12;
    optional TRtmrVolumeDescription CreateRtmrVolume = 13;
    optional TBlockStoreVolumeDescription CreateBlockStoreVolume = 14;
    optional TBlockStoreVolumeDescription AlterBlockStoreVolume = 15;
    optional TBlockStoreAssignOp AssignBlockStoreVolume = 16;
    optional TKesusDescription Kesus = 17;
    optional TCreateSolomonVolume CreateSolomonVolume = 18;
    optional TAlterUserAttributes AlterUserAttributes = 19;
    repeated TApplyIf ApplyIf = 20;
    optional TIndexCreationConfig CreateTableIndex = 21;
    optional TIndexedTableCreationConfig CreateIndexedTable = 22;
    optional TConsistentTableCopyingConfig CreateConsistentCopyTables = 23;
    reserved 24;
    optional TUpgradeSubDomain UpgradeSubDomain = 25;
    optional TIndexBuildConfig InitiateIndexBuild = 26;
    optional TInitiateBuildIndexMainTable InitiateBuildIndexMainTable = 27;
    optional TLockConfig LockConfig = 28;
    optional TLockGuard LockGuard = 29;
    optional TIndexAlteringConfig AlterTableIndex = 30;
    optional TFinalizeBuildIndexMainTable FinalizeBuildIndexMainTable = 31;
    optional TIndexBuildControl ApplyIndexBuild = 32;
    optional TAlterSolomonVolume AlterSolomonVolume = 33;
    optional TDropIndex DropIndex = 34;
    optional TIndexBuildControl CancelIndexBuild = 35;
    optional TFileStoreDescription CreateFileStore = 37;
    optional TFileStoreDescription AlterFileStore = 38;
    optional TRestoreTask Restore = 39;
    optional TColumnStoreDescription CreateColumnStore = 40;
    optional TColumnTableDescription CreateColumnTable = 41;
    optional TAlterColumnStore AlterColumnStore = 42;
    optional TAlterColumnTable AlterColumnTable = 43;
    optional TAlterLogin AlterLogin = 44;
    optional TCreateCdcStream CreateCdcStream = 45;
    optional TAlterCdcStream AlterCdcStream = 46;
    optional TDropCdcStream DropCdcStream = 47;
    optional TMove MoveTable = 48;
    optional TMove MoveTableIndex = 49;
    optional TSequenceDescription Sequence = 51;
    optional TReplicationDescription Replication = 52;

    optional TBlobDepotDescription BlobDepot = 54;
    optional TMoveIndex MoveIndex = 55;

    optional TPersQueueGroupAllocate AllocatePersQueueGroup = 56;
    optional TPersQueueGroupDeallocate DeallocatePersQueueGroup = 57;

    optional TExternalTableDescription CreateExternalTable = 58;

    optional TExternalDataSourceDescription CreateExternalDataSource = 59;

    optional TDropBlockStoreVolume DropBlockStoreVolume = 60;

    optional NKikimrIndexBuilder.TColumnBuildSettings InitiateColumnBuild = 61;

    optional bool SuccessOnNotExist = 62;

    optional bool FailedOnAlreadyExists = 63 [default = true];

    optional TViewDescription CreateView = 64;

    optional NActorsProto.TActorId TempTableOwnerActorId = 65;

    optional TCopySequence CopySequence = 66;
    optional TReplicationDescription AlterReplication = 67;

    optional TCreateContinuousBackup CreateContinuousBackup = 68;
    optional TAlterContinuousBackup AlterContinuousBackup = 69;
    optional TDropContinuousBackup DropContinuousBackup = 70;
}

message TCopySequence {
    optional string CopyFrom = 1;
}

// "Script", used by client to parse text files with multiple DDL commands
message TModifyScript {
    repeated TModifyScheme ModifyScheme = 1;
}

message TDescribeOptions {
    optional bool ReturnPartitioningInfo = 1 [default = true];
    optional bool ReturnPartitionConfig = 2 [default = true];
    optional bool BackupInfo = 3 [default = false];
    optional bool ReturnPartitionStats = 4 [default = false];
    optional bool ReturnChildren = 5 [default = true];
    optional bool ReturnBoundaries = 6 [default = false];
    optional bool ShowPrivateTable = 7 [default = false];
    optional bool ReturnChannelsBinding = 8 [default = false];
    optional bool ReturnRangeKey = 9 [default = true];
    optional bool ReturnSetVal = 10 [default = false];
}

// Request to read scheme for a specific path
// Path can be specified in two ways:
// 1. full path
// 2. (schemeshard id, path id) pair that is unique within the whole system
message TDescribePath {
    optional string Path = 1;
    optional uint64 PathId = 2;
    optional uint64 SchemeshardId = 3;

    optional bool ReturnPartitioningInfo = 4 [default = true]; // deprecated
    optional bool ReturnPartitionConfig = 5 [default = true]; //  deprecated
    optional bool BackupInfo = 6 [default = false];           //  deprecated

    optional TDescribeOptions Options = 7;
}

// Must be sync with Ydb::EntryType
enum EPathType {
    EPathTypeInvalid = 0;
    EPathTypeDir = 1;
    EPathTypeTable = 2;
    EPathTypePersQueueGroup = 3;
    EPathTypeSubDomain = 4;
    EPathTypeRtmrVolume = 5;
    EPathTypeBlockStoreVolume = 6;
    EPathTypeKesus = 7;
    EPathTypeSolomonVolume = 8;
    EPathTypeTableIndex = 9; // Used for abstract index
    EPathTypeExtSubDomain = 10;
    EPathTypeFileStore = 11;
    EPathTypeColumnStore = 12;
    EPathTypeColumnTable = 13;
    EPathTypeCdcStream = 14;
    EPathTypeSequence = 15;
    EPathTypeReplication = 16;
    EPathTypeBlobDepot = 17;
    EPathTypeExternalTable = 18;
    EPathTypeExternalDataSource = 19;
    EPathTypeView = 20;
}

enum EPathSubType {
    EPathSubTypeEmpty = 0;
    EPathSubTypeSyncIndexImplTable = 1;
    EPathSubTypeAsyncIndexImplTable = 2;
    EPathSubTypeStreamImpl = 3;
}

enum EPathState {
    EPathStateNotExist = 1;
    EPathStateNoChanges = 2;
    EPathStateCreate = 3;
    EPathStateAlter = 4;
    EPathStateDrop = 5;
    EPathStateCopying = 6;
    EPathStateBackup = 7;
    EPathStateUpgrade = 8;
    EPathStateMigrated = 9;
    EPathStateRestore = 10;
    EPathStateMoving = 11;
}

message TPathVersion {
    optional uint64 GeneralVersion = 1;

    optional uint64 ACLVersion = 2;
    optional uint64 EffectiveACLVersion = 3;
    optional uint64 UserAttrsVersion = 4;
    optional uint64 ChildrenVersion = 5;
    optional uint64 SubDomainVersion = 6;
    optional uint64 TableSchemaVersion = 7;
    optional uint64 TablePartitionVersion = 8;
    optional uint64 TableIndexVersion = 9;
    optional uint64 PQVersion = 10;
    optional uint64 BSVVersion = 11;
    optional uint64 KesusVersion = 12;
    optional uint64 RTMRVersion = 13;
    optional uint64 SolomonVersion = 14;
    optional uint64 FileStoreVersion = 15;
    optional uint64 ColumnStoreVersion = 16;
    optional uint64 ColumnTableVersion = 17;
    optional uint64 SubDomainStateVersion = 19;
    optional uint64 ColumnTableSchemaVersion = 20;
    optional uint64 ColumnTableTtlSettingsVersion = 21;
    optional uint64 CdcStreamVersion = 22;
    optional uint64 SecurityStateVersion = 23;
    optional uint64 SequenceVersion = 24;
    optional uint64 ReplicationVersion = 25;
    optional uint64 BlobDepotVersion = 26;
    optional uint64 ExternalTableVersion = 27;
    optional uint64 ExternalDataSourceVersion = 28;
    optional uint64 ViewVersion = 29;
}

// Describes single path
message TDirEntry {
    optional string Name = 1;
    optional uint64 PathId = 2;
    optional uint64 SchemeshardId = 3; // PathOwnerId
    optional EPathType PathType = 4;
    optional bool CreateFinished = 5;
    optional uint64 CreateTxId = 6;
    optional uint64 CreateStep = 7;
    optional uint64 ParentPathId = 8; // parentPathOwnerId ?
    optional EPathState PathState = 9;
    optional string Owner = 10;
    optional bytes ACL = 11;
    optional bytes EffectiveACL = 12;
    optional uint64 PathVersion = 13;
    optional EPathSubType PathSubType = 14;
    optional TPathVersion Version = 15;

    optional uint64 BalancerTabletID = 999; //temporary optimization for old PQ read/write protocol. Must be removed later
}

// Describes single partition (range or point) of a table
message TTablePartition {
    optional bytes EndOfRangeKeyPrefix = 1;     // Serialize/deserialize using TSerializedCellVec
    optional bool IsPoint = 2;
    optional bool IsInclusive = 3;
    optional uint64 DatashardId = 4;
}

message TShardError {
    optional uint64 ShardId = 1;
    optional string Explain = 2;
};

message TBackupProgress {
    optional uint32 NotCompleteYet = 1;
    optional uint32 Total = 2;
    optional uint32 ErrorCount = 3;
    optional uint64 StartTime = 4;
    repeated TShardError Errors = 5;
    optional TYTSettings YTSettings = 6;
    optional uint64 DataTotalSize = 7;
    optional uint64 TxId = 8;
}

message TLastBackupResult {
    optional uint32 ErrorCount = 1;
    optional uint64 CompleteTimeStamp = 2;
    optional uint64 StartTimeStamp = 3;
    repeated TShardError Errors = 4;
    optional TYTSettings YTSettings = 5;
    optional uint64 DataTotalSize = 6;
    optional uint64 TxId = 7;
};

// Result for TDescribePath request
message TPathDescription {
    optional TDirEntry Self = 1;                    // info about the path itself
    repeated TDirEntry Children = 2;                // for directory
    optional TTableDescription Table = 3;           // for table
    repeated TTablePartition TablePartitions = 4;   // for table
    optional TPersQueueGroupDescription PersQueueGroup = 5; // for pq group
    optional TBackupProgress BackupProgress = 6;
    repeated TLastBackupResult LastBackupResult = 7;
    optional NKikimrTableStats.TTableStats TableStats = 8;
    optional NKikimrTabletBase.TMetrics TabletMetrics = 9;
    optional NKikimrSubDomains.TDomainDescription DomainDescription = 10;
    optional TRtmrVolumeDescription RtmrVolumeDescription = 11; // for rtmr volume
    optional TBlockStoreVolumeDescription BlockStoreVolumeDescription = 12;
    optional TKesusDescription Kesus = 13;
    optional TSolomonVolumeDescription SolomonDescription = 14;
    repeated NKikimrTableStats.TTableStats TablePartitionStats = 15;
    repeated TUserAttribute UserAttributes = 16;
    optional TIndexDescription TableIndex = 17;
    repeated NKikimrTabletBase.TMetrics TablePartitionMetrics = 18;
    repeated uint64 AbandonedTenantsSchemeShards = 19;
    optional TFileStoreDescription FileStoreDescription = 20;
    optional TColumnStoreDescription ColumnStoreDescription = 21;
    optional TColumnTableDescription ColumnTableDescription = 22;
    optional TCdcStreamDescription CdcStreamDescription = 23;
    optional TSequenceDescription SequenceDescription = 24;
    optional TReplicationDescription ReplicationDescription = 25;
    optional TBlobDepotDescription BlobDepotDescription = 26;
    optional TExternalTableDescription ExternalTableDescription = 27;
    optional TExternalDataSourceDescription ExternalDataSourceDescription = 28;
    optional TViewDescription ViewDescription = 29;
}

// For persisting AlterTable Tx description in Schemeshard internal DB
message TAlterExtraData {
    optional TPartitionConfig PartitionConfig = 1;
}

message TResourceProfile {
    // Here is how tablet resource profile with specified NAME and TYPE is searched:
    //  1. Search for profile NAME for tablet TYPE.
    //  2. Search for profile 'default' for tablet TYPE.
    //  3. Search for profile NAME for tablet 'Unknown'.
    //  4. Search for profile 'default' for tablet 'Unknown'.
    //  5. Use default NKikimrSchemeOp.TResourceProfile value.
    optional NKikimrTabletBase.TTabletTypes.EType TabletType = 1 [default = Unknown];
    optional string Name = 2;
    // Memory used by tablet (not related to transactions and executor cache).
    // Used only for new tablets with no memory usage statistics collected.
    optional uint64 DefaultTabletMemoryUsage = 3 [default = 1048576]; //1MB
    // Max static memory consumption for tablet transactions. Additional memory should
    // be requested in Resource Broker.
    optional uint64 StaticTabletTxMemoryLimit = 4 [default = 0]; // Unlimited by default.
    // Max static memory consumption for a single transaction. If transaction requires
    // more memory then it has to be requested via Resource Broker.
    optional uint64 StaticTxMemoryLimit = 5 [default = 262144000]; // 250MB.
    // Memory consumption limit for transactions. Transactions requiring more
    // memory should be terminated.
    optional uint64 TxMemoryLimit = 6 [default = 0]; // Unlimited by default.
    // Memory initially allocated for transaction data (doesn't include pages used
    // by transaction). Additional memory should be requested by transaction via
    // transaction context.
    optional uint64 InitialTxMemory = 7 [default = 4194304]; // 4MB
    // Memory consumption limit for small transactions.
    optional uint64 SmallTxMemoryLimit = 8 [default = 10485760]; // 10MB
    // Memory consumption limit for medium transactions.
    optional uint64 MediumTxMemoryLimit = 9 [default = 104857600]; // 100MB
    // Resource Broker task type for small transactions.
    optional string SmallTxTaskType = 10 [default = "transaction"];
    // Resource Broker task type for medium transactions.
    optional string MediumTxTaskType = 11 [default = "transaction"];
    // Resource Broker task type for large transactions.
    optional string LargeTxTaskType = 12 [default = "transaction"];
}

message TExternalTableDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string SourceType = 4;
    optional string DataSourcePath = 5;
    optional string Location = 6;
    repeated TColumnDescription Columns = 7;
    optional bytes Content = 8;
    optional bool ReplaceIfExists = 9; // Only applicable for `create external table` operation
}

// Access without authorization
message TNoneAuth {
}

message TServiceAccountAuth {
    optional string Id = 1;
    optional string SecretName = 2;
}

message TMdbBasic {
    optional string ServiceAccountId = 1;
    optional string ServiceAccountSecretName = 2;
    optional string Login = 3;
    optional string PasswordSecretName = 4;
}

message TAws {
    optional string AwsAccessKeyIdSecretName = 1;
    optional string AwsSecretAccessKeySecretName = 2;
    optional string AwsRegion = 3;
}

message TBasic {
    optional string Login = 1;
    optional string PasswordSecretName = 2;
}

message TToken {
    optional string TokenSecretName = 2;
}

message TAuth {
    oneof identity {
        TNoneAuth None = 3;
        TServiceAccountAuth ServiceAccount = 4;
        TBasic Basic = 5;
        TMdbBasic MdbBasic = 6;
        TAws Aws = 7;
        TToken Token = 8;
    }
}

message TExternalTableReferences {
    message TReference {
        optional string Path = 1;
        optional NKikimrProto.TPathID PathId = 2;
    }
    repeated TReference References = 1;
}

message TExternalDataSourceProperties {
    map<string, string> Properties = 1;
}

message TExternalDataSourceDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string SourceType = 4;
    optional string Location = 5;
    optional string Installation = 6;
    optional TAuth Auth = 7;
    optional TExternalDataSourceProperties Properties = 8;
    optional bool ReplaceIfExists = 9;
}

message TViewDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string QueryText = 4;
}
