import "ydb/core/protos/bind_channel_storage_pool.proto";
import "ydb/core/protos/blob_depot_config.proto";
import "ydb/core/protos/blockstore_config.proto";
import "ydb/core/protos/channel_purpose.proto";
import "ydb/core/protos/compaction.proto";
import "ydb/core/protos/filestore_config.proto";
import "ydb/core/protos/follower_group.proto";
import "ydb/core/protos/index_builder.proto";
import "ydb/core/protos/pqconfig.proto";
import "ydb/core/protos/replication.proto";
import "ydb/core/protos/s3_settings.proto";
import "ydb/core/protos/schemeshard/operations.proto";
import "ydb/core/protos/subdomains.proto";
import "ydb/core/protos/sys_view_types.proto";
import "ydb/core/protos/table_stats.proto";
import "ydb/core/protos/tablet.proto";
import "ydb/core/protos/yql_translation_settings.proto";
import "ydb/core/scheme/protos/pathid.proto";
import "ydb/core/scheme/protos/type_info.proto";
import "ydb/core/tx/columnshard/common/protos/snapshot.proto";
import "ydb/core/tx/columnshard/engines/scheme/defaults/protos/data.proto";
import "ydb/library/actors/protos/actors.proto";
import "ydb/library/formats/arrow/protos/accessor.proto";
import "ydb/library/mkql_proto/protos/minikql.proto";
import "ydb/public/api/protos/ydb_coordination.proto";
import "ydb/public/api/protos/ydb_export.proto";
import "ydb/public/api/protos/ydb_table.proto";
import "ydb/public/api/protos/ydb_topic.proto";
import "ydb/public/api/protos/ydb_value.proto";

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";

package NKikimrSchemeOp;
option java_package = "ru.yandex.kikimr.proto";

message TMkDir {
    optional string Name = 1;
}

enum EDropWaitPolicy {
    EDropFailOnChanges = 0;
    EDropAbortChanges = 1; //deprecated
    EDropWaitChanges = 2;
}

message TDrop {
    optional string Name = 1;
    optional EDropWaitPolicy WaitPolicy = 2;
    optional uint64 Id = 3;
}

enum EColumnCodec {
    ColumnCodecPlain = 0;
    ColumnCodecLZ4 = 1; // lz4fast
    // TODO: there're 3 variants of LZ4 in Arrow: Lz4Frame, Lz4HadoopRaw, Lz4Raw. ColumnCodecLZ4 points to Lz4Frame.
    ColumnCodecZSTD = 2;
}

enum EColumnCache {
    ColumnCacheNone = 0;
    ColumnCacheOnce = 1;
    ColumnCacheEver = 2;
}

enum EColumnStorage {
    ColumnStorage1 = 0;
    ColumnStorage2 = 1;
    ColumnStorage1Ext1 = 2;
    ColumnStorage1Ext2 = 3;
    ColumnStorage2Ext1 = 4;
    ColumnStorage2Ext2 = 5;
    ColumnStorage1Med2Ext2 = 6;
    ColumnStorage2Med2Ext2 = 7;
    ColumnStorageTest_1_2_1k = 999;
}

enum EFreezeState {
    Unspecified = 0;
    Freeze = 1;
    Unfreeze = 2;
}

enum EMvccState {
    MvccUnspecified = 0;
    MvccEnabled = 1;
    MvccDisabled = 2;
}

message TColumnDescription {
    optional string Name = 1;
    optional string Type = 2;
    optional uint32 TypeId = 3;
    optional NKikimrProto.TTypeInfo TypeInfo = 9;
    optional uint32 Id = 4;
    optional uint32 Family = 5; // On default place column to default(0) family
    optional string FamilyName = 6; // set Family by name (0 - "default")
    oneof DefaultValue {
        string DefaultFromSequence = 7; // Path to sequence for default values
        Ydb.TypedValue DefaultFromLiteral = 10; // Literal default value
        google.protobuf.NullValue EmptyDefault = 12; // Drop default case
    }
    optional bool NotNull = 8;
    // flag that indicates that column is currently under the build
    // operation.
    optional bool IsBuildInProgress = 11 [default = false];
}

message TStorageSettings {
    optional string PreferredPoolKind = 1;
    optional bool AllowOtherKinds = 2 [default = true];
}

message TStorageConfig {
    optional TStorageSettings SysLog = 1;
    optional TStorageSettings Log = 2;
    optional TStorageSettings Data = 3;
    optional TStorageSettings External = 4;
    optional uint32 DataThreshold = 5;
    optional uint32 ExternalThreshold = 6;
    optional uint32 ExternalChannelsCount = 7 [default = 1];
}

message TKeyValueStorageConfig {
    repeated TStorageSettings Channel = 3;
}

message TFamilyDescription {
    optional uint32 Id = 1;
    optional uint32 Room = 2; // Used by datashard, must not be used by users
    optional uint32 Codec = 3; // DEPRECATED: use ColumnCodec
    optional bool InMemory = 4; // DEPRECATED: use ColumnCache
    optional string Name = 5;
    optional EColumnCodec ColumnCodec = 6;
    optional EColumnCache ColumnCache = 7;
    optional EColumnStorage Storage = 8; // DEPRECATED: use StorageConfig
    optional TStorageConfig StorageConfig = 9;
    optional int32 ColumnCodecLevel = 10;
}

message TFastSplitSettings {
    optional uint64 SizeThreshold = 1;
    optional uint64 RowCountThreshold = 2;
    optional uint32 CpuPercentageThreshold = 3;
}

message TSplitByLoadSettings {
    optional bool Enabled = 1;
    optional uint32 CpuPercentageThreshold = 2;
    // TODO: optional uint32 KeySampleSize = 3;
    // TODO: optional uint32 KeySampleCollectTimeSec = 4;
}

message TPartitioningPolicy {
    optional uint64 SizeToSplit = 1;    // Partition gets split when this threshold is exceeded

    optional uint32 MinPartitionsCount = 2;
    optional uint32 MaxPartitionsCount = 3;

    optional TFastSplitSettings FastSplitSettings = 4;
    optional TSplitByLoadSettings SplitByLoadSettings = 5;
}

message TPipelineConfig {
    optional uint32 NumActiveTx = 1 [default = 8];
    optional uint32 DataTxCacheSize = 2;
    optional bool EnableOutOfOrder = 3 [default = true];
    optional bool DisableImmediate = 4;
    optional bool EnableSoftUpdates = 5;
}

message TPartitionConfig {
    optional string NamedCompactionPolicy = 1; // One of the predefined policies
    optional NKikimrCompaction.TCompactionPolicy CompactionPolicy = 2; // Customized policy
    optional uint64 FollowerCount = 3;
    optional uint64 ExecutorCacheSize = 4; // (DEPRECATED) Cache size for the whole tablet including all user and system tables
    optional bool AllowFollowerPromotion = 5 [default = true]; // if true followers can upgrade to leader, if false followers only handle reads
    optional uint64 TxReadSizeLimit = 6; // Maximum size in bytes that is allowed to be read by a single Tx
    //optional bool CrossDataCenterFollowers = 7; // deprecated -> CrossDataCenterFollowerCount
    optional uint32 CrossDataCenterFollowerCount = 8; // deprecated -> FollowerGroups
    optional uint32 ChannelProfileId = 9;   // for configuring erasure and disk categories
    optional TPartitioningPolicy PartitioningPolicy = 10;
    optional TPipelineConfig PipelineConfig = 11;
    repeated TFamilyDescription ColumnFamilies = 12;
    optional string ResourceProfile = 13;
    optional bool DisableStatisticsCalculation = 14; // KIKIMR-3861 hotfix
    optional bool EnableFilterByKey = 15 [default = false]; // Build and use per-part bloom filter for fast key non-existence check
    optional bool ExecutorFastLogPolicy = 16 [default  = true]; // Commit log faster at the expense of bandwidth for cross-DC
    repeated NKikimrStorageSettings.TStorageRoom StorageRooms = 17;
    optional bool EnableEraseCache = 18 [default = true]; // Use erase cache for faster iteration over erased rows
    optional uint32 EraseCacheMinRows = 19; // Minimum number of erased rows worth caching (default 16)
    optional uint32 EraseCacheMaxBytes = 20; // Maximum number of bytes to use for cached rows (default 1MB)
    optional EFreezeState FreezeState = 21;
    optional bool ShadowData = 22; // Table has separate shadow data for later merging
    repeated NKikimrHive.TFollowerGroup FollowerGroups = 23;
    reserved 24; // EMvccState MvccState = 24; no longer used
    optional uint64 KeepSnapshotTimeout = 25; // milliseconds
}

message TSplitBoundary {
    optional NKikimrMiniKQL.TValue KeyPrefix = 1; // A tuple representing full key or key prefix
    optional bytes SerializedKeyPrefix = 2;       // Or same as above but already serialized
}

message TShardIdx {
    optional uint64 OwnerId = 1;
    optional uint64 LocalId = 2;
}

message TTTLSettings {
    enum EUnit {
        UNIT_AUTO = 0;
        UNIT_SECONDS = 1;
        UNIT_MILLISECONDS = 2;
        UNIT_MICROSECONDS = 3;
        UNIT_NANOSECONDS = 4;
    }

    message TSysSettings {
        optional uint64 RunInterval = 1 [default = 3600000000]; // 1 hour
        optional uint64 RetryInterval = 2 [default = 300000000]; // 5 minutes
        optional uint32 BatchMaxBytes = 3 [default = 512000];
        optional uint32 BatchMinKeys = 4 [default = 1];
        optional uint32 BatchMaxKeys = 5 [default = 256];
        optional uint32 MaxShardsInFlight = 6 [default = 0]; // zero means no limit
    }

    message TEvictionToExternalStorageSettings {
        optional string Storage = 1;
    }

    message TTier {
        optional uint32 ApplyAfterSeconds = 1;
        oneof Action {
            google.protobuf.Empty Delete = 2;
            TEvictionToExternalStorageSettings EvictToExternalStorage = 3;
        }
    }

    message TEnabled {
        optional string ColumnName = 1;
        optional uint32 ExpireAfterSeconds = 2 [deprecated = true];
        optional EUnit ColumnUnit = 3;
        optional TSysSettings SysSettings = 4;
        repeated TTier Tiers = 5;
    }

    message TDisabled {
    }

    oneof Status {
        TEnabled Enabled = 1;
        TDisabled Disabled = 2;
    }

    reserved 3;
}

message TTableReplicationConfig {
    enum EReplicationMode {
        REPLICATION_MODE_NONE = 0;
        REPLICATION_MODE_READ_ONLY = 1;
    }

    enum EConsistencyLevel {
        CONSISTENCY_LEVEL_UNKNOWN = 0;
        CONSISTENCY_LEVEL_GLOBAL = 1;
        CONSISTENCY_LEVEL_ROW = 2;
    }

    optional EReplicationMode Mode = 1;
    optional EConsistencyLevel ConsistencyLevel = 2;
}

message TTableIncrementalBackupConfig {
    enum ERestoreMode {
        RESTORE_MODE_NONE = 0;
        RESTORE_MODE_INCREMENTAL_BACKUP = 1;
    }

    enum EConsistency {
        CONSISTENCY_UNKNOWN = 0;
        CONSISTENCY_STRONG = 1;
        CONSISTENCY_WEAK = 2;
    }

    optional ERestoreMode Mode = 1;
    optional EConsistency Consistency = 2;
}

message TTableDescription {
    optional string Name = 1;
    optional uint64 Id_Deprecated = 2; // LocalPathId, deprecated
    repeated TColumnDescription Columns = 3;
    repeated string KeyColumnNames = 4;
    repeated uint32 KeyColumnIds = 5;
    optional uint32 UniformPartitionsCount = 6;     // Describes uniform partitioning on first key column into
                                                    // N ranges. The first key column must be of integer type

    optional TPartitionConfig PartitionConfig = 7;
    repeated TColumnDescription DropColumns = 8;
    optional string Path = 9;

    // It shouldn't be there
    optional bytes PartitionRangeBegin = 20;
    optional bytes PartitionRangeEnd = 21;
    optional bool PartitionRangeBeginIsInclusive = 22;
    optional bool PartitionRangeEndIsInclusive = 23;

    optional string CopyFromTable = 30;
    repeated TSplitBoundary SplitBoundary = 31;     // Boundaries for non-uniform split

    repeated TIndexDescription TableIndexes = 32;

    optional uint64 TableSchemaVersion = 33;

    optional NKikimrProto.TPathID PathId = 34; // TPathId, owerride Id = 2

    optional TTTLSettings TTLSettings = 35;

    optional bool OmitFollowers = 36 [default = false]; // used with CopyFromTable
    optional bool IsBackup = 37 [default = false];
    optional bool IsRestore = 45 [default = false];

    repeated TCdcStreamDescription CdcStreams = 38;
    repeated TSequenceDescription Sequences = 39;

    oneof IncomingStreamConfig {
        TTableReplicationConfig ReplicationConfig = 40;
        TTableIncrementalBackupConfig IncrementalBackupConfig = 43;
    }

    // For kqp internal use only
    optional bool Temporary = 41;

    // This flag is create-only, and has to be set up
    // on table creation to allow system column names (started with __ydb_)
    // It won't be present on describes and won't be preserved
    optional bool SystemColumnNamesAllowed = 42;
    optional bool AllowUnderSameOperation = 44 [default = false];
    // Create only as-well. Used for CopyTable to create table in desired state instead of default
    optional EPathState PathState = 46;
}

message TDictionaryEncodingSettings {
   optional bool Enabled = 1;
}

message TCompressionOptions {
    optional EColumnCodec Codec = 2; // LZ4 (in arrow LZ4_FRAME variant) if not set
    optional int32 Level = 3; // Use default compression level if not set (0 != not set)
}

message TOlapColumn {

    message TSerializer {
        optional string ClassName = 1;
        oneof Implementation {
            TCompressionOptions ArrowCompression = 40;
        }
    }
}

message TOlapColumnDiff {
    optional string Name = 1;
    optional TDictionaryEncodingSettings DictionaryEncoding = 4;
    optional TOlapColumn.TSerializer Serializer = 5;
    optional string StorageId = 6;
    optional string DefaultValue = 7;
    optional NKikimrArrowAccessorProto.TRequestedConstructor DataAccessorConstructor = 8;
    optional string ColumnFamilyName = 9;
}

message TOlapColumnDescription {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    // Column name is required, some column names are reserved
    optional string Name = 2;

    optional string Type = 3;
    optional uint32 TypeId = 4; // TypeId cannot be set explicitly, use Type
    optional NKikimrProto.TTypeInfo TypeInfo = 6;
    optional bool NotNull = 7;

    optional TCompressionOptions Compression = 8[deprecated = true];
    optional TDictionaryEncodingSettings DictionaryEncoding = 9;
    optional TOlapColumn.TSerializer Serializer = 10;
    optional string StorageId = 11;
    optional NKikimrColumnShardColumnDefaults.TColumnDefault DefaultValue = 12;
    optional NKikimrArrowAccessorProto.TConstructor DataAccessorConstructor = 13;
    optional uint32 ColumnFamilyId = 14;
    optional string ColumnFamilyName = 15;
}

message TIndexDataExtractor {
    optional string ClassName = 1;
    message TDefault {
    }

    message TSubColumn {
        optional string SubColumnName = 1;
    }

    oneof Implementation {
        TDefault Default = 20;
        TSubColumn SubColumn = 21;
    }
}

message TSkipIndexBitSetStorage {
    optional string ClassName = 1;
    message TFixString {
    }
    message TBitSet {
    }
    oneof Implementation {
        TFixString FixString = 20;
        TBitSet BitSet = 21;
    }
}

message TRequestedBloomFilter {
    optional double FalsePositiveProbability = 1 [default = 0.1];
    repeated string ColumnNames = 3;
    optional TIndexDataExtractor DataExtractor = 4;
    optional TSkipIndexBitSetStorage BitsStorage = 5;
}

message TRequestedBloomNGrammFilter {
    optional uint32 NGrammSize = 1;
    optional uint32 FilterSizeBytes = 2;
    optional uint32 HashesCount = 3;
    optional string ColumnName = 4;
    optional uint32 RecordsCount = 5;
    optional TIndexDataExtractor DataExtractor = 6;
    optional TSkipIndexBitSetStorage BitsStorage = 7;
    optional bool CaseSensitive = 8 [default = true];
}

message TRequestedMaxIndex {
    optional string ColumnName = 1;
}

message TRequestedCountMinSketch {
    // sketch built on the combined data from the set of columns
    repeated string ColumnNames = 1;
}

message TOlapIndexRequested {
    optional string Name = 1;
    optional TCompressionOptions Compression = 3;
    optional string StorageId = 4;

    optional string ClassName = 39;
    oneof Implementation {
        TRequestedBloomFilter BloomFilter = 40;
        TRequestedMaxIndex MaxIndex = 41;
        TRequestedCountMinSketch CountMinSketch = 42;
        TRequestedBloomNGrammFilter BloomNGrammFilter = 43;
    }
}

message TBloomFilter {
    optional double FalsePositiveProbability = 1 [default = 0.1];
    optional uint64 MaxBytesCount = 2 [default = 8196];
    repeated uint32 ColumnIds = 3;
    optional TIndexDataExtractor DataExtractor = 4;
    optional TSkipIndexBitSetStorage BitsStorage = 5;
}

message TBloomNGrammFilter {
    optional uint32 NGrammSize = 1;
    optional uint32 FilterSizeBytes = 2;
    optional uint32 HashesCount = 3;
    optional uint32 ColumnId = 4;
    optional uint32 RecordsCount = 5;
    optional TIndexDataExtractor DataExtractor = 6;
    optional TSkipIndexBitSetStorage BitsStorage = 7;
    optional bool CaseSensitive = 8 [default = true];
}

message TMaxIndex {
    optional uint32 ColumnId = 1;
}

message TCountMinSketch {
    repeated uint32 ColumnIds = 1;
}

message TOlapIndexDescription {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    optional string Name = 2;
    optional TCompressionOptions Compression = 3;

    optional string StorageId = 4;

    optional string ClassName = 40;
    oneof Implementation {
        TBloomFilter BloomFilter = 41;
        TMaxIndex MaxIndex = 42;
        TCountMinSketch CountMinSketch = 43;
        TBloomNGrammFilter BloomNGrammFilter = 44;
    }
}

enum EColumnTableEngine {
    COLUMN_ENGINE_NONE = 0;
    COLUMN_ENGINE_REPLACING_TIMESERIES = 1;
}

enum EOlapProgramType {
    OLAP_PROGRAM_SSA_PROGRAM = 1;
    OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS = 2;
}

message TStorageTierConfig {
    optional string Name = 1;
    optional NKikimrSchemeOp.TS3Settings ObjectStorage = 2;
    optional TCompressionOptions Compression = 3;
}

message TCompactionLevelConstructorContainer {
    optional string ClassName = 1;
    optional string DefaultSelectorName = 2;

    message TZeroLevel {
        optional uint32 PortionsLiveDurationSeconds = 1;
        optional uint64 ExpectedBlobsSize = 2;
        optional uint64 PortionsCountAvailable = 3;
        optional uint64 PortionsCountLimit = 4;
        optional uint64 PortionsSizeLimit = 5;
    }

    message TOneLayer {
        optional uint32 ExpectedPortionSize = 1;
        optional float BytesLimitFraction = 2;
        optional uint64 SizeLimitGuarantee = 3;
    }

    oneof Implementation {
        TZeroLevel ZeroLevel = 10;
        TOneLayer OneLayer = 11;
    }

}

message TCompactionSelectorConstructorContainer {
    optional string ClassName = 1;
    optional string Name = 2;

    message TTransparentSelector {
    }

    message TEmptySelector {
    }

    message TDataSnapshotInterval {
        optional uint32 StartSecondsUTC = 1;
        optional uint32 FinishSecondsUTC = 2;
    }

    message TSnapshotSelector {
        optional TDataSnapshotInterval Interval = 1;
    }

    oneof Implementation {
        TEmptySelector Empty = 10;
        TTransparentSelector Transparent = 11;
        TSnapshotSelector Snapshot = 12;
    }

}

message TCompactionPlannerConstructorContainer {
    optional string ClassName = 1;
    optional uint64 NodePortionsCountLimit = 2;

    message TLOptimizer {

    }

    message TSOptimizer {
        optional string LogicName = 1;
        optional uint32 FreshnessCheckDurationSeconds = 2 [default = 300];
    }

    message TLCOptimizer {
        repeated TCompactionLevelConstructorContainer Levels = 1;
        repeated TCompactionSelectorConstructorContainer Selectors = 2;
    }

    message TTilingOptimizer {
        optional string Json = 1;
    }

    oneof Implementation {
        TLOptimizer LBuckets = 20;
        TSOptimizer SBuckets = 21;
        TLCOptimizer LCBuckets = 22;
        TTilingOptimizer Tiling = 23;
    }
}

message TMetadataManagerConstructorContainer {
    optional string ClassName = 1;

    message TInMem {
    }

    message TLocalDB {
        optional uint64 MemoryCacheSize = 1 [default = 128000000];
        optional bool FetchOnStart = 2 [default = false];
    }

    oneof Implementation {
        TInMem InMem = 20;
        TLocalDB LocalDB = 21;
    }
}

message TColumnTableSchemeOptions {
    optional bool SchemeNeedActualization = 1 [default = false];
    optional TCompactionPlannerConstructorContainer CompactionPlannerConstructor = 3;
    optional TMetadataManagerConstructorContainer MetadataManagerConstructor = 4;
    optional string ScanReaderPolicyName = 5;
}

message TColumnTableSchema {
    // A list of columns for tables with this schema
    repeated TOlapColumnDescription Columns = 1;
    repeated string KeyColumnNames = 2;

    optional EColumnTableEngine Engine = 3;
    // Internal fields
    optional uint32 NextColumnId = 4;

    // Incremented on each schema change
    optional uint64 Version = 5 [default = 1];

    //optional EColumnCodec DefaultCompressionCodec = 6; // deprecated, not used before replace
    //optional int32 DefaultCompressionLevel = 7; // deprecated, not used before replace
    optional TCompressionOptions DefaultCompression = 8;

    repeated TOlapIndexDescription Indexes = 10;
    optional TColumnTableSchemeOptions Options = 12;

    repeated TFamilyDescription ColumnFamilies = 13;
    // Internal fields
    optional uint32 NextColumnFamilyId = 14;
}

message TColumnTableSchemaDiff {
    optional uint64 Version = 1;

    repeated TOlapColumnDescription UpsertColumns = 2;
    repeated uint32 DropColumns = 3;

    optional TCompressionOptions DefaultCompression = 4;

    repeated TOlapIndexDescription UpsertIndexes = 5;
    repeated uint32 DropIndexes = 6;

    optional TColumnTableSchemeOptions Options = 7;
}

message TColumnTableRequestedOptions {
    optional bool SchemeNeedActualization = 1 [default = false];
    optional TCompactionPlannerConstructorContainer CompactionPlannerConstructor = 3;
    optional TMetadataManagerConstructorContainer MetadataManagerConstructor = 4;
    optional string ScanReaderPolicyName = 5;
}

message TAlterColumnTableSchema {
    repeated TOlapColumnDescription AddColumns = 1;
    //optional TCompressionOptions DefaultCompression = 5;
    repeated TOlapColumnDescription DropColumns = 6;
    repeated TOlapColumnDiff AlterColumns = 7;
    repeated TOlapIndexRequested UpsertIndexes = 8;
    repeated string DropIndexes = 9;
    optional TColumnTableRequestedOptions Options = 12;
    repeated TFamilyDescription AddColumnFamily = 13;
    repeated TFamilyDescription AlterColumnFamily = 14;
}

// Schema presets are used to manage multiple tables with the same schema
// Tables may be created without an explicit list of columns, linking to the
// same schema preset. Later schema presets may be altered, effectively
// altering all tables that have the same preset.
message TColumnTableSchemaPreset {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    // Preset name is required, preset named "default" will be used by default
    optional string Name = 2;

    optional TColumnTableSchema Schema = 3;
}

message TAlterColumnTableSchemaPreset {
    // Existing preset name to alter
    optional string Name = 1;

    optional TAlterColumnTableSchema AlterSchema = 2;
}

message TRemoveColumnTableSchemaPreset {
    // Existing preset name to remove
    optional string Name = 1;
}

// TTL and external storage eviction policies
message TColumnDataLifeCycle {
    message TTtl {
        optional string ColumnName = 1;
        oneof Expire {
            uint32 ExpireAfterSeconds = 2 [deprecated = true]; // ignored if Tiers are not empty
            uint64 ExpireAfterBytes = 4;
        }
        optional TTTLSettings.EUnit ColumnUnit = 3;
        repeated TTTLSettings.TTier Tiers = 5;
    }

    message TDisabled {
    }

    oneof Status {
        TTtl Enabled = 1;
        TDisabled Disabled = 2;
    }

    // Incremented on each settings change
    optional uint64 Version = 3 [default = 1];

    reserved 5;
}

message TColumnTableTtlSettingsPreset {
    // This id is auto-generated by schemeshard
    optional uint32 Id = 1;

    // Preset name is required, preset named "default" will be used by default
    optional string Name = 2;

    optional TColumnDataLifeCycle TtlSettings = 3;
}

message TAlterColumnTableTtlSettingsPreset {
    // Existing preset name to alter
    optional string Name = 1;

    optional TColumnDataLifeCycle AlterTtlSettings = 2;
}

message TRemoveColumnTableTtlSettingsPreset {
    // Existing preset name to remove
    optional string Name = 1;
}

message TColumnStorageConfig {
    optional TStorageSettings SysLog = 1;
    optional TStorageSettings Log = 2;
    optional TStorageSettings Data = 3;
    optional uint32 DataChannelCount = 4;
}

// This is used internally by schemeshard
message TColumnStoreSharding {
    repeated TShardIdx ColumnShards = 2;
}

message TColumnStoreDescription {
    optional string Name = 1;
    optional uint32 RESERVED_MetaShardCount = 2;
    optional uint32 ColumnShardCount = 3;
    repeated uint64 RESERVED_MetaShards = 4;
    repeated uint64 ColumnShards = 5;
    repeated TColumnTableSchemaPreset SchemaPresets = 6;
    repeated TColumnTableTtlSettingsPreset RESERVED_TtlSettingsPresets = 7;
    optional TColumnStorageConfig StorageConfig = 10;

    // Internal fields
    optional uint32 NextSchemaPresetId = 8;
    optional uint32 NextTtlSettingsPresetId = 9;
}

message TAlterColumnStore {
    optional string Name = 1;
    repeated TColumnTableSchemaPreset AddSchemaPresets = 2;
    repeated TAlterColumnTableSchemaPreset AlterSchemaPresets = 3;
    repeated TRemoveColumnTableSchemaPreset RemoveSchemaPresets = 4;
    repeated TColumnTableTtlSettingsPreset RESERVED_AddTtlSettingsPresets = 5;
    repeated TAlterColumnTableTtlSettingsPreset RESERVED_AlterTtlSettingsPresets = 6;
    repeated TRemoveColumnTableTtlSettingsPreset RESERVED_RemoveTtlSettingsPresets = 7;
}

message TConsistencyShardingTablet {
    optional uint64 TabletId = 1;
    optional uint64 HashIntervalLeftClosed = 2;
    optional uint64 HashIntervalRightOpened = 3;
}

message TModuloShardingTablet {
    optional uint64 TabletId = 1;
    repeated uint32 AppropriateMods = 2;
}

message THashShardingInfo {
    repeated string ColumnNames = 1;
}

message TGranuleConsistencyShardingInfo {
    optional THashShardingInfo Hashing = 1;
    optional TConsistencyShardingTablet ShardInfo = 2;
}

message TGranuleModuloShardingInfo {
    optional THashShardingInfo Hashing = 1;
    optional TModuloShardingTablet ShardInfo = 2;
    optional uint64 ModuloPartsCount = 3;
}

message TGranuleShardingLogicContainer {
    optional string ClassName = 1;
    oneof Implementation {
        TGranuleConsistencyShardingInfo Consistency = 20;
        TGranuleModuloShardingInfo Modulo = 21;
    }
}

message TGranuleShardingInfo {
    optional uint64 PathId = 1;
    optional uint64 VersionId = 2;
    optional TGranuleShardingLogicContainer Container = 3;
}

message TGranuleShardInfo {
    optional uint64 TabletId = 1;
    optional uint32 SequenceIdx = 2;
    optional bool IsOpenForRead = 3;
    optional bool IsOpenForWrite = 4;
    optional NKikimrColumnShardProto.TSnapshot OpenForWriteSnapshot = 5;
    optional uint64 ShardingVersion = 6;
}

message TColumnTableSharding {
    // An ordered list of currently used column shards
    // This field is managed by the system.
    repeated uint64 ColumnShards = 2;

    // Random sharding chooses a random shard for new data at write time
    message TRandomSharding {
        // No additional fields
    }

    // Hash sharding is based on a hash of specified columns' values at write time.
    message THashSharding {
        enum EHashFunction {
            // A simple hash modulo number of shards
            HASH_FUNCTION_MODULO_N = 0;
            HASH_FUNCTION_CLOUD_LOGS = 1;
            HASH_FUNCTION_CONSISTENCY_64 = 2;
        }

        // Hash function used for mapping column values to a column shard
        optional EHashFunction Function = 1 [default = HASH_FUNCTION_MODULO_N];

        // A list of columns used for hashing, must not be empty
        repeated string Columns = 2;

        // Argument for HASH_FUNCTION_CLOUD_LOGS
        optional uint32 ActiveShardsCount = 4;
        repeated TConsistencyShardingTablet TabletsForConsistency = 5;

        optional uint32 ModuloPartsCount = 6;
        repeated TModuloShardingTablet TabletsForModulo = 7;
    }

    oneof Method {
        TRandomSharding RandomSharding = 5;
        THashSharding HashSharding = 6;
    }

    repeated TGranuleShardInfo ShardsInfo = 7;
}

message TColumnTableDescription {
    optional string Name = 1;

    // When creating a table these may be omitted, then ttl preset will be
    // used instead. When describing current schema and settings are always
    // returned.
    optional TColumnTableSchema Schema = 2;
    optional TColumnDataLifeCycle TtlSettings = 3;

    // Table may be created using presets specific to the olap store.
    optional uint32 SchemaPresetId = 4;
    optional string SchemaPresetName = 6;

    // Associated olap store id, initialized by schemeshard
    // May be missing for tables that are not part of an ColumnStore
    optional NKikimrProto.TPathID ColumnStorePathId = 8;

    // Specifies the desired number of ColumnShards for this table
    optional uint32 ColumnShardCount = 9;

    // Sharding schema used by this table, may be used for specifying sharding settings
    optional TColumnTableSharding Sharding = 10;

    // Internal fields that make sure versions always increase when presets are switched
    optional uint64 SchemaPresetVersionAdj = 11;
    optional uint64 TtlSettingsPresetVersionAdj = 12;

    // Channels for standalone column table
    optional TColumnStorageConfig StorageConfig = 13;

    // For kqp internal use only
    optional bool Temporary = 14;
}

message TAlterColumnTable {
    optional string Name = 1;

    optional TAlterColumnTableSchema AlterSchema = 2;
    optional TColumnDataLifeCycle AlterTtlSettings = 3;

    optional string AlterSchemaPresetName = 4;
    optional string RESERVED_AlterTtlSettingsPresetName = 5;

    optional TAlterShards AlterShards = 6;
    optional TReshardColumnTable ReshardColumnTable = 7;
}

message TReshardColumnTable {
    optional bool Increase = 1;
}

message TLoginCreateUser {
    optional string User = 1;
    optional string Password = 2;
    optional bool CanLogin = 3 [default = true];
    optional bool IsHashedPassword = 4 [default = false];
}

message TLoginModifyUser {
    optional string User = 1;
    optional string Password = 2;
    optional bool CanLogin = 3;
    optional bool IsHashedPassword = 4 [default = false];
}

message TLoginRemoveUser {
    optional string User = 1;
    optional bool MissingOk = 2;
}

message TLoginCreateGroup {
    optional string Group = 1;
}

message TLoginAddGroupMembership {
    optional string Group = 1;
    optional string Member = 2;
}

message TLoginRemoveGroupMembership {
    optional string Group = 1;
    optional string Member = 2;
}

message TLoginRenameGroup {
    optional string Group = 1;
    optional string NewName = 2;
}

message TLoginRemoveGroup {
    optional string Group = 1;
    optional bool MissingOk = 2;
}

message TAlterLogin {
    oneof Alter {
        TLoginCreateUser CreateUser = 1;
        TLoginModifyUser ModifyUser = 2;
        TLoginRemoveUser RemoveUser = 3;
        TLoginCreateGroup CreateGroup = 4;
        TLoginAddGroupMembership AddGroupMembership = 5;
        TLoginRemoveGroupMembership RemoveGroupMembership = 6;
        TLoginRemoveGroup RemoveGroup = 7;
        TLoginRenameGroup RenameGroup = 8;
    }
}

enum ECdcStreamState {
    ECdcStreamStateInvalid = 0;
    ECdcStreamStateReady = 1;
    ECdcStreamStateDisabled = 2;
    ECdcStreamStateScan = 3;
}

enum ECdcStreamMode {
    ECdcStreamModeInvalid = 0;
    ECdcStreamModeKeysOnly = 1;
    ECdcStreamModeUpdate = 2;
    ECdcStreamModeNewImage = 3;
    ECdcStreamModeOldImage = 4;
    ECdcStreamModeNewAndOldImages = 5;
    ECdcStreamModeRestoreIncrBackup = 106;
}

enum ECdcStreamFormat {
    ECdcStreamFormatInvalid = 0;
    ECdcStreamFormatProto = 1;
    ECdcStreamFormatJson = 2;
    ECdcStreamFormatDynamoDBStreamsJson = 3;
    ECdcStreamFormatDebeziumJson = 4;
}

message TCdcStreamScanProgress {
    optional uint32 ShardsTotal = 1;
    optional uint32 ShardsCompleted = 2;
}

message TCdcStreamDescription {
    optional string Name = 1;
    optional ECdcStreamMode Mode = 2;
    optional ECdcStreamFormat Format = 6;
    optional bool VirtualTimestamps = 7;
    optional NKikimrProto.TPathID PathId = 3;
    optional ECdcStreamState State = 4;
    optional uint64 SchemaVersion = 5;
    repeated TUserAttribute UserAttributes = 8;
    // AwsRegion used to mark records in DynamoDB-compatible mode (FormatDynamoDBStreamsJson)
    optional string AwsRegion = 9;
    // Set to '0' to disable resolved timestamps
    optional uint64 ResolvedTimestampsIntervalMs = 10;
    optional TCdcStreamScanProgress ScanProgress = 11;
    optional bool SchemaChanges = 12;
}

message TCreateCdcStream {
    optional string TableName = 1;
    optional TCdcStreamDescription StreamDescription = 2;
    optional uint64 RetentionPeriodSeconds = 3 [default = 86400]; // 1d by default
    optional uint32 TopicPartitions = 4;

    // Topic autopartitioning settings
    optional bool TopicAutoPartitioning = 5 [default = false]; // we always can split and merge of topic partitions
    optional uint32 MaxPartitionCount = 6;
}

message TAlterCdcStream {
    optional string TableName = 1;
    optional string StreamName = 2;

    message TDisable {
    }

    message TGetReady {
        optional uint64 LockTxId = 1;
    }

    oneof Action {
        TDisable Disable = 3;
        TGetReady GetReady = 4;
    }
}

message TDropCdcStream {
    optional string TableName = 1;
    repeated string StreamName = 2;
}

message TRotateCdcStream {
    optional string TableName = 1;
    optional string OldStreamName = 2;
    optional TCreateCdcStream NewStream = 3;
}

message TContinuousBackupDescription {
    optional string StreamName = 1;
}

message TCreateContinuousBackup {
    optional string TableName = 1;
    optional TContinuousBackupDescription ContinuousBackupDescription = 2;
}

message TAlterContinuousBackup {
    optional string TableName = 1;

    message TStop {
    }

    message TTakeIncrementalBackup {
        optional string DstPath = 1;
        optional string DstStreamPath = 2;
    }

    oneof Action {
        TStop Stop = 2;
        TTakeIncrementalBackup TakeIncrementalBackup = 3;
    }
}

message TDropContinuousBackup {
    optional string TableName = 1;
}

message TRestoreIncrementalBackup {
    optional string SrcTablePath = 1; // Absolute path
    optional NKikimrProto.TPathID SrcPathId = 3;

    optional string DstTablePath = 2; // Absolute path
    optional NKikimrProto.TPathID DstPathId = 4;
}

message TRestoreMultipleIncrementalBackups {
    repeated string SrcTablePaths = 1; // Absolute path
    repeated NKikimrProto.TPathID SrcPathIds = 3;

    optional string DstTablePath = 2; // Absolute path
    optional NKikimrProto.TPathID DstPathId = 4;
}

enum EIndexType {
    EIndexTypeInvalid = 0;
    EIndexTypeGlobal = 1;
    EIndexTypeGlobalAsync = 2;
    EIndexTypeGlobalUnique = 3;
    EIndexTypeGlobalVectorKmeansTree = 4;
}

enum EIndexState {
    EIndexStateInvalid = 0;
    EIndexStateReady = 1;
    EIndexStateNotReady = 2;
    EIndexStateWriteOnly = 3;
}

message TVectorIndexKmeansTreeDescription {
    optional Ydb.Table.KMeansTreeSettings Settings = 1;
}

message TIndexDescription {
    optional string Name = 1;
    optional uint64 LocalPathId = 2;

    optional EIndexType Type = 3;
    optional EIndexState State = 4;

    repeated string KeyColumnNames = 5;

    optional uint64 SchemaVersion = 6; // Schema version of abstract index (not impl table)

    optional uint64 PathOwnerId = 7;

    repeated string DataColumnNames = 8;

    // DataSize + IndexSize of indexImplTable
    optional uint64 DataSize = 9;
    repeated TTableDescription IndexImplTableDescriptions = 10;

    oneof SpecializedIndexDescription {
        TVectorIndexKmeansTreeDescription VectorIndexKmeansTreeDescription = 11;
    }
}

message TIndexCreationConfig {
    optional string Name = 1;
    repeated string KeyColumnNames = 2;
    optional EIndexType Type = 3;
    repeated TTableDescription IndexImplTableDescriptions = 4; //description for index impl tables
    optional EIndexState State = 5; //state of index at the creation time
    repeated string DataColumnNames = 6; //columns to be denormalized to read data just from index
    oneof SpecializedIndexDescription {
        TVectorIndexKmeansTreeDescription VectorIndexKmeansTreeDescription = 7;
    }
}

message TGenericTxInFlyExtraData {
    message TTxCopyTableExtraData {
        optional NKikimrProto.TPathID CdcPathId = 1;
        optional NKikimrSchemeOp.EPathState TargetPathTargetState = 2;
    }

    // we do not use oneof here as far as we want to combine some subops rarely
    // and it can be used in this case
    optional TTxCopyTableExtraData TxCopyTableExtraData = 1;
}

message TIndexAlteringConfig {
    optional string Name = 1;
    optional EIndexState State = 2;
}

message TIndexedTableCreationConfig {
    optional TTableDescription TableDescription = 1;
    repeated TIndexCreationConfig IndexDescription = 2;
    repeated TSequenceDescription SequenceDescription = 3;
}

message TInitiateBuildIndexMainTable {
    optional string TableName = 1;
}

message TBuildIndexOutcome {
    message TCancel {
        // Path id of the index whose creation was cancelled
        optional NKikimrProto.TPathID IndexPathId = 1;
    }

    message TApply {
        // Path id of the index whose creation was done
        optional NKikimrProto.TPathID IndexPathId = 1;
    }

    reserved 1; // Apply type was changed from Empty to TApply

    oneof Result {
        TCancel Cancel = 2;
        TApply Apply = 3;
    }
}

message TFinalizeBuildIndexMainTable {
    optional string TableName = 1;
    optional uint64 SnapshotTxId = 2;
    optional uint64 BuildIndexId = 3;
    optional TBuildIndexOutcome Outcome = 4;
}

message TCopyTableConfig { //TTableDescription implemets copying a table in original and full way
    optional string SrcPath = 1;
    optional string DstPath = 2;

    optional bool OmitIndexes = 3 [default = false];
    optional bool OmitFollowers = 4 [default = false];
    optional bool IsBackup = 5 [default = false];

    // additionally creates cdc stream on src table consistently with taking snapshot
    optional TCreateCdcStream CreateSrcCdcStream = 6;
    optional bool AllowUnderSameOperation = 7 [default = false];

    optional NKikimrSchemeOp.EPathState TargetPathTargetState = 8;
}

message TConsistentTableCopyingConfig {
    repeated TCopyTableConfig CopyTableDescriptions = 1;
}

message TYTSettings {
    optional string Host = 1;
    optional string TablePattern = 2;
    optional string Token = 3;
    optional uint32 Port = 4 [default = 80];

    reserved 5; // YSONasText
    reserved 6; // AddScheme
    reserved 7; // CreateYTTable

    optional bool UseTypeV3 = 8;
};

message TTaskCleaner {
    optional uint64 PathId = 1;
    optional NKikimrSchemeOp.TS3Settings StorageSettings = 2;
    optional string TieringId = 3;
}

message TBackupTask {
    optional string TableName = 1;
    optional uint64 TableId = 2;
    optional uint32 ShardNum = 3;
    optional uint32 NumberOfRetries = 5;

    reserved 6; // IfFailedBeforeTxId
    reserved 7; // UserProvidedId
    reserved 8; // UserProvidedComment

    oneof Settings {
        TYTSettings YTSettings = 4;
        NKikimrSchemeOp.TS3Settings S3Settings = 9;
    }

    optional TPathDescription Table = 10; // for further restore
    repeated TPathDescription ChangefeedUnderlyingTopics = 17; // for further restore

    message TScanSettings {
        optional uint64 RowsBatchSize = 1 [default = 0]; // no limit
        optional uint64 BytesBatchSize = 2 [default = 33554432]; // 32 MB
    }

    optional TScanSettings ScanSettings = 11;
    optional bool NeedToBill = 12;

    message TCompressionOptions {
        optional string Codec = 1;
        optional int32 Level = 2;
    }

    optional uint64 SnapshotStep = 14;
    optional uint64 SnapshotTxId = 15;

    // currently available only for s3:
    optional TCompressionOptions Compression = 13;
    optional bool EnableChecksums = 16;
    optional bool EnablePermissions = 18;

    // Encryption (currently available only for s3):
    message TEncryptionSettings {
        optional string EncryptionAlgorithm = 1;
        optional bytes IV = 2;
        oneof Key {
            Ydb.Export.EncryptionSettings.SymmetricKey SymmetricKey = 3;
        }
    }

    optional TEncryptionSettings EncryptionSettings = 19;
}

message TRestoreTask {
    optional string TableName = 1;
    optional uint64 TableId = 2;
    optional TTableDescription TableDescription = 3;
    optional uint32 ShardNum = 4;
    optional uint32 NumberOfRetries = 5;

    oneof Settings {
        NKikimrSchemeOp.TS3Settings S3Settings = 6;
    }

    optional bool ValidateChecksums = 7; // currently available for s3

    message TEncryptionSettings {
        optional bytes IV = 1;
        oneof Key {
            Ydb.Export.EncryptionSettings.SymmetricKey SymmetricKey = 2;
        }
    }

    optional TEncryptionSettings EncryptionSettings = 8;
}

message TPersQueueGroupAllocate {
    message TPartition {
        optional uint32 PartitionId = 1;
        optional uint64 GroupId = 2;
        optional uint64 TabletId = 3;

        optional uint64 OwnerId = 4;
        optional uint64 ShardId = 5;

        optional NKikimrPQ.ETopicPartitionStatus Status = 6;
        repeated uint32 ParentPartitionIds = 7;
        optional NKikimrPQ.TPartitionKeyRange KeyRange = 10;
    }

    optional string Name = 1;
    optional uint64 AlterVersion = 2;

    optional uint32 TotalGroupCount = 3;
    optional uint32 NextPartitionId = 4;
    optional uint32 PartitionPerTablet = 5;

    optional NKikimrPQ.TPQTabletConfig PQTabletConfig = 6;
    repeated TPartition Partitions = 7;

    optional uint64 BalancerTabletID = 8;
    optional uint64 BalancerOwnerId = 9;
    optional uint64 BalancerShardId = 10;
}

message TPersQueueGroupDeallocate {
    optional string Name = 1;
}

message TPersQueueGroupDescription {

    message TPartition {
        optional uint32 PartitionId = 1;
        optional uint64 TabletId = 2;
        optional NKikimrPQ.TPartitionKeyRange KeyRange = 3;
        optional NKikimrPQ.ETopicPartitionStatus Status = 4;
        repeated uint32 ParentPartitionIds = 5;
        repeated uint32 ChildPartitionIds = 6;
    }

    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint32 TotalGroupCount = 3; // mandatory
    message TPartitionToAdd {
        optional uint32 PartitionId = 1;
        optional uint32 GroupId = 2;
    }
    repeated TPartitionToAdd PartitionsToAdd = 9;
    repeated uint32 PartitionsToDelete = 10;
    optional uint32 NextPartitionId = 11;
    optional uint32 PartitionPerTablet = 4; // default = 10
    optional NKikimrPQ.TPQTabletConfig PQTabletConfig = 5; // mandatory
    repeated TPartition Partitions = 6; // do not set
    optional uint64 AlterVersion = 7;
    optional uint64 BalancerTabletID = 8;

    // Can be passed upon creation.
    // PQTabletConfig.PartitionKeySchema must be set.
    // Size must be equal to TotalGroupCount - 1
    repeated NKikimrMiniKQL.TValue PartitionBoundaries = 12;

    // Can be passed upon creation
    optional NKikimrPQ.TBootstrapConfig BootstrapConfig = 13;

    optional TPersQueueGroupAllocate Allocate = 14;

    message TPartitionSplit {
        required uint32 Partition = 1;
        required bytes SplitBoundary = 2;
    }
    repeated TPartitionSplit Split = 15;

    message TPartitionMerge {
        required uint32 Partition = 1;
        required uint32 AdjacentPartition = 2;
    }
    repeated TPartitionMerge Merge = 16;
}

message TRtmrVolumeDescription {
    message TPartition {
        optional bytes PartitionId = 1;
        optional uint64 BusKey = 2;
        optional uint64 TabletId = 3;
    }

    optional string Name = 1;
    optional uint64 PathId = 2;
    optional uint64 PartitionsCount = 3;
    repeated TPartition Partitions = 4;
}

message TBlockStoreVolumeDescription {
    message TPartition {
        optional uint32 PartitionId = 1;
        optional uint64 TabletId = 2;
    }

    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional NKikimrBlockStore.TVolumeConfig VolumeConfig = 3; // mandatory
    repeated TPartition Partitions = 4; // do not set
    optional uint64 VolumeTabletId = 5; // do not set
    optional uint64 AlterVersion = 6; // do not set
    optional string MountToken = 7; // do not set
    optional uint64 TokenVersion = 8; // do not set
}

message TFileStoreDescription {
    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint64 IndexTabletId = 3; // do not set
    optional NKikimrFileStore.TConfig Config = 4; // mandatory
    optional uint64 Version = 5; // do not set
}

message TKesusDescription {
    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint64 KesusTabletId = 3; // do not set
    optional Ydb.Coordination.Config Config = 4;
    optional uint64 Version = 5; // do not set
}

message TSolomonVolumeDescription {
    message TPartition {
        optional uint64 PartitionId = 1;
        optional uint64 TabletId = 2;
        optional uint64 ShardIdx = 3;
        repeated NKikimrStoragePool.TChannelBind BoundChannels = 4;
    }

    optional string Name = 1; // mandatory
    optional uint64 PathId = 2;
    optional uint64 PartitionCount = 3;
    repeated TPartition Partitions = 4;
    repeated NKikimrStoragePool.TChannelBind BoundChannels = 5;
}

message TCreateSolomonVolume {
    message TAdoptedPartition {
        optional uint64 OwnerId = 1;
        optional uint64 ShardIdx = 2;
        optional uint64 TabletId = 3;
    }

    optional string Name = 1; // mandatory
    optional uint32 ChannelProfileId = 2;

    optional uint64 PartitionCount = 3;                // it is a mutually exclusive parametr
    repeated TAdoptedPartition AdoptedPartitions = 4; // with this one

    optional TKeyValueStorageConfig StorageConfig = 5;
}

message TAlterSolomonVolume {
    optional string Name = 1; // mandatory

    optional uint32 ChannelProfileId = 2;

    optional uint64 PartitionCount = 3;

    optional bool UpdateChannelsBinding = 4 [default = false];

    optional TKeyValueStorageConfig StorageConfig = 5;
}

message TBlockStoreAssignOp {
    optional string Name = 1; // mandatory
    optional string NewMountToken = 2; // unset to unassign
    optional uint64 TokenVersion = 3;
}

message TDropBlockStoreVolume {
    optional uint64 FillGeneration = 1;
}

message TModifyACL {
    optional string Name = 1;
    optional bytes DiffACL = 2; // NACLibProto.TDiffACL
    optional string NewOwner = 3;
}

message TSplitMergeTablePartitions {
    optional uint64 TxId = 1;
    optional string TablePath = 2;
    optional uint64 TableLocalId = 3;
    repeated uint64 SourceTabletId = 4;
    repeated TSplitBoundary SplitBoundary = 5;  // Points of split (there will be N+1 parts)
    optional uint64 SchemeshardId = 6;          // Only needed if TableId is used instead of path
    optional uint64 TableOwnerId = 7;
    optional bool AllowOneToOneSplitMerge = 8;  // Allow a special 1-to-1 split/merge for emergencies
}

message TUserAttribute {
    optional string Key = 1;
    optional string Value = 2;
}

message TAlterUserAttributes {
    optional string PathName = 1;
    repeated TUserAttribute UserAttributes = 2;
}

message TMove { // private description of the operation
    optional string SrcPath = 1;
    optional string DstPath = 2;
}

message TMoveIndex {
    optional string TablePath = 1;
    optional string SrcPath = 2;
    optional string DstPath = 3;
    optional bool AllowOverwrite = 4;
}

message TSequenceDescription {
    message TSetVal {
        optional sint64 NextValue = 1;
        optional bool NextUsed = 2;
    }
    optional string Name = 1; // mandatory
    optional NKikimrProto.TPathID PathId = 2; // sequence path id, assigned by schemeshard
    optional uint64 Version = 3; // incremented every time sequence is altered
    optional uint64 SequenceShard = 4; // current sequenceshard, assigned by schemeshard

    optional sint64 MinValue = 5; // minimum value, defaults to 1 or Min<i64>
    optional sint64 MaxValue = 6; // maximum value, defaults to Max<i64> or -1
    optional sint64 StartValue = 7; // start value, defaults to MinValue
    optional uint64 Cache = 8; // number of items to cache, defaults to 1
    optional sint64 Increment = 9; // increment at each call, defaults to 1
    optional bool Cycle = 10; // true when cycle on overflow is allowed
    optional TSetVal SetVal = 11; // SetVal(NextValue, NextUsed) is executed atomically when creating
    optional string DataType = 12; // data type of the sequence: Int64/pgint8, Int32/pgint4, Int16/pgint2, defaults to Int64/pgint8
    optional bool Restart = 13; // flag for changing the current value of the sequence with SetVal if it is set, or start value otherwise
}

message TSequenceSharding {
    // The last shard is the one currently active
    repeated TShardIdx SequenceShards = 1;
}

message TReplicationDescription {
    optional string Name = 1;
    optional NKikimrReplication.TReplicationConfig Config = 2;
    optional NKikimrProto.TPathID PathId = 3; // path id assigned by schemeshard
    optional uint64 Version = 4;
    optional uint64 ControllerId = 5; // replication controller's tablet id
    optional NKikimrReplication.TReplicationState State = 6;

    message TAlterTransfer {
        optional string TransformLambda = 1;
        optional uint64 FlushIntervalMilliSeconds = 2 [default = 60000];
        optional uint64 BatchSizeBytes = 3 [default = 8388608];
    }

    optional TAlterTransfer AlterTransfer = 10;
}

message TBlobDepotDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional NKikimrBlobDepot.TBlobDepotConfig Config = 4;
    optional fixed64 TabletId = 5; // for unsharded mode
}

message TApplyIf {
    optional uint64 PathId = 1;
    optional uint64 PathVersion = 2;
    optional uint64 LockedTxId = 3;
    optional bool CheckEntityVersion = 4 [default = false];
    repeated EPathType PathTypes = 5;
}

message TUpgradeSubDomain {
    optional string Name = 1;

    enum EDecision {
        Invalid = 0;
        Undo = 2;
        Commit = 3;
    }

    optional EDecision Decision = 2;
}

message TIndexBuildConfig {
    optional string Table = 1;
    optional TIndexCreationConfig Index = 2;
}

message TIndexBuildControl {
    optional string TablePath = 1;
    optional string IndexName = 2;
    optional uint64 SnapshotTxId = 3;
    optional uint64 BuildIndexId = 4;
}

message TLockConfig {
    optional string Name = 1;
    optional uint64 LockTxId = 2; // if missing, current tx id is used
}

message TLockGuard {
    optional uint64 OwnerTxId = 1;
}

message TDropIndex {
    optional string TableName = 1;
    optional string IndexName = 2;
}

message TConsistencyShardsModification {
    repeated TConsistencyShardingTablet Shards = 1;
}

message TModuloShardsModification {
    repeated TModuloShardingTablet Shards = 1;
    optional uint32 PartsCount = 2;
}

message TShardingModification {
    repeated uint64 NewShardIds = 1;
    repeated uint64 DeleteShardIds = 2;

    repeated uint64 CloseWriteIds = 3;
    repeated uint64 CloseReadIds = 4;
    repeated uint64 OpenWriteIds = 5;
    repeated uint64 OpenReadIds = 6;

    oneof Implementation {
        TConsistencyShardsModification Consistency = 20;
        TModuloShardsModification Modulo = 21;
    }
}

message TShardingTransfer {
    optional uint64 DestinationTabletId = 1;
    repeated uint64 SourceTabletIds = 2;
    optional bool Moving = 3 [default = false];
    optional string SessionId = 4;
}

message TShardingTransfers {
    repeated TShardingTransfer Transfers = 1;
}

message TAlterShards {
    oneof Implementation {
        TShardingModification Modification = 20;
        TShardingTransfers Transfer = 21;
    }
}

// Request for scheme modification
// Has only one of the operations
message TModifyScheme {
    optional string WorkingDir = 1;
    optional EOperationType OperationType = 2;
    optional bool Internal = 36 [default = false]; // internal operations are not generated directly by the user
    optional bool FailOnExist = 50 [default = false]; // as a replacement for TEvModifySchemeTransaction.FailOnExist
    optional bool AllowAccessToPrivatePaths = 53 [default = false];

    optional TMkDir MkDir = 3;
    optional TTableDescription CreateTable = 4;
    optional TPersQueueGroupDescription CreatePersQueueGroup = 5;
    optional TPersQueueGroupDescription AlterPersQueueGroup = 6;
    optional TDrop Drop = 7;
    optional TModifyACL ModifyACL = 8;
    optional TTableDescription AlterTable = 9;
    optional TSplitMergeTablePartitions SplitMergeTablePartitions = 10;
    optional TBackupTask Backup = 11;
    optional NKikimrSubDomains.TSubDomainSettings SubDomain = 12;
    optional TRtmrVolumeDescription CreateRtmrVolume = 13;
    optional TBlockStoreVolumeDescription CreateBlockStoreVolume = 14;
    optional TBlockStoreVolumeDescription AlterBlockStoreVolume = 15;
    optional TBlockStoreAssignOp AssignBlockStoreVolume = 16;
    optional TKesusDescription Kesus = 17;
    optional TCreateSolomonVolume CreateSolomonVolume = 18;
    optional TAlterUserAttributes AlterUserAttributes = 19;
    repeated TApplyIf ApplyIf = 20;
    optional TIndexCreationConfig CreateTableIndex = 21;
    optional TIndexedTableCreationConfig CreateIndexedTable = 22;
    optional TConsistentTableCopyingConfig CreateConsistentCopyTables = 23;
    reserved 24;
    optional TUpgradeSubDomain UpgradeSubDomain = 25;
    optional TIndexBuildConfig InitiateIndexBuild = 26;
    optional TInitiateBuildIndexMainTable InitiateBuildIndexMainTable = 27;
    optional TLockConfig LockConfig = 28;
    optional TLockGuard LockGuard = 29;
    optional TIndexAlteringConfig AlterTableIndex = 30;
    optional TFinalizeBuildIndexMainTable FinalizeBuildIndexMainTable = 31;
    optional TIndexBuildControl ApplyIndexBuild = 32;
    optional TAlterSolomonVolume AlterSolomonVolume = 33;
    optional TDropIndex DropIndex = 34;
    optional TIndexBuildControl CancelIndexBuild = 35;
    optional TFileStoreDescription CreateFileStore = 37;
    optional TFileStoreDescription AlterFileStore = 38;
    optional TRestoreTask Restore = 39;
    optional TColumnStoreDescription CreateColumnStore = 40;
    optional TColumnTableDescription CreateColumnTable = 41;
    optional TAlterColumnStore AlterColumnStore = 42;
    optional TAlterColumnTable AlterColumnTable = 43;
    optional TAlterLogin AlterLogin = 44;
    optional TCreateCdcStream CreateCdcStream = 45;
    optional TAlterCdcStream AlterCdcStream = 46;
    optional TDropCdcStream DropCdcStream = 47;
    optional TRotateCdcStream RotateCdcStream = 83;
    optional TMove MoveTable = 48;
    optional TMove MoveTableIndex = 49;
    optional TSequenceDescription Sequence = 51;
    optional TReplicationDescription Replication = 52;

    optional TBlobDepotDescription BlobDepot = 54;
    optional TMoveIndex MoveIndex = 55;

    optional TPersQueueGroupAllocate AllocatePersQueueGroup = 56;
    optional TPersQueueGroupDeallocate DeallocatePersQueueGroup = 57;

    optional TExternalTableDescription CreateExternalTable = 58;

    optional TExternalDataSourceDescription CreateExternalDataSource = 59;

    optional TDropBlockStoreVolume DropBlockStoreVolume = 60;

    optional NKikimrIndexBuilder.TColumnBuildSettings InitiateColumnBuild = 61;

    optional bool SuccessOnNotExist = 62;

    optional bool FailedOnAlreadyExists = 63 [default = true];

    optional TViewDescription CreateView = 64;

    optional NActorsProto.TActorId TempDirOwnerActorId = 65;

    optional TCopySequence CopySequence = 66;
    optional TReplicationDescription AlterReplication = 67;

    optional TCreateContinuousBackup CreateContinuousBackup = 68;
    optional TAlterContinuousBackup AlterContinuousBackup = 69;
    optional TDropContinuousBackup DropContinuousBackup = 70;

    // This flag is required for TModifyScheme to create any new objects inside temporary zone.
    // Reads/Updates can be executed without flag.
    // Object is in temporary zone if there is a directory with nonempty OwnerActorId on it's path.
    optional bool AllowCreateInTempDir = 71 [default = false];

    optional TResourcePoolDescription CreateResourcePool = 72;

    optional TRestoreMultipleIncrementalBackups RestoreMultipleIncrementalBackups = 73;

    optional TBackupCollectionDescription CreateBackupCollection = 74;
    optional TBackupCollectionDescription AlterBackupCollection = 75;
    optional TBackupCollectionDescription DropBackupCollection = 76;
    optional TBackupBackupCollection BackupBackupCollection = 78;
    optional TBackupBackupCollection BackupIncrementalBackupCollection = 79;
    optional TBackupBackupCollection RestoreBackupCollection = 80;

    optional TMove MoveSequence = 77;

    optional TSysViewDescription CreateSysView = 81;

    optional TChangePathState ChangePathState = 82;

    // Some entries are grouped by semantics, so are out of order
}

message TCopySequence {
    optional string CopyFrom = 1;
}

// "Script", used by client to parse text files with multiple DDL commands
message TModifyScript {
    repeated TModifyScheme ModifyScheme = 1;
}

message TDescribeOptions {
    optional bool ReturnPartitioningInfo = 1 [default = true];
    optional bool ReturnPartitionConfig = 2 [default = true];
    optional bool BackupInfo = 3 [default = false];
    optional bool ReturnPartitionStats = 4 [default = false];
    optional bool ReturnChildren = 5 [default = true];
    optional bool ReturnBoundaries = 6 [default = false];
    optional bool ShowPrivateTable = 7 [default = false];
    optional bool ReturnChannelsBinding = 8 [default = false];
    optional bool ReturnRangeKey = 9 [default = true];
    optional bool ReturnSetVal = 10 [default = false];
    optional bool ReturnIndexTableBoundaries = 11 [default = false];
}

// Request to read scheme for a specific path
// Path can be specified in two ways:
// 1. full path
// 2. (schemeshard id, path id) pair that is unique within the whole system
message TDescribePath {
    optional string Path = 1;
    optional uint64 PathId = 2;
    optional uint64 SchemeshardId = 3;

    optional bool ReturnPartitioningInfo = 4 [default = true]; // deprecated
    optional bool ReturnPartitionConfig = 5 [default = true]; //  deprecated
    optional bool BackupInfo = 6 [default = false];           //  deprecated

    optional TDescribeOptions Options = 7;
}

// Must be sync with Ydb::EntryType
enum EPathType {
    EPathTypeInvalid = 0;
    EPathTypeDir = 1;
    EPathTypeTable = 2;
    EPathTypePersQueueGroup = 3;
    EPathTypeSubDomain = 4;
    EPathTypeRtmrVolume = 5;
    EPathTypeBlockStoreVolume = 6;
    EPathTypeKesus = 7;
    EPathTypeSolomonVolume = 8;
    EPathTypeTableIndex = 9; // Used for abstract index
    EPathTypeExtSubDomain = 10;
    EPathTypeFileStore = 11;
    EPathTypeColumnStore = 12;
    EPathTypeColumnTable = 13;
    EPathTypeCdcStream = 14;
    EPathTypeSequence = 15;
    EPathTypeReplication = 16;
    EPathTypeBlobDepot = 17;
    EPathTypeExternalTable = 18;
    EPathTypeExternalDataSource = 19;
    EPathTypeView = 20;
    EPathTypeResourcePool = 21;
    EPathTypeBackupCollection = 22;
    EPathTypeTransfer = 23;
    EPathTypeSysView = 24;
}

enum EPathSubType {
    EPathSubTypeEmpty = 0;
    EPathSubTypeSyncIndexImplTable = 1;
    EPathSubTypeAsyncIndexImplTable = 2;
    EPathSubTypeStreamImpl = 3;
    EPathSubTypeVectorKmeansTreeIndexImplTable = 4;
}

enum EPathState {
    EPathStateNotExist = 1;
    EPathStateNoChanges = 2;
    EPathStateCreate = 3;
    EPathStateAlter = 4;
    EPathStateDrop = 5;
    EPathStateCopying = 6;
    EPathStateBackup = 7;
    EPathStateUpgrade = 8;
    EPathStateMigrated = 9;
    EPathStateRestore = 10;
    EPathStateMoving = 11;
    EPathStateOutgoingIncrementalRestore = 12;
    EPathStateAwaitingOutgoingIncrementalRestore = 13;
    EPathStateIncomingIncrementalRestore = 14;
}

message TPathVersion {
    optional uint64 GeneralVersion = 1;

    optional uint64 ACLVersion = 2;
    optional uint64 EffectiveACLVersion = 3;
    optional uint64 UserAttrsVersion = 4;
    optional uint64 ChildrenVersion = 5;
    optional uint64 SubDomainVersion = 6;
    optional uint64 TableSchemaVersion = 7;
    optional uint64 TablePartitionVersion = 8;
    optional uint64 TableIndexVersion = 9;
    optional uint64 PQVersion = 10;
    optional uint64 BSVVersion = 11;
    optional uint64 KesusVersion = 12;
    optional uint64 RTMRVersion = 13;
    optional uint64 SolomonVersion = 14;
    optional uint64 FileStoreVersion = 15;
    optional uint64 ColumnStoreVersion = 16;
    optional uint64 ColumnTableVersion = 17;
    optional uint64 SubDomainStateVersion = 19;
    optional uint64 ColumnTableSchemaVersion = 20;
    optional uint64 ColumnTableTtlSettingsVersion = 21;
    optional uint64 CdcStreamVersion = 22;
    optional uint64 SecurityStateVersion = 23;
    optional uint64 SequenceVersion = 24;
    optional uint64 ReplicationVersion = 25;
    optional uint64 BlobDepotVersion = 26;
    optional uint64 ExternalTableVersion = 27;
    optional uint64 ExternalDataSourceVersion = 28;
    optional uint64 ViewVersion = 29;
    optional uint64 ResourcePoolVersion = 30;
    optional uint64 BackupCollectionVersion = 31;
    optional uint64 SysViewVersion = 32;
}

// Describes single path
message TDirEntry {
    optional string Name = 1;
    optional uint64 PathId = 2;
    optional uint64 SchemeshardId = 3; // PathOwnerId
    optional EPathType PathType = 4;
    optional bool CreateFinished = 5;
    optional uint64 CreateTxId = 6;
    optional uint64 CreateStep = 7;
    optional uint64 ParentPathId = 8; // parentPathOwnerId ?
    optional EPathState PathState = 9;
    optional string Owner = 10;
    optional bytes ACL = 11;
    optional bytes EffectiveACL = 12;
    optional uint64 PathVersion = 13;
    optional EPathSubType PathSubType = 14;
    optional TPathVersion Version = 15;
    optional bool ChildrenExist = 16;

    optional uint64 BalancerTabletID = 999; //temporary optimization for old PQ read/write protocol. Must be removed later
}

// Describes single partition (range or point) of a table
message TTablePartition {
    optional bytes EndOfRangeKeyPrefix = 1;     // Serialize/deserialize using TSerializedCellVec
    optional bool IsPoint = 2;
    optional bool IsInclusive = 3;
    optional uint64 DatashardId = 4;
}

message TShardError {
    optional uint64 ShardId = 1;
    optional string Explain = 2;
};

message TBackupProgress {
    optional uint32 NotCompleteYet = 1;
    optional uint32 Total = 2;
    optional uint32 ErrorCount = 3;
    optional uint64 StartTime = 4;
    repeated TShardError Errors = 5;
    optional TYTSettings YTSettings = 6;
    optional uint64 DataTotalSize = 7;
    optional uint64 TxId = 8;
}

message TLastBackupResult {
    optional uint32 ErrorCount = 1;
    optional uint64 CompleteTimeStamp = 2;
    optional uint64 StartTimeStamp = 3;
    repeated TShardError Errors = 4;
    optional TYTSettings YTSettings = 5;
    optional uint64 DataTotalSize = 6;
    optional uint64 TxId = 7;
};

// Result for TDescribePath request
message TPathDescription {
    optional TDirEntry Self = 1;                    // info about the path itself
    repeated TDirEntry Children = 2;                // for directory
    optional TTableDescription Table = 3;           // for table
    repeated TTablePartition TablePartitions = 4;   // for table
    optional TPersQueueGroupDescription PersQueueGroup = 5; // for pq group
    optional TBackupProgress BackupProgress = 6;
    repeated TLastBackupResult LastBackupResult = 7;
    optional NKikimrTableStats.TTableStats TableStats = 8;
    optional NKikimrTabletBase.TMetrics TabletMetrics = 9;
    optional NKikimrSubDomains.TDomainDescription DomainDescription = 10;
    optional TRtmrVolumeDescription RtmrVolumeDescription = 11; // for rtmr volume
    optional TBlockStoreVolumeDescription BlockStoreVolumeDescription = 12;
    optional TKesusDescription Kesus = 13;
    optional TSolomonVolumeDescription SolomonDescription = 14;
    repeated NKikimrTableStats.TTableStats TablePartitionStats = 15;
    repeated TUserAttribute UserAttributes = 16;
    optional TIndexDescription TableIndex = 17;
    repeated NKikimrTabletBase.TMetrics TablePartitionMetrics = 18;
    repeated uint64 AbandonedTenantsSchemeShards = 19;
    optional TFileStoreDescription FileStoreDescription = 20;
    optional TColumnStoreDescription ColumnStoreDescription = 21;
    optional TColumnTableDescription ColumnTableDescription = 22;
    optional TCdcStreamDescription CdcStreamDescription = 23;
    optional TSequenceDescription SequenceDescription = 24;
    optional TReplicationDescription ReplicationDescription = 25;
    optional TBlobDepotDescription BlobDepotDescription = 26;
    optional TExternalTableDescription ExternalTableDescription = 27;
    optional TExternalDataSourceDescription ExternalDataSourceDescription = 28;
    optional TViewDescription ViewDescription = 29;
    optional TResourcePoolDescription ResourcePoolDescription = 30;
    optional TBackupCollectionDescription BackupCollectionDescription = 31;
    optional TSysViewDescription SysViewDescription = 32;
}

// For persisting AlterTable Tx description in Schemeshard internal DB
message TAlterExtraData {
    optional TPartitionConfig PartitionConfig = 1;
}

message TResourceProfile {
    // Here is how tablet resource profile with specified NAME and TYPE is searched:
    //  1. Search for profile NAME for tablet TYPE.
    //  2. Search for profile 'default' for tablet TYPE.
    //  3. Search for profile NAME for tablet 'Unknown'.
    //  4. Search for profile 'default' for tablet 'Unknown'.
    //  5. Use default NKikimrSchemeOp.TResourceProfile value.
    optional NKikimrTabletBase.TTabletTypes.EType TabletType = 1 [default = Unknown];
    optional string Name = 2;
    // Memory used by tablet (not related to transactions and executor cache).
    // Used only for new tablets with no memory usage statistics collected.
    optional uint64 DefaultTabletMemoryUsage = 3 [default = 1048576]; //1MB
    // Max static memory consumption for tablet transactions. Additional memory should
    // be requested in Resource Broker.
    optional uint64 StaticTabletTxMemoryLimit = 4 [default = 0]; // Unlimited by default.
    // Max static memory consumption for a single transaction. If transaction requires
    // more memory then it has to be requested via Resource Broker.
    optional uint64 StaticTxMemoryLimit = 5 [default = 262144000]; // 250MB.
    // Memory consumption limit for transactions. Transactions requiring more
    // memory should be terminated.
    optional uint64 TxMemoryLimit = 6 [default = 0]; // Unlimited by default.
    // Memory initially allocated for transaction data (doesn't include pages used
    // by transaction). Additional memory should be requested by transaction via
    // transaction context.
    optional uint64 InitialTxMemory = 7 [default = 4194304]; // 4MB
    // Memory consumption limit for small transactions.
    optional uint64 SmallTxMemoryLimit = 8 [default = 10485760]; // 10MB
    // Memory consumption limit for medium transactions.
    optional uint64 MediumTxMemoryLimit = 9 [default = 104857600]; // 100MB
    // Resource Broker task type for small transactions.
    optional string SmallTxTaskType = 10 [default = "transaction"];
    // Resource Broker task type for medium transactions.
    optional string MediumTxTaskType = 11 [default = "transaction"];
    // Resource Broker task type for large transactions.
    optional string LargeTxTaskType = 12 [default = "transaction"];
}

message TExternalTableDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string SourceType = 4;
    optional string DataSourcePath = 5;
    optional string Location = 6;
    repeated TColumnDescription Columns = 7;
    optional bytes Content = 8;
    optional bool ReplaceIfExists = 9; // Only applicable for `create external table` operation
}

// Access without authorization
message TNoneAuth {
}

message TServiceAccountAuth {
    optional string Id = 1;
    optional string SecretName = 2;
}

message TMdbBasic {
    optional string ServiceAccountId = 1;
    optional string ServiceAccountSecretName = 2;
    optional string Login = 3;
    optional string PasswordSecretName = 4;
}

message TAws {
    optional string AwsAccessKeyIdSecretName = 1;
    optional string AwsSecretAccessKeySecretName = 2;
    optional string AwsRegion = 3;
}

message TBasic {
    optional string Login = 1;
    optional string PasswordSecretName = 2;
}

message TToken {
    optional string TokenSecretName = 2;
}

message TAuth {
    oneof identity {
        TNoneAuth None = 3;
        TServiceAccountAuth ServiceAccount = 4;
        TBasic Basic = 5;
        TMdbBasic MdbBasic = 6;
        TAws Aws = 7;
        TToken Token = 8;
    }
}

message TExternalTableReferences {
    message TReference {
        optional string Path = 1;
        optional NKikimrProto.TPathID PathId = 2;
    }
    repeated TReference References = 1;
}

message TExternalDataSourceProperties {
    map<string, string> Properties = 1;
}

message TExternalDataSourceDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string SourceType = 4;
    optional string Location = 5;
    optional string Installation = 6;
    optional TAuth Auth = 7;
    optional TExternalDataSourceProperties Properties = 8;
    optional bool ReplaceIfExists = 9;
    optional TExternalTableReferences References = 10;
}

message TViewDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string QueryText = 4;
    optional NYql.NProto.TTranslationSettings CapturedContext = 5;
}

message TResourcePoolProperties {
    map<string, string> Properties = 1;
}

message TResourcePoolDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional TResourcePoolProperties Properties = 4;
}

message TBackupCollectionDescription {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional uint64 Version = 3;
    optional string Prefix = 8; // Used as WorkingDir for all entities. Not persisted.

    message TBackupEntry {
        enum EType {
            ETypeInvalid = 0;
            ETypeTable = 1;
        }

        optional EType Type = 1;
        optional string Path = 2;
    }

    message TExplicitEntryList {
        repeated TBackupEntry Entries = 1;
    }

    message TIncrementalBackupConfig {

    }

    oneof Entries {
        google.protobuf.Empty Database = 4;
        TExplicitEntryList ExplicitEntryList = 5;
    }

    // non-empty enables data-collection
    optional TIncrementalBackupConfig IncrementalBackupConfig = 6;

    oneof Storage {
        google.protobuf.Empty Cluster = 7;
    }
}

message TBackupBackupCollection {
    optional string Name = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional string TargetDir = 3; // must be set on Rewrite
}

message TImportTableChangefeeds {
    message TImportChangefeedTopic {
        optional Ydb.Table.ChangefeedDescription Changefeed = 1;
        optional Ydb.Topic.DescribeTopicResult Topic = 2;
    }
    repeated TImportChangefeedTopic Changefeeds = 1;
}

message TChangefeedUnderlyingTopics {
    repeated TPathDescription ChangefeedUnderlyingTopics = 1;
}

message TExportMetadata {
    message TSchemaMappingItem {
        optional string SourcePath = 1;
        optional string DestinationPrefix = 2;

        // encryption details
        optional bytes IV = 3;
    }

    repeated TSchemaMappingItem SchemaMapping = 1;

    optional string CompressionAlgorithm = 2;
    optional string EncryptionAlgorithm = 3;
    optional bytes IV = 4;
}

message TSysViewDescription {
    optional string Name = 1;
    optional NKikimrSysView.ESysViewType Type = 2;
    optional NKikimrProto.TPathID SourceObject = 3;
}

message TLongIncrementalRestoreOp {
    optional uint64 TxId = 1;
    optional NKikimrProto.TPathID BackupCollectionPathId = 2;
    optional string Id = 3;
    repeated string TablePathList = 4;
    optional string FullBackupTrimmedName = 5;
    repeated string IncrementalBackupTrimmedNames = 6;
}

message TChangePathState {
    optional string Path = 1;
    optional EPathState TargetState = 2;
}
