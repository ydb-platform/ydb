option cc_enable_arenas = true;

import "ydb/library/actors/protos/actors.proto";
import "ydb/core/protos/base.proto";
import "ydb/core/scheme/protos/type_info.proto";
import "ydb/core/scheme/protos/key_range.proto";
import "ydb/core/scheme/protos/pathid.proto";
import "ydb/core/protos/data_events.proto";
import "ydb/core/protos/kqp.proto";
import "ydb/library/formats/arrow/protos/ssa.proto";
import "ydb/core/protos/tablet.proto";
import "ydb/core/protos/tx.proto";
import "ydb/core/protos/flat_scheme_op.proto";
import "ydb/core/protos/table_stats.proto";
import "ydb/core/protos/subdomains.proto";
import "ydb/core/protos/sys_view_types.proto";
import "ydb/core/protos/query_stats.proto";
import "ydb/public/api/protos/ydb_issue_message.proto";
import "ydb/public/api/protos/ydb_status_codes.proto";
import "ydb/public/api/protos/ydb_table.proto";
import "ydb/library/yql/dq/actors/protos/dq_events.proto";
import "ydb/library/yql/dq/actors/protos/dq_stats.proto";
import "ydb/library/yql/dq/proto/dq_tasks.proto";
import "google/protobuf/empty.proto";
import "ydb/core/protos/index_builder.proto";

package NKikimrTxDataShard;
option java_package = "ru.yandex.kikimr.proto";

enum EDatashardState {
    Uninitialized = 0;
    WaitScheme = 1;
    Ready = 2;
    Readonly = 3;
    Offline = 4;
    PreOffline = 5;     // Offline but waits for loaned snapshots to be returned and for SchemaChangedResult to be received
    Frozen = 6; // Read only transactions are allowed. Scheme modification is forbidden

    // Split/Merge Src states
    SplitSrcWaitForNoTxInFlight = 101;    // Temporary state: split src waits for all Tx to finish and then starts splitting
    SplitSrcMakeSnapshot = 102;
    SplitSrcSendingSnapshot = 103;
    SplitSrcWaitForPartitioningChanged = 104;

    // Split/Merge Dst states
    SplitDstReceivingSnapshot = 201;

    Unknown = 0xFFFF;
}

message TEvGetShardState {
   optional NActorsProto.TActorId Source = 1;
}

message TEvGetShardStateResult {
    optional uint64 Origin = 1;
    optional uint32 State = 2;
    optional uint64 DropTxId = 3;
}

message TShardOpResult {
    optional bool Success = 1;
    optional string Explain = 2;
    optional uint64 BytesProcessed = 3;
    optional uint64 RowsProcessed = 4;
}

message TEvSchemaChanged {
    optional NActorsProto.TActorId Source = 1;
    optional uint64 Origin = 2;
    optional uint32 State = 3;  // EDatashardState
    optional uint64 TxId = 4;
    optional uint64 Step = 5;
    optional uint32 Generation = 6;

    optional TShardOpResult OpResult = 7;
}

message TEvSchemaChangedResult {
    optional uint64 TxId = 1;
    // DEPRECATED: optional bool Retry = 2;
}

message TEvStateChanged {
    optional NActorsProto.TActorId Source = 1;
    optional uint64 TabletId = 2;
    optional uint32 State = 3;  // EDatashardState
}

message TEvStateChangedResult {
    optional uint64 TabletId = 1;
    optional uint32 State = 2;  // EDatashardState
}
message TRWTransaction {
}

message TROTransaction {
}

message TReadTableTransaction {
    message TColumn {
        optional uint32 Id = 1;
        optional string Name = 2;
        optional uint32 TypeId = 3;
        optional NKikimrProto.TTypeInfo TypeInfo = 4;
        optional bool NotNull = 5 [default = false]; //If not set datashard will treat not null type as nullable (for compatibility)
    }

    optional NKikimrDataEvents.TTableId TableId = 1;
    repeated TColumn Columns = 2;
    optional NKikimrTx.TKeyRange Range = 3;
    optional uint32 ApiVersion = 4;
    optional uint64 SnapshotStep = 5;
    optional uint64 SnapshotTxId = 6;
}

message TKqpValidateLocksResult {
    optional bool Success = 1;
    repeated NKikimrDataEvents.TLock BrokenLocks = 2;
};

enum EKqpTransactionType {
    KQP_TX_TYPE_UNSPECIFIED = 0;
    KQP_TX_TYPE_DATA = 1;
    KQP_TX_TYPE_SCAN = 2;
}

message TKqpTransaction {
    message TColumnMeta {
        optional uint32 Id = 1;
        optional string Name = 2;
        optional uint32 Type = 3;
        optional NKikimrProto.TTypeInfo TypeInfo = 4;
        optional bool NotNull = 5;
        optional bool IsPrimary = 6;
    }

    message TColumnWriteMeta {
        optional TColumnMeta Column = 1;
        optional uint32 MaxValueSizeBytes = 2;
    }

    message TTableKeyRange {
        // ordered lists of non-intersecting ranges and points
        repeated NKikimrTx.TKeyRange KeyRanges = 1;
        repeated bytes KeyPoints = 2;
    }

    message TTableMeta {
        optional NKikimrDataEvents.TTableId TableId = 1;
        optional string TablePath = 2;
        optional uint64 SchemaVersion = 3;
        // reserved 4
        optional string SysViewInfo = 5;
        optional uint32 TableKind = 6;      // NKikimr::NKqp::ETableKind
        optional NKikimrSysView.TSysViewDescription SysViewDescription = 7;
    }

    // Data-query task meta
    message TDataTaskMeta {
        // key range - can be either explicit full datashard range or ordered list of non-intersecting ranges
        message TKeyRange {
            oneof Kind {
                NKikimrTx.TKeyRange FullRange = 1;
                TTableKeyRange Ranges = 2;
            }
        }

        // single Read operation (== single ReadTable callable)
        message TReadOpMeta {
            repeated TColumnMeta Columns = 1;
            optional TKeyRange Range = 2;
            optional uint64 ItemsLimit = 3;
            optional bool Reverse = 4;
        }

        message TWriteOpMeta {
            optional TKeyRange Range = 1;
            repeated TColumnWriteMeta Columns = 3;
            optional bool IsPureEraseOp = 4;
        }

        optional TTableMeta Table = 1;
        repeated TReadOpMeta Reads = 2;   // if not set/empty -> no reads
        optional TWriteOpMeta Writes = 3; // if not set -> no writes
    };

    // Scan-query task meta
    message TScanTaskMeta {
        // represents single scan instance over the specified table, with given limit and ordering
        // can cover multiple datashards
        message TReadOpMeta {
            // shard id hint, may change (split, merge, kick, ...)
            optional uint64 ShardId = 1;
            // ordered list of non-intersecting ranges (not adjacent), with points (`To` is empty and `ToInclusive` is true)
            repeated NKikimrTx.TKeyRange KeyRanges = 2;
        }

        enum EReadType {
            ROWS = 0;
            BLOCKS = 1;
        }

        optional TTableMeta Table = 1;
        repeated TColumnMeta Columns = 2;
        repeated uint32 KeyColumnTypes = 3; // for debug logs only
        repeated NKikimrProto.TTypeInfo KeyColumnTypeInfos = 13; // for debug logs only
        repeated bool SkipNullKeys = 4;
        repeated TReadOpMeta Reads = 5;
        optional uint64 ItemsLimit = 6;
        optional bool Reverse = 7;
        reserved 8; // optional bytes ProcessProgram = 8;
        optional NKikimrDataEvents.EDataFormat DataFormat = 9;
        optional NKikimrSSA.TOlapProgram OlapProgram = 10; // Currently only for OLAP tables
        optional bool EnableShardsSequentialScan = 11;
        repeated TColumnMeta ResultColumns = 12;
        // Type of read result: unboxed values or Arrow blocks of data
        optional EReadType ReadType = 14;
        repeated string GroupByColumnNames = 15;
        optional uint32 OptionalSorting = 16;
    }

    optional EKqpTransactionType Type = 1;
    repeated NYql.NDqProto.TDqTask Tasks = 2;
    optional NKikimrDataEvents.TKqpLocks Locks = 3;

    optional NYql.NDqProto.TComputeRuntimeSettings RuntimeSettings = 4;
    reserved 5;

    optional NKikimrKqp.TKqpSnapshot Snapshot = 6;

    // When true datashard will exchange a generic TReadSetData with other shards
    optional bool UseGenericReadSets = 7 [default = false];
}

message TEvKqpInputActorResultInfo {
    repeated NKikimrDataEvents.TLock Locks = 1;
    optional string BatchOperationMaxKey = 2;
    repeated uint32 BatchOperationKeyIds = 3;
}

message TKqpReadRangesSourceSettings {
    optional TKqpTransaction.TTableMeta Table = 1;

    oneof RangeType {
        NKikimrTx.TKeyRange FullRange = 2;
        TKqpTransaction.TTableKeyRange Ranges = 3;
    }

    repeated TKqpTransaction.TColumnMeta Columns = 4;
    optional uint64 ItemsLimit = 5;
    optional bool Reverse = 6;

    repeated uint32 KeyColumnTypes = 8;
    repeated NKikimrProto.TTypeInfo KeyColumnTypeInfos = 15;

    optional NKikimrDataEvents.EDataFormat DataFormat = 9;
    optional NKikimrProto.TRowVersion Snapshot = 10;
    optional uint64 ShardIdHint = 11;
    optional bool Sorted = 12;

    optional uint64 LockTxId = 13;
    optional uint32 LockNodeId = 14;

    optional uint64 MaxInFlightShards = 16;
    optional bool UseFollowers = 17 [default = false];
    optional bool AllowInconsistentReads = 18 [default = false];

    repeated TKqpTransaction.TColumnMeta DuplicateCheckColumns = 19;

    optional NKikimrDataEvents.ELockMode LockMode = 20;
    optional uint32 OptionalSorting = 21;
    optional bool IsBatch = 22 [default = false];

    optional bool IsTableImmutable = 23 [default = false];
}

message TKqpTaskInfo {
    optional uint64 TaskId = 1;
    optional NActorsProto.TActorId ComputeActor = 2;
}

message TKqpReply {
    repeated NYql.NDqProto.TChannelData Outputs = 1;
    repeated TKqpTaskInfo Tasks = 2;
}

message TKqpReadset {
    repeated NYql.NDqProto.TChannelData Outputs = 1;
    optional TKqpValidateLocksResult ValidateLocksResult = 2;
}

message TDataTransaction {
    optional TRWTransaction RWTransaction = 1;  // DEPRECATED
    optional TROTransaction ROTransaction = 2;  // DEPRECATED
    optional bytes MiniKQL = 3;
    optional bool Immediate = 4;
    optional fixed64 LockTxId = 5;
    optional bool NeedDiagnostics = 6;
    optional bool ReadOnly = 7;
    optional TReadTableTransaction ReadTableTransaction = 8;
    optional bool StreamResponse = 9;
    optional NActorsProto.TActorId Sink = 10;
    optional bool LlvmRuntime = 11;
    optional uint64 PerShardKeysSizeLimitBytes = 12;
    optional TKqpTransaction KqpTransaction = 13;
    optional uint64 CancelDeadlineMs = 14; // Wallclock timestamp from datareq (not duration)
    optional uint64 CancelAfterMs = 15; // Duration from tx start local to datashard
    optional bool CollectStats = 16;

    // Datashard will subscribe to lock status when node id is non-zero
    optional uint32 LockNodeId = 17;
    optional NKikimrDataEvents.ELockMode LockMode = 18;
}

message TCreateVolatileSnapshot {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional string Name = 3;
    optional uint64 TimeoutMs = 4;
}

message TDropVolatileSnapshot {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional uint64 Step = 3;
    optional uint64 TxId = 4;
}

message TSnapshotTransaction {
    optional TCreateVolatileSnapshot CreateVolatileSnapshot = 1;
    optional TDropVolatileSnapshot DropVolatileSnapshot = 2;
}

message TSnapshotTransferReadSet {
    optional bytes BorrowedSnapshot = 1;
    optional uint64 MinWriteVersionStep = 2;
    optional uint64 MinWriteVersionTxId = 3;
    optional uint64 MvccCompleteEdgeStep = 4;
    optional uint64 MvccCompleteEdgeTxId = 5;
    optional uint64 MvccIncompleteEdgeStep = 6;
    optional uint64 MvccIncompleteEdgeTxId = 7;
    optional uint64 MvccLowWatermarkStep = 8;
    optional uint64 MvccLowWatermarkTxId = 9;
    optional uint64 MvccImmediateWriteEdgeStep = 10;
    optional uint64 MvccImmediateWriteEdgeTxId = 11;
    optional bool WithOpenTxs = 12;
}

message TSnapshotTransferInfo {
    optional uint64 Shard = 1;
};

message TReceiveSnapshot {
    optional uint64 TableId_Deprecated = 1;
    repeated TSnapshotTransferInfo ReceiveFrom = 2;
    optional NKikimrDataEvents.TTableId TableId = 3;
}

message TSendSnapshot {
    optional uint64 TableId_Deprecated = 1;
    repeated TSnapshotTransferInfo SendTo = 2;
    optional NKikimrDataEvents.TTableId TableId = 3;
}

message TSchemeOpSeqNo {
    optional uint64 Generation = 1;
    optional uint64 Round = 2;
}

message TCreatePersistentSnapshot {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional string Name = 3;
}

message TDropPersistentSnapshot {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional uint64 Step = 3;
    optional uint64 TxId = 4;
}

message TInitiateBuildIndex {
    optional NKikimrProto.TPathID PathId = 1;
    optional string SnapshotName = 2;
    optional uint64 TableSchemaVersion = 3;

    optional NKikimrSchemeOp.TIndexDescription IndexDescription = 4;
}

message TFinalizeBuildIndex {
    optional NKikimrProto.TPathID PathId = 1;

    optional uint64 SnapshotStep = 2;
    optional uint64 SnapshotTxId = 3;

    optional uint64 TableSchemaVersion = 4;

    optional uint64 BuildIndexId = 5;

    optional NKikimrSchemeOp.TBuildIndexOutcome Outcome = 6;
}

message TDropIndexNotice {
    // Path id of the table that the index is being dropped from
    optional NKikimrProto.TPathID PathId = 1;
    optional uint64 TableSchemaVersion = 2;

    // Path id of the index being dropped
    optional NKikimrProto.TPathID IndexPathId = 3;
}

message TCreateCdcStreamNotice {
    optional NKikimrProto.TPathID PathId = 1;
    optional uint64 TableSchemaVersion = 2;
    optional NKikimrSchemeOp.TCdcStreamDescription StreamDescription = 3;
    optional string SnapshotName = 4;
}

message TSnapshot {
    optional uint64 Step = 1;
    optional uint64 TxId = 2;
}

message TAlterCdcStreamNotice {
    optional NKikimrProto.TPathID PathId = 1;
    optional uint64 TableSchemaVersion = 2;
    optional NKikimrSchemeOp.TCdcStreamDescription StreamDescription = 3;
    optional TSnapshot DropSnapshot = 4;
}

message TDropCdcStreamNotice {
    optional NKikimrProto.TPathID PathId = 1;
    optional uint64 TableSchemaVersion = 2;
    optional NKikimrProto.TPathID StreamPathId = 3;
    optional TSnapshot DropSnapshot = 4;
}

message TAsyncIndexInfo {
}

message TRemapIndexPathId {
    optional NKikimrProto.TPathID SrcPathId = 1;
    optional NKikimrProto.TPathID DstPathId = 2;
    optional NKikimrProto.TPathID ReplacedPathId = 3;
    optional string DstName = 4;
}

message TMoveTable {
    optional NKikimrProto.TPathID PathId = 1;
    optional uint64 TableSchemaVersion = 2;

    optional NKikimrProto.TPathID DstPathId = 3;
    optional string DstPath = 4;

    repeated TRemapIndexPathId ReMapIndexes = 5;
}

message TMoveIndex {
    optional NKikimrProto.TPathID PathId = 1;
    optional uint64 TableSchemaVersion = 2;

    optional TRemapIndexPathId ReMapIndex = 3;
}


message TCreateIncrementalBackupSrc {
    optional TSendSnapshot SendSnapshot = 1;
    optional TCreateCdcStreamNotice CreateCdcStreamNotice = 2;
}

message TFlatSchemeTransaction {
    optional NKikimrSchemeOp.TTableDescription CreateTable = 1;
    optional NKikimrSchemeOp.TTableDescription DropTable = 2;
    optional NKikimrSchemeOp.TTableDescription AlterTable = 3;
    optional TReceiveSnapshot ReceiveSnapshot = 4;
    optional TSendSnapshot SendSnapshot = 5;
    optional NKikimrSchemeOp.TBackupTask Backup = 6;

    optional TSchemeOpSeqNo SeqNo = 7;
    optional bool ReadOnly = 8;
    reserved 9;

    optional TCreatePersistentSnapshot CreatePersistentSnapshot = 10;
    optional TDropPersistentSnapshot DropPersistentSnapshot = 11;

    optional TInitiateBuildIndex InitiateBuildIndex = 12;
    optional TFinalizeBuildIndex FinalizeBuildIndex = 13;
    optional TDropIndexNotice DropIndexNotice = 14;

    optional NKikimrSchemeOp.TRestoreTask Restore = 15;

    optional TAsyncIndexInfo AsyncIndexInfo = 16;

    optional TMoveTable MoveTable = 17;

    optional TCreateCdcStreamNotice CreateCdcStreamNotice = 18;
    optional TAlterCdcStreamNotice AlterCdcStreamNotice = 19;
    optional TDropCdcStreamNotice DropCdcStreamNotice = 20;
    optional TMoveIndex MoveIndex = 21;

    optional NKikimrSchemeOp.TRestoreIncrementalBackup CreateIncrementalRestoreSrc = 22;
    optional TCreateIncrementalBackupSrc CreateIncrementalBackupSrc = 23;
}

message TDistributedEraseTransaction {
    message TDependent {
        optional uint64 ShardId = 1;
    }

    message TDependency {
        optional uint64 ShardId = 1;
        optional bytes PresentRows = 2; // bitmap
    }

    optional TEvEraseRowsRequest EraseRowsRequest = 1;
    repeated TDependent Dependents = 2;
    repeated TDependency Dependencies = 3;

    // Identifiers (in term of main table) & values of indexed columns
    repeated uint32 IndexColumnIds = 4;
    repeated bytes IndexColumns = 5; // SerilializedCellVector
}

message TDistributedEraseRS {
    optional bytes ConfirmedRows = 1; // bitmap
}

// This transaction commits all changes previously written using some WriteTxId
message TCommitWritesTransaction {
    // TODO: add lock checking in the future

    optional NKikimrDataEvents.TTableId TableId = 1;
    optional uint64 WriteTxId = 2;
}

enum ETransactionKind {
    TX_KIND_NONE = 0;
    TX_KIND_DATA = 1;
    TX_KIND_SCHEME = 2;
    DEPRECATED_3 = 3; //TX_KIND_BALANCE
    DEPRECATED_4 = 4; //TX_KIND_SNAPSHOT_POLICY
    TX_KIND_SCAN = 5;
    TX_KIND_SNAPSHOT = 6;
    TX_KIND_DISTRIBUTED_ERASE = 7;
    TX_KIND_COMMIT_WRITES = 8;

    // Values [100, inf) are used for internal datashard operation
    // kinds. See NKikimr::NDataShard::EOperationKind.
}

message TEvProposeTransaction {
    optional ETransactionKind TxKind = 1;
    optional NActorsProto.TActorId SourceDeprecated = 2 [deprecated = true]; // for compatibility with old tx engine
    optional bytes TxBody = 3;
    optional uint64 TxId = 4;
    optional uint32 ExecLevel = 5;
    optional uint32 Flags = 6;
    optional uint64 SchemeShardId = 7;
    optional NKikimrSubDomains.TProcessingParams ProcessingParams = 8;
    optional uint64 SubDomainPathId = 9; // LocalPathId (SchemeShardId is the OwnerId)
    optional NKikimrDataEvents.TMvccSnapshot MvccSnapshot = 10;
    optional bool MvccSnapshotRepeatable = 11 [default = true];
}

message TEvCancelTransactionProposal {
    optional uint64 TxId = 1;
}

message TError {
    enum EKind {
        OK = 0;
        BAD_TX_KIND = 1;
        BAD_ARGUMENT = 2;
        SCHEME_ERROR = 3;
        WRONG_PAYLOAD_TYPE = 4;
        LEAF_REQUIRED = 5;
        READONLY = 6;
        WRONG_SHARD_STATE = 7;
        SNAPSHOT_NOT_EXIST = 8;
        SNAPSHOT_NOT_READY_YET = 9;
        SCHEME_CHANGED = 10;
        DUPLICATED_SNAPSHOT_POLICY = 11;
        MISSING_SNAPSHOT_POLICY = 12;
        PROGRAM_ERROR = 13;
        OUT_OF_SPACE = 14;
        READ_SIZE_EXECEEDED = 15;
        SHARD_IS_BLOCKED = 16;
        UNKNOWN = 17;
        REPLY_SIZE_EXCEEDED = 18;
        EXECUTION_CANCELLED = 19;
        // This enum value is not supported in versions 23-2 and below and would be interpreted as OK due to how proto2 enums work.
        // Version 23-3 can handle the value, so it is safe to use only in the next major release after 23-3.
        DISK_SPACE_EXHAUSTED = 20;
    }

    optional EKind Kind = 1;
    optional bytes Key = 2;
    optional bytes Reason = 3;
}

message TEvProposeTransactionResult {
    enum EStatus {
        PREPARED = 1;
        COMPLETE = 2;
        ABORTED = 3;
        ERROR = 4;
        TRY_LATER = 5;
        OVERLOADED = 6;
        RESPONSE_DATA = 7;
        EXEC_ERROR = 8;
        RESULT_UNAVAILABLE = 9;
        LOCKS_BROKEN = 10;
        CANCELLED = 11;
        BAD_REQUEST = 12;
    };

    message TReadSetInfo {
        optional uint64 ShardId = 1;
        optional uint64 Size = 2;
    };

    optional ETransactionKind TxKind = 1;
    optional uint64 Origin = 2;
    optional EStatus Status = 3;
    repeated TError Error = 4;
    optional uint64 TxId = 5;
    optional uint64 MinStep = 6;
    optional uint64 MaxStep = 7;
    optional bytes TxResult = 8;
    optional uint64 Step = 9;
    optional uint64 OrderId = 10;
    optional NKikimrTx.TBalanceTrackList BalanceTrackList = 11;
    optional uint64 PrepareArriveTime = 12;
    optional uint64 ExecLatency = 13;
    optional uint64 ProposeLatency = 14;
    repeated NKikimrDataEvents.TLock TxLocks = 15;
    optional uint64 ReadSize = 16;
    optional uint64 ReplySize = 17;
    repeated TReadSetInfo OutgoingReadSetInfo = 18;
    optional NKikimrDataEvents.TTabletInfo TabletInfo = 19;
    // For read table tx result holds offsets in TxResult to cut response
    repeated uint32 RowOffsets = 20;
    repeated fixed64 DomainCoordinators = 21;
    optional uint32 ApiVersion = 22; // Version of TxResult response data
    optional NKikimrQueryStats.TTxStats TxStats = 23;
    optional uint64 DataSeqNo = 24; // Response data seqno (1, 2, ...)
    optional bytes DataLastKey = 25; // Response data last key (for retries)
    reserved 26; // optional NKqpProto.TKqpStatsRun KqpRunStats = 26;
    optional NYql.NDqProto.TDqComputeActorStats ComputeActorStats = 27; // overall time + per-task statistics
    optional NKikimrProto.TRowVersion CommitVersion = 28;
}

message TEvProposeTransactionRestart {
    optional uint64 TabletId = 1;
    optional uint64 TxId = 2;
}

message TEvProposeTransactionAttach {
    optional uint64 TabletId = 1;
    optional uint64 TxId = 2;
}

message TEvProposeTransactionAttachResult {
    optional uint64 TabletId = 1;
    optional uint64 TxId = 2;
    optional NKikimrProto.EReplyStatus Status = 3;
}

message TAddSnapshotPolicyTransaction {
    optional uint32 SnapshotCountLimit = 1;
    optional uint64 StartStep = 2;
    optional uint64 DeltaStep = 3;
}

message TEvReturnBorrowedPart {
    optional uint64 FromTabletId = 1;
    repeated NKikimrProto.TLogoBlobID PartMetadata = 2;
}

message TEvReturnBorrowedPartAck {
    repeated NKikimrProto.TLogoBlobID PartMetadata = 1;
}

message TKeyRangeToTablet {
    optional bytes KeyRangeBegin = 1;
    optional bytes KeyRangeEnd = 2;
    optional uint64 TabletID = 3;       // datashard tabletId
    optional uint64 ShardIdx = 4;       // Internal idx of a datashard in schemeshard
}

message TSplitMergeDescription {
    repeated TKeyRangeToTablet SourceRanges = 1;
    repeated TKeyRangeToTablet DestinationRanges = 2;
}

// Schemeshard -> Dst datashard
message TEvInitSplitMergeDestination {
    optional uint64 OperationCookie = 1;
    optional uint64 SchemeshardTabletId = 2; // OwnerSchemeShardTabletId
    optional TSplitMergeDescription SplitDescription = 3;
    optional NKikimrSubDomains.TProcessingParams ProcessingParams = 4;
    optional NKikimrSchemeOp.TTableDescription CreateTable = 5;
    optional uint64 SubDomainPathId = 6; // LocalPathId (SchemeshardTabletId is the OwnerId)
}

message TEvInitSplitMergeDestinationAck {
    optional uint64 OperationCookie = 1;
    optional uint64 TabletId = 2;
}

// Schemeshard -> Src datashard
message TEvSplit {
    optional uint64 OperationCookie = 1;
    optional TSplitMergeDescription SplitDescription = 2;
}

message TEvSplitAck {
    optional uint64 OperationCookie = 1;
    optional uint64 TabletId = 2;
}

message TTableSnapshot {
    optional uint64 TableId = 1; // tableid in term of localDB
    optional bytes SnapshotData = 2;
}

message TPersistentSnapshot {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional uint64 Step = 3;
    optional uint64 TxId = 4;
    optional string Name = 5;
    optional uint64 Flags = 6;
    optional uint64 TimeoutMs = 7;
}

// Src datashard -> Dst datashard
message TEvSplitTransferSnapshot {
    optional uint64 OperationCookie = 1;
    optional uint64 SrcTabletId = 2;
    optional NKikimrSchemeOp.TTableDescription UserTableScheme = 3;
    repeated TTableSnapshot TableSnapshot = 4;
    optional uint64 MinWriteVersionStep = 5;
    optional uint64 MinWriteVersionTxId = 6;
    repeated TPersistentSnapshot PersistentSnapshots = 7;
    optional uint64 MvccCompleteEdgeStep = 8;
    optional uint64 MvccCompleteEdgeTxId = 9;
    optional uint64 MvccIncompleteEdgeStep = 10;
    optional uint64 MvccIncompleteEdgeTxId = 11;
    optional uint64 MvccLowWatermarkStep = 12;
    optional uint64 MvccLowWatermarkTxId = 13;
    optional bool WaitForActivation = 14;

    // Generation of the sender tablet
    optional uint64 SrcTabletGeneration = 15;

    // Number of bytes that are in the ReplicationSourceOffsets table
    optional uint64 ReplicationSourceOffsetsBytes = 16;

    optional uint64 MvccImmediateWriteEdgeStep = 17;
    optional uint64 MvccImmediateWriteEdgeTxId = 18;
    optional bool MvccPerformedUnprotectedReads = 19;
}

message TEvSplitTransferSnapshotAck {
    optional uint64 TabletId = 1;
    optional uint64 OperationCookie = 2;
}

// Schemeshard -> Src datashard
message TEvSplitPartitioningChanged {
    optional NActorsProto.TActorId Sender = 2;
    optional uint64 OperationCookie = 1;
}

message TEvSplitPartitioningChangedAck {
    optional uint64 OperationCookie = 1;
    optional uint64 TabletId = 2;
}

message TEvCancelBackup {
    optional uint64 BackupTxId = 1;
    optional uint64 TableId = 2;
}

message TEvCancelRestore {
    optional uint64 RestoreTxId = 1;
    optional uint64 TableId = 2;
}

message TEvGetTableStats {
    optional uint64 TableId = 1;
    optional uint64 DataSizeResolution = 2;
    optional uint64 RowCountResolution = 3;
    optional bool CollectKeySample = 4;
    optional uint32 HistogramBucketsCount = 5;
}

message TEvGetTableStatsResult {
    optional uint64 DatashardId = 1;
    optional uint64 TableLocalId = 2;
    optional NKikimrTableStats.TTableStats TableStats = 3;
    optional NKikimrTabletBase.TMetrics TabletMetrics = 4;
    optional uint32 ShardState = 5;
    repeated uint64 UserTablePartOwners = 6;
    repeated uint64 SysTablesPartOwners = 7;
    optional bool FullStatsReady = 8;
    optional uint64 TableOwnerId = 9;
}

message TEvPeriodicTableStats {
    optional uint64 DatashardId = 1;
    optional uint64 TableLocalId = 2;

    optional uint64 Generation = 3;
    optional uint64 Round = 4;

    optional NKikimrTableStats.TTableStats TableStats = 5;
    optional NKikimrTabletBase.TMetrics TabletMetrics = 6;

    optional uint32 ShardState = 7;
    repeated uint64 UserTablePartOwners = 8;
    repeated uint64 SysTablesPartOwners = 9;

    optional uint32 NodeId = 10;
    optional uint64 StartTime = 11; // milliseconds since epoch

    optional uint64 TableOwnerId = 12;

    optional bool IsDstSplit = 13;

    repeated TEvPeriodicTableStats Tables = 14;
    optional uint32 FollowerId = 15;
}

message TObjectStorageListingFilter {
    enum EMatchType {
        EQUAL = 0;
        NOT_EQUAL = 1;
    }
    optional bytes Values = 1;
    repeated uint32 Columns = 2;
    repeated EMatchType MatchTypes = 3;
}

message TEvObjectStorageListingRequest {
    optional uint64 TableId = 1;
    optional bytes SerializedKeyPrefix = 2;

    optional string PathColumnPrefix = 3;
    optional string PathColumnDelimiter = 4;

    optional bytes SerializedStartAfterKeySuffix = 5;

    repeated uint32 ColumnsToReturn = 6;
    optional uint32 MaxKeys = 7;

    optional string LastCommonPrefix = 8;
    optional string LastPath = 9;

    optional TObjectStorageListingFilter Filter = 10;
}

message TEvObjectStorageListingResponse {
    optional uint64 TabletID = 1;
    optional uint32 Status = 2;
    optional string ErrorDescription = 3;
    repeated string CommonPrefixesRows = 4;
    repeated bytes ContentsRows = 5; // TSerializedCellVec
    optional bool MoreRows = 6;
}

message TObjectStorageListingContinuationToken {
    optional string last_path = 1;
    optional bool is_folder = 2;
}

message TSerializedRowColumnsScheme {
    repeated uint32 KeyColumnIds = 1;
    repeated uint32 ValueColumnIds = 2;
}

// In SerilializedCellVector format
// Order of cells in KeyColumns and NonKeyColumns is described by TSerializedRowColumnsScheme
message TSerializedRowToLoad {
    optional bytes KeyColumns = 1;
    optional bytes ValueColumns = 2;
}

message TEvUploadRowsRequest {
    optional uint64 TableId = 1;
    optional TSerializedRowColumnsScheme RowScheme = 2;
    repeated TSerializedRowToLoad Rows = 3;
    optional uint64 CancelDeadlineMs = 4; // Wallclock timestamp (not duration)
    optional bool WriteToTableShadow = 5;
    optional uint64 OverloadSubscribe = 7;
    optional bool UpsertIfExists = 8 [ default = false ];
    optional uint64 SchemaVersion = 9;
}

message TEvUploadRowsResponse {
    optional uint64 TabletID = 1;
    optional uint32 Status = 2;
    optional string ErrorDescription = 3;
    optional uint64 OverloadSubscribed = 4;
}

message TEvReadColumnsRequest {
    optional uint64 TableId = 1;
    repeated string Columns = 2;
    optional uint64 MaxRows = 3;
    optional uint64 MaxBytes = 4;

    optional bytes FromKey = 5;
    optional bool FromKeyInclusive = 6;

    optional uint64 SnapshotStep = 7;
    optional uint64 SnapshotTxId = 8;

    optional string Format = 9;
}

message TEvReadColumnsResponse {
    optional uint64 TabletID = 1;
    optional uint32 Status = 2;
    optional string ErrorDescription = 3;

    optional bytes Blocks = 4;              // The data
    optional bytes LastKey = 5;             // For continuation
    optional bool LastKeyInclusive = 6;
    optional bool EndOfShard = 7;
}

message TStatus {
    optional Ydb.StatusIds.StatusCode Code = 1;
    repeated Ydb.Issue.IssueMessage Issues = 2;
}

message TEvGetInfoRequest {
}

message TEvGetInfoResponse {
    message TStats {
        optional uint64 RowCount = 1;
        optional uint64 DataSize = 2;
        optional string LastAccessTime = 3;
        optional string LastUpdateTime = 4;
        optional string LastStatsUpdateTime = 5;
        optional string LastStatsReportTime = 6;
    }

    message TUserTable {
        optional string Name = 1;
        optional string Path = 2;
        optional uint32 LocalId = 3;
        optional uint64 PathId = 4;
        optional NKikimrSchemeOp.TTableDescription Description = 5;
        optional TStats Stats = 6;
        optional NKikimrTabletBase.TMetrics Metrics = 7;
        optional uint64 SchemaVersion = 8;
    }

    message TTabletInfo {
        optional uint64 SchemeShard = 1;
        optional uint64 Mediator = 2;
        optional uint32 Generation = 3;
        optional bool IsFollower = 4;
        optional string State = 5;
        optional bool IsActive = 6;
        optional bool HasSharedBlobs = 7;
    }

    message TNamedValue {
        optional string Name = 1;
        optional string Value = 2;
    }

    message TActivities {
        optional uint64 InFlyPlanned = 1;
        optional uint64 InFlyImmediate = 2;
        optional uint64 ExecutingOps = 3;
        optional uint64 WaitingOps = 4;
        optional uint64 ExecuteBlockers = 5;
        optional uint64 DataTxCached = 6;
        optional uint64 OutReadSets = 7;
        optional uint64 OutReadSetsAcks = 8;
        optional uint64 DelayedAcks = 9;
        optional uint64 Locks = 10;
        optional uint64 BrokenLocks = 11;
        optional uint64 LastPlannedTx = 12;
        optional uint64 LastPlannedStep = 13;
        optional uint64 LastCompletedTx = 14;
        optional uint64 LastCompletedStep = 15;
        optional uint64 UtmostCompletedTx = 16;
        optional uint64 UtmostCompletedStep = 17;
        optional uint64 DataTxCompleteLag = 18;
        optional uint64 ScanTxCompleteLag = 19;
    }

    message TPipelineConfig {
        optional bool OutOfOrderEnabled = 1;
        optional uint32 ActiveTxsLimit = 2;
        optional bool AllowImmediate = 3;
        optional bool ForceOnlineRW = 4;
        optional bool DirtyOnline = 5;
        optional bool DirtyImmediate = 6;
        optional uint32 DataTxCacheSize = 7;
    }

    optional TStatus Status = 1;
    repeated TUserTable UserTables = 2;
    optional TTabletInfo TabletInfo = 3;
    repeated TNamedValue Controls = 4;
    optional TActivities Activities = 5;
    repeated TNamedValue SysTable = 6;
    optional TPipelineConfig PipelineConfig = 7;
}

message TEvListOperationsRequest {
}

message TEvListOperationsResponse {
    message TOperationInfo {
        optional uint64 TxId = 1;
        optional uint64 Step = 2;
        optional string Kind = 3;
        optional bool IsImmediate = 4;
        optional bool IsReadOnly = 5;
        optional bool IsWaiting = 6;
        optional bool IsExecuting = 7;
        optional bool IsCompleted = 8;
        optional string ExecutionUnit = 9;
        optional uint64 ReceivedAt = 10;
    }

    optional TStatus Status = 1;
    repeated TOperationInfo Operations = 2;
}

message TEvGetOperationRequest {
    optional uint64 TxId = 1;
}

message TBasicOpInfo {
    optional uint64 TxId = 1;
    optional uint64 Step = 2;
    optional string Kind = 3;
    optional uint64 ReceivedAt = 4;
    optional uint64 MinStep = 5;
    optional uint64 MaxStep = 6;
    repeated string Flags = 7;
}

message TExecutionProfile {
    message TUnitProfile {
        optional string UnitKind = 1;
        optional uint64 WaitTime = 2;
        optional uint64 ExecuteTime = 3;
        optional uint64 CommitTime = 4;
        optional uint64 CompleteTime = 5;
        optional uint32 ExecuteCount = 6;
    }

    repeated TUnitProfile UnitProfiles = 1;
}

message TEvGetOperationResponse {
    message TExecutionPlan {
        repeated string Units = 1;
        optional bool IsFinished = 2;
        optional uint32 CurrentUnit = 3;
    }

    message TDependency {
        optional uint64 Target = 1;
        repeated string Types = 2;
    }

    message TDependencies {
        repeated TDependency Dependencies = 1;
        repeated TDependency Dependents = 2;
    }

    message TInputRS {
        optional uint64 From = 1;
        optional uint32 Received = 2;
    }

    message TInputData {
        repeated TInputRS InputRS = 1;
        optional uint32 RemainedInputRS = 2;
    }

    message TReadTableState {
        optional string State = 1;
        optional uint32 TableId = 2;
        optional uint64 SnapshotId = 3;
        optional uint64 ScanTaskId = 4;
        optional string SinkActor = 5;
        optional string ScanActor = 6;
    }

    optional TStatus Status = 1;
    optional TBasicOpInfo BasicInfo = 2;
    optional TExecutionPlan ExecutionPlan = 3;
    optional TDependencies Dependencies = 4;
    optional TInputData InputData = 5;
    optional TExecutionProfile ExecutionProfile = 6;

    optional TReadTableState ReadTableState = 10;
}

message TEvGetReadTableSinkStateRequest {
    optional uint64 TxId = 1;
}

message TShard {
    optional uint64 Id = 1;
}

message TEvGetReadTableSinkStateResponse {
    optional TStatus Status = 1;
    optional uint64 TxId = 2;
    optional uint64 WallClockAccepted = 3;
    optional uint64 WallClockResolveStarted = 4;
    optional uint64 WallClockResolved = 5;
    optional uint64 WallClockPrepared = 6;
    optional uint64 WallClockPlanned = 7;
    optional uint64 ExecTimeoutPeriod = 8;
    optional uint64 SelectedCoordinator = 9;
    optional string RequestSource = 10;
    optional uint32 RequestVersion = 11;
    optional uint32 ResponseVersion = 12;
    repeated TShard ClearanceRequests = 13;
    repeated TShard QuotaRequests = 14;
    repeated TShard StreamingShards = 15;
    repeated TShard ShardsQueue = 16;
    optional bool Ordered = 17;
    optional bool RowsLimited = 18;
    optional uint64 RowsRemain = 19;
}

message TEvGetReadTableScanStateRequest {
    optional uint64 TxId = 1;
}

message TEvGetReadTableScanStateResponse {
    optional TStatus Status = 1;
    optional uint64 TxId = 2;
    optional uint64 MessageQuota = 3;
    optional uint64 MessageSizeLimit = 4;
    optional uint64 RowsLimit = 5;
    optional uint64 PendingAcks = 6;
    optional uint64 ResultSize = 7;
    optional uint64 ResultRows = 8;
    optional bool HasUpperBorder = 9;
    optional bool Finished = 10;
    optional string Error = 11;
}

message TEvGetReadTableStreamStateRequest {
    optional uint64 TxId = 1;
}

message TEvGetReadTableStreamStateResponse {
    message TShardQuota {
        optional uint64 ShardId = 1;
        optional uint64 Quota = 2;
    }

    optional TStatus Status = 1;
    optional bool Ready = 2;
    optional bool Finished = 3;
    optional uint64 ResponseQueueSize = 4;
    repeated TShard QuotaRequests = 5;
    repeated TShardQuota ShardQuotas = 6;
    optional uint64 QuotaLimit = 7;
    optional uint64 QuotaReserved = 8;
    repeated TShard ReleasedShards = 9;
    optional uint64 InactiveClientTimeout = 10;
    optional uint64 InactiveServerTimeout = 11;
    optional uint64 LastDataStreamTimestamp = 12;
    optional uint64 LastStatusTimestamp = 13;
}

message TEvGetSlowOpProfilesRequest {
}

message TEvGetSlowOpProfilesResponse {
    message TOpProfile {
        optional TBasicOpInfo BasicInfo = 1;
        optional TExecutionProfile ExecutionProfile = 2;
    }

    optional TStatus Status = 1;
    repeated TOpProfile Profiles = 2;
}

message TEvGetRSInfoRequest {
}

message TEvGetRSInfoResponse {
    message TOutRSInfo {
        optional uint64 TxId = 1;
        optional uint64 Origin = 2;
        optional uint64 Source = 3;
        optional uint64 Destination = 4;
        optional uint64 SeqNo = 5;
    }

    message TRSAckInfo {
        optional uint64 TxId = 1;
        optional uint64 Step = 2;
        optional uint64 Origin = 3;
        optional uint64 Source = 4;
        optional uint64 Destination = 5;
        optional uint64 SeqNo = 6;
    }

    message TExpectation {
        optional uint64 Source = 1;
        optional uint64 TxId = 2;
        optional uint64 Step = 3;
    }

    message TPipe {
        optional uint64 Destination = 1;
        optional uint64 OutReadSets = 2;
        optional bool Subscribed = 3;
    }

    optional TStatus Status = 1;
    repeated TOutRSInfo OutReadSets = 2;
    repeated TRSAckInfo OutRSAcks = 3;
    repeated TRSAckInfo DelayedRSAcks = 4;
    repeated TExpectation Expectations = 5;
    repeated TPipe Pipes = 6;
}

message TEvGetDataHistogramRequest {
    optional uint32 CollectKeySampleMs = 1;
    optional bool ActualData = 2;
}

message TEvGetDataHistogramResponse {
    message THistogramItem {
        optional uint64 Value = 1;
        repeated string KeyValues = 2;
    }

    message THistogram {
        repeated THistogramItem Items = 1;
    }

    message TTableHistograms {
        optional string TableName = 1;
        repeated string KeyNames = 2;
        optional THistogram SizeHistogram = 3;
        optional THistogram CountHistogram = 4;
        optional THistogram KeyAccessSample = 5;
    }

    optional TStatus Status = 1;
    repeated TTableHistograms TableHistograms = 2;
}

message TEvRefreshVolatileSnapshotRequest {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional uint64 Step = 3;
    optional uint64 TxId = 4;
}

message TEvRefreshVolatileSnapshotResponse {
    enum EStatus {
        REFRESHED = 1;
        WRONG_SHARD_STATE = 2;
        SNAPSHOT_NOT_FOUND = 3;
        SNAPSHOT_TRANSFERRED = 4;
        SNAPSHOT_NOT_READY = 5;
    }

    optional uint64 Origin = 1;
    optional uint64 OwnerId = 2;
    optional uint64 PathId = 3;
    optional uint64 Step = 4;
    optional uint64 TxId = 5;
    optional EStatus Status = 6;
    repeated uint64 TransferredToShards = 7;
}

message TEvDiscardVolatileSnapshotRequest {
    optional uint64 OwnerId = 1;
    optional uint64 PathId = 2;
    optional uint64 Step = 3;
    optional uint64 TxId = 4;
}

message TEvDiscardVolatileSnapshotResponse {
    enum EStatus {
        DISCARDED = 1;
        WRONG_SHARD_STATE = 2;
        SNAPSHOT_NOT_FOUND = 3;
        SNAPSHOT_TRANSFERRED = 4;
        SNAPSHOT_NOT_READY = 5;
    }

    optional uint64 Origin = 1;
    optional uint64 OwnerId = 2;
    optional uint64 PathId = 3;
    optional uint64 Step = 4;
    optional uint64 TxId = 5;
    optional EStatus Status = 6;
    repeated uint64 TransferredToShards = 7;
}

message TEvMigrateSchemeShardRequest {
    optional fixed64 CurrentSchemeShardId = 1;
    optional fixed64 NewSchemeShardId = 2;
    optional fixed64 TabletId = 3;
}

message TEvMigrateSchemeShardResponse {
    enum EStatus {
        Success = 1;
        Already = 2;
        WrongRequest = 3;
    }

    optional EStatus Status = 1;
    optional fixed64 TabletId = 2;
}

message TExpirationCondition {
    // erase if valueof(ColumnId) < WallClockTimestamp
    optional uint32 ColumnId = 1; // Must contain date type
    optional uint64 WallClockTimestamp = 2;
    optional NKikimrSchemeOp.TTTLSettings.EUnit ColumnUnit = 3;
}

message TEvEraseRowsRequest {
    optional uint64 TableId = 1;
    repeated uint32 KeyColumnIds = 2;
    repeated bytes KeyColumns = 3; // SerilializedCellVector
    optional uint64 SchemaVersion = 5;
    optional uint64 OverloadSubscribe = 6;

    oneof Condition {
        TExpirationCondition Expiration = 4;
    }
}

message TEvEraseRowsResponse {
    enum EStatus {
        OK = 0;
        BAD_REQUEST = 1;
        SCHEME_ERROR = 2;
        EXEC_ERROR = 3;
        WRONG_SHARD_STATE = 4;
        UNKNOWN = 5;
        // coordinator
        COORDINATOR_DECLINED = 10;
        COORDINATOR_UNKNOWN = 11;
        // shard
        SHARD_NOT_AVAILABLE = 20;
        SHARD_ABORTED = 21;
        SHARD_CANCELLED = 22;
        SHARD_RESULT_UNAVAILABLE = 23;
        SHARD_OVERLOADED = 24;
        SHARD_TRY_LATER = 25;
        SHARD_EXEC_ERROR = 26;
        SHARD_UNKNOWN = 27;
    }

    optional uint64 TabletID = 1;
    optional EStatus Status = 2;
    optional string ErrorDescription = 3;
    optional uint64 OverloadSubscribed = 4;
}

message TEvConditionalEraseRowsRequest {
    message TIndexDescription {
        message TKeyMap {
            optional uint32 IndexColumnId = 1;
            optional uint32 MainColumnId = 2;
        }

        optional uint64 OwnerId = 1;
        optional uint64 PathId = 2;
        optional uint64 SchemaVersion = 3;
        repeated TKeyMap KeyMap = 4; // sorted
    };

    message TLimits {
        optional uint32 BatchMaxBytes = 1 [default = 512000];
        optional uint32 BatchMinKeys = 2 [default = 1000];
        optional uint32 BatchMaxKeys = 3 [default = 50000];
    };

    optional uint64 TableId = 1;
    optional uint64 SchemaVersion = 3;
    repeated TIndexDescription Indexes = 4;
    optional TLimits Limits = 5;

    oneof Condition {
        TExpirationCondition Expiration = 2;
    }
}

message TEvConditionalEraseRowsResponse {
    enum EStatus {
        ACCEPTED = 0;
        PARTIAL = 1;
        OK = 2;
        BAD_REQUEST = 3;
        ABORTED = 4;
        ERASE_ERROR = 5; // error during underlying erase execution
        OVERLOADED = 6; // another conditional erase in flight
        SCHEME_ERROR = 7;
    }

    message TStats {
        optional uint64 RowsProcessed = 1;
        optional uint64 RowsErased = 2;
    }

    optional uint64 TabletID = 1;
    optional EStatus Status = 2;
    optional string ErrorDescription = 3;
    optional TStats Stats = 4;
}

message TEvBuildIndexCreateRequest {
    optional uint64 Id = 1;          // unique id of build index process

    optional uint64 TabletId = 2;
    optional uint64 OwnerId = 3;
    optional uint64 PathId = 4;

    optional string TargetName = 5;
    repeated string IndexColumns = 6;          // key columns that is needed to transfer in terms of target table

    optional NKikimrTx.TKeyRange KeyRange = 7; // key range to transfer in term of source table

    optional uint64 SnapshotTxId = 8;
    optional uint64 SnapshotStep = 9;

    reserved 10; // MaxBatchRows
    reserved 11; // MaxBatchBytes

    optional uint64 SeqNoGeneration = 12;       // monotonically increasing sequence, first part
    optional uint64 SeqNoRound = 13;            // monotonically increasing sequence, second part
    reserved 14; // MaxRetries

    repeated string DataColumns = 15;

    optional NKikimrIndexBuilder.TColumnBuildSettings ColumnBuildSettings = 16;

    optional NKikimrIndexBuilder.TIndexBuildScanSettings ScanSettings = 17;
}

message TEvBuildIndexProgressResponse {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional uint64 OwnerId = 3;
    optional uint64 PathId = 4;

    optional NKikimrIndexBuilder.EBuildStatus Status = 5;

    optional Ydb.StatusIds.StatusCode UploadStatus = 6;
    repeated Ydb.Issue.IssueMessage Issues = 7;

    reserved 8;
    optional bytes LastKeyAck = 9;

    optional uint64 RowsDelta = 10;
    optional uint64 BytesDelta = 11;

    optional uint64 RequestSeqNoGeneration = 12;
    optional uint64 RequestSeqNoRound = 13;
}

message TEvSampleKRequest {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 K = 4;

    optional uint64 Seed = 5;

    // We want to sample small instead of large probabilities
    // because size of message will be smaller (varint)
    optional uint64 MaxProbability = 6;

    repeated string Columns = 7;
    optional NKikimrTx.TKeyRange KeyRange = 8;

    optional uint64 SnapshotTxId = 9;
    optional uint64 SnapshotStep = 10;

    optional uint64 SeqNoGeneration = 11;
    optional uint64 SeqNoRound = 12;
}

message TEvSampleKResponse {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional NKikimrIndexBuilder.EBuildStatus Status = 4;
    repeated Ydb.Issue.IssueMessage Issues = 5;

    optional uint64 RequestSeqNoGeneration = 8;
    optional uint64 RequestSeqNoRound = 9;

    repeated uint64 Probabilities = 10;
    repeated bytes Rows = 11;

    reserved 6 to 7;
    optional NKikimrIndexBuilder.TMeteringStats MeteringStats = 12;
}

enum EKMeansState {
    UNSPECIFIED = 0;
    SAMPLE = 1;
    KMEANS = 2;
    UPLOAD_MAIN_TO_BUILD = 3;
    UPLOAD_MAIN_TO_POSTING = 4;
    UPLOAD_BUILD_TO_BUILD = 5;
    UPLOAD_BUILD_TO_POSTING = 6;
    DONE = 7;
};

message TEvLocalKMeansRequest {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 SnapshotTxId = 4;
    optional uint64 SnapshotStep = 5;

    optional uint64 SeqNoGeneration = 6;
    optional uint64 SeqNoRound = 7;

    optional Ydb.Table.VectorIndexSettings Settings = 8;

    optional uint64 Seed = 9;

    optional EKMeansState Upload = 11;

    optional uint32 K = 10;
    optional uint32 NeedsRounds = 14;

    optional uint64 ParentFrom = 15;
    optional uint64 ParentTo = 21;
    optional uint64 Child = 16;

    optional string LevelName = 17;
    optional string OutputName = 18;

    optional string EmbeddingColumn = 19;
    repeated string DataColumns = 20;

    optional NKikimrIndexBuilder.TIndexBuildScanSettings ScanSettings = 22;
}

message TEvLocalKMeansResponse {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 RequestSeqNoGeneration = 4;
    optional uint64 RequestSeqNoRound = 5;

    optional NKikimrIndexBuilder.EBuildStatus Status = 6;
    repeated Ydb.Issue.IssueMessage Issues = 7;

    reserved 8 to 11;
    optional NKikimrIndexBuilder.TMeteringStats MeteringStats = 12;
}

message TEvReshuffleKMeansRequest {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 SnapshotTxId = 4;
    optional uint64 SnapshotStep = 5;

    optional uint64 SeqNoGeneration = 6;
    optional uint64 SeqNoRound = 7;

    optional Ydb.Table.VectorIndexSettings Settings = 8;

    optional EKMeansState Upload = 9;

    // id of parent cluster
    optional uint64 Parent = 10;
    // [Child ... Child + ClustersSize) ids of this kmeans clusters
    optional uint64 Child = 11;
    // centroids of clusters
    repeated string Clusters = 12;

    optional string OutputName = 13;

    optional string EmbeddingColumn = 14;
    repeated string DataColumns = 15;

    optional NKikimrIndexBuilder.TIndexBuildScanSettings ScanSettings = 16;
}

message TEvReshuffleKMeansResponse {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 RequestSeqNoGeneration = 4;
    optional uint64 RequestSeqNoRound = 5;

    optional NKikimrIndexBuilder.EBuildStatus Status = 6;
    repeated Ydb.Issue.IssueMessage Issues = 7;

    reserved 8 to 11;
    optional NKikimrIndexBuilder.TMeteringStats MeteringStats = 12;
}

message TEvRecomputeKMeansRequest {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 SnapshotTxId = 4;
    optional uint64 SnapshotStep = 5;

    optional uint64 SeqNoGeneration = 6;
    optional uint64 SeqNoRound = 7;

    optional Ydb.Table.VectorIndexSettings Settings = 8;

    // id of parent cluster
    optional uint64 Parent = 9;
    // centroids of clusters
    repeated string Clusters = 10;

    optional string EmbeddingColumn = 11;
}

message TEvRecomputeKMeansResponse {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 RequestSeqNoGeneration = 4;
    optional uint64 RequestSeqNoRound = 5;

    optional NKikimrIndexBuilder.EBuildStatus Status = 6;
    repeated Ydb.Issue.IssueMessage Issues = 7;

    // recomputed clusters and cluster sizes (row counts for every cluster)
    repeated bytes Clusters = 10;
    repeated uint64 ClusterSizes = 11;

    reserved 8 to 9;
    optional NKikimrIndexBuilder.TMeteringStats MeteringStats = 12;
}

message TEvPrefixKMeansRequest {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 SeqNoGeneration = 4;
    optional uint64 SeqNoRound = 5;

    optional Ydb.Table.VectorIndexSettings Settings = 6;

    optional uint64 Seed = 7;

    optional EKMeansState Upload = 8;

    optional uint32 K = 9;
    optional uint32 NeedsRounds = 10;

    // [Child ... Child + (1 + TableSize) * ShardIndex]
    optional uint64 Child = 11;

    optional string LevelName = 12;
    optional string OutputName = 13;
    optional string PrefixName = 14;

    optional string EmbeddingColumn = 15;
    repeated string DataColumns = 16;
    optional uint32 PrefixColumns = 17;

    optional NKikimrIndexBuilder.TIndexBuildScanSettings ScanSettings = 18;

    repeated string SourcePrimaryKeyColumns = 19;
}

message TEvPrefixKMeansResponse {
    optional uint64 Id = 1;

    optional uint64 TabletId = 2;
    optional NKikimrProto.TPathID PathId = 3;

    optional uint64 RequestSeqNoGeneration = 4;
    optional uint64 RequestSeqNoRound = 5;

    optional NKikimrIndexBuilder.EBuildStatus Status = 6;
    repeated Ydb.Issue.IssueMessage Issues = 7;

    reserved 8 to 11;
    optional NKikimrIndexBuilder.TMeteringStats MeteringStats = 12;
}

message TEvCdcStreamScanRequest {
    message TLimits {
        optional uint32 BatchMaxBytes = 1 [default = 512000];
        optional uint32 BatchMinRows = 2 [default = 10];
        optional uint32 BatchMaxRows = 3 [default = 1000];
    };

    optional NKikimrProto.TPathID TablePathId = 1; // which table should be scanned
    optional uint64 TableSchemaVersion = 2;
    optional NKikimrProto.TPathID StreamPathId = 3;
    optional uint64 SnapshotStep = 4;
    optional uint64 SnapshotTxId = 5;
    optional TLimits Limits = 6;
}

message TEvCdcStreamScanResponse {
    enum EStatus {
        PENDING = 0;
        ACCEPTED = 1;
        IN_PROGRESS = 2;
        DONE = 3;
        BAD_REQUEST = 4;
        SCHEME_ERROR = 5;
        OVERLOADED = 6;
        ABORTED = 7;
    }

    message TStats {
        optional uint64 RowsProcessed = 1;
        optional uint64 BytesProcessed = 2;
    }

    optional uint64 TabletId = 1;
    optional NKikimrProto.TPathID TablePathId = 2;
    optional NKikimrProto.TPathID StreamPathId = 3;
    optional EStatus Status = 4;
    optional string ErrorDescription = 5;
    optional TStats Stats = 6;
}

message TComputeShardingPolicy {
    repeated string ColumnNames = 1;
    optional uint32 ShardsCount = 2 [default = 0];

}

message TEvKqpScan {
    optional uint64 TxId = 1;
    optional uint64 ScanId = 2;
    optional uint64 LocalPathId = 3;
    optional string TablePath = 4;
    optional uint64 SchemaVersion = 5;
    repeated uint32 ColumnTags = 6;
    repeated uint32 ColumnTypes = 7;
    repeated NKikimrProto.TTypeInfo ColumnTypeInfos = 22;
    repeated bool SkipNullKeys = 8;
    repeated NKikimrTx.TKeyRange Ranges = 9;
    optional NKikimrKqp.TKqpSnapshot Snapshot = 10;
    reserved 11; // optional NKqpProto.EKqpStatsMode StatsMode = 11;
    optional uint64 TimeoutMs = 12;
    optional uint32 Generation = 13;
    // Seralized OlapProgram in old format without parameters
    reserved 14;
    optional uint64 ItemsLimit = 15;
    optional bool Reverse = 16;
    optional NKikimrDataEvents.EDataFormat DataFormat = 17;
    optional NYql.NDqProto.EDqStatsMode StatsMode = 18;
    optional bytes OlapProgram = 19;
    optional NKikimrSchemeOp.EOlapProgramType OlapProgramType = 20;
    optional TComputeShardingPolicy ComputeShardingPolicy = 23;
    optional uint64 LockTxId = 24;
    optional uint32 LockNodeId = 25;
    optional string CSScanPolicy = 26;
    optional NKikimrKqp.TEvKqpScanCursor ScanCursor = 27;
    optional NKikimrDataEvents.ELockMode LockMode = 28;
    optional double CpuGroupThreadsLimit = 29;
    optional string CpuGroupName = 30;
}

message TEvCompactTable {
    optional NKikimrProto.TPathID PathId = 1;
    optional bool CompactBorrowed = 2; // i.e. taken
    optional bool CompactSinglePartedShards = 3;
}

message TEvCompactTableResult {
    enum EStatus {
        OK = 0;
        NOT_NEEDED = 1;
        FAILED = 2;
        BORROWED = 3;
        LOANED = 4;
    };

    optional uint64 TabletId = 1;
    optional NKikimrProto.TPathID PathId = 2;
    optional EStatus Status = 3;
}

message TEvCompactBorrowed {
    optional NKikimrProto.TPathID PathId = 1;
}

message TEvCompactBorrowedResult {
    optional uint64 TabletId = 1;
    optional NKikimrProto.TPathID PathId = 2;
}

message TEvGetCompactTableStats {
    optional NKikimrProto.TPathID PathId = 1;
}

message TEvGetCompactTableStatsResult {
    optional uint64 BackgroundCompactionRequests = 1;
    optional uint64 BackgroundCompactionCount = 2;
    optional uint64 CompactBorrowedCount = 3;
}

// TEvRead is used to request multiple queries from a shard and
// to read results possibly splitted into multiple replies.
//
// The TEvRead message starts a new read request with given queries
// and starts streaming a single resultset in the requested format.
// The TEvRead contains number of rows (hard limit) and bytes (soft limit)
// the client can handle, the server is allowed to reply with multiple TEvReadResult
// messages within the quota. To update quota user uses TEvReadAck message.
//
// The protocol works as follows:
// 1. Optionally user obtains LockTxId and LockNodeId from TxProxy.
//
// 2. Optionally user obtains snapshot version.
//
// 3. User starts reading by sending TEvRead to the shard.
//
// 4. Shard replies with TEvReadResult, which contains:
//    - ReadId which is the same as in TEvRead. Shard gives no guarantee
//    that the ReadId will be valid any time.
//    - Snapshot version in case of MVCC read or when HEAD read transformed to MVCC, i.e. repeatable read
//    - SeqNo that should be used by user in TEvReadAck
//    - ContinuationToken, which user can use to restart the read.
//    - TxLocks or BrokenTxLocks when user specified LockTxId and LockNodeId.
//
// 5. Client must ack results, it is allowed to send single ack on multiple results
// at once using SeqNo from the last result. Note that currently ack is rather quota update.
// * If user has received final TEvReadResult, he is allowed to not send TEvReadAck, though sending message is
// not a protocol violation.
// * If user has received TEvReadResult with error he should not send any reply.
// Note that server will stop sending TEvReadResult messages only if last sent result contains either
// Finished or LimitReached field set. Otherwise until there is no disconnect, user can rely that
// he will receive more TEvReadResult messages. Though to improve latency it's a good practice
// to send TEvReadAck before exhausting quota.
//
// 6. User either receives TEvReadResult with Finished field set or TEvReadResult with error
// or stops reading hisself using TEvReadCancel.
//
// TEvReadResult is valid only if its Status is equal to Ydb::StatusIds::SUCCESS.
// * Ydb::StatusIds::OVERLOADED means that shard has possibly been splitted, user must check schemeshard to find
// proper shards.
// * Ydb::StatusIds::SCHEME_ERROR means that either scheme version mismatch, wrong columns or table has been deleted.
// * Ydb::StatusIds::BAD_REQUEST should not be retried, because it shows protocol violation.
// In case of any other status code iterator has been invalidated and further
// usage of its ReadId will result in either non-success status code. Also non-success result message might not
// contain SeqNo.
//
// Shard is allowed to send TEvReadResult without actual results, but with LimitReached field set.
// E.g. it happens when initial TEvRead has too small quota to read at least single row.
// Receiving TEvReadResult with LimitReached set means that shard will not read more rows until
// user sends ACK with extended quota.
//
// User must detect disconnect and after it happened ignore possible results from the shard.
// Instead new read must be started using ContinuationToken from last successful TEvReadResult.
// Note that current DS implementation uses interconnect session from originating TEvRead message,
// it sends all results via this session and detects disconnect based on the session. Though client
// is allowed to send ACK via any sessions.
//
// Note that when user obtains lock then only first reply contains either TxLocks or BrokenTxLocks.
// In further read results these fields will be set only in case of lock changes.
message TEvRead {
    // User must always provide unique ReadId
    // Note that shard distinguishes equal ReadId's
    // from different users.
    optional uint64 ReadId = 1;

    // To read regular user tables client must specify proper
    // owner of the table (schemeshard).
    // Only for internal usage we support reading shard system tables:
    // in this case owner is shard itself, TableId is LocalTid, SchemaVersion
    // must not be set
    optional NKikimrDataEvents.TTableId TableId = 2;

    // A list of column ids that are returned in the result set. Empty columns can be used to Count(*) rows.
    // * In case of CellVec and empty columns: result will
    // contain an empty CellVec for each read row.
    // * In case of Arrow and empty Columns: ArrowBatch is a batch with single column of type NullType
    // and with num_rows equal rowsCount. All values are null.
    // In all cases RowCount can be checked with GetRowsCount() call (return RowCount field).
    repeated uint32 Columns = 3;

    // An optional snapshot for point in time queries
    // When snapshot is unspecified datashard will read the most recent data
    // and try to allocate an appropriate point in time for repeatable reads
    // appropriate for this shard.
    optional NKikimrProto.TRowVersion Snapshot = 4;

    // An optional LockTxId for acquiring locks
    // When specified shard adds read locks with the specified TxId on processed ranges
    optional uint64 LockTxId = 5;
    optional uint32 LockNodeId = 11;

    // Specifies the format for result data in TEvReadResult
    optional NKikimrDataEvents.EDataFormat ResultFormat = 6;

    // Limits the total number of rows or bytes client currently can handle
    // MaxRows is hard limit: shard must never violate it
    // MaxBytes is soft limit: shard stops only after crossing the limit, i.e.
    // if n rows are within MaxBytes and n+1 is not - shard returns n+1 rows.
    //
    // Note that because of this result will always contain at least one row
    // independent on quota.
    optional uint32 MaxRows = 7;
    optional uint32 MaxBytes = 8;

    // mainly for testing purposes, limits number of rows in single result message
    optional uint32 MaxRowsInResult = 9;

    // When specified requests are handled in reverse order as well as range reads
    optional bool Reverse = 10;

    // Limits total number of rows which iterator can read.
    optional uint64 TotalRowsLimit = 12;

    enum EHint {
        // No hits. This is the default.
        HINT_NONE = 0;

        // This hint should be specified for batch queries. DataShard will
        // attempt to run this query as a scan when possible, minimizing
        // effects on concurrent OLTP queries.
        HINT_BATCH = 1;

        // This hint should be specified for low priority queries. DataShard
        // will attempt to use low-priority reads when possible, minimizing
        // effects on concurrent OLTP queries.
        HINT_LOW_PRIORITY = 2;
    }

    // Optional bit flags with hints
    optional uint32 Hints = 13;

    // Request must contain either keys, queries or program
    // mixed requests are not supported

    // TSerializedCellVec containing a PK prefix
    repeated bytes Keys = 900;

    // A range of PK values where From is always the left border
    // and To is always the right border. Both From and To can
    // be PK prefixes.
    repeated NKikimrTx.TKeyRange Ranges = 901;

    optional bytes Program = 902;
    optional NKikimrSchemeOp.EOlapProgramType ProgramType = 903;

    optional NKikimrDataEvents.ELockMode LockMode = 904;
}

message TReadContinuationToken {
    // An index of the last query that datashard attempted to process
    // When starting a new TEvRead call for the same query, this would be
    // the first query that needs to be resent.
    optional uint32 FirstUnprocessedQuery = 1;

    // TSerializedCellVec of the last observed key before returning the result
    // When starting a new TEvRead call for the same query, this would be
    // the first non-inclusive from key for the first range.
    optional bytes LastProcessedKey = 2;
}

// Every TEvRead and TEvReadAck produces a result
// The result may be partial, in which case client may continue streaming more
// results using TEvReadAck.
//
// Note the condition that everything has been read: Finished field is set.
message TEvReadResult {
    message TArrowBatch {
        optional bytes Schema = 1;
        optional bytes Batch = 2;
    }

    message TCellVecBatch {
        // TODO: add schema?
        repeated bytes Rows = 1;
    }

    // same as ReadId from the TEvRead
    optional uint64 ReadId = 1;

    // Specifies SeqNo for the next TEvReadAck call
    optional uint64 SeqNo = 2;

    optional TStatus Status = 3;
    optional NKikimrDataEvents.EDataFormat ResultFormat = 4;
    optional NKikimrProto.TRowVersion Snapshot = 5;

    optional bytes ContinuationToken = 6;

    // True when shard may have possibly returned more data, but
    // stopped because it reached MaxRows or MaxBytes limits.
    // Note that if data split between multiple results because of
    // MaxRowsInResult, then this field is not set
    optional bool LimitReached = 7;

    optional NKikimrQueryStats.TReadOpStats Stats = 8;

    optional bool Finished = 9;

    repeated NKikimrDataEvents.TLock TxLocks = 10;
    repeated NKikimrDataEvents.TLock BrokenTxLocks = 11;

    optional uint64 RowCount = 12;

    optional uint32 NodeId = 13;

    // Data for the possibly partial result
    oneof ReadResult {
        TArrowBatch ArrowBatch = 900;
        TCellVecBatch CellVec = 901;
    }
}

// After handling ReadResult with specified SeqNo user is ready to handle at most
// MaxRows and MaxBytes. But keep in mind that until shard handles this message
// it can send data based on previous quota.
message TEvReadAck {
    optional uint64 ReadId = 1;
    optional uint64 SeqNo = 2;

    // see comment for same fields in TEvRead
    optional uint32 MaxRows = 3;
    optional uint32 MaxBytes = 4;
};

// Cancels a possibly active previously started read
message TEvReadCancel {
    optional uint64 ReadId = 1;
};

// Applies a batch of replication changes
message TEvApplyReplicationChanges {
    message TUpdates {
        // Column tags
        repeated uint32 Tags = 1;
        // Serialized values (TSerializedCellVec)
        optional bytes Data = 2;
    }

    message TChange {
        // Offset of the change within a particular source
        optional int64 SourceOffset = 1;

        // Changes will be applied using the specified uncommitted TxId
        optional uint64 WriteTxId = 2;

        // TSerializedCellVec with the table primary key
        optional bytes Key = 3;

        oneof RowOperation {
            // Upsert the specified key with these column updates
            TUpdates Upsert = 4;

            // Remove the specified key
            google.protobuf.Empty Erase = 5;

            // Reset all columns to default values and apply updates
            TUpdates Reset = 6;
        }
    }

    // Table these changes are applied to
    optional NKikimrDataEvents.TTableId TableId = 1;

    // Source of changes for deduplication and exactly-once processing. This
    // should be a source which guarantees monotonically increasing offsets,
    // e.g. a topic partition id. All changes with offsets not greater than
    // the maximum accepted will be ignored.
    optional bytes Source = 2;

    repeated TChange Changes = 3;
}

message TEvApplyReplicationChangesResult {
    enum EStatus {
        STATUS_UNKNOWN = 0;
        STATUS_OK = 1;
        STATUS_REJECTED = 2;
    }

    enum EReason {
        REASON_NONE = 0;
        REASON_WRONG_STATE = 1;
        REASON_SCHEME_ERROR = 2;
        REASON_BAD_REQUEST = 3;
        REASON_UNEXPECTED_ROW_OPERATION = 4;
        REASON_OUTDATED_SCHEME = 6;
    }

    optional EStatus Status = 1;
    optional EReason Reason = 2;
    optional string ErrorDescription = 3;
}

message TEvGetReplicationSourceOffsets {
    // Each read must have a unique (Sender, ReadId) pair for identification
    optional uint64 ReadId = 1;

    optional NKikimrDataEvents.TTableId TableId = 2;

    // The tuple (SourceId, SplitKeyId) where the read should start, inclusive
    optional uint64 FromSourceId = 3;
    optional uint64 FromSplitKeyId = 4;

    // Maximum total number of unACKed bytes the client is willing to accept
    optional uint64 WindowSize = 5;
}

message TEvReplicationSourceOffsets {
    message TSourceOffset {
        // The pair (SourceId, SplitKeyId) is non decreasing during read
        optional uint64 SourceId = 1;
        optional uint64 SplitKeyId = 2;

        optional bytes Source = 3;

        // The left PK prefix of the [SplitKey, NextSplitKey) range for MaxOffset
        optional bytes SplitKey = 4;

        // The special value -1 is not transmitted
        optional int64 MaxOffset = 5 [default = -1];
    }

    // Same as ReadId in the request, so result and request may be matched
    optional uint64 ReadId = 1;

    // Each consecutive result has a monotonically increasing SeqNo, starting from 1
    optional uint64 SeqNo = 2;

    // When true this is the last result for this read
    // Note that datashard may still be waiting for either ack or cancel to free up the send window
    optional bool EndOfStream = 3;

    // The size of the result in bytes as it counts towards WindowSize
    optional uint64 ResultSize = 4;

    // A possibly partial read result
    // The sum of these protobuf values counts towards WindowSize
    repeated TSourceOffset Result = 5;
}

message TEvReplicationSourceOffsetsAck {
    // Same as ReadId in the request
    optional uint64 ReadId = 1;

    // The client is acknowledging every SeqNo <= AckSeqNo has been received and processed
    // This will remove their corresponding
    optional uint64 AckSeqNo = 2;

    // The client may optionally change the current window size
    optional uint64 WindowSize = 3;
}

message TEvReplicationSourceOffsetsCancel {
    // Cancels a previously started read for (Sender, ReadId)
    optional uint64 ReadId = 1;
}

message TTxVolatileDetails {
    optional uint64 TxId = 1;

    // Step and TxId that should be used for the eventual commit
    optional uint64 VersionStep = 2;
    optional uint64 VersionTxId = 3;

    // A list of local db transactions that need to be committed on success or rolled back on failure
    repeated uint64 CommitTxIds = 4 [packed = true];

    // A list of volatile transaction ids that need to be committed or rolled back before this transaction commits.
    // This is because local db changes must be committed in the same order they performed writes.
    repeated uint64 Dependencies = 5 [packed = true];

    // An optional change group for committing change collector changes
    optional uint64 ChangeGroup = 6;

    // A relative commit order local to the shard
    optional uint64 CommitOrder = 7;

    // When true all preceding transactions are dependencies
    optional bool CommitOrdered = 8;

    // When true marks an arbiter for other participants
    // Arbiters hold outgoing readsets until the transaction is decided
    optional bool IsArbiter = 9;
}

// Sent by datashard when some overload reason stopped being relevant
message TEvOverloadReady {
    optional uint64 TabletID = 1;
    optional uint64 SeqNo = 2;
}

// Sent by overload subscribers to unsubscribe and free memory
message TEvOverloadUnsubscribe {
    optional uint64 SeqNo = 1;
}

// Used for events serialization/deserialization
message TSerializedEvent {
    // Serialized TEventPBBase event
    optional bytes EventData = 1;
    // TEventSerializationInfo::IsExtendedFormat flag
    optional bool IsExtendedFormat = 2;
}

// In-memory variables that are important to restore between shard generations
message TInMemoryVars {
    optional NKikimrProto.TRowVersion ImmediateWriteEdge = 1;
    optional NKikimrProto.TRowVersion ImmediateWriteEdgeReplied = 2;
    optional NKikimrProto.TRowVersion UnprotectedReadEdge = 3;
}

// In-memory locks
message TInMemoryLockInfo {
    optional uint64 LockId = 1;
    optional uint32 LockNodeId = 2;
    optional uint32 Generation = 3;
    optional uint32 Counter = 4;
    optional uint64 CreateTs = 5;
    optional uint64 Flags = 6;
    optional NKikimrProto.TRowVersion BreakVersion = 7;
    repeated NKikimrProto.TPathID ReadTables = 8;
    repeated NKikimrProto.TPathID WriteTables = 9;
}

// In-memory ranges associated with the lock
// Note: whole shard locks will have whole table read/write ranges
message TInMemoryLockRange {
    optional uint64 LockId = 1;
    optional NKikimrProto.TPathID TableId = 2;
    optional uint64 Flags = 3;
    optional bytes Data = 4;
}

// In-memory conflicts between locks
message TInMemoryLockConflict {
    // When this lock is committed
    optional uint64 LockId = 1;
    // It must break another lock with the specified id
    optional uint64 ConflictId = 2;
}

// In-memory volatile dependencies
// This specifies that to commit this lock we must use a volatile transaction
// that must have a dependency on the specified TxId.
message TInMemoryLockVolatileDependency {
    optional uint64 LockId = 1;
    optional uint64 TxId = 2;
}

// In-memory prepared volatile transactions, i.e. those we have accepted for
// execution and may be planned and executed later. This includes planned and
// acknowledged transactions that haven't executed yet (including those that
// have not been committed yet?)
message TInMemoryPreparedVolatileTx {
    optional uint64 TxId = 1;
    optional NActorsProto.TActorId Source = 2;
    optional uint64 Cookie = 3;
    optional uint64 Type = 4;
    optional bytes Body = 5;
    optional uint64 Flags = 6;
    // This is Min/Max step of a prepared transactions, mostly used for deadline cleanup
    optional uint64 MinStep = 7;
    optional uint64 MaxStep = 8;
    // Specified when the transaction has been planned already (including predictions)
    optional uint64 PredictedStep = 9;
    optional uint64 Step = 10;
}

// In-memory waiting volatile transactions, i.e. those that have not been
// decided yet (at least persistently), and for which we need to send a
// result when they eventually commit or abort. This is matched against
// transactions that are restored from disk.
message TInMemoryWaitingVolatileTx {
    optional uint64 TxId = 1;
    optional NActorsProto.TActorId Source = 2;
    optional uint64 Cookie = 3;
    optional uint64 Type = 4;
}

// Partial in-memory state of the datashard
message TInMemoryState {
    optional TInMemoryVars Vars = 1;
    repeated TInMemoryLockInfo Locks = 2;
    repeated TInMemoryLockRange LockRanges = 3;
    repeated TInMemoryLockConflict LockConflicts = 4;
    repeated TInMemoryLockVolatileDependency LockVolatileDependencies = 5;
    repeated TInMemoryPreparedVolatileTx PreparedVolatileTxs = 6;
    repeated TInMemoryWaitingVolatileTx WaitingVolatileTxs = 7;
}

// Internal continuation token, may change between versions
message TInMemoryStateContinuationToken {
    // Index to continue from
    optional uint64 NextIndex = 1;
}

// Sent to the state actor by new generations
message TEvInMemoryStateRequest {
    // Generation of the new tablet
    optional uint32 Generation = 1;

    // Continuation token to get the next response
    optional bytes ContinuationToken = 2;
}

// Sent by the state actor to new generations
message TEvInMemoryStateResponse {
    // Partial serialized TInMemoryState chunk
    optional uint32 SerializedStatePayloadIndex = 1;

    // Optional checkpoint offsets within the chunk. The protobuf message may
    // be parsed cleanly up to these offsets without the need to concatenate
    // subsequent chunks.
    repeated uint32 SerializedStateCheckpoints = 2 [packed = true];

    // Will be set for incomplete replies
    optional bytes ContinuationToken = 3;
}

// Forces cleanup-related operations in datashard tablet:
// compaction, GC, GC log and other temporary data erasure.
// Once the operation is done, any deleted data not used initially
// will be included in garbage collection requests for the blobstorage.
// Note: deleted data may still be used for a while, e.g. for history for MVCC.
message TEvForceDataCleanup {
    optional uint64 DataCleanupGeneration = 1; // increasing sequence
}

// Returns DataCleanupGeneration of the last successfully completed TEvForceDataCleanup request.
// Intermediate requests and corresponding TEvForceDataCleanupResult's may be skipped.
message TEvForceDataCleanupResult {
    enum EStatus {
        UNKNOWN = 0;
        OK = 1;
        WRONG_SHARD_STATE = 2;
        BORROWED = 3;
    };
    optional uint64 DataCleanupGeneration = 1; // from corresponding request (or greater)
    optional uint64 TabletId = 2;
    optional EStatus Status = 3;
}
