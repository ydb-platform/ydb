#include "columnshard_schema.h"
#include "tables_manager.h"

#include "engines/column_engine_logs.h"
#include "engines/metadata_accessor.h"
#include "engines/reader/simple_reader/iterator/sys_view/abstract/schema.h"
#include "transactions/transactions/tx_add_sharding_info.h"

#include <ydb/core/scheme/scheme_types_proto.h>
#include <ydb/core/tablet_flat/tablet_flat_executor.h>
#include <ydb/core/tx/columnshard/blobs_action/blob_manager_db.h>
#include <ydb/core/tx/tiering/manager.h>

#include <library/cpp/protobuf/json/proto2json.h>
#include <util/string/join.h>

namespace NKikimr::NColumnShard {

void TSchemaPreset::Deserialize(const NKikimrSchemeOp::TColumnTableSchemaPreset& presetProto) {
    Id = presetProto.GetId();
    Name = presetProto.GetName();
}

namespace {

TInternalPathId GetInitialMaxInternalPathId(const ui64 tabletId) {
    //Generated internal path IDs must not overlap with external(SchemeShard) path IDs for any table or tablestore.
    //In other words, internal path Id must be either equal to schemeShard PathId or differernt from any other schemeshard path id within a tablet
    //Otherwise there may be a clash between values generated by SS and CS
    static constexpr ui64 InternalPathIdBase = 1'000'000'000;   //Use a value presumably greater than any really used

    //Internal path IDs are not required to have different or identical values across a table's tablets.
    //But they may differ because shards generate internal path ids independently based on thier internal counters
    //So, we intentionally make them different in order to detect possible errors earlier
    static constexpr ui64 InternalPathIdTabletMod = 1'000;   //not huge, to be able to write tests on equal values
    return TInternalPathId::FromRawValue(InternalPathIdBase + tabletId % InternalPathIdTabletMod);
}

}   //namespace

std::optional<std::set<NColumnShard::TSchemeShardLocalPathId>> TTablesManager::ResolveSchemeShardLocalPathIdsOptional(
    const TInternalPathId internalPathId) const {
    if (!HasTable(internalPathId, true)) {
        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("method", "resolve_ss_path_id")("internal", internalPathId)("result", "not_found");
        return std::nullopt;
    }
    const auto p = Tables.FindPtr(internalPathId);
    AFL_VERIFY(p)("internal", internalPathId);
    std::set<NColumnShard::TSchemeShardLocalPathId> result;
    for (const auto& unifiedPathId: p->GetPathIds()) {
        result.insert(unifiedPathId.SchemeShardLocalPathId);
    }
    return result;
}

std::optional<TInternalPathId> TTablesManager::ResolveInternalPathIdOptional(
    const NColumnShard::TSchemeShardLocalPathId schemeShardLocalPathId, const bool withTabletPathId) const {
    if (const auto* internalPathId = SchemeShardLocalToInternal.FindPtr(schemeShardLocalPathId)) {
        return { *internalPathId };
    } else {
        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("method", "resolve_internal_path_id")("ss_local", schemeShardLocalPathId)(
            "result", "not_found");
        if (withTabletPathId && TabletPathId.has_value() && schemeShardLocalPathId == TabletPathId->SchemeShardLocalPathId) {
            return { TabletPathId->InternalPathId };
        }
        return std::nullopt;
    }
}

bool TTablesManager::FillMonitoringReport(NTabletFlatExecutor::TTransactionContext& txc, NJson::TJsonValue& json) {
    NIceDb::TNiceDb db(txc.DB);
    {
        auto& schemaJson = json.InsertValue("schema_versions", NJson::JSON_ARRAY);
        auto rowset = db.Table<Schema::SchemaPresetVersionInfo>().Select();
        if (!rowset.IsReady()) {
            return false;
        }

        while (!rowset.EndOfSet()) {
            TSchemaPreset::TSchemaPresetVersionInfo info;
            Y_ABORT_UNLESS(info.ParseFromString(rowset.GetValue<Schema::SchemaPresetVersionInfo::InfoProto>()));
            NProtobufJson::Proto2Json(info, schemaJson.AppendValue(NJson::JSON_MAP));

            if (!rowset.Next()) {
                return false;
            }
        }
    }
    json.InsertValue("tables_count", Tables.size());
    json.InsertValue("presets_count", SchemaPresetsIds.size());
    json.InsertValue("to_drop_count", PathsToDrop.size());
    return true;
}

void TTablesManager::Init(NIceDb::TNiceDb& db, const TSchemeShardLocalPathId tabletSchemeShardLocalPathId, const TTabletStorageInfo* info) {
    AFL_VERIFY(info);
    const auto& tabletInternalPathId = GetOrCreateInternalPathId(tabletSchemeShardLocalPathId);
    const auto& tabletPathId = TUnifiedPathId::BuildValid(tabletInternalPathId, tabletSchemeShardLocalPathId);
    if (TabletPathId.has_value()) {
        AFL_VERIFY(tabletPathId == *TabletPathId)("old", *TabletPathId)("new", tabletPathId);
        AFL_VERIFY(SchemaObjectsCache);
    } else {
        TabletPathId.emplace(tabletPathId);
        AFL_VERIFY(!SchemaObjectsCache);
        SchemaObjectsCache = NOlap::TSchemaCachesManager::GetCache(tabletSchemeShardLocalPathId, info->TenantPathId);
        Schema::SaveSpecialValue(db, Schema::EValueIds::OwnerPathId, tabletSchemeShardLocalPathId.GetRawValue());
        Schema::SaveSpecialValue(db, Schema::EValueIds::InternalOwnerPathId, tabletInternalPathId.GetRawValue());
        if (GenerateInternalPathId) {
            Schema::SaveSpecialValue(db, Schema::EValueIds::MaxInternalPathId, MaxInternalPathId.GetRawValue());
        }
    }
}

void TTablesManager::AddTableInfo(const TUnifiedPathId unifiedPathId, TTableInfo&& tableInfo) {
    auto it = Tables.find(unifiedPathId.InternalPathId);
    if (it == Tables.end()) {
        Tables.emplace(unifiedPathId.InternalPathId, std::move(tableInfo));
    } else {
        it->second.Merge(std::move(tableInfo));
    }
    SchemeShardLocalToInternal.emplace(unifiedPathId.SchemeShardLocalPathId, unifiedPathId.InternalPathId);
}

bool TTablesManager::InitFromDB(NIceDb::TNiceDb& db, const TTabletStorageInfo* info) {
    {
        std::optional<ui64> tabletSchemeShardLocalPathIdValue;
        if (!Schema::GetSpecialValueOpt(db, Schema::EValueIds::OwnerPathId, tabletSchemeShardLocalPathIdValue)) {
            return false;
        }
        std::optional<ui64> tabletInternalPathIdValue;
        if (!Schema::GetSpecialValueOpt(db, Schema::EValueIds::InternalOwnerPathId, tabletInternalPathIdValue)) {
            return false;
        }
        if (!tabletInternalPathIdValue.has_value()) {
            tabletInternalPathIdValue = tabletSchemeShardLocalPathIdValue;
        }
        if (tabletSchemeShardLocalPathIdValue.has_value()) {
            AFL_VERIFY(tabletInternalPathIdValue.has_value());
            TabletPathId.emplace(TUnifiedPathId::BuildValid(TInternalPathId::FromRawValue(*tabletInternalPathIdValue),
                TSchemeShardLocalPathId::FromRawValue(*tabletSchemeShardLocalPathIdValue)));
            if (info) {
                SchemaObjectsCache = NOlap::TSchemaCachesManager::GetCache(TabletPathId->SchemeShardLocalPathId, info->TenantPathId);
            } else {
                SchemaObjectsCache = std::make_shared<NOlap::TSchemaObjectsCache>();
            }
        }

        std::optional<ui64> maxPathIdValue;
        if (!Schema::GetSpecialValueOpt(db, Schema::EValueIds::MaxInternalPathId, maxPathIdValue)) {
            return false;
        }
        if (GenerateInternalPathId && maxPathIdValue.has_value()) {
            MaxInternalPathId = TInternalPathId::FromRawValue(*maxPathIdValue);
            AFL_VERIFY(MaxInternalPathId >= GetInitialMaxInternalPathId(TabletId));
        }
    }
    TMap<TSchemeShardLocalPathId, TInternalPathId> mutableTables;
    {
        TLoadTimeSignals::TLoadTimer timer = LoadTimeCounters->TableLoadTimeCounters.StartGuard();
        TMemoryProfileGuard g("TTablesManager/InitFromDB::TablesV1");
        auto rowset = db.Table<Schema::TableInfoV1>().Select();
        if (!rowset.IsReady()) {
            timer.AddLoadingFail();
            return false;
        }

        while (!rowset.EndOfSet()) {
            TTableInfo table = TTableInfo::InitFromDBV1(rowset);
            const auto pathIds = table.GetPathIds();
            AFL_VERIFY(pathIds.size() == 1);
            const auto pathId = *pathIds.begin();
            if (GenerateInternalPathId) {
                AFL_VERIFY(pathId.InternalPathId <= MaxInternalPathId)("path_id", pathId)("max_internal_path_id", MaxInternalPathId);
            }
            if (!table.IsReadOnly(pathId.GetSchemeShardLocalPathId())) {
                mutableTables[pathId.GetSchemeShardLocalPathId()] = pathId.InternalPathId;
            }
            AddTableInfo(pathId, std::move(table));

            if (!rowset.Next()) {
                timer.AddLoadingFail();
                return false;
            }
        }
    }
    {
        TLoadTimeSignals::TLoadTimer timer = LoadTimeCounters->TableLoadTimeCounters.StartGuard();
        TMemoryProfileGuard g("TTablesManager/InitFromDB::Tables");
        auto rowset = db.Table<Schema::TableInfo>().Select();
        if (!rowset.IsReady()) {
            timer.AddLoadingFail();
            return false;
        }

        while (!rowset.EndOfSet()) {
            TTableInfo table = TTableInfo::InitFromDB(rowset);
            const auto pathIds = table.GetPathIds();
            AFL_VERIFY(pathIds.size() == 1);
            const auto pathId = *pathIds.begin();
            if (GenerateInternalPathId) {
                AFL_VERIFY(pathId.InternalPathId <= MaxInternalPathId)("path_id", pathId)("max_internal_path_id", MaxInternalPathId);
            }
            mutableTables.erase(pathId.GetSchemeShardLocalPathId());
            AddTableInfo(pathId, std::move(table));

            if (!rowset.Next()) {
                timer.AddLoadingFail();
                return false;
            }
        }
    }

    for (const auto& [schemeShardLocalPathId, internalPathId] : mutableTables) { // backward compatibility
        auto it = Tables.find(internalPathId);
        if (it == Tables.end()) {
            continue;
        }
        it->second.Remove(schemeShardLocalPathId);
        if (it->second.GetPathIds().empty()) {
            Tables.erase(it);
        }
    }

    for (const auto& [internalPathId, table]: Tables) {
        if (table.IsDropped()) {
            AFL_VERIFY(PathsToDrop[table.GetDropVersionVerified()].emplace(internalPathId).second);
        }
    }

    std::optional<TSchemaPreset> preset;
    {
        TLoadTimeSignals::TLoadTimer timer = LoadTimeCounters->SchemaPresetLoadTimeCounters.StartGuard();
        TMemoryProfileGuard g("TTablesManager/InitFromDB::SchemaPresets");
        auto rowset = db.Table<Schema::SchemaPresetInfo>().Select();
        if (!rowset.IsReady()) {
            timer.AddLoadingFail();
            return false;
        }

        if (!rowset.EndOfSet()) {
            preset = TSchemaPreset();
            preset->InitFromDB(rowset);

            if (preset->IsStandaloneTable()) {
                Y_VERIFY_S(!preset->GetName(), "Preset name: " + preset->GetName());
                AFL_VERIFY(!preset->Id);
            } else {
                Y_VERIFY_S(preset->GetName() == "default", "Preset name: " + preset->GetName());
                AFL_VERIFY(preset->Id);
            }
            AFL_VERIFY(SchemaPresetsIds.emplace(preset->GetId()).second);
            if (!rowset.Next()) {
                timer.AddLoadingFail();
                return false;
            }
        }

        AFL_VERIFY(rowset.EndOfSet())("reson", "multiple_presets_not_supported");
    }

    {
        TLoadTimeSignals::TLoadTimer timer = LoadTimeCounters->TableVersionsLoadTimeCounters.StartGuard();
        TMemoryProfileGuard g("TTablesManager/InitFromDB::Versions");
        auto rowset = db.Table<Schema::TableVersionInfo>().Select();
        if (!rowset.IsReady()) {
            timer.AddLoadingFail();
            return false;
        }

        while (!rowset.EndOfSet()) {
            const auto pathId = TInternalPathId::FromRawValue(rowset.GetValue<Schema::TableVersionInfo::PathId>());
            const auto table = Tables.FindPtr(pathId);
            AFL_VERIFY(table);
            NOlap::TSnapshot version(
                rowset.GetValue<Schema::TableVersionInfo::SinceStep>(), rowset.GetValue<Schema::TableVersionInfo::SinceTxId>());

            NKikimrTxColumnShard::TTableVersionInfo versionInfo;
            AFL_VERIFY(versionInfo.ParseFromString(rowset.GetValue<Schema::TableVersionInfo::InfoProto>()));
            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "load_table_version")("path_id", pathId)("snapshot", version);
            AFL_VERIFY(preset);
            AFL_VERIFY(preset->Id == versionInfo.GetSchemaPresetId())("preset", preset->Id)("table", versionInfo.GetSchemaPresetId());

            if (versionInfo.HasTtlSettings()) {
                Ttl.AddVersionFromProto(pathId, version, versionInfo.GetTtlSettings());
            }
            table->AddVersion(version);
            if (!rowset.Next()) {
                timer.AddLoadingFail();
                return false;
            }
        }
    }

    {
        TLoadTimeSignals::TLoadTimer timer = LoadTimeCounters->SchemaPresetVersionsLoadTimeCounters.StartGuard();
        TMemoryProfileGuard g("TTablesManager/InitFromDB::PresetVersions");

        auto rowset = db.Table<Schema::SchemaPresetVersionInfo>().Select();
        if (!rowset.IsReady()) {
            timer.AddLoadingFail();
            return false;
        }

        while (!rowset.EndOfSet()) {
            const ui32 id = rowset.GetValue<Schema::SchemaPresetVersionInfo::Id>();
            AFL_VERIFY(preset);
            AFL_VERIFY(preset->Id == id)("preset", preset->Id)("schema", id);
            NOlap::TSnapshot version(
                rowset.GetValue<Schema::SchemaPresetVersionInfo::SinceStep>(), rowset.GetValue<Schema::SchemaPresetVersionInfo::SinceTxId>());

            TSchemaPreset::TSchemaPresetVersionInfo info;
            Y_ABORT_UNLESS(info.ParseFromString(rowset.GetValue<Schema::SchemaPresetVersionInfo::InfoProto>()));
            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "load_preset")("preset_id", id)("snapshot", version)(
                "version", info.HasSchema() ? info.GetSchema().GetVersion() : -1);

            AFL_VERIFY(info.HasSchema());
            AFL_INFO(NKikimrServices::TX_COLUMNSHARD)("event", "index_schema")("preset_id", id)("snapshot", version)(
                "version", info.GetSchema().GetVersion());
            NOlap::IColumnEngine::TSchemaInitializationData schemaInitializationData(info);
            if (!PrimaryIndex) {
                PrimaryIndex = std::make_unique<NOlap::TColumnEngineForLogs>(TabletId, SchemaObjectsCache.GetObjectPtrVerified(),
                    DataAccessorsManager.GetObjectPtrVerified(), StoragesManager, version, preset->Id, schemaInitializationData, PortionsStats);
            } else if (PrimaryIndex->GetVersionedIndex().IsEmpty() ||
                       info.GetSchema().GetVersion() > PrimaryIndex->GetVersionedIndex().GetLastSchema()->GetVersion()) {
                PrimaryIndex->RegisterSchemaVersion(version, preset->Id, schemaInitializationData);
            } else {
                PrimaryIndex->RegisterOldSchemaVersion(version, preset->Id, schemaInitializationData);
            }

            if (!rowset.Next()) {
                timer.AddLoadingFail();
                return false;
            }
        }
    }

    TMemoryProfileGuard g("TTablesManager/InitFromDB::Other");
    for (auto&& i : Tables) {
        PrimaryIndex->RegisterTable(i.first);
    }
    return true;
}

THashMap<TSchemeShardLocalPathId, TInternalPathId> TTablesManager::ResolveInternalPathIds(
    const TSchemeShardLocalPathId from, const TSchemeShardLocalPathId to) const {
    THashMap<TSchemeShardLocalPathId, TInternalPathId> result;
    for (const auto& [schemeShardLocalPathId, internalPathId] : SchemeShardLocalToInternal) {
        if ((from <= schemeShardLocalPathId) && (schemeShardLocalPathId <= to)) {
            result.emplace(schemeShardLocalPathId, internalPathId);
        }
    }
    return result;
}

bool TTablesManager::HasTable(
    const TInternalPathId pathId, const bool withDeleted, const std::optional<NOlap::TSnapshot> minReadSnapshot) const {
    auto it = Tables.find(pathId);
    if (it == Tables.end()) {
        return false;
    }
    if (it->second.IsDropped(minReadSnapshot)) {
        return withDeleted;
    }
    return true;
}

TInternalPathId TTablesManager::GetOrCreateInternalPathId(const TSchemeShardLocalPathId schemeShardLocalPathId) {
    if (const auto& internalPathId = ResolveInternalPathId(schemeShardLocalPathId, true)) {
        return *internalPathId;
    }
    if (GenerateInternalPathId) {
        const auto result = TInternalPathId::FromRawValue(MaxInternalPathId.GetRawValue() + 1);
        MaxInternalPathId = result;
        return result;
    } else {
        return TInternalPathId::FromRawValue(schemeShardLocalPathId.GetRawValue());
    }
}

bool TTablesManager::IsReadyForStartWrite(const TInternalPathId pathId, const bool withDeleted) const {
    return HasPrimaryIndex() && HasTable(pathId, withDeleted);
}

bool TTablesManager::IsReadyForFinishWrite(const TInternalPathId pathId, const NOlap::TSnapshot& minReadSnapshot) const {
    return HasPrimaryIndex() && HasTable(pathId, false, minReadSnapshot);
}

bool TTablesManager::HasPreset(const ui32 presetId) const {
    return SchemaPresetsIds.contains(presetId);
}

const TTableInfo& TTablesManager::GetTable(const TInternalPathId pathId) const {
    Y_ABORT_UNLESS(HasTable(pathId));
    return Tables.at(pathId);
}

ui64 TTablesManager::GetMemoryUsage() const {
    ui64 memory = Tables.size() * sizeof(TTableInfo) + PathsToDrop.size() * sizeof(ui64) + Ttl.GetMemoryUsage();
    if (PrimaryIndex) {
        memory += PrimaryIndex->MemoryUsage();
    }
    return memory;
}

void TTablesManager::DropTable(const TSchemeShardLocalPathId schemeShardLocalPathId, const TInternalPathId pathId, const NOlap::TSnapshot& version, NIceDb::TNiceDb& db) {
    auto* table = Tables.FindPtr(pathId);
    AFL_VERIFY(table);
    table->SetDropVersion(schemeShardLocalPathId, version);
    if (table->IsDropped()) {
        AFL_VERIFY(PathsToDrop[version].emplace(pathId).second);
    }
    if (!table->IsReadOnly(schemeShardLocalPathId)) { // v0 can't be read-only
        Schema::SaveTableDropVersion(db, pathId, version.GetPlanStep(), version.GetTxId());
    }
    Schema::SaveTableDropVersionV1(db, schemeShardLocalPathId, pathId, version.GetPlanStep(), version.GetTxId());
}

void TTablesManager::DropPreset(const ui32 presetId, const NOlap::TSnapshot& version, NIceDb::TNiceDb& db) {
    AFL_VERIFY(SchemaPresetsIds.contains(presetId));
    SchemaPresetsIds.erase(presetId);
    Schema::SaveSchemaPresetDropVersion(db, presetId, version);
}

void TTablesManager::RegisterTable(TTableInfo&& table, NIceDb::TNiceDb& db) {
    AFL_VERIFY(table.GetPathIds().size() == 1);
    const auto pathId = *table.GetPathIds().begin();
    Y_ABORT_UNLESS(table.IsEmpty());
    NYDBTest::TControllers::GetColumnShardController()->OnAddPathId(TabletId, pathId);

    Schema::SaveTableInfo(db, pathId.InternalPathId); // v0
    Schema::SaveTableInfoV1(db, pathId.InternalPathId, pathId.SchemeShardLocalPathId); // v1

    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("method", "RegisterTable")("path_id", pathId);
    bool needRegisterTable = PrimaryIndex != nullptr;
    AFL_VERIFY(pathId.SchemeShardLocalPathId.IsValid());
    AddTableInfo(pathId, std::move(table));
    Schema::SaveTableSchemeShardLocalPathId(db, pathId.InternalPathId, pathId.SchemeShardLocalPathId); // v0
    if (GenerateInternalPathId) {
        Schema::SaveSpecialValue(db, Schema::EValueIds::MaxInternalPathId, MaxInternalPathId.GetRawValue());
    }
    if (needRegisterTable) {
        PrimaryIndex->RegisterTable(pathId.GetInternalPathId());
    }
}

bool TTablesManager::RegisterSchemaPreset(const TSchemaPreset& schemaPreset, NIceDb::TNiceDb& db) {
    if (SchemaPresetsIds.contains(schemaPreset.GetId())) {
        return false;
    }
    SchemaPresetsIds.emplace(schemaPreset.GetId());
    Schema::SaveSchemaPresetInfo(db, schemaPreset.GetId(), schemaPreset.GetName());
    return true;
}

void TTablesManager::AddSchemaVersion(
    const ui32 presetId, const NOlap::TSnapshot& version, const NKikimrSchemeOp::TColumnTableSchema& schema, NIceDb::TNiceDb& db) {
    Y_ABORT_UNLESS(SchemaPresetsIds.contains(presetId));

    TSchemaPreset::TSchemaPresetVersionInfo versionInfo;
    versionInfo.SetId(presetId);
    versionInfo.SetSinceStep(version.GetPlanStep());
    versionInfo.SetSinceTxId(version.GetTxId());
    *versionInfo.MutableSchema() = schema;

    auto it = ActualSchemaForPreset.find(presetId);
    if (it == ActualSchemaForPreset.end()) {
        ActualSchemaForPreset.emplace(presetId, schema);
    } else {
        *versionInfo.MutableDiff() = NOlap::TSchemaDiffView::MakeSchemasDiff(it->second, schema);
        it->second = schema;
    }

    versionInfo.MutableSchema()->SetEngine(NKikimrSchemeOp::COLUMN_ENGINE_REPLACING_TIMESERIES);
    Schema::SaveSchemaPresetVersionInfo(db, presetId, version, versionInfo);
    if (!PrimaryIndex) {
        PrimaryIndex = std::make_unique<NOlap::TColumnEngineForLogs>(TabletId, SchemaObjectsCache.GetObjectPtrVerified(),
            DataAccessorsManager.GetObjectPtrVerified(), StoragesManager, version, presetId,
            NOlap::IColumnEngine::TSchemaInitializationData(versionInfo), PortionsStats);
        for (auto&& i : Tables) {
            PrimaryIndex->RegisterTable(i.first);
        }
        PrimaryIndex->OnTieringModified(GetTtl());
    } else {
        PrimaryIndex->RegisterSchemaVersion(version, presetId, NOlap::IColumnEngine::TSchemaInitializationData(versionInfo));
    }
}

std::unique_ptr<NTabletFlatExecutor::ITransaction> TTablesManager::CreateAddShardingInfoTx(TColumnShard& owner,
    const TSchemeShardLocalPathId schemeShardLocalPathId, const ui64 versionId,
    const NSharding::TGranuleShardingLogicContainer& tabletShardingLogic) const {
    const auto* internalPathId = SchemeShardLocalToInternal.FindPtr(schemeShardLocalPathId);
    AFL_VERIFY(internalPathId)("scheme_shard_local_path_id", schemeShardLocalPathId);
    return std::make_unique<TTxAddShardingInfo>(owner, tabletShardingLogic, *internalPathId, versionId);
}

void TTablesManager::AddTableVersion(const TInternalPathId pathId, const NOlap::TSnapshot& version,
    const NKikimrTxColumnShard::TTableVersionInfo& versionInfo, const std::optional<NKikimrSchemeOp::TColumnTableSchema>& schema,
    NIceDb::TNiceDb& db) {
    auto it = Tables.find(pathId);
    AFL_VERIFY(it != Tables.end())("method", "AddTableVersion")("internal_path_id", pathId)("version", version);
    auto& table = it->second;

    bool isTtlModified = false;
    if (versionInfo.HasTtlSettings()) {
        isTtlModified = true;
        Ttl.AddVersionFromProto(pathId, version, versionInfo.GetTtlSettings());
    }

    if (versionInfo.HasSchemaPresetId()) {
        AFL_VERIFY(!schema);
        Y_ABORT_UNLESS(SchemaPresetsIds.contains(versionInfo.GetSchemaPresetId()));
    } else if (schema) {
        TSchemaPreset fakePreset;
        if (SchemaPresetsIds.empty()) {
            Y_ABORT_UNLESS(RegisterSchemaPreset(fakePreset, db));
        } else {
            Y_ABORT_UNLESS(SchemaPresetsIds.contains(fakePreset.GetId()));
        }
        AddSchemaVersion(fakePreset.GetId(), version, *schema, db);
    }

    if (isTtlModified) {
        if (PrimaryIndex) {
            PrimaryIndex->OnTieringModified(GetTableTtl(pathId), pathId);
        }
    }
    Schema::SaveTableVersionInfo(db, pathId, version, versionInfo);
    table.AddVersion(version);
}

TTablesManager::TTablesManager(const std::shared_ptr<NOlap::IStoragesManager>& storagesManager,
    const std::shared_ptr<NOlap::NDataAccessorControl::IDataAccessorsManager>& dataAccessorsManager,
    const std::shared_ptr<TPortionIndexStats>& portionsStats, const ui64 tabletId)
    : StoragesManager(storagesManager)
    , DataAccessorsManager(dataAccessorsManager)
    , LoadTimeCounters(std::make_unique<TTableLoadTimeCounters>())
    , PortionsStats(portionsStats)
    , TabletId(tabletId)
    , GenerateInternalPathId(AppData()->ColumnShardConfig.GetGenerateInternalPathId() ||
                             NYDBTest::TControllers::GetColumnShardController()->IsForcedGenerateInternalPathId())
    , MaxInternalPathId(GetInitialMaxInternalPathId(TabletId)) {
}

bool TTablesManager::TryFinalizeDropPathOnExecute(NTable::TDatabase& dbTable, const TInternalPathId pathId) const {
    const auto& itTable = Tables.find(pathId);
    AFL_VERIFY(itTable != Tables.end())("problem", "No schema for path")("path_id", pathId);
    
    if (!itTable->second.IsDropped()) {
        return true;
    }

    auto itDrop = PathsToDrop.find(itTable->second.GetDropVersionVerified());
    AFL_VERIFY(itDrop != PathsToDrop.end());
    AFL_VERIFY(itDrop->second.contains(pathId));

    AFL_VERIFY(!GetPrimaryIndexSafe().HasDataInPathId(pathId));
    NIceDb::TNiceDb db(dbTable);
    NColumnShard::Schema::EraseTableInfo(db, pathId); // v0
    for (const auto& unifiedPathId : itTable->second.GetPathIds()) {
        NColumnShard::Schema::EraseTableInfoV1(db, pathId, unifiedPathId.GetSchemeShardLocalPathId());
    }
    for (auto&& tableVersion : itTable->second.GetVersions()) {
        NColumnShard::Schema::EraseTableVersionInfo(db, pathId, tableVersion);
    }
    return true;
}

bool TTablesManager::TryFinalizeDropPathOnComplete(const TInternalPathId pathId) {
    const auto& itTable = Tables.find(pathId);
    AFL_VERIFY(itTable != Tables.end())("problem", "No schema for path")("path_id", pathId);
    AFL_VERIFY(itTable->second.IsDropped());
    {
        auto itDrop = PathsToDrop.find(itTable->second.GetDropVersionVerified());
        AFL_VERIFY(itDrop != PathsToDrop.end());
        AFL_VERIFY(itDrop->second.erase(pathId));
        if (itDrop->second.empty()) {
            PathsToDrop.erase(itDrop);
        }
    }
    AFL_VERIFY(!GetPrimaryIndexSafe().HasDataInPathId(pathId));
    AFL_VERIFY(MutablePrimaryIndex().ErasePathId(pathId));
    for (const auto& unifiedPathId : itTable->second.GetPathIds()) {
        AFL_VERIFY(SchemeShardLocalToInternal.erase(unifiedPathId.GetSchemeShardLocalPathId()));
    }
    Tables.erase(itTable);
    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("method", "TryFinalizeDropPathOnComplete")("path_id", pathId)("size", Tables.size());
    return true;
}

void TTablesManager::MoveTablePropose(const TSchemeShardLocalPathId srcSchemeShardLocalPathId) {
    NActors::TLogContextGuard gLogging =
        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("scheme_shard_src_local_path_id", srcSchemeShardLocalPathId);
    const auto& internalPathId = ResolveInternalPathId(srcSchemeShardLocalPathId, false);
    AFL_VERIFY(internalPathId);
    AFL_VERIFY(RenamingLocalToInternal.emplace(srcSchemeShardLocalPathId, *internalPathId).second)("src_internal_path_id", internalPathId);
    AFL_VERIFY(SchemeShardLocalToInternal.erase(srcSchemeShardLocalPathId));
}

void TTablesManager::CopyTablePropose(const TSchemeShardLocalPathId srcSchemeShardLocalPathId) {
    NActors::TLogContextGuard gLogging =
        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("scheme_shard_src_local_path_id", srcSchemeShardLocalPathId);
    const auto& internalPathId = ResolveInternalPathId(srcSchemeShardLocalPathId, false);
    AFL_VERIFY(internalPathId);
    AFL_VERIFY(CopyingLocalToInternal.emplace(srcSchemeShardLocalPathId, *internalPathId).second)("src_internal_path_id", internalPathId);
}

void TTablesManager::MoveTableProgress(
    NIceDb::TNiceDb& db, const TSchemeShardLocalPathId oldSchemeShardLocalPathId, const TSchemeShardLocalPathId newSchemeShardLocalPathId) {
    NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD) ("event", "move_table_progress")(
        "old_path_id", oldSchemeShardLocalPathId)("new_path_id", newSchemeShardLocalPathId);
    AFL_VERIFY(!ResolveInternalPathId(newSchemeShardLocalPathId, false));
    const auto* pInternalPathId = RenamingLocalToInternal.FindPtr(oldSchemeShardLocalPathId);
    AFL_VERIFY(pInternalPathId);
    const auto internalPathId = *pInternalPathId;
    AFL_VERIFY(HasTable(internalPathId));
    auto* table = Tables.FindPtr(internalPathId);
    AFL_VERIFY(table);
    table->RenameTableSchemeShardLocalPathId(db, oldSchemeShardLocalPathId, newSchemeShardLocalPathId);
    AFL_VERIFY(RenamingLocalToInternal.erase(oldSchemeShardLocalPathId));
    AFL_VERIFY(SchemeShardLocalToInternal.emplace(newSchemeShardLocalPathId, internalPathId).second);
    if (internalPathId == TabletPathId->InternalPathId) {
        TabletPathId->SchemeShardLocalPathId = newSchemeShardLocalPathId;
        Schema::SaveSpecialValue(db, Schema::EValueIds::OwnerPathId, newSchemeShardLocalPathId.GetRawValue());
    }
    NYDBTest::TControllers::GetColumnShardController()->OnDeletePathId(TabletId, TUnifiedPathId::BuildValid(internalPathId, oldSchemeShardLocalPathId));
    NYDBTest::TControllers::GetColumnShardController()->OnAddPathId(TabletId, TUnifiedPathId::BuildValid(internalPathId, newSchemeShardLocalPathId));
}

void TTablesManager::CopyTableProgress(
    NIceDb::TNiceDb& db, const NOlap::TSnapshot& version,
    const TSchemeShardLocalPathId srcSchemeShardLocalPathId, const TSchemeShardLocalPathId dstSchemeShardLocalPathId) {
    NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("event", "copy_table_progress")(
        "src_path_id", srcSchemeShardLocalPathId)("dst_path_id", dstSchemeShardLocalPathId);
    AFL_VERIFY(!ResolveInternalPathId(dstSchemeShardLocalPathId, false));
    const auto* pInternalPathId = CopyingLocalToInternal.FindPtr(srcSchemeShardLocalPathId);
    AFL_VERIFY(pInternalPathId);
    const auto internalPathId = *pInternalPathId;
    AFL_VERIFY(HasTable(internalPathId));
    auto* table = Tables.FindPtr(internalPathId);
    AFL_VERIFY(table);
    table->CopySchemeShardLocalPathId(db, srcSchemeShardLocalPathId, dstSchemeShardLocalPathId, version);
    AFL_VERIFY(CopyingLocalToInternal.erase(srcSchemeShardLocalPathId));
    AFL_VERIFY(SchemeShardLocalToInternal.emplace(dstSchemeShardLocalPathId, internalPathId).second);
    NYDBTest::TControllers::GetColumnShardController()->OnAddPathId(TabletId, TUnifiedPathId::BuildValid(internalPathId, dstSchemeShardLocalPathId));
}

std::vector<TTablesManager::TSchemasChain> TTablesManager::ExtractSchemasToClean() const {
    const ui64 lastSchemaVersion = PrimaryIndex->GetVersionedIndex().GetLastSchema()->GetVersion();
    std::set<TSchemaAddress> toRemove;
    std::vector<TTablesManager::TSchemasChain> chains;
    std::optional<TSchemaAddress> addrPred;
    std::set<ui64> versionsToRemove;
    std::optional<ui64> ignoreToVersion;
    std::vector<ui64> versions;
    ui32 predVersion = 0;
    auto& index = MutablePrimaryIndexAsVerified<NOlap::TColumnEngineForLogs>();
    for (auto&& i : index.GetVersionedIndex().GetSchemaByVersion()) {
        versions.emplace_back(i.first);
        TSchemaAddress addr(i.second->GetIndexInfo().GetPresetId(), i.second->GetSnapshot());
        if (addrPred) {
            AFL_VERIFY(*addrPred < addr);
        }
        addrPred = addr;
        if (ignoreToVersion) {
            AFL_VERIFY(*ignoreToVersion == i.second->GetIndexInfo().GetVersion())("ignore_to", *ignoreToVersion)(
                                             "next_version", i.second->GetIndexInfo().GetVersion());
        }
        if (auto ignoreToVersion = index.MutableVersionedIndex().ExtractIgnoreSchemaVersionFor(i.second->GetIndexInfo().GetVersion())) {
            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("event", "schema_to_remove")("reason", "equal_to_use")("from", i.first)(
                "to", ignoreToVersion);
            AFL_VERIFY(versionsToRemove.emplace(i.first).second);
            AFL_VERIFY(toRemove.emplace(addr).second);
        } else {
            ignoreToVersion.reset();
            if (!index.HasDataWithSchemaVersion(predVersion, i.first) &&
                lastSchemaVersion != i.first) {
                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("event", "schema_to_remove")("reason", "empty")("from", i.first);
                AFL_VERIFY(versionsToRemove.emplace(i.first).second);
                AFL_VERIFY(toRemove.emplace(addr).second);
            } else {
                predVersion = i.first + 1;
                if (toRemove.size()) {
                    chains.emplace_back(toRemove, addr);
                    toRemove.clear();
                }
            }
        }
    }
    AFL_VERIFY(toRemove.empty())("last_version", lastSchemaVersion)("ignore_last", ignoreToVersion)("versions", JoinSeq(",", versions));
    for (auto&& i : versionsToRemove) {
        MutablePrimaryIndexAsVerified<NOlap::TColumnEngineForLogs>().MutableVersionedIndex().EraseVersion(i);
    }
    return chains;
}

TConclusion<std::shared_ptr<NOlap::ITableMetadataAccessor>> TTablesManager::BuildTableMetadataAccessor(
    const TString& tablePath, const TInternalPathId internalPathId, const TSchemeShardLocalPathId externalPathId) {
    if (!HasTable(internalPathId)) {
        return std::make_shared<NOlap::TAbsentTableAccessor>(tablePath, NColumnShard::TUnifiedPathId::BuildValid(internalPathId, externalPathId));
    }
    return std::make_shared<NOlap::TUserTableAccessor>(tablePath, NColumnShard::TUnifiedPathId::BuildValid(internalPathId, externalPathId));
}

TConclusion<std::shared_ptr<NOlap::ITableMetadataAccessor>> TTablesManager::BuildTableMetadataAccessor(
    const TString& tablePath, const TSchemeShardLocalPathId externalPathId) {
    const std::optional<TInternalPathId> internalPathId = ResolveInternalPathIdOptional(externalPathId, false);
    auto path = TFsPath(tablePath).Fix();
    auto schemaAdapter = NOlap::NReader::NSimple::NSysView::NAbstract::ISchemaAdapter::TFactory::MakeHolder(std::tuple{path.Parent().GetName(), path.GetName()});
    if (schemaAdapter) {
        return schemaAdapter->BuildMetadataAccessor(tablePath, TUnifiedOptionalPathId::BuildExternal(externalPathId, internalPathId));
    } else if (!internalPathId) {
        return TConclusionStatus::Fail(
            "incorrect table name and table id for scan start: " + tablePath + "::" + externalPathId.DebugString());
    } else {
        if (!HasTable(*internalPathId)) {
            return std::make_shared<NOlap::TAbsentTableAccessor>(
                tablePath, NColumnShard::TUnifiedPathId::BuildValid(*internalPathId, externalPathId));
        } else {
            return std::make_shared<NOlap::TUserTableAccessor>(
                tablePath, NColumnShard::TUnifiedPathId::BuildValid(*internalPathId, externalPathId));
        }
    }
}

}   // namespace NKikimr::NColumnShard
