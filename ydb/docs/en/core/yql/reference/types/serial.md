# Serial Types

Serial types are integer data types with an associated value-generation mechanism. They create auto-increment columns: each new row inserted into a table automatically generates a unique value for this column (similar to the [SERIAL](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL) type in PostgreSQL or the [AUTO_INCREMENT](https://dev.mysql.com/doc/refman/9.0/en/example-auto-increment.html) property in MySQL).

## Description

When a column of a serial type is defined, a separate schema object called a `Sequence` is created and bound to this column. This object is a private sequence generator and it is hidden from the user. The `Sequence` will be destroyed together with the table.

The `Sequence` object supports several parameters that determine its behavior. These parameters can be altered after creation using the [ALTER SEQUENCE](../syntax/alter-sequence.md) command.

By default, values generated by the `Sequence` start from one, are incremented by one with each new value, and are limited according to the chosen type.

{% note info %}

Serial columns are supported both for columns included in the primary key and for non-key columns.

However, such columns cannot be [altered](../syntax/alter_table/family#mod-column-groups) or [dropped](../syntax/alter_table/columns.md) from the table — attempting to perform these operations will result in an error.

{% endnote %}

| Type        | Maximum Value         | Underlying Type |
|-------------|----------------------|----------|
| `SmallSerial` | $2^15–1$                | `Int16`    |
| `Serial2`     | $2^15–1$                | `Int16`    |
| `Serial`      | $2^31–1$                | `Int32`    |
| `Serial4`     | $2^31–1$                | `Int32`    |
| `Serial8`     | $2^63–1$                | `Int64`    |
| `BigSerial`   | $2^63–1$                | `Int64`    |

If a sequence reaches its maximum value, insertion results in an error:

```text
Error: Failed to get next val for sequence: /dev/test/users/_serial_column_user_id, status: SCHEME_ERROR
    <main>: Error: sequence [OwnerId: <some>, LocalPathId: <some>] doesn't have any more values available, code: 200503
```

{% note info %}

The next value is allocated by the generator before the actual insertion into the table and is considered used even if the row is not successfully inserted (for example, in case of transaction rollback).
As a result, the values in such a column may have gaps and may not form a continuous sequence.

{% endnote %}

Tables with `Serial` columns support [copy](../../../reference/ydb-cli/tools-copy.md), [rename](../../../reference/ydb-cli/commands/tools/rename.md), [dump](../../../reference/ydb-cli/export-import/tools-dump.md), [restore](../../../reference/ydb-cli/export-import/import-file.md), and [import](../../../reference/ydb-cli/export-import/import-s3.md)/[export](../../../reference/ydb-cli/export-import/export-s3.md) CLI operations.

## Usage Example

Carefully choose the columns for your [PRIMARY KEY](../../../dev/primary-key/row-oriented.md). To ensure scalability and high performance, avoid using monotonically increasing primary keys; this pattern directs all inserts to the last partition, concentrating load on a single server.

Instead, use a hash of the entire primary key (or a portion of it) as the first key element to distribute data evenly across cluster partitions.

```yql
CREATE TABLE users (
    user_hash Uint64,
    user_id Serial,
    name Utf8,
    email Utf8,
    PRIMARY KEY (user_hash, user_id)
);
```

The `user_hash` field can be calculated on the application side, for example, by applying a hash function to the `email` column.

``` yql
UPSERT INTO users (user_hash, name, email) VALUES (123456789, 'Alice', 'alice@example.com');
INSERT INTO users (user_hash, name, email) VALUES (987654321, 'Bob', 'bob@example.com');
REPLACE INTO users (user_hash, name, email) VALUES (111111111, 'John', 'john@example.com');
```

Result (example `user_hash` values are used):

| user_hash   | email                 | name  | user_id |
|-------------|-----------------------|-------|---------|
| 123456789   | `alice@example.com`   | Alice | 1       |
| 987654321   | `bob@example.com`     | Bob   | 2       |
| 111111111   | `john@example.com`    | John  | 3       |

You can also explicitly specify a value for a column of type `Serial` during insertion, for example, when restoring data. In this case, the insertion behaves like a regular integer column, and the sequence remains unaffected:

``` yql
UPSERT INTO users (user_hash, user_id, name, email) VALUES (222222222, 10, 'Peter', 'peter@example.com');
```

### Suboptimal Schema Example

```yql
CREATE TABLE users_bad (
    user_id Serial,
    name Utf8,
    email Utf8,
    PRIMARY KEY (user_id)
);
```

In this example, the auto-increment column is the sole component of the primary key, resulting in an uneven load and creating a bottleneck on the last partition.
