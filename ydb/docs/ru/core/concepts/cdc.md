# Change Data Capture (CDC)

Change Data Capture (CDC) обеспечивает захват изменений строк таблицы {{ ydb-short-name }}, формирует из них _поток изменений (changefeed)_, записывает в распределенное хранилище и предоставляет доступ к этим записям для дальнейшей обработки. В качестве распределенного хранилища используется [топик](topic.md), который позволяет эффективно хранить лог изменений таблицы.

Когда в таблице добавляется, обновляется или удаляется строка, CDC формирует запись о произошедшем изменении с указанием [первичного ключа](datamodel/table.md) строки и пишет ее в соответствующую данному ключу партицию топика.

## Гарантии {#guarantees}

* Записи об изменениях шардированы между партициями топика по первичному ключу.
* Каждое изменение доставляется ровно один раз (exactly-once семантика).
* Изменения по одному и тому же первичному ключу доставляются в том же порядке, в котором они происходили в таблице в одну и ту же партицию топика.
* Запись об изменении доставляется до партиции топика только после фиксации (коммита) соответствующей транзакции в таблице.

## Ограничения {#restrictions}

* Количество партиций топика фиксируется на момент создания потока изменений и остается неизменным (топики, в отличие от таблиц, не являются эластичными).
* В потоке изменений поддерживаются записи о следующих видах операций:
  * обновление;
  * удаление.

  Таким образом, добавление строки является частным случаем обновления, и в потоке изменений запись о добавлении строки будет выглядеть аналогично записи об обновлении.

## Виртуальные метки времени {#virtual-timestamps}

Все изменения в таблицах {{ ydb-short-name }} упорядочены в соответствии с порядком выполнения транзакций. Каждое изменение маркируется виртуальной меткой времени, являющейся кортежем из двух элементов:

1. Глобального времени координатора.
1. Уникального идентификатора транзакции.

Используя эти метки, можно упорядочить записи из разных партиций топика относительного друг друга или использовать их для фильтрации (например, чтобы исключить записи о старых изменениях).

{% note info %}

По умолчанию виртуальные метки времени не выгружаются в поток изменений. Для их включения используйте [соответствующий параметр](../yql/reference/syntax/alter_table.md#changefeed-options) при создании потока.

{% endnote %}

## Первоначальное сканирование таблицы {#initial-scan}

По умолчанию в поток изменений выгружаются записи только о тех строках таблицы, которые изменились после создания потока. Первоначальное сканирование таблицы позволяет выгрузить в поток изменений значения всех строк, существовавших на момент его создания.

Сканирование производится в фоновом режиме поверх снапшота таблицы. При этом возможны следующие ситуации:
* В таблице меняется значение непросканированной строки. В поток изменений последовательно будут выгружены: запись с исходным значением и запись об изменении. При повторном изменении этой же строки будет выгружена только запись об изменении.
* Во время сканирования обнаруживается измененная строка. В поток изменений ничего не выгружается, так как исходное значение уже было выгружено в момент изменения (см. предыдущий пункт).
* В таблице меняется значение просканированной строки. В поток изменений выгружается только запись об изменении.

Таким образом, гарантируется, что для одной и той же строки (первичного ключа) сначала будет выгружено исходное значение, а затем — запись об изменении.

{% note info %}

Запись с исходным значением строки будет помечена как запись об [обновлении](#restrictions). При использовании [виртуальных меток времени](#virtual-timestamps) записи маркируются меткой времени снапшота.

{% endnote %}

В процессе сканирования, в зависимости от частоты обновления данных таблицы, возможен повышенный фон ошибок `OVERLOADED` из-за того, что, помимо записей об изменениях, необходимо доставить также записи с исходными значениями строк. По окончании сканирования поток изменений переходит в нормальный режим работы.

## Структура записи {#record-structure}

В зависимости от [параметров потока](../yql/reference/syntax/alter_table.md#changefeed-options) структура записи может отличаться.

### JSON-формат {#json-record-structure}

Запись в формате [JSON](https://en.wikipedia.org/wiki/JSON) имеет следующую структуру:

```json
{
    "key": [<key components>],
    "update": {<columns>},
    "erase": {},
    "newImage": {<columns>},
    "oldImage": {<columns>},
    "ts": [<step>, <txId>]
}
```

* `key` — массив значений компонент первичного ключа. Присутствует всегда.
* `update` — признак обновления. Присутствует, если запись соответствует операции обновления. В режиме `UPDATES` так же содержит названия и значения изменившихся столбцов.
* `erase` — признак удаления. Присутствует, если запись соответствует операции удаления.
* `newImage` — снимок состояния строки, получившегося в результате изменения. Присутствует в режимах `NEW_IMAGE` и `NEW_AND_OLD_IMAGES`. Содержит названия и значения столбцов.
* `oldImage` — снимок состояния строки, предшествовавшего изменению. Присутствует в режимах `OLD_IMAGE` и `NEW_AND_OLD_IMAGES`. Содержит названия и значения столбцов.
* `ts` — виртуальная метка времени. Присутствует, если включена настройка `VIRTUAL_TIMESTAMPS`. Содержит значение глобального времени координатора (`step`) и уникальный идентификатор транзакции (`txId`).

>Например, запись об обновлении в режиме `UPDATES`:
>
>```json
>{
>    "key": [1, "one"],
>    "update": {
>        "payload": "lorem ipsum",
>        "date": "2022-02-22"
>    }
>}
>```
>
>Запись об удалении:
>```json
>{
>    "key": [2, "two"],
>    "erase": {}
>}
>```
>
>Запись со снимками строки:
>```json
>{
>    "key": [1, 2, 3],
>    "update": {},
>    "newImage": {
>        "textColumn": "value1",
>        "intColumn": 101,
>        "boolColumn": true
>    },
>    "oldImage": {
>        "textColumn": null,
>        "intColumn": 100,
>        "boolColumn": false
>    }
>}
>```
>
>Запись с виртуальными метками времени:
>```json
>{
>    "key": [1],
>    "update": {
>        "created": "2022-12-12T00:00:00.000000Z",
>        "customer": "Name123"
>    },
>    "ts": [1670792400890, 562949953607163]
>}
>```

{% note info %}

* Одна и та же запись не может содержать поля `update` и `erase` одновременно, так как эти поля являются признаками операции (невозможно одновременно обновить и удалить строку таблицы). Но каждая запись содержит одно из этих полей (любая операция является обновлением или удалением).
* В режиме `UPDATES` для операций обновления поле `update` выполняет роль не только признака операции (обновление), но и содержит названия и значения изменившихся столбцов.
* Поля JSON-объекта, содержащие названия и значения столбцов (`newImage`, `oldImage` и `update` в режиме `UPDATES`), *не включают* в себя столбцы, являющиеся компонентами первичного ключа.
* Если в записи присутствует поле `erase` (то есть запись соответствует операции удаления), то это всегда пустой JSON-объект (`{}`).

{% endnote %}

{% if audience == "tech" %}

### JSON-формат, совместимый с Amazon DynamoDB Streams {#dynamodb-streams-json-record-structure}

Для документных таблиц, совместимых с [Amazon DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html), {{ ydb-short-name }} может генерировать записи об изменениях в формате, совместимом с [Amazon DynamoDB Streams](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html).

Структура записи соответствует [структуре записей Amazon DynamoDB Streams](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_Record.html):
* `awsRegion` — содержит строку, переданную в параметре `AWS_REGION` при создании потока изменений.
* `dynamodb` — [StreamRecord](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_StreamRecord.html).
* `eventID` — уникальный идентификатор записи.
* `eventName` — `INSERT`, `MODIFY` или `REMOVE`. Значение `INSERT` допустимо только в режиме `NEW_AND_OLD_IMAGES`.
* `eventSource` — содержит строку `ydb:document-table`.
* `eventVersion` — содержит строку `1.0`.

{% endif %}

{% if audience == "tech" %}

### JSON-формат, совместимый с Debezium {#debezium-json-record-structure}

Запись в формате [JSON](https://en.wikipedia.org/wiki/JSON), совместимого с [Debezium](https://debezium.io), имеет следующую структуру:

Тело сообщения:
```json
{
    "payload": {
        "op": <op>,
        "before": {<columns>},
        "after": {<columns>},
        "ts": [<step>, <txId>],
        "source": {
            "version": <version>,
            "connector": <connector>,
            "ts_ms": <ts_ms>,
            "txId": <txId>
        }
    }
}
```

* `op`: операция, которая была произведена над строкой в таблице:
  * "u" обозначает обновление.
  * "s" обозначает сброс (reSet).
  * "d" обозначает удаление.
* `before`: снимок состояния строки до изменения. Присутствует в режимах `OLD_IMAGE` и `NEW_AND_OLD_IMAGES`. Содержит названия и значения столбцов. Присутствует только если строка существовала до изменения.
* `after`: снимок состояния строки после изменения. Присутствует в режимах `NEW_IMAGE` и `NEW_AND_OLD_IMAGES`. Содержит названия и значения столбцов. Присутствует только если строка существует после изменения.
* `ts`: виртуальная метка времени. Присутствует, если включена настройка `VIRTUAL_TIMESTAMPS`. Содержит значение глобального времени координатора (`step`) и уникальный идентификатор транзакции (`txId`). Обратите внимание, что Debezium коннекторы обычно используют число `ts_ms`.
* `source`: метаданные записи.
  * `version`: версия коннектора, используемая для генерации записи. Текущая версия: `0.0.1`.
  * `connector`: название коннектора. Текущее название: `ydb_debezium_json`.
  * `ts_ms`: примерное время применения изменения в YDB, в миллисекундах.
  * `txId`: уникальный идентификатор транзакции.

{% note warning %}

Пока Debezium JSON формат не поддерживает `schema` в сообщении. Другие Debezium коннекторы это поддерживают.

{% endnote %}

При использовании kafka API для чтения топика, вы увидите Debezium-совместимый kafka ключ в следующем формате:
```json
{
    "payload": {
        <columns>
    }
}
```

* `payload`: Первичный ключ строки, которая была изменена

Информацию о том, как это сохранено в сообщении, и как можно получить информацию о ключе без использования kafka API, читайте в [документации об интеграции с kafka](../reference/kafka-api/index.md)

{% endif %}

## Время хранения записей {#retention-period}

По умолчанию записи хранятся в потоке изменений в течение 24 часов с момента отправки. В зависимости от сценариев использования время хранения можно уменьшить или увеличить до 30 дней.

{% note warning %}

Записи, время хранения которых истекло, удаляются вне зависимости от того, успели их обработать (прочитать) или нет.

{% endnote %}

Удаление записей до их обработки клиентом приводит к возникновению пропусков [офсетов](topic.md#offset), то есть офсеты последней прочитанной из партиции записи и самой ранней из доступных будут отличаться более, чем на единицу.

Для настройки времени хранения записей укажите параметр [RETENTION_PERIOD](../yql/reference/syntax/alter_table.md#changefeed-options) при создании потока изменений.

## Количество партиций топика {#topic-partitions}

По умолчанию количество [партиций топика](topic.md#partitioning) равно количеству партиций таблицы. Количество партиций топика можно переопределить, указав параметр [TOPIC_MIN_ACTIVE_PARTITIONS](../yql/reference/syntax/alter_table.md#changefeed-options) при создании потока изменений.

{% note info %}

В настоящий момент возможность явного указания числа партиций топика доступна только для таблиц, у которых первый компонент первичного ключа имеет тип `Uint64` или `Uint32`.

{% endnote %}

## Создание и удаление потока изменений {#ddl}

Поток изменений может быть добавлен к существующей таблице или удален директивами [ADD CHANGEFEED и DROP CHANGEFEED](../yql/reference/syntax/alter_table.md#changefeed) операции YQL `ALTER TABLE`. При удалении таблицы добавленный к ней поток изменений также будет удален.

## Назначение и применение CDC {#best_practices}

Об использовании CDC при разработке приложений смотрите в [рекомендациях](../best_practices/cdc.md).
