# Change Data Capture (CDC)

Change Data Capture (CDC) обеспечивает захват изменений строк таблицы {{ ydb-short-name }}, формирует из них _поток изменений (changefeed)_, записывает в распределенное хранилище и предоставляет доступ к этим записям для дальнейшей обработки. В качестве распределенного хранилища используется [топик](topic.md), который позволяет эффективно хранить лог изменений таблицы.

Когда в таблице добавляется, обновляется или удаляется строка, CDC формирует запись о произошедшем изменении с указанием [первичного ключа](datamodel/table.md) строки и пишет ее в соответствующую данному ключу партицию топика.

## Гарантии {#guarantees}

* Записи об изменении шардированы между партициями топика по первичному ключу.
* Каждое изменение доставляется ровно один раз (exactly-once семантика).
* Изменения по одному и тому же первичному ключу доставляются в том же порядке, в котором они происходили в таблице в одну и ту же партицию топика.

## Ограничения {#restrictions}

* Количество партиций топика фиксируется на момент создания потока изменений и остается неизменным (топики, в отличие от таблиц, не являются эластичными).
* В потоке изменений поддерживаются записи о следующих видах операций:
  * обновление;
  * удаление.

  Таким образом, добавление строки является частным случаем обновления, и в потоке изменений запись о добавлении строки будет выглядеть аналогично записи об обновлении.

## Виртуальные метки времени {#virtual-timestamps}

Все изменения в таблицах {{ ydb-short-name }} упорядочены в соответствии с порядком выполнения транзакций. Каждое изменение маркируется виртуальной меткой времени, являющейся кортежем из двух элементов:

1. Глобального времени координатора.
1. Уникального идентификатора транзакции.

Используя эти метки, можно упорядочить записи из разных партиций топика относительного друг друга или использовать их для фильтрации (например, чтобы исключить записи о старых изменениях).

{% note info %}

По умолчанию виртуальные метки времени не выгружаются в поток изменений. Для их включения используйте [соответствующий параметр](../yql/reference/syntax/alter_table.md#changefeed-options) при создании потока.

{% endnote %}

## Первоначальное сканирование таблицы {#initial-scan}

По умолчанию в поток изменений выгружаются записи только о тех строках таблицы, которые изменились после создания потока. Первоначальное сканирование таблицы позволяет выгрузить в поток изменений значения всех строк, существовавших на момент его создания.

Сканирование производится в фоновом режиме поверх снапшота таблицы. При этом возможны следующие ситуации:
* В таблице меняется значение непросканированной строки. В поток изменений последовательно будут выгружены: запись с исходным значением и запись об изменении. При повторном изменении этой же строки будет выгружена только запись об изменении.
* Во время сканирования обнаруживается измененная строка. В поток изменений ничего не выгружается, так как исходное значение уже было выгружено в момент изменения (см. предыдущий пункт).
* В таблице меняется значение просканированной строки. В поток изменений выгружается только запись об изменении.

Таким образом, гарантируется, что для одной и той же строки (первичного ключа) сначала будет выгружено исходное значение, а затем — запись об изменении.

{% note info %}

Запись с исходным значением строки будет помечена как запись об [обновлении](#restrictions). При использовании [виртуальных меток времени](#virtual-timestamps) записи маркируются меткой времени снапшота.

{% endnote %}

В процессе сканирования, в зависимости от частоты обновления данных таблицы, возможен повышенный фон ошибок `OVERLOADED` из-за того, что, помимо записей об изменениях, необходимо доставить также записи с исходными значениями строк. По окончании сканирования поток изменений переходит в нормальный режим работы.

## Структура записи {#record-structure}

В зависимости от [параметров потока](../yql/reference/syntax/alter_table.md#changefeed-options) структура записи может отличаться.

Запись в формате [JSON](https://en.wikipedia.org/wiki/JSON) имеет следующую структуру:

```json
{
    "key": [<key components>],
    "update": {<columns>},
    "erase": {},
    "newImage": {<columns>},
    "oldImage": {<columns>},
    "ts": [<step>, <txId>]
}
```

* `key` — массив значений компонент первичного ключа. Присутствует всегда.
* `update` — признак обновления. Присутствует, если запись соответствует операции обновления. В режиме `UPDATES` так же содержит названия и значения изменившихся столбцов.
* `erase` — признак удаления. Присутствует, если запись соответствует операции удаления.
* `newImage` — снимок состояния строки, получившегося в результате изменения. Присутствует в режимах `NEW_IMAGE` и `NEW_AND_OLD_IMAGES`. Содержит названия и значения столбцов.
* `oldImage` — снимок состояния строки, предшествовавшего изменению. Присутствует в режимах `OLD_IMAGE` и `NEW_AND_OLD_IMAGES`. Содержит названия и значения столбцов.
* `ts` — виртуальная метка времени. Присутствует, если включена настройка `VIRTUAL_TIMESTAMPS`. Содержит значение глобального времени координатора (`step`) и уникальный идентификатор транзакции (`txId`).

>Например, запись об обновлении в режиме `UPDATES`:
>
>```json
>{
>    "key": [1, "one"],
>    "update": {
>        "payload": "lorem ipsum",
>        "date": "2022-02-22"
>    }
>}
>```
>
>Запись об удалении:
>```json
>{
>    "key": [2, "two"],
>    "erase": {}
>}
>```
>
>Запись со снимками строки:
>```json
>{
>    "key": [1, 2, 3],
>    "update": {},
>    "newImage": {
>        "textColumn": "value1",
>        "intColumn": 101,
>        "boolColumn": true
>    },
>    "oldImage": {
>        "textColumn": null,
>        "intColumn": 100,
>        "boolColumn": false
>    }
>}
>```
>
>Запись с виртуальными метками времени:
>```json
>{
>    "key": [1],
>    "update": {
>        "created": "2022-12-12T00:00:00.000000Z",
>        "customer": "Name123"
>    },
>    "ts": [1670792400, 562949953607163]
>}
>```

{% note info %}

* Одна и та же запись не может содержать поля `update` и `erase` одновременно, так как эти поля являются признаками операции (невозможно одновременно обновить и удалить строку таблицы). Но каждая запись содержит одно из этих полей (любая операция является обновлением или удалением).
* В режиме `UPDATES` для операций обновления поле `update` выполняет роль не только признака операции (обновление), но и содержит названия и значения изменившихся столбцов.
* Поля JSON-объекта, содержащие названия и значения столбцов (`newImage`, `oldImage` и `update` в режиме `UPDATES`), *не включают* в себя столбцы, являющиеся компонентами первичного ключа.
* Если в записи присутствует поле `erase` (то есть запись соответствует операции удаления), то это всегда пустой JSON-объект (`{}`).

{% endnote %}

## Время хранения записей {#retention-period}

По умолчанию записи хранятся в потоке изменений в течение 24 часов с момента отправки. В зависимости от сценариев использования время хранения можно уменьшить или увеличить до 30 дней.

{% note warning %}

Записи, время хранения которых истекло, удаляются вне зависимости от того, успели их обработать (прочитать) или нет.

{% endnote %}

Удаление записей до их обработки клиентом приводит к возникновению пропусков [офсетов](topic.md#offset), то есть офсеты последней прочитанной из партиции записи и самой ранней из доступных будут отличаться более, чем на единицу.

Для настройки времени хранения записей укажите параметр [RETENTION_PERIOD](../yql/reference/syntax/alter_table.md#changefeed-options) при создании потока изменений.

## Создание и удаление потока изменений {#ddl}

Поток изменений может быть добавлен к существующей таблице или удален директивами [ADD CHANGEFEED и DROP CHANGEFEED](../yql/reference/syntax/alter_table.md#changefeed) операции YQL `ALTER TABLE`. При удалении таблицы добавленный к ней поток изменений также будет удален.

## Назначение и применение CDC {#best_practices}

Об использовании CDC при разработке приложений смотрите в [рекомендациях](../best_practices/cdc.md).
