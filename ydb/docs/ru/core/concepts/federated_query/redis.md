# Работа с базами данных Redis

В этом разделе описана основная информация про работу с внешней `NoSQL` базой данных [Redis](https://redis.io/), которая представляет собой `in-memory` `key-value` хранилище.

Для работы с внешней базой данных Redis необходимо выполнить следующие шаги:

1. Создать [секрет](../datamodel/secrets.md), содержащий пароль для подключения к базе данных.

    ```yql
    CREATE OBJECT redis_datasource_user_password (TYPE SECRET) WITH (value = "<password>");
    ```

1. Создать [внешний источник данных](../datamodel/external_data_source.md), описывающий определённую базу данных Redis. Включить шифрование соединений к внешней базе данных можно с помощью параметра `USE_TLS="TRUE"`.

    ```yql
    CREATE EXTERNAL DATA SOURCE external_data_source WITH (
        SOURCE_TYPE="Redis",
        LOCATION="<host>:<port>",
        DATABASE_NAME="<database>",
        AUTH_METHOD="BASIC",
        LOGIN="default",
        PASSWORD_SECRET_NAME="redis_datasource_user_password",
        --PROTOCOL="NATIVE",
        USE_TLS="FALSE"
    );
    ```

1. {% include [!](_includes/connector_deployment.md) %}
1. [Выполнить запрос](#query) к базе данных.

## Синтаксис запросов {#query}

Для работы с Redis используется следующая форма SQL-запроса:

```yql
SELECT * FROM redis_datasource.`<key_prefix:*>`
```

где:

- `redis_datasource` - идентификатор внешнего источника данных;
- `<key_prefix>` - префикс ключа внешнего источника данных.

например, если у вас в Redis ключи:
```
sample_session:1
sample_session:2
sample_session:3
user:email:1
user:email:2
user:email:3
```

то вы можете получить все ключи `sample_session` следующим образом:

```yql
SELECT * FROM redis_datasource.`sample_session:*`
```

## Ограничения

При работе с Redis существует ряд ограничений:

1. {% include [!](_includes/supported_requests.md) %}

2. Система обработки федеративных запросов {{ ydb-short-name }} умеет передавать исполнение некоторых частей запроса системе, выступающей в качестве источника данных. Фрагменты запроса передаются сквозь {{ ydb-short-name }} непосредственно во внешнюю систему и обрабатываются внутри неё. С помощью этой оптимизации, которая носит название «пушдауна предикатов» (predicate pushdown), удаётся значительно снизить объём данных, передаваемых от источника к движку обработки федеративных запросов. Благодаря этому снижается нагрузка на сеть и экономятся вычислительные ресурсы {{ ydb-short-name }}.

   В случае с Redis производится пушдаун фильтрации по `<key_prefix>`, описанной выше.

3. Поскольку данные в Redis не имеют схемы, нам для отображения их в таблицу приходится выводить ее самостоятельно при каждом запросе. Делается это согласно следующему алгоритму: 
   1.	**Сбор ключей** – Выполняется выборка доступных ключей из `Redis` в количестве `N`.
   2.	**Определение типов данных** – Для выбранных `N` ключей анализируются хранимые значения `string`, `hash`.
   3.	**Выявление структуры данных** – Если значения представлены в формате `hash` или другой структурированной форме, извлекаются потенциальные колонки.
   4.	**Формирование схемы** – Определяются типы данных для колонок на основе их значений.
   5.	**Сохранение схемы** – Полученная схема используется для получения и обработки данных из источника.

   > Если среди `N` `hash` ключей, будет встречено 3 вложенных поля `field1..3`, а при дальнейшем чтении будет встречен `hash` с бОльшим количеством полей, то в результат будут записаны лишь `field1..3`, при их наличии.

## Поддерживаемые типы данных
[Более подробно про типы Redis можно почитать тут](https://redis.io/glossary/redis-data-structures/)

Для ключей поддерживается тип `string`, для значений: `string`, `hash`

Поскольку Redis хранит в себе не традиционные таблицы, а пары `key-value` значений, то данные при чтении трансформируются следующим образом:

- Все ключи складываются в колонку `key` типа `String`
- Все встреченные значения типа `string` складываются в колонку `string_values`
- Все значения из `hash`, которые присутствуют в схеме, выведенной на этапе сканирования метаданных, заполняются, остальные помечаются `null`

Таким образом, для каждого ключа, который хранит в себе значение типа `string`, ячейка в колонке `string_values` будет заполнена, а в `hash_values` будет равна `null`. Для `hash` аналогично.

Ниже приведена таблица соответствия типов Redis и {{ ydb-short-name }}. Все остальные типы данных, за исключением перечисленных, не поддерживаются.

| Тип данных Redis | Тип данных {{ ydb-full-name }} | Примечания                                                 |
|------------------|--------------------------------|------------------------------------------------------------|
| `string`         | `Optional<String>`             |                                                            |
| `hash`           | `Optional<Struct>`             | `StructMembers` внутри `Struct` так же являются `Optional` |
