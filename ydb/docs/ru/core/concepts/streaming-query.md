# Потоковые запросы

Потоковые запросы предназначены для обработки данных, которые поступают непрерывно (из топика), в реальном времени.
В обычных запросах запрашиваемые данные на момент запуска запроса уже сохранены в таблицах.

![Обычные запросы](../concepts/_assets/streaming_queries_1.drawio.png "Обычные запросы" =640x)

В потоковых запросах запрос формулируется заранее, а данные "протекают" сквозь него.

![Потоковые запросы](../concepts/_assets/streaming_queries_2.drawio.png "Потоковые запросы" =640x)

## Отличия от обычных запросов:

- Мгновенная реакция. Традиционные отчеты строятся раз в день или раз в час. Потоковые запросы дают ответ через миллисекунды после события.
- Работа с бесконечными данными. Многие источники данных никогда не заканчиваются: логи серверов, клики пользователей на сайте, показания датчиков IoT, финансовые тикеры.
- Аналитика во времени. Например, нужно узнать, сколько покупок было совершено с 12:00 до 13:00.Потоковый запрос может открыть "окно", подождать опоздавшие события, пересчитать результат и выдать точную цифру, даже если события пришли вразнобой. Отличительной особенностью от аналитических запросов является то, что результаты запроса становятся доступны сразу после закрытия окна.
- Непрерывное обновление результатов. ННапример, нужно построить дашборд "Топ-10 продаваемых товаров за последние 10 минут". Потоковый запрос постоянно обновляет состояние этого топа.
- Возможность сложной логики с сохранением состояния. Например, нужно отправить алерт, если пользователь совершил 3 неудачные попытки входа подряд за 5 минут.

## Технические особенности {#technical_features}

- не имеют ограничений по времени работы;
- автоматически восстанавливают работоспособность в случае сбоев или обновлений базы;
- периодически сохраняют свое состояние ([чекпоинты](#checkpoints));
- результат запроса в виде посчитанных данных следует явно вставить в другой топик или таблицу.

В случае внутренних сбоев запрос автоматически перезапускается и восстанавливается из последнего сохраненного [чекпоинта](#checkpoints).

## Поддерживаемые входные и выходные данные {#input_output_data}

В качестве входных данных могут быть использованы:

- [топики](../concepts/datamodel/topic.md) из которых читается поток событий, как в той же БД, так и во внешних;
- внешние [источники S3](../concepts/federated_query/s3/external_data_source.md) для обогащения потока;
- Поток изменений из [CDC](../concepts/cdc.md)

Для выходных данных могут быть использованы

- топики, как в той же БД, так и во внешних;
- таблицы в той же БД.

## Ограничения {#limitations}

- запрос должен содержать хотя бы одно чтение из топика;
- чтение локальных таблиц для обогащения потока не поддерживается;
- `JOIN` двух потоков не поддерживается;
- чтение/запись локальных топиков без использования [внешних источников данных](../concepts/datamodel/external_data_source.md) не поддерживается.

## Гарантии {#guarantees}

Потоковые запросы обеспечивают гарантию at-least-once. Это гарантируется повторной обработкой данных с последнего сохраненного чекпоинта с [дедупликацией](https://ru.wikipedia.org/wiki/Дедупликация) при вставке в топик.

В частности это обеспечивается:

- гарантиями [топиков](../concepts/datamodel/topic.md) at-least-once при чтении и exactly-once при записи;
- сохранения [смещений](../concepts/datamodel/topic.md#offset) во входных топиках;
- сохранения [порядковых номеров сообщений](../concepts/datamodel/topic.md#seqno) для дедупликации в выходных топиках;
- сохранения стейтов агрегаций (ссылка на термин), таких как `GROUP BY HOP` и `MATCH_RECOGNIZE`.

## Использование читателя {#consumer-usage}

Использование [читателя](../concepts/datamodel/topic.md#consumer) не влияет на функциональность потоковых запросов, но позволяет на стороне мониторинга топиков просматривать метрики по читателю.
По умолчанию чтение из топика происходит [без использования читателя](../reference/ydb-sdk/topic.md#no-consumer).
Чтобы использовать читателя необходимо предварительно его создать через [CLI](../reference/ydb-cli/topic-consumer-add) или при создании топика с помощью [CREATE TOPIC](../yql/reference/syntax/create-topic.md).
Пример использования читателя можно увидеть в [CREATE STREAMING QUERY](../yql/reference/syntax/create-streaming-query). 

## Управление потоковыми запросами {#control}

### Состояние запроса {#state}

Управление работой потокового запроса происходит через команду  `ALTER STREAMING QUERY`
Исполнение команды от пользователя происходит асинхронно. Чтобы узнать в каком актуальном статусе находится потоковый запрос, необходимо посмотреть на значение колонки Status в системной таблице [.sys/streaming_queries](../dev/system-views.md).

### Поддерживаемые типы данных в топиках {#data-types}

Содержимое сообщений в топиках представляет собой набор байт, которое никак не интерпретируется {{ ydb-short-name }}. Читать сообщения из топика можно в виде набора байт, или можно воспользоваться встроенными механизмами парсинга наиболее популярных форматов данных (см. [Форматы данных потоковых запросов](../dev/streaming-query-formats.md)). Запись можно выполнять только в виде набора байт (например, как строка или JSON).

### Синтаксис {#syntax}

Для чтения из топика в той же базе или в другой базе необходимо создать [внешний источник данных](../concepts/datamodel/external_data_source.md). Более удобный механизм чтения из локальных топиков, где не будет требоваться создание внешнего источника данных, будет сделан в будущем, поэтому предварительно необходимо создать источник через [CREATE EXTERNAL DATA SOURCE](../yql/reference/syntax/create-external-data-source).

Управлять потоковыми запросами можно с помощью следующих конструкций YQL:

- [CREATE STREAMING QUERY](../yql/reference/syntax/create-streaming-query)
- [ALTER STREAMING QUERY](../yql/reference/syntax/alter-streaming-query)
- [DROP STREAMING QUERY](../yql/reference/syntax/drop-streaming-query)

### Чтение из топика без использования CREATE STREAMING QUERY {#read-from-topic}

Для удобной отладки потоковых запросов есть возможность использовать привычные `SELECT` конструкции с топиками без использования `CREATE STREAMING QUERY`. При этом важно задать ограничение на количество выходных строк, иначе запрос просто зависнет. В таких запросах отключены чекпоинты и есть ограничение на время работы, и как следствие, такие запросы не способны восстановить свою работоспособность после сбоя. Режим рекомендуется использовать исключительно в отладочных целях.

### Потоковая агрегация {#stream-agregation}

Агрегация данных в потоковом режиме возможна с помощью:

- [GROUP BY HOP](../yql/reference/syntax/select/group-by#group-by-hop)
- [MATCH_RECOGNIZE](../yql/reference/syntax/select/match_recognize)

Примеры запросов смотрите в [рецептах](../recipes/streaming_queries/index.md).

## Обогащение данных (S3) {#enrichment}

В потоковых запросах возможно присоединение к потоку данных из S3 с помощью конструкции `JOIN`. При этом поток обязательно должен находиться в левой части `JOIN`. Механизм имеет ограничения, т.к. правая часть `JOIN` полностью помещается в оперативную память процесса.

Обогащение данных (S3) возможно через [внешние источники данных](../concepts/federated_query/s3/external_data_source.md).

На данный момент `JOIN` потока с таблицами {{ ydb-short-name }} (как локальными, так и внешними) не поддерживается (в разработке).

## Запись в таблицы {#table-write}

Запись результата в таблицу {{ ydb-short-name }} возможна с помощью [UPSERT INTO](../yql/reference/syntax/upsert_into.md).

[INSERT INTO](../yql/reference/syntax/insert_into) не поддерживается.
Запись в таблицы {{ ydb-short-name }}, находящихся во внешних БД, не поддерживается.

## Чекпоинты {#checkpoints}

Чекпоинт представляет собой состояние рабочего потокового запроса, которое необходимо для восстановления работы запроса в случае сбоев в распределенной системе: выход из строя узлов, падения процессов при нехватке памяти и др. Инфраструктура собирает чекпоинты всех запущенных потоковых запросов периодически и сохраняет в системные таблицы базы.

Чекпоинт состоит из:

- состояний агрегаций, таких как [MATCH_RECOGNIZE](../yql/reference/syntax/select/match_recognize) и [GROUP BY HOP](../yql/reference/syntax/select/group-by#group-by-hop);
- текущих [смещений](../concepts/datamodel/topic.md#consumer-offset) во входных топиках;
- текущих [порядковых номеров сообщений](../concepts/datamodel/topic.md#seqno) в выходных топиках.

При первом запуске запроса производится его компиляция, результат которой сохраняется в системную таблицу.
В случае завершения запроса с ошибкой, он будет перезапущен автоматически, при этом:

- повторной компиляции не будет, т.к. в самом начале её сделали, и в таблице есть её результат;
- внутреннее состояние запроса будет восстановлено из последнего сохранённого чекпоинта.

У пользователя нет возможности для конкретного запроса как-то повлиять на сохранение чекпоинтов и выбор чекпоинта для восстановления, это делается автоматически.

### Очистка {#cleaning}

Размер чекпоинта зависит от сложности запроса, используемых агрегаций и от характера данных. Для оптимального потребления хранилища после очередного успешного сохранения чекпоинта старые удаляются автоматически. То есть большую часть времени для одного запроса в хранилище хранится только один чекпоинт.

### Отключение чекпоинтов {#shutdown}

Для снижения накладных расходов (от сохранения чекпоинтов) возможно отключение чекпоинтов. Для этого используется прагма `ydb.DisableCheckpoints`. При этом нужно учитывать отсутствие гарантий на консистентность данных (при пользовательских или внутренних перезапусках запроса). Используется исключительно с целью отладки.

## См. также

- [Форматы данных потоковых запросов](../dev/streaming-query-formats.md)
- [Рецепты работы с потоковыми запросами](../recipes/streaming_queries/index.md)
