# Процесс разработки: работа над изменениями кода {{ ydb-short-name }}

Этот раздел содержит пошаговый сценарий, который поможет вам выполнить необходимые шаги по настройке и узнать, как внести изменения в проект {{ ydb-short-name }}. Этому сценарию не обязательно строго следовать, вы можете разработать свой собственный подход на основе предоставленной информации.

## Настройка окружения {#envsetup}

### Учетная запись на GitHub {#GitHub_login}

Чтобы предлагать какие-либо изменения в исходном коде {{ ydb-short-name }}, необходима учетная запись на GitHub. Зарегистрируйтесь на [GitHub](https://github.com/), если вы еще этого не сделали.

### Пара ключей SSH {#ssh_key_pair}

* Для подключения к GitHub вы можете использовать: ssh/token/ssh из yubikey/password и т.д. Рекомендуемый метод - ssh-ключи.
* Если у вас еще нет созданных ключей (или yubikey), то просто создайте новые ключи. Полные инструкции находятся на [этой странице GitHub](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key).
* Если у вас есть yubikey, вы можете использовать legacy ключ из yubikey:

  * Предположим, что у вас уже есть настроенный yubikey (или вы настроили yubikey локально)
  * На вашем ноутбуке: `skotty ssh keys`
  * Загрузите ssh-ключ `legacy@yubikey` на GitHub ([через пользовательский интерфейс](https://github.com/settings/keys))
  * Проверьте подключение на ноутбуке: `ssh -T git@github.com`

#### Удаленная разработка

Если вы разрабатываете на удаленном компьютере, вы можете использовать ключ со своего ноутбука (сгенерированный или ключ от yubikey). Вам необходимо настроить переадресацию ключей. (Полные инструкции находятся на [этой странице GitHub](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/using-ssh-agent-forwarding)).

Предположим, что ваш удаленный компьютер dev123456.search.yandex.net.

* на вашем ноутбуке добавьте переадресацию по ssh (`~/.ssh/config`):

```text
Host dev123456.search.yandex.net
    ForwardAgent yes
```

* на удаленном компьютере добавьте в `~/.bashrc`:

```bash
if [[ -S "$SSH_AUTH_SOCK" && ! -h "$SSH_AUTH_SOCK" ]]; then
    ln -sf "$SSH_AUTH_SOCK" ~/.ssh/ssh_auth_sock;
fi
export SSH_AUTH_SOCK=~/.ssh/ssh_auth_sock;
```

* проверьте подключение: `ssh -T git@github.com`

### Git CLI {#git_cli}

У вас должна быть установлена утилита командной строки git для запуска команд из консоли. Посетите страницу [Downloads](https://git-scm.com/downloads) официального веб-сайта для получения инструкций по установке.

Чтобы установить ее в Linux/Ubuntu, запустите:

```bash
sudo apt-get update
sudo apt-get install git
```

### Зависимости сборки {#build_dependencies}

На компьютере разработчика должны быть установлены некоторые библиотеки.

Чтобы установить их под Linux/Ubuntu, запустите:

```bash
sudo apt-get update
sudo apt-get install libidn11-dev libaio-dev libc6-dev
```

### GitHub CLI (необязательно) {#gh_cli}

Использование GitHub CLI позволяет создавать Pull Request'ы и управлять репозиторием из командной строки. Вы также можете использовать GitHub UI для таких действий.

Установите GitHub CLI, как описано [на домашней странице](https://cli.github.com/). Для Linux Ubuntu вы можете перейти непосредственно к [https://github.com/cli/cli/blob/trunk/docs/install_linux.md#debian-ubuntu-linux-raspberry-pi-os-apt](https://github.com/cli/cli/blob/trunk/docs/install_linux.md#debian-ubuntu-linux-raspberry-pi-os-apt).

Выполните настройку аутентификации:

```bash
gh auth login
```

Вам будет задано несколько вопросов в интерактивном режиме, ответьте на них следующим образом:

|Вопрос|Ответ|
|--|--|
|What account do you want to log into?|**GitHub.com**|
|What is your preferred protocol for Git operations?|**SSH**|
|Upload your SSH public key to your GitHub account?|Выберите файл с открытым ключом (расширение `.pub`) из тех, что были созданы на шаге ["Создать пару ключей SSH"](#ssh_key_pair), например **/home/user/.ssh/id_ed25519.pub**|
|Title for your SSH key|**GitHub CLI** (оставьте значение по умолчанию)|
|How would you like to authenticate GitHub CLI|**Paste your authentication token**|

После последнего ответа вам будет предложено ввести токен, который вы можете сгенерировать в пользовательском интерфейсе GitHub:

```text
Tip: you can generate a Personal Access Token here https://github.com/settings/tokens
The minimum required scopes are 'repo', 'read:org', 'admin:public_key'.
? Paste your authentication token:
```

Откройте [настройки токенов в GitHub](https://github.com/settings/tokens), нажмите  "Generate new token" / "Classic", поставьте галочки в четырех полях:

* Поле **`workflow`**
* Три других, как указано в подсказке:  "repo", "admin:public_key" and "read:org" (в разделе "admin:org")

И скопипастите показанный токен, чтобы завершить настройку GitHub CLI.

### Форк и клонирование репозитория {#fork_create}

Официальным репозиторием {{ ydb-short-name }} является [https://github.com/ydb-platform/ydb](https://github.com/ydb-platform/ydb), расположенный под учетной записью организации YDB `ydb-platform`.

Чтобы работать над изменениями в {{ ydb-short-name }}, вы должны создать форк репозитория в вашем аккаунте GitHub. Нажмите на кнопку `Fork` на странице [официального репозитория {{ ydb-short-name }}](https://github.com/ydb-platform/ydb).

После того, как ваш форк создан, создайте локальный git репозиторий с двумя remote:

- `official`: официальный репозиторий {{ ydb-short-name }}, с ветками main и stable
- `fork`: ваш форк {{ ydb-short-name }} для разработки

```bash
mkdir -p ~/ydbwork
cd ~/ydbwork
git clone -o official git@github.com:ydb-platform/ydb.git
```

```bash
cd ydb
git remote add fork git@github.com:{your_github_user_name}/ydb.git
```

После завершения у вас будет форк репозитория {{ ydb-short-name }} Git, клонированный в `~/ydbwork/ydb`.

Форк репозитория - это мгновенное действие, однако клонирование на локальный компьютер требует некоторого времени для передачи около 650 МБ данных репозитория по сети.

Затем установите поведение по умолчанию для команды `git push`:

```bash
git config push.default current
git config push.autoSetupRemote true
```

Таким образом, команда `git push {remote}`будет автоматически устанавливать upstream `{remote}` для текущей ветки и последующие команды `git push` будут отправлять только текущую ветку.

Если вы собираетесь использовать GitHub CLI, установите `ydb-platform/ydb` репозиторием по умолчанию для GitHub CLI:

```bash
gh repo set-default ydb-platform/ydb
```

### Настройка авторства коммитов {#author}

Запустите следующую команду, чтобы указать свое имя и адрес электронной почты для коммитов, отправляемых с помощью Git (замените имя пользователя и email на ваши):

```bash
git config --global user.name "Marco Polo"
git config --global user.email "marco@ydb.tech"
```

## Работа над изменением {#feature}

Чтобы начать работу над изменением, убедитесь, что шаги, указанные в разделе [Настройка окружения](#envsetup) выше, выполнены.

### Обновление транка {#fork_sync}

Обычно для начала работы над изменением требуется последняя версия официального репозитория. Синхронизируйте вашу локальную ветку `main`, выполнив следующую команду:

Если ваша текущая локальная ветка `main`:

```bash
git pull --ff-only official main
```

Если ваша текущая локальная ветка не `main`:

```bash
cd ~/ydbwork/ydb
git fetch official main:main
```

Эта команда обновляет локальную ветку `main` без checkout.

### Создайте ветку разработки {#create_devbranch}

Создайте ветку разработки с помощью Git (замените "feature42" на название вашей новой ветки):

```bash
git checkout -b feature42
```

### Внесите изменения и коммиты {#commit}

Редактируйте файлы локально, используйте стандартные команды Git для добавления файлов, проверки статуса, выполнения коммитов и отправки изменений в ваш fork репозиторий:

```bash
git add .
git status
```

```bash
git commit -m "Implemented feature 42"
git push fork
```

Последующие push не требуют upstream или имени ветки:

```bash
git push
```

### Создайте Pull Request в официальный репозиторий {#create_pr}

Когда изменения будут завершены и протестированы локально (см. [Ya Build and Test](build-ya.md)), создайте Pull Request.

{% list tabs %}

- GitHub UI

  Откройте страницу вашей ветки на GitHub.com (`https://github.com/{your_github_user_name}/ydb/tree/{branch_name}`), нажмите `Contribute` и затем `Open Pull Request`.
  Также можно использовать ссылку в выводе команды `git push`, чтобы создать Pull Request:

  ```text
  ...
  remote: Resolving deltas: 100% (1/1), completed with 1 local object.
  remote:
  remote: Create a pull request for '{branch_name}' on GitHub by visiting:
  remote:      https://github.com/{your_github_user_name}/test/pull/new/{branch_name}
  ...
  ```

- GitHub CLI

  Установите и сконфигурируйте [GitHub CLI](https://cli.github.com/).

  ```bash
  cd ~/ydbwork/ydb
  ```

  ```bash
  gh pr create --title "Feature 42 implemented"
  ```

  После ответа на некоторые вопросы Pull Request будет создан, и вы получите ссылку на его страницу на GitHub.com.

{% endlist %}

### Заполните описание к Pull Request'у {#create_pr_desc}

При создании Pull Request'а описание будет заполнено текстом из шаблона, который нужно отредактировать:

1. **Changelog Category.** В этом блоке нужно оставить одну категорию из списка, которой соответствует изменение (см. [как выбрать категорию](#choose_category)). Есть категории, для которых сообщения из Changelog Entry можно не заполнять, они не будут опубликованы в списке изменений. Остальные категории определяют раздел списка изменений, в который попадёт сообщение.
2. **Changelog Entry.** В этот блок следует добавить описание изменения для конечных пользователей системы (см. [требования](#changelog_entry_req)). Содержимое этого блока будет опубликовано в [списке изменений](../changelog-server.md), если PR будет замержен.
3. **Description for reviewers.** В этот блок можно добавить ссылку на задачу и любую дополнительную информацию, которая будет полезна для ревью вашего изменения. Содержимое этого блока не попадёт в список изменений.


#### Требования к Changelog Entry {#changelog_entry_req}

Сообщение в Changelog Entry должно отвечать следующим требованиям:

- должно быть написано на английском языке;
- содержать не менее 20 символов, если [выбранная категория](#choose_category) имеет раздел в списке изменений;
- опираться на термины, которые используются в [глоссарии](../concepts/glossary.md);
- описывать, что в работе системы изменилось для конечного пользователя;
- соответствовать дополнительным требованиям, определяемым выбранной категорией.


#### Как выбрать Changelog Category {#choose_category}

#|
|| Категория | Раздел в списке изменений | Описание | Требования к сообщению ||
|| Feature
| Функциональность
| Новая функциональность. Иногда выпускается под флагом для сохранения совместимости.

Если вы делаете более одного PR'а в рамках задачи, эту категорию нужно выбрать только для финального коммита, а для промежуточных коммитов — Not for changelog.
| Должно включать:

  * ссылку на документацию (если описание превышает два предложения);
  * описание того, как включить функциональность, если она выпускается под флагом (если описание превышает одно предложение, его также стоит вынести в документацию).
||
|| Experimental feature
| Функциональность с пометкой «экспериментально»
| Новая функциональность. Всегда выпускается под флагом для сохранения совместимости.

Отличие от предыдущей категории в том, что даже после тестирования мы не можем гарантировать конечному пользователю корректную работу системы с этим изменением.
| Должно включать:

  * ссылку на документацию (если описание превышает два предложения);
  * описание того, как включить функциональность (если описание превышает одно предложение, его также стоит вынести в документацию).
||
|| Improvement
| Функциональность
| Изменения существующей функциональности.
| Должно включать ссылку на документацию (если описание превышает два предложения).
||
|| Performance improvement
| Производительность
| Изменения в производительности системы — ускорения, оптимизации, улучшения, которые привели к измеряемым изменениям в производительности.
| Должно отвечать на вопросы: производительность какой части системы изменилась и насколько.
||
|| Bugfix
| Исправления ошибок
| Исправления ошибок, с которыми пользователь сталкивался или мог столкнуться в предыдущих релизных версиях.
| Должно содержать:

  * ссылку на задачу в GitHub;
  * описание условий, при которых пользователь мог столкнуться с проблемой;
  * описание проявления проблемы;
  * описание способа исправления (необязательно, если логика работы системы принципиально не изменилась).
||
|| User Interface
| {{ ydb-short-name }} UI
| Любые изменения в {{ ydb-short-name }} UI
|
||
|| Backward incompatible changes
| Изменения с потерей обратной совместимости
| Изменения с потерей обратной совместимости с предыдущими релизными версиями.
| Должно содержать:

  * инструкцию по обновлению кластера без downtime приложений, которые используют изменяемую функциональность;
  * инструкцию по откату обновлений с кластера без downtime приложений.
||
|| Documentation
| -
| Изменения в документации.
| Не будет опубликовано в истории изменений. Сообщение заполнять не нужно.
||
|| Not for Changelog
| -
| Изменения, которые не видны конечному пользователю — рефакторинг кода, тесты, CI/CD, изменения CHANGELOG.md, исправления ошибок в коде новой функциональности (которая не попала в предыдущие релизные версии).
| Не будет опубликовано в истории изменений. Сообщение заполнять не нужно.
||
|#

{% note info %}

Важно выбрать только одну категорию, поэтому не рекомендуется включать в один PR изменения из разных категорий, например, новую функциональность и исправление ошибки. Однако если так случилось, следует выбрать категорию более важного для пользователя изменения, а в блок Changelog Entry добавить описание всех изменений.

{% endnote %}

#### Сообщение из Changelog Entry будет опубликовано в CHANGELOG.md

После создания Pull Request будет запущена неблокирующая [предварительная проверка](#precommit_checks), которая убеждается, что:

  * описание к Pull Request написано;
  * поле Changelog Category содержит одну категорию;
  * поле Changelog Entry содержит не менее 20 символов, если у категории есть [раздел в списке изменений](#choose_category).

Регулярно в `main` и `stable` ветках будет запущен процесс, который:

  1. Cобирает Changelog Entry из Pull Request, которые:

    * замержены в ветку;
    * относятся к категории, у которой есть [раздел в списке изменений](#choose_category);
    * успешно прошли предварительную проверку.

  2. Формирует Pull Request на добавление их в [CHANGELOG.md](https://github.com/ydb-platform/ydb/blob/main/CHANGELOG.md).

На ревью этого Pull Request проверят, что выбрана верная категория и описание соответствует [требованиям](#changelog_entry_req). Если описание не будет отвечать требованиям, то автора Pull Request попросят исправить сообщение. После ревью сообщение будет опубликовано в CHANGELOG.md. Перед публикацией новой версии {{ ydb-short-name }} будет собрана история изменений на основании CHANGELOG.md и опубликована в [документацию](../changelog-server.md).

#### Где посмотреть CHANGELOG.md

Файл CHANGELOG.md нужен, чтобы:

* ознакомиться с изменениями, которые были сделаны в предыдущих релизах или планируются к выпуску в следующих;
* обновить описание вашего изменения (например, если вы хотите дополнить его ссылкой на документацию);
* после мержа изменения в текущий релиз перенести описание из блока Unreleased в блок нужной версии.

В `main` файл CHANGELOG.md хранится [в корне](https://github.com/ydb-platform/ydb/blob/main/CHANGELOG.md). Чтобы открыть CHANGELOG.md в stable-ветке, выберите её из списка веток.
В `main` CHANGELOG.md содержит изменения для всех выпущенных версий и изменения, которые попадут в следующий релиз. В `stable-*` — изменения, которые были в `main` на момент ответвления, а также изменения, которые были домержены.

#### Как изменить сообщение в CHANGELOG.md

Если Pull Request ещё не замержен в ветку, можно изменить блок Changelog Entry в его описании.
Если Pull Request уже замержен, следует создать новый Pull Request, в котором изменить соответствующее сообщение в файле CHANGELOG.md этой ветки. Если от этой ветки уже были созданы другие stable-ветки, то в них тоже нужно внести соответствующее изменение — найдите последнюю мажорную ветку `stable-XX-Y`, а также все её минорные ветки `stable-XX-Y-Z`, и поправьте CHANGELOG.md в них.

### Предварительные проверки {#precommit_checks}

Перед мержем изменений выполняются прекоммитные проверки Pull Request'а.

Для изменений в коде {{ ydb-short-name }} прекоммитные проверки собирают артефакты, и запускают описанные в файлах `ya.make` тесты. Сборка/тесты выполняются на специальном merge коммите, который мержит ваши изменения с текущей веткой `main`.

Вы можете увидеть статус проверок на странице Pull Request'а. Также, ключевая информация о ходе сборки/тестов {{ ydb-short-name }} и текущий статус публикуются в комментариях к PR.

Если вы не являетесь членом команды {{ ydb-short-name }}, проверки не будут запущены до тех пор, пока член команды не рассмотрит ваши изменения, и не одобрит PR для тестов, присвоив метку `ok-to-test`.

Проверки перезапускаются каждый раз, когда пушатся новые изменения, предыдущая проверка прерывается, если она еще не завершена. Каждая итерация проверок создает собственный комментарий на странице PR, поэтому там сохраняется история проверок.

Участники команды разработки {{ ydb-short-name }} могут рестартовать проверки на новом merge коммите без пуша изменений. Для этого необходимо добавить к PR метку `rebase-and-check`.

### Результаты тестирования {#test-results}

Вы можете кликнуть по количеству тестов в разных разделах комментария с результатами тестирования, чтобы перейти к простому HTML-отчету о тестировании. В этом отчете вы можете увидеть, какие тесты были пройдены неудачно/успешно, и получить доступ к их логам.

### История тестов {#test_history}

Каждый раз, когда тесты запускаются {{ ydb-short-name }} CI, их результаты загружаются в [приложение Test History](https://nebius.testmo.net/projects/view/1). В комментарии к результатам тестирования есть ссылка "Test history", ведущая на страницу с соответствующим прогоном в этом приложении.

В "Test history" члены команды {{ ydb-short-name }} могут просматривать тестовые прогоны, выполнять поиск тестов, просматривать логи и сравнивать их между различными тестовыми прогонами. Если какой-либо тест завершается сбоем на некоторой прекоммитной проверке, в его истории можно увидеть, был ли этот сбой вызван данным изменением, или тест был сломан ранее.

### Review и merge {#review}

Pull Request может быть замержен после получения Approve от члена команды {{ ydb-short-name }}. Для коммуникации используются комментарии. После подтверждения участник команды {{ ydb-short-name }} нажимает на кнопку "Merge".

### Обновление изменения {#update}

Если в вашем репозитории открыт Pull Request для какой-либо ветки разработки, он будет обновляться каждый раз, когда вы выполняете push в эту ветку, с перезапуском проверок.

### Rebase changes {#rebase}

При возникновении конфликтов, вы можете сделать rebase своих изменений поверх текущего транка из официального репозитория. Чтобы сделать это, [обновите транк](#fork_sync) на вашей локальной машине, и запустите команду rebase:

```bash
# Предполагается, что ваша активная ветка является вашей веткой разработки
git fetch official main:main
git rebase main
```

### Перенос патчей в стабильную ветку {#cherry_pick_stable}

Когда есть необходимость перенести патч в стабильную ветку, отведите ветку от ветки stable:

```bash
git fetch official
git checkout -b "cherry-pick-fix42" official/stable-24-1
```

Затем используйте cherry-pick для переноса патча и сделайте push ветки в ваш fork:

```bash
git cherry-pick {fixes_commit_hash}
git push fork
```

И создайте Pull Request из вашей ветки с патчем в стабильную ветку. Это делается аналогично открытию PR в ветку `main`, но необходимо убедиться что в качестве target выбрана нужная стабильная ветка.

Если вы используете GitHub CLI, target ветка указывается в опции `-B`:

```bash
gh pr create --title "Title" -B stable-24-1
```
