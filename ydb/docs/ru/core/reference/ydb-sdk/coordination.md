==Работа с сервисом координации YDB

В этой статье приведены примеры использования YDB SDK для работы с сервисом координации YDB, который можно использовать для решения типовых задач координации в кластере, например, выбора для лидера или обработки задач с помощью пула воркеров. Во внешнем мире такие задачи, как правило, решают с помощью [ZooKeeper](https://zookeeper.apache.org/), [Consul](https://www.consul.io/), [etcd](https://etcd.io/) и им подобным.

===Как воспользоваться

Сервис координации предоставляет концепцию распределенных семафоров, аналогов обычных [семафоров](https://en.wikipedia.org/wiki/Semaphore_(programming)), только захватывать и отпускать их можно не в рамках одной машины, а в кластере. Чтобы создать такой семафор, сначала нужно завести в базе узел координации (Coordination Node, аналог таблицы), в которой мы и будем создавать семафоры.

{% list tabs %}

- Go

   ```(go)
   err := db.Coordination().CreateNode(
       ctx,
       "/local/myCoordinationNode", // имя Coordination Node в базе
   )
   ```

{% endlist %}

Для начала работы клиент должен установить сессию, в рамках которой он и будет осуществлять все операции с семафорами внутри Coordination Node.

{% list tabs %}

- Go

   ```(go)
   session, err := db.Coordination().CreateSession(
       ctx,
       "/local/myCoordinationNode", // имя Coordination Node в базе 
   )
   ```

{% endlist %}

Сессия — самый важный объект для клиента, только пока она жива, клиент может рассчитывать на состояние семафоров, которые он захватил. Когда сессия заканчивается (по инициативе клиента или сервера, например, при обрыве связи и невозможности восстановить соединение с сервисом), клиент больше не может рассчитывать на то, что другие клиенты в кластере не захватили его семафоры и не поменяли их состояние:

{% list tabs %}

- Go

  В Go SDK для отслеживания таких ситуаций используется контекст сессии `session.Context()`, который завершается вместе с сессией. При этом SDK умеет самостоятельно обрабатывать ошибки транспортного уровня и переустанавливать соединение с сервисом, пытаясь восстановить сессию, если это ещё возможно. Таким образом, клиенту достаточно следить только за контекстом сессии, чтобы вовремя отреагировать на её потерю.

{% endlist %}

Как и в других подобных сервисах, семафоры могут быть персистентными и эфемерными. Персистентный семафор перед захватом необходимо создать, он будет существовать до момента его удаления (или удаления Coordination Node, в которой он был создан). Эфемерные семафоры создаются в момент их захвата, что удобно использовать, например, в сценариях распределенной блокировки.

При создании семафору можно указать его лимит, т.е. на какое максимальное значение его можно увеличить, прежде чем последующие вызовы, пытающиеся увеличить значение семафора выше этого лимита, начнут ждать, пока их запросы на увеличение смогут быть выполнены, так чтобы значение семафора не превышало его лимит.

{% list tabs %}

- Go

   ```(go)
   err := session.CreateSemaphore(ctx,
       "mySemaphore", // имя семафора
       10,            // лимит семафора
   )
   ```

{% endlist %}

Лимит эфемерных семафоров автоматически устанавливается равным %%MaxSemaphoreLimit%%.

Чтобы захватить семафор, клиент должен вызвать метод `AcquireSemaphore` и дождаться получения специального объекта `Lease`,  который по сути представляет из себя подтверждение сервиса о том, что значение семафора было успешно увеличено и может считаться таковым до явного отпускания такого семафора или завершения сессии, в которой такое подтверждение было получено. Как и в случае с сессией, у объекта `Lease` тоже есть контекст, который завершается в один из таких моментов.

{% list tabs %}

- Go

   ```(go)
   lease, err := session.AcquireSemaphore(ctx, "mySemaphore", 5);
   ```

{% endlist %}

Для отмены ожидания взятия семафора, достаточно отменить переданный в метод контекст %%ctx%%.

Чтобы отпустить захваченный в сессии семафор, у объекта %%Lease%% надо вызвать метод %%Release%%.

{% list tabs %}

- Go

   ```(go)
   err := lease.Release()
   ```

{% endlist %}

Взятое значение захваченного семафора можно снизить (но не увеличить), вновь вызвав для него метод %%AcquireSemaphore%% с меньшим %%count%%.

===Распределенная “блокировка”

Рассмотрим сценарий, где нам необходимо гарантировать, чтобы с разделяемым ресурсом в один момент времени работала только одна машина в кластере.

Важно понимать, что такие гарантии весьма условны. [Как и в других подобных сервисах](https://etcd.io/docs/v3.5/learning/why/#notes-on-the-usage-of-lock-and-lease), клиенты не захватывают блокировки или семафоры, как это происходит с локальными локами и семафорами, а получают его в аренду на определённое время, которую можно периодически продлевать. Полагаясь на физическое время (которое, как известно, может различаться на разных машинах), клиенты и сервер могут оказаться в ситуации, когда в один момент времени несколько клиентов считают, что их сессии захватили один и тот же семафор, несмотря на то что с точки зрения сервера это не так.

Таким образом, реализация распределенной блокировки через такие механизмы не может дать гарантию отсутствия одновременного доступа к ресурсу, но может значительно снизить вероятность такого события, а, значит, может быть использована как оптимизация, для того чтобы клиенты не дрались друг с другом за общий ресурс, когда это не имеет смысла. Гарантии же на отсутствие конкурентных запросов к ресурсу могут быть реализованы на самом ресурсе, например с помощью оптимистической блокировки.

Псевдокод такого сценария может выглядеть так:

{% list tabs %}

- Go

   ```(go)
   for {
     if session, err := db.Coordination().CreateSession(ctx, path); err != nil {
       return fmt.Errorf("cannot create session: %v", err);
     }
  
     if lease, err := session.AcquireSemaphore(ctx, 
       semaphore, 
       coordination.Exclusive, 
       options.WithEphemeral(true),
     ); err != nil {
       // обычно это происходит, если сессия была потеряна, поэтому пытаемся установить новую и получить лок в ней
       session.Close(ctx);
       continue;
     }

     // лок получен, можно запускать обработку
     select {
     case <-lease.Context().Done():
     }

     // лок отпущен, нужно завершать обработку
   }
   ```

{% endlist %}
