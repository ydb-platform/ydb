# Аутентификация

После успешной установки сетевого соединения сервер принимает к обработке запросы от клиента, в которых передается аутентификационная информация. На ее основании сервер определяет учетную запись (аккаунт) клиента и проверяет доступ на выполнение запроса.

{% note info %}

Под клиентом аутентификации понимается SDK или CLI.

{% endnote %}

Поддерживаются следующие режимы аутентификации:

* Анонимная аутентификация — включена по умолчанию и доступна сразу после [установки кластера](../devops/index.md).
* [Аутентификация с использованием стороннего IAM-провайдера](#iam), например [Yandex Identity and Access Management]{% if lang == "en" %}(https://cloud.yandex.com/en/docs/iam/){% endif %}{% if lang == "ru" %}(https://cloud.yandex.ru/docs/iam/){% endif %}.
* Аутентификация по [логину и паролю](#static-credentials).
* Аутентификация с использованием [LDAP каталога](#ldap-auth-provider).

## Анонимная аутентификация

В данном режиме допускается логин без указания пользователя или токена. В этом случае также не производится [авторизация](authorization.md) (проверка прав).

Но если будет указан пользователь или токен, то будет работать соответствующий режим аутентификации с последующей авторизацией.

{% note warning %}

Использовать анонимную аутентификацию следует только в ознакомительных целях для внутренних локальных баз данных, не имеющих доступа по сети.

{% endnote %}

Чтобы включить анонимную аутентификацию, необходимо указать значение `false` для ключа `enforce_user_token_requirement` в [конфигурационном файле](../reference/configuration/index.md#auth) кластера.

## Аутентификация с использованием стороннего IAM-провайдера {#iam}

* **Access Token** — параметром для клиента (SDK или CLI) задается фиксированный токен, который передается в запросы.
* **Refresh Token** — параметром для клиента (SDK или CLI) задается [OAuth токен](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/) персональной учетной записи, на основании которого клиент периодически в фоновом режиме обращается к IAM API для ротации (получения следующего) токена, передаваемого в запросы.
* **Service Account Key** — параметром для клиента (SDK или CLI) задаются атрибуты сервисной учетной записи и ключ для подписи, на основании которых клиент периодически в фоновом режиме обращается к IAM API для ротации (получения следующего) токена, передаваемого в запросы.
* **Metadata** — клиент (SDK или CLI) периодически обращается к локальному сервису для ротации (получения следующего) токена, передаваемого в запросы.
* **OAuth 2.0 token exchange** - клиент (SDK или CLI) обменивает токен другого типа на access token по [протоколу обмена токенов OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8693), который затем передаётся в запросы {{ ydb-short-name }} API.

Любой обладатель валидного токена может получить доступ на выполнение операций, поэтому главная задача системы безопасности — обеспечение секретности токена и предотвращение его компрометации.

Режимы аутентификации с ротацией токена **Refresh Token** и **Service Account Key** обеспечивают больший уровень безопасности по сравнению с режимом с фиксированным токеном **Access Token**, так как на сервер {{ ydb-short-name }} по сети передаются только короткоживущие секреты.

Максимальная безопасность и производительность обеспечивается при использовании режима **Metadata**, так как он исключает необходимость работы с секретами при развертывании приложения, а также позволяет обратиться к IAM и закешировать токен заранее, до запуска приложения.

При выборе режима аутентификации среди поддерживаемых сервером и окружением, следует руководствоваться следующими рекомендациями:

* **Anonymous** обычно применяется на самостоятельно разворачиваемых локальных кластерах {{ ydb-short-name }}, недоступных по сети.
* **Access Token** применяется при отсутствии поддержки других режимов на стороне сервера или в настроечных/отладочных целях. Он не требует взаимодействий клиента с IAM. Однако, если IAM поддерживает API для ротации токенов, то обычно выдаваемые таким IAM фиксированные токены имеют короткий срок жизни, что вынуждает регулярно обновлять их в IAM вручную заново.
* **Refresh Token** может применяться при выполнении разовых ручных операций под персональной учетной записью, например, связанных с обслуживанием данных в БД, выполнением ad-hoc операций в CLI, или запусками приложений с рабочей станции. Такой токен можно получить вручную в IAM один раз на долгий срок и сохранить в переменной окружения на личной рабочей станции для автоматического применения при запуске CLI без дополнительных параметров аутентификации.
* **Service Account Key** применяется в первую очередь для приложений, рассчитанных на эксплуатацию в окружениях, где поддерживается режим **Metadata**, при их тестировании вне таких окружений (например, на рабочей станции). Также он может применяться для приложений вне таких окружений, работая как аналог **Refresh Token** для сервисных учетных записей. В отличие от персональной учетной записи, объекты доступа и роли сервисной учетной записи могут быть ограничены.
* **Metadata** применяется при разворачивании приложений в облаках. В настоящее время этот режим поддерживается на виртуальных машинах и в {{ sf-name }} {{ yandex-cloud }}.

Токен для указания в параметрах может быть получен в системе IAM, с которой связана конкретная установка {{ ydb-short-name }}. В частности, для сервиса {{ ydb-short-name }} в {{ yandex-cloud }} применяется Yandex.Passport OAuth и сервисные аккаунты {{ yandex-cloud }}. При использовании {{ ydb-short-name }} в корпоративных контекстах могут применяться стандартные для данной организации системы централизованной аутентификации.

При использовании режимов, предусматривающих обращение клиента {{ ydb-short-name }} к IAM, дополнительно может быть задан URL IAM, предоставляющий API выдачи токенов. По умолчанию в существующих SDK и CLI производится попытка обращения к API IAM {{ yandex-cloud }}, размещенному на `iam.api.cloud.yandex.net:443`.

## Аутентификация по логину и паролю {#static-credentials}

Данный вид доступа подразумевает наличие у каждого пользователя базы данных логина и пароля.
Логин пользователя может содержать только строчные буквы латинского алфавита и цифры.
Допускается использование пустого пароля.

Логин пользователя и хеш пароля хранятся в таблице внутри компонента аутентификации. Пароль хеширован методом [Argon2]{% if lang == "en" %}(https://en.wikipedia.org/wiki/Argon2){% endif %}{% if lang == "ru" %}(https://ru.wikipedia.org/wiki/Argon2){% endif %}. В режиме аутентификации по логину и паролю доступ к таблице имеет только администратор системы.

В ответ на логин и пароль возвращается токен. Время жизни токена по умолчанию 12 часов. Для ротации токенов клиент, например, SDK, самостоятельно обращается к сервису аутентификации. Использование токена ускоряет процесс аутентификации и повышает безопасность.

Процесс аутентификации по логину и паролю включает следующие шаги:

1. Клиент обращается к БД и передает логин и пароль пользователя сервису аутентификации {{ ydb-short-name }}.
1. Сервис аутентификации передает аутентификационные данные в компонент аутентификации {{ ydb-short-name }}.
1. Компонент проверяет аутентификационные данные, при успешном сопоставлении создает токен и возвращает его сервису аутентификации.
1. Сервис аутентификации возвращает токен клиенту.
1. Клиент обращается к БД, передавая в качестве аутентификационной информации токен.

Для включения аутентификации по логину и паролю укажите значение `true` для ключа `enforce_user_token_requirement` в [конфигурационном файле](../reference/configuration/index.md#auth) кластера.

Об управлении ролями и пользователями читайте в [{#T}](../security/authorization.md).

## Взаимодействие с LDAP каталогом {#ldap-auth-provider}

В {{ ydb-short-name }} интегрировано взаимодействие с [LDAP каталогом](https://ru.wikipedia.org/wiki/LDAP). LDAP каталог является внешним по отношению к {{ ydb-short-name }} сервисом и используется для аутентификации и авторизации пользователей базы данных. Прежде чем воспользоваться данным способом аутентификации и авторизации необходимо иметь развернутый LDAP сервис и настроенный сетевой доступ между ним и серверами {{ ydb-short-name }}.

Примеры поддерживаемых реализаций LDAP каталогов: [OpenLdap](https://openldap.org/), [Active Directory](https://azure.microsoft.com/en-us/products/active-directory/).

### Аутентификация

Аутентификация с помощью LDAP протокола похожа на процесс аутентификации по логину и паролю. Отличие заключается лишь в том, что роль компонента аутентификации играет LDAP каталог. LDAP каталог используется только для проверки пары логин/пароль.

{% note info %}

Так как LDAP каталог является внешним независимым сервисом, {{ ydb-short-name }} не имеет возможности управлять учетными записями пользователей в каталоге. Для успешной аутентификации пользователь уже должен быть создан в LDAP каталоге. Использование команд `CREATE USER`, `CREATE GROUP`, `ALTER USER`, `ALTER GROUP`, `DROP USER`, `DROP GROUP` не окажет влияния на список пользователей и групп в каталоге. Информацию об управлении учетными записями необходимо искать в документации используемого LDAP каталога.

{% endnote %}

На данный момент {{ ydb-short-name }} поддерживает только один способ LDAP аутентификации, так называемый search+bind метод, состоящий из нескольких шагов. После получения логина и пароля пользователя, которого нужно аутентифицировать, выполняется операция *bind* с заранее определенными в секции [ldap_authentication](../reference/configuration/index.md#ldap-auth-config) учетными данными специального сервисного аккаунта. Учетные данные такого сервисного аккаунта задаются через параметры конфигурации **bind_dn** и **bind_password**. После успешной аутентификации сервисного пользователя от его имени выполняется поиск в LDAP каталоге пользователя, который пытается аутентифицироваться в системе. Операция *search* выполняется для всего поддерева, корень которого берется из параметра конфигурации **base_dn**. Поиск записи в поддереве осуществляется в соответствии с фильтром, задаваемым в параметре конфигурации **search_filter**. После того как запись пользователя была найдена, {{ ydb-short-name }} выполняет повторную операцию *bind* от лица этого найденного пользователя, используя ранее запрошенный пароль. Успех аутентификации пользователя определяется результатом повторной операции *bind*.

После успешной аутентификации пользователя формируется токен. Далее этот токен используется вместо логина и пароля. Оперирование токеном ускоряет процесс аутентификации и повышает безопасность.

{% note info %}

При использовании LDAP-аутентификации, никакие пароли пользователей в {{ ydb-short-name }} не хранятся.

{% endnote %}

### Проверка токена

После аутентификации пользователя в системе, формируется токен, который проверяется перед выполнением запрошенной операции. В процессе проверки токена определяется, от имени какого пользователя запрашивается действие в системе и в каких группах он состоит. Для пользователей из LDAP каталога токен не содержит информацию о группах, поэтому, после проверки токена, выполняется еще один запрос к LDAP серверу для получения списка групп, в которых состоит пользователь.

Группы, как и сам пользователь, являются субъектами выполнения операций над объектами схемы базы данных. Для разграничения доступа к различным ресурсам базы данных субъектам могут назначаться права доступа. И в соответствии со списком назначенных прав субъекты будут авторизованы на выполнение тех или иных операций.

Процесс получения списка групп пользователя из LDAP каталога похож на те действия, которые выполняются при аутентификации. Сначала выполняется операция *bind* для сервисного пользователя, учетные данные которого записаны в параметрах **bind_dn** и **bind_password** секции [ldap_authentication](../reference/configuration/index.md#ldap-auth-config) файла конфигурации. После успешной аутентификации выполняется поиск записи пользователя, для которого был ранее сформирован токен. Поиск также выполняется в соответствии с параметром **search_filter**. Если пользователь всё ещё существует, то в качестве возвращаемого результата операции *search* будет список значений атрибута, записанного в параметре **requested_group_attribute**. В случае, если этот параметр пуст, то аттрибутом обратного членства в группе будет являться *memberOf*. Атрибут *memberOf* хранит уникальные имена (Distinguished Name, DN) групп, в которых состоит пользователь.

#### Получение групп

По умолчанию {{ ydb-short-name }} выполняет поиск только тех групп, в которых пользователь состоит непосредственно. С помощью включения флага **extended_settings.enable_nested_groups_search** секции [ldap_authentication](../reference/configuration/index.md#ldap-auth-config) {{ ydb-short-name }} будет пытаться получить группы на всех уровнях вложенности, а не только те, в которые пользователь входит напрямую. Если {{ ydb-short-name }} настроен для работы с Active Directory, для поиска всех вложенных групп будет использовано специфичное для Active Directory правило соответствия [LDAP_MATCHING_RULE_IN_CHAIN](https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax?redirectedfrom=MSDN). Это правило позволяет получить все вложенные группы одним запросом. Для LDAP-серверов на основе OpenLDAP поиск групп будет выполнен рекурсивным обходом графа, что в общем случае требует выполнения нескольких запросов. Как для Active Directory, так и для OpenLDAP поиск групп будет выполнен только для поддерева, корень которого берётся из параметра конфигурации **base_dn**.

{% note info %}

В текущей реализации имена групп, которыми будет оперировать {{ ydb-short-name }}, совпадают с теми значениями, которые записаны в атрибуте *memberOf*. Они могут иметь большую длину и быть сложночитаемыми.

Пример:

```text
cn=Developers,ou=Groups,dc=mycompany,dc=net@ldap
```

{% endnote %}

{% note info %}

В секции конфигурационного файла, описывающего аутентификационную информацию, можно настроить частоту обновления информации о пользователе и его группах. Этот показатель регулируется параметром **refresh_time**. Подробную информацию о файлах конфигурации можно узнать в разделе о [конфигурировании кластера](../reference/configuration/index.md#auth-config).

{% endnote %}

{% note warning %}

Нужно заметить, что на данный момент {{ ydb-short-name }} не имеет возможности отслеживать переименования групп, сделанные на стороне LDAP сервера. Тем самым, группа с новым именем не будет обладать теми же правами, которые были у группы с прежним именем.

{% endnote %}

### LDAP пользователи и группы в {{ ydb-short-name }}

Так как {{ ydb-short-name }} позволяет использовать различные способы аутентификации пользователя (аутентификация по логину и паролю, использование IAM провайдера, LDAP каталог), то, оперируя именами пользователей и групп, часто бывает полезно различать, где именно аутентифицировался пользователь. Для всех видов аутентификации, кроме аутентификации по логину и паролю, имена групп и пользователей дополняются суффиксом вида `<имя_пользователя>@<domain>`.

Для LDAP пользователей *domain* задается в [параметре конфигурации](../reference/configuration/index.md#ldap-auth-config) **ldap_authentication_domain**. По умолчанию имеет значение `ldap`, поэтому все имена пользователей, аутентифицированных с помощью LDAP каталога, и имена групп, в которых они состоят, в {{ ydb-short-name }} будут иметь следующий вид:

- `user1@ldap`
- `group1@ldap`
- `group2@ldap`

{% note warning %}

Чтобы различать, что введенный логин должен быть логином пользователя из LDAP каталога, а не логином для аутентификации по логину и паролю, к нему нужно добавлять суффикс домена LDAP-аутентификации. Суффикс задается через параметр конфигурации **ldap_authentication_domain**.

Ниже приведены примеры аутентификации пользователя `user1` используя [{{ ydb-short-name }} CLI](../reference/ydb-cli/index.md):

* Аутентификация пользователя из LDAP каталога: `ydb --user user1@ldap -p ydb_profile scheme ls`
* Аутентификация пользователя внутренним механизмом {{ ydb-short-name }}: `ydb --user user1 -p ydb_profile scheme ls`

{% endnote %}

### TLS соединение {#ldap-tls}

В зависимости от указанных параметров конфигурации {{ ydb-short-name }} может устанавливать либо зашифрованное либо незашифрованное соединение. Зашифрованное соединение с LDAP сервером устанавливается с использованием протокола TLS. Такой способ рекомендуется использовать для production кластеров. Существует два способа включить TLS соединение:

* Автоматически. Используется схема соединения [`ldaps`](#ldaps)
* Использование расширения LDAP протокола [`StartTls`](#starttls)

При использовании незашифрованного соединения, все данные, которые передаются в запросах к LDAP серверу, будут передаваться в открытом виде, в том числе и пароли. Таким способом соединения проще начать пользоваться, он больше подходит для экспериментов или тестирования.

#### LDAPS

Для того чтобы {{ ydb-short-name }} автоматически установила зашифрованное соединение с LDAP-сервером, необходимо в [параметре конфигурации](../reference/configuration/index.md#ldap-auth-config) **scheme** установить значение `ldaps`. TLS-диалог будет инициирован на порту, указанном в конфигурации. Если порт не указан, для схемы `ldaps` будет применён порт по умолчанию 636. LDAP-сервер должен быть настроен на приём TLS-соединений на указанных портах.

#### Расширение LDAP протокола `StartTls` {#starttls}

`StartTls` — это расширение протокола LDAP, используемое для шифрования сообщений по протоколу TLS. Оно позволяет передавать в рамках одного соединения с LDAP-сервером одни сообщения в зашифрованном виде, а другие — открыто. Сообщение с этим расширением отправляется от {{ ydb-short-name }} к LDAP-серверу для инициирования TLS-соединения. В случае {{ ydb-short-name }} не предусмотрено включение и выключение TLS-соединения в рамках одного соединения. Поэтому при использовании расширения `StartTls` после установления зашифрованного соединения {{ ydb-short-name }} будет отправлять все дальнейшие сообщения к LDAP-серверу в зашифрованном виде. Одним из преимуществ использования данного расширения вместо схемы `ldaps` (при соответствующей настройке LDAP-сервера) является возможность установить TLS-соединение на нешифрованном порту. Расширение включается в [секции `use_tls`](../reference/configuration/index.md#ldap-auth-config) файла конфигурации.
