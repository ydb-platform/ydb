# Аутентификация

После успешной установки сетевого соединения сервер принимает к обработке запросы от клиента, в которых передается аутентификационная информация в виде [аутентификационного токена](../concepts/glossary.md#auth-token). На ее основании сервер определяет [SID](../concepts/glossary.md#access-sid) клиента и проверяет его доступы на выполнение запроса.

{% note info %}

Под клиентом аутентификации понимается пользователь, проходящий процедуру проверки подлинности при доступе к {{ ydb-short-name }}. Примерами клиентов являются приложения, использующие [SDK](../reference/ydb-sdk/index.md) или [CLI](../reference/ydb-cli/index.md).

{% endnote %}

Поддерживаются следующие виды аутентификации:

* [Анонимная](#anonymous) аутентификация.
* Аутентификация по [логину и паролю](#static-credentials).
* Аутентификация с использованием [LDAP-каталога](#ldap).
* [Аутентификация с использованием стороннего IAM-провайдера](#iam), например [Yandex Identity and Access Management](https://yandex.cloud/ru/docs/iam/).

## Анонимная аутентификация {#anonymous}

По умолчанию, {{ ydb-short-name }} допускает выполнение запросов без указания аутентификационных данных, таких как имя пользователя или [токен](../concepts/glossary.md#auth-token). Проверка прав доступа ([авторизация](authorization.md)) при этом также не проводится.

{% note warning %}

Использовать анонимную аутентификацию следует только в ознакомительных целях для локальных баз данных, не имеющих доступа по сети.

{% endnote %}

За выключение режима анонимной аутентификации отвечает флаг `enforce_user_token_requirement` в [настройках режима аутентификации](../reference/configuration/index.md#security-auth) {{ ydb-short-name }}.

В зависимости от настроек режима аутентификации, реальная аутентификация может быть не анонимной:

- Отсутствующий в запросах токен может подменяться на токен по умолчанию
- Явно указанный в запросах токен может проверяться по надлежащим правилам

Тогда запросы будут выполняться не анонимно, и будет также выполняться проверка прав.

В зависимости от [настроек уровней доступа](../reference/configuration/index.md#security-access-levels), анонимные запросы могут в том числе выполнять в системе действия, требующие административного уровня доступа.

## Аутентификация по логину и паролю {#static-credentials}

Аутентификация по логину и паролю через сервер {{ ydb-short-name }} доступна только для [локальных пользователей](../concepts/glossary.md#access-user). В аутентификации внешних пользователей участвуют сервера внешних систем.

Данный вид доступа подразумевает наличие у каждого пользователя базы данных логина и пароля.
Логин пользователя может содержать только строчные буквы латинского алфавита, цифры и символ `@`.
Допускается установление различных [критериев](#password-complexity) на сложность пароля.

Логин пользователя и хеш пароля хранятся в таблице внутри компонента аутентификации. Пароль хеширован методом [Argon2](https://ru.wikipedia.org/wiki/Argon2). Доступ к этой таблице имеет только администратор системы.

В ответ на логин и пароль возвращается [аутентификационный токен](../concepts/glossary.md#auth-token). Время жизни токена по умолчанию составляет 12 часов. Для ротации токенов клиент, например, [SDK](../reference/ydb-sdk/index.md), самостоятельно обращается к сервису аутентификации. Использование токена ускоряет процесс аутентификации и повышает безопасность.

Процесс аутентификации по логину и паролю включает следующие шаги:

1. Клиент обращается к базе данных и передаёт логин и пароль пользователя сервису аутентификации {{ ydb-short-name }}.
1. Сервис проверяет аутентификационные данные, при успешном сопоставлении создаёт токен и возвращает его клиенту.
1. Клиент обращается к БД, передавая в качестве аутентификационной информации токен.

Для включения аутентификации по логину и паролю, необходимо убедиться, что параметры `use_login_provider` и `enable_login_authentication` выставлены в значение по умолчанию `true` в [конфигурации](../reference/configuration/auth_config.md). Кроме того, чтобы отключить анонимную аутентификацию, необходимо выставить значение параметра [`enforce_user_token_requirement` в `true`](../reference/configuration/security_config.md).

Об управлении ролями и пользователями читайте в [{#T}](../security/authorization.md).

### Сложность пароля {#password-complexity}

{{ ydb-short-name }} позволяет настраивать требования к сложности паролей. Если пароль, предоставляемый через команды `CREATE USER` или `ALTER USER`, не соответствует критериям сложности, выполнение команды завершится ошибкой.
По умолчанию на пароли не накладываются никакие ограничения: принимается пароль любой длины, включая пустую строку; в пароле могут присутствовать произвольное количество цифр и букв в любом регистре, а также специальные символы из списка `!@#$%^&*()_+{}|<>?=`. Чтобы задать ограничения на сложность пароля, необходимо заполнить секцию `password_complexity` в [конфигурации](../reference/configuration/auth_config.md#password-complexity).


### Принудительная блокировка/разблокировка пользователя

Существует ещё один способ запретить пользователю выполнять аутентификацию — принудительная блокировка администратором кластера или базы данных. Администраторы могут снимать блокировку как с пользователей, заблокированных принудительно, так и с пользователей, оказавшихся заблокированными из-за превышения лимита на количество попыток ввода неправильного пароля. Подробную информацию о принудительной блокировке и разблокировке пользователей можно найти в описании команды [`ALTER USER LOGIN/NOLOGIN`](../yql/reference/syntax/alter-user.md).

### Защита от перебора пароля

{{ ydb-short-name }} предоставляет защиту от перебора пароля пользователем. Пользователь будет считаться заблокированным, если превысит число попыток ввода неправильного пароля. По истечении указанного времени он снова получит возможность аутентифицироваться.

{% note info %}

Данный механизм применим только для пользователей, которые обслуживаются самой {{ ydb-short-name }}, для, так называемых, встроенных пользователей. Пользователи, обслуживаемые внешними источниками аутентификации, такими как LDAP серверы, не подпадают под действие механизма защиты от перебора пароля.

{% endnote %}

По умолчанию пользователю даётся 4 попытки ввести правильный пароль. В противном случае аутентификация для него будет запрещена в течение одного часа. Настроить критерии блокировки пользователя можно в [конфигурации](../reference/configuration/index.md#account-lockout).

При необходимости администратор кластера или базы данных может досрочно [разблокировать](../yql/reference/syntax/alter-user.md) пользователя.

Информацию о статусе блокировки пользователя и количества попыток неправильного ввода пароля можно узнать из [системного представления](../dev/system-views.md#информация-о-пользователях-users) пользователя.


## Аутентификация с использованием LDAP-каталога {#ldap}

В {{ ydb-short-name }} интегрировано взаимодействие с [LDAP каталогом](https://ru.wikipedia.org/wiki/LDAP). LDAP каталог является внешним по отношению к {{ ydb-short-name }} сервисом и используется для аутентификации и авторизации пользователей базы данных. Прежде чем воспользоваться данным способом аутентификации и авторизации необходимо иметь развернутый LDAP сервис и настроенный сетевой доступ между ним и серверами {{ ydb-short-name }}.

Примеры поддерживаемых реализаций LDAP каталогов: [OpenLdap](https://openldap.org/), [Active Directory](https://azure.microsoft.com/en-us/products/active-directory/).

### Аутентификация

Аутентификация с помощью LDAP протокола похожа на процесс аутентификации по логину и паролю. Отличие заключается лишь в том, что роль компонента аутентификации играет LDAP каталог. LDAP каталог используется для проверки пары логин/пароль и для определения групп, к которым принадлежит пользователь.

{% note info %}

Так как LDAP каталог является внешним независимым сервисом, {{ ydb-short-name }} не имеет возможности управлять учетными записями пользователей в каталоге. Для успешной аутентификации пользователь уже должен быть создан в LDAP каталоге. Использование команд `CREATE USER`, `CREATE GROUP`, `ALTER USER`, `ALTER GROUP`, `DROP USER`, `DROP GROUP` не окажет влияния на список пользователей и групп в каталоге. Информацию об управлении учетными записями необходимо искать в документации используемого LDAP каталога.

{% endnote %}

На данный момент {{ ydb-short-name }} поддерживает только один способ LDAP аутентификации, так называемый *search+bind* метод, состоящий из нескольких шагов. После получения логина и пароля пользователя, которого нужно аутентифицировать, выполняется операция *bind* с заранее определенными в секции [ldap_authentication](../reference/configuration/index.md#ldap-auth-config) учетными данными специального сервисного аккаунта. Учетные данные такого сервисного аккаунта задаются через параметры конфигурации `bind_dn` и `bind_password`. После успешной аутентификации сервисного пользователя от его имени выполняется поиск в LDAP каталоге пользователя, который пытается аутентифицироваться в системе. Операция *search* выполняется для всего поддерева, корень которого берется из параметра конфигурации `base_dn`. Поиск записи в поддереве осуществляется в соответствии с фильтром, задаваемым в параметре конфигурации `search_filter`. После того как запись пользователя была найдена, {{ ydb-short-name }} выполняет повторную операцию *bind* от лица этого найденного пользователя, используя ранее запрошенный пароль. Успех аутентификации пользователя определяется результатом повторной операции *bind*.

В результате успешной проверки логина и пароля пользователя в LDAP каталоге возвращается [аутентификационный токен](../concepts/glossary.md#auth-token) {{ ydb-short-name }}. Далее этот токен используется вместо логина и пароля. Оперирование токеном ускоряет процесс аутентификации и повышает безопасность.

{% note info %}

При использовании LDAP-аутентификации, никакие пароли пользователей в {{ ydb-short-name }} не хранятся.

{% endnote %}

### Проверка токена

После аутентификации пользователя в системе, формируется токен, который проверяется перед выполнением запрошенной операции. В процессе проверки токена определяется, от имени какого пользователя запрашивается действие в системе и в каких группах он состоит. Для пользователей из LDAP каталога токен не содержит информацию о группах, поэтому, после проверки токена, выполняется еще один запрос к LDAP серверу для получения списка групп, в которых состоит пользователь.

Группы, как и сам пользователь, являются субъектами выполнения операций над объектами схемы базы данных. Для разграничения доступа к различным ресурсам базы данных субъектам могут назначаться права доступа. И в соответствии со списком назначенных прав субъекты будут авторизованы на выполнение тех или иных операций.

Процесс получения списка групп пользователя из LDAP каталога похож на те действия, которые выполняются при аутентификации. Сначала выполняется операция *bind* для сервисного пользователя, учетные данные которого записаны в параметрах `bind_dn` и `bind_password` секции [ldap_authentication](../reference/configuration/index.md#ldap-auth-config) файла конфигурации. После успешной аутентификации выполняется поиск записи пользователя, для которого был ранее сформирован токен. Поиск также выполняется в соответствии с параметром `search_filter`. Если пользователь всё ещё существует, то в качестве возвращаемого результата операции *search* будет список значений атрибута, записанного в параметре `requested_group_attribute`. В случае, если этот параметр пуст, то аттрибутом обратного членства в группе будет являться `memberOf`. Атрибут `memberOf` хранит уникальные имена (Distinguished Name, DN) групп, в которых состоит пользователь.

#### Получение групп

По умолчанию {{ ydb-short-name }} выполняет поиск только тех групп, в которых пользователь состоит непосредственно. С помощью включения флага `extended_settings.enable_nested_groups_search` секции [ldap_authentication](../reference/configuration/index.md#ldap-auth-config) {{ ydb-short-name }} будет пытаться получить группы на всех уровнях вложенности, а не только те, в которые пользователь входит напрямую. Если {{ ydb-short-name }} настроен для работы с Active Directory, для поиска всех вложенных групп будет использовано специфичное для Active Directory правило соответствия [LDAP_MATCHING_RULE_IN_CHAIN](https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax?redirectedfrom=MSDN). Это правило позволяет получить все вложенные группы одним запросом. Для LDAP-серверов на основе OpenLDAP поиск групп будет выполнен рекурсивным обходом графа, что в общем случае требует выполнения нескольких запросов. Как для Active Directory, так и для OpenLDAP поиск групп будет выполнен только для поддерева, корень которого берётся из параметра конфигурации `base_dn`.

{% note info %}

В текущей реализации имена групп, которыми будет оперировать {{ ydb-short-name }}, совпадают с теми значениями, которые записаны в атрибуте `memberOf`. Они могут иметь большую длину и быть сложночитаемыми.

Пример:

```text
cn=Developers,ou=Groups,dc=mycompany,dc=net@ldap
```

{% endnote %}

{% note info %}

В секции конфигурационного файла, описывающего аутентификационную информацию, можно настроить частоту обновления информации о пользователе и его группах. Этот показатель регулируется параметром `refresh_time`. Подробную информацию о файлах конфигурации можно узнать в разделе о [конфигурировании кластера](../reference/configuration/index.md#auth-config).

{% endnote %}

{% note warning %}

Нужно заметить, что на данный момент {{ ydb-short-name }} не имеет возможности отслеживать переименования групп, сделанные на стороне LDAP сервера. Тем самым, группа с новым именем не будет обладать теми же правами, которые были у группы с прежним именем.

{% endnote %}

### LDAP-пользователи и LDAP-группы в {{ ydb-short-name }}

Так как {{ ydb-short-name }} позволяет использовать разные способы аутентификации пользователя, то, оперируя именами пользователей и групп, часто бывает полезно различать, где именно аутентифицировался пользователь. Для всех видов аутентификации, кроме аутентификации по логину и паролю, имена групп и пользователей дополняются суффиксом вида `@<auth-domain>`.

Для LDAP пользователей *auth-domain* задается в [параметре конфигурации](../reference/configuration/index.md#ldap-auth-config) `ldap_authentication_domain`. По умолчанию имеет значение `ldap`, поэтому все имена пользователей, аутентифицированных с помощью LDAP каталога, и имена групп, в которых они состоят, в {{ ydb-short-name }} будут иметь следующий вид:

- `user1@ldap`
- `group1@ldap`
- `group2@ldap`

{% note warning %}

Чтобы различать, что введенный логин должен быть логином пользователя из LDAP каталога, а не логином локального пользователя {{ ydb-short-name }}, к нему нужно добавлять суффикс `@ldap`.

Ниже приведены примеры аутентификации пользователя `user1` используя [{{ ydb-short-name }} CLI](../reference/ydb-cli/index.md):

* Аутентификация пользователя из LDAP каталога: `ydb --user user1@ldap -p ydb_profile scheme ls`
* Аутентификация пользователя внутренним механизмом {{ ydb-short-name }}: `ydb --user user1 -p ydb_profile scheme ls`

{% endnote %}

### TLS соединение {#ldap-tls}

В зависимости от указанных параметров конфигурации {{ ydb-short-name }} может устанавливать либо зашифрованное либо незашифрованное соединение. Зашифрованное соединение с LDAP сервером устанавливается с использованием протокола TLS. Такой способ рекомендуется использовать для production кластеров. Существует два способа включить TLS соединение:

* Автоматически. Используется схема соединения [`ldaps`](#ldaps)
* Использование расширения LDAP протокола [`StartTls`](#starttls)

При использовании незашифрованного соединения, все данные, которые передаются в запросах к LDAP серверу, будут передаваться в открытом виде, в том числе и пароли. Таким способом соединения проще начать пользоваться, он больше подходит для экспериментов или тестирования.

#### LDAPS

Для того чтобы {{ ydb-short-name }} автоматически установила зашифрованное соединение с LDAP-сервером, необходимо в [параметре конфигурации](../reference/configuration/index.md#ldap-auth-config) **scheme** установить значение `ldaps`. TLS-диалог будет инициирован на порту, указанном в конфигурации. Если порт не указан, для схемы `ldaps` будет применён порт по умолчанию 636. LDAP-сервер должен быть настроен на приём TLS-соединений на указанных портах.

#### Расширение LDAP протокола `StartTls` {#starttls}

`StartTls` — это расширение протокола LDAP, используемое для шифрования сообщений по протоколу TLS. Оно позволяет передавать в рамках одного соединения с LDAP-сервером одни сообщения в зашифрованном виде, а другие — открыто. Сообщение с этим расширением отправляется от {{ ydb-short-name }} к LDAP-серверу для инициирования TLS-соединения. В случае {{ ydb-short-name }} не предусмотрено включение и выключение TLS-соединения в рамках одного соединения. Поэтому при использовании расширения `StartTls` после установления зашифрованного соединения {{ ydb-short-name }} будет отправлять все дальнейшие сообщения к LDAP-серверу в зашифрованном виде. Одним из преимуществ использования данного расширения вместо схемы `ldaps` (при соответствующей настройке LDAP-сервера) является возможность установить TLS-соединение на нешифрованном порту. Расширение включается в [секции `use_tls`](../reference/configuration/index.md#ldap-auth-config) файла конфигурации.


## Аутентификация с использованием стороннего IAM-провайдера {#iam}

* **Access Token** — параметром для клиента (SDK или CLI) задается фиксированный токен, который передается в запросы.
* **Refresh Token** — параметром для клиента (SDK или CLI) задается [OAuth токен](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/) персональной учетной записи, на основании которого клиент периодически в фоновом режиме обращается к IAM API для ротации (получения следующего) токена, передаваемого в запросы.
* **Service Account Key** — параметром для клиента (SDK или CLI) задаются атрибуты сервисной учетной записи и ключ для подписи, на основании которых клиент периодически в фоновом режиме обращается к IAM API для ротации (получения следующего) токена, передаваемого в запросы.
* **Metadata** — клиент (SDK или CLI) периодически обращается к локальному сервису для ротации (получения следующего) токена, передаваемого в запросы.
* **OAuth 2.0 token exchange** - клиент (SDK или CLI) обменивает токен другого типа на access token по [протоколу обмена токенов OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8693), который затем передаётся в запросы {{ ydb-short-name }} API.

Любой обладатель валидного токена может получить доступ на выполнение операций, поэтому главная задача системы безопасности — обеспечение секретности токена и предотвращение его компрометации.

Режимы аутентификации с ротацией токена **Refresh Token** и **Service Account Key** обеспечивают больший уровень безопасности по сравнению с режимом с фиксированным токеном **Access Token**, так как на сервер {{ ydb-short-name }} по сети передаются только короткоживущие секреты.

Максимальная безопасность и производительность обеспечивается при использовании режима **Metadata**, так как он исключает необходимость работы с секретами при развертывании приложения, а также позволяет обратиться к IAM и закешировать токен заранее, до запуска приложения.

При выборе режима аутентификации среди поддерживаемых сервером и окружением, следует руководствоваться следующими рекомендациями:

* **Anonymous** обычно применяется на самостоятельно разворачиваемых локальных кластерах {{ ydb-short-name }}, недоступных по сети.
* **Access Token** применяется при отсутствии поддержки других режимов на стороне сервера или в настроечных/отладочных целях. Он не требует взаимодействий клиента с IAM. Однако, если IAM поддерживает API для ротации токенов, то обычно выдаваемые таким IAM фиксированные токены имеют короткий срок жизни, что вынуждает регулярно обновлять их в IAM вручную заново.
* **Refresh Token** может применяться при выполнении разовых ручных операций под персональной учетной записью, например, связанных с обслуживанием данных в БД, выполнением ad-hoc операций в CLI, или запусками приложений с рабочей станции. Такой токен можно получить вручную в IAM один раз на долгий срок и сохранить в переменной окружения на личной рабочей станции для автоматического применения при запуске CLI без дополнительных параметров аутентификации.
* **Service Account Key** применяется в первую очередь для приложений, рассчитанных на эксплуатацию в окружениях, где поддерживается режим **Metadata**, при их тестировании вне таких окружений (например, на рабочей станции). Также он может применяться для приложений вне таких окружений, работая как аналог **Refresh Token** для сервисных учетных записей. В отличие от персональной учетной записи, объекты доступа и роли сервисной учетной записи могут быть ограничены.
* **Metadata** применяется при разворачивании приложений в облаках. В настоящее время этот режим поддерживается на виртуальных машинах и в {{ sf-name }} {{ yandex-cloud }}.

Токен для указания в параметрах может быть получен в системе IAM, с которой связана конкретная установка {{ ydb-short-name }}. В частности, для сервиса {{ ydb-short-name }} в {{ yandex-cloud }} применяется Yandex.Passport OAuth и сервисные аккаунты {{ yandex-cloud }}. При использовании {{ ydb-short-name }} в корпоративных контекстах могут применяться стандартные для данной организации системы централизованной аутентификации.

При использовании режимов, предусматривающих обращение клиента {{ ydb-short-name }} к IAM, дополнительно может быть задан URL IAM, предоставляющий API выдачи токенов. По умолчанию в существующих SDK и CLI производится попытка обращения к API IAM {{ yandex-cloud }}, размещенному на `iam.api.cloud.yandex.net:443`.
