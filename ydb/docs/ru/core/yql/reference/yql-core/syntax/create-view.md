# CREATE VIEW

`CREATE VIEW` создаёт [представление](../../../../concepts/datamodel/view).

Представление - это обёртка над `SELECT` запросом, позволяющая обращаться к нему как к таблице, в которую сохранены актуальные результаты выполнения этого запроса. Представление не хранит никаких данных, кроме текста запроса. Чтение из представления аналогично чтению из подзапроса.

## Синтаксис

```sql
CREATE VIEW <имя>
[ WITH ( <имя_параметра_представления> [= <значение_параметра_представления>] [, ... ] ) ]
AS <запрос>
```

### Параметры

* `имя` - имя создаваемого представления. Должно быть уникально. Допускается запись в виде абсолютного пути до представления.
* `запрос` - `SELECT` запрос, который выдаёт столбцы и строки представления.
* `WITH ( <имя_параметра_представления> [= <значение_параметра_представления>] [, ... ] )` позволяет задать значения параметров, определяющих поведение представления. Поддерживаются следующие опции:
  * `security_invoker` (Bool) - опция, при включении которой запрос, хранящийся в представлении, будет исполнен от имени пользователя, читающего из представления, а не от имени создателя представления. {#security_invoker}

## Замечания {#замечания}

`security_invoker` опция должна быть всегда выставлена в TRUE, потому что поведением по умолчанию для представления является исполнение сохранённого запроса от имени создателя представления, но эта возможность на данный момент не реализована в {{ ydb-short-name }}.

Контекст исполнения запроса, хранящегося в представлении, отличается от контекста объемлющего запроса, читающего из представления. Внутренний контекст создаётся заново и ничего не наследует из объемлющего. Он не "видит" ранее определённые PRAGMA (например, TablePathPrefix), именованные выражения и прочее. Самое важное следствие из этого состоит в том, что названия таблиц (и, возможно, других представлений), на которые ссылается создаваемое представление, должны быть записаны в виде абсолютного пути. В приведенных ниже [примерах](#примеры) видно, что пути до таблиц, из которых читает создаваемое представление, записаны в абсолютном виде: `/domain/database/path/to/underlying_table`. В следующих релизах эта недоработка будет исправлена. {#context}

Если вы хотите задать список интересующих вас колонок или, например, переименовать одну из них в выдаче при чтении из представления, то сделать это можно, сохранив в представление подходящий запрос:
```sql
CREATE VIEW view_with_a_renamed_column WITH (security_invoker = TRUE) AS
SELECT
    original_column_name AS custom_column_name
FROM `/domain/database/path/to/underlying_table`;
```

Интерпретация символа `*` для получения списка колонок при чтении из подлежащих таблиц происходит каждый раз при чтении из представления. Это означает, что список колонок в результате следующего запроса:
```sql
/*
CREATE VIEW view_with_an_asterisk WITH (security_invoker = TRUE) AS
SELECT
    *
FROM `/domain/database/path/to/underlying_table`;
*/

SELECT * FROM view_with_an_asterisk;
```
изменится при добавлении или удалении колонок из подлежащей таблицы.

## Примеры {#примеры}

Создание представления, которое будет возвращать список современных сериалов:

```sql
CREATE VIEW recent_series WITH (security_invoker = TRUE) AS
SELECT
    *
FROM `/domain/database/path/to/series`
WHERE
    release_date > Date("2020-01-01");
```

Создание представления, которое будет возвращать названия первых эпизодов современных сериалов:

```sql
CREATE VIEW recent_series_first_episodes_titles WITH (security_invoker = TRUE) AS
SELECT
    episodes.title AS first_episode
FROM `/domain/database/path/to/recent_series`
    AS recent_series
JOIN `/domain/database/path/to/episodes`
    AS episodes
USING(series_id)
WHERE episodes.season_id = 1 AND episodes.episode_id = 1;
```

## См. также

* [ALTER VIEW](alter-view.md)
* [DROP VIEW](drop-view.md)