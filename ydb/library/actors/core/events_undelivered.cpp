#include "events.h"
#include "actorsystem.h"

namespace NActors {
    TString TEvents::TEvUndelivered::ToStringHeader() const {
        return "TSystem::Undelivered";
    }

    bool TEvents::TEvUndelivered::SerializeToArcadiaStream(TChunkSerializer *serializer) const {
        Y_ABORT_UNLESS(!Unsure); // these are local-only events generated by Interconnect
        return serializer->WriteString(&Data);
    }

    void TEvents::TEvUndelivered::Out(IOutputStream& o, EReason x) {
        switch (x) {
        case ReasonActorUnknown:
            o << "ActorUnknown";
            break;
        case Disconnected:
            o << "Disconnected";
            break;
        default:
            o << "Undefined";
            break;
        }
    }

    bool TEvents::TEvUndelivered::IsSerializable() const {
        return true;
    }

    IEventBase* TEvents::TEvUndelivered::Load(TEventSerializedData* bufs) {
        TString str = bufs->GetString();
        Y_ABORT_UNLESS(str.size() == (sizeof(ui32) + sizeof(ui32)));
        const char* p = str.data();
        const ui64 sourceType = ReadUnaligned<ui32>(p + 0);
        const ui64 reason = ReadUnaligned<ui32>(p + 4);
        return new TEvUndelivered(sourceType, reason);
    }

    std::unique_ptr<IEventHandle> IEventHandle::ForwardOnNondelivery(std::unique_ptr<IEventHandle>&& ev, ui32 reason, bool unsure) {
        if (ev->Flags & FlagForwardOnNondelivery) {
            const ui32 updatedFlags = ev->Flags & ~(FlagForwardOnNondelivery | FlagSubscribeOnSession);
            const TActorId recp = ev->OnNondeliveryHolder ? ev->OnNondeliveryHolder->Recipient : TActorId();

            if (ev->Event)
                return std::unique_ptr<IEventHandle>(new IEventHandle(recp, ev->Sender, ev->Event.Release(), updatedFlags, ev->Cookie, &ev->Recipient, std::move(ev->TraceId)));
            else
                return std::unique_ptr<IEventHandle>(new IEventHandle(ev->Type, updatedFlags, recp, ev->Sender, ev->Buffer, ev->Cookie, &ev->Recipient, std::move(ev->TraceId)));
        }

        if (ev->Flags & FlagTrackDelivery) {
            const ui32 updatedFlags = ev->Flags & ~(FlagTrackDelivery | FlagSubscribeOnSession | FlagGenerateUnsureUndelivered);
            return std::unique_ptr<IEventHandle>(new IEventHandle(ev->Sender, ev->Recipient, new TEvents::TEvUndelivered(ev->Type, reason, unsure), updatedFlags,
                ev->Cookie, nullptr, std::move(ev->TraceId)));
        }
        return {};
    }
}
