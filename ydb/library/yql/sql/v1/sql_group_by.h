#pragma once

#include "sql_translation.h"

namespace NSQLTranslationV1 {

using namespace NSQLv1Generated;

class TGroupByClause: public TSqlTranslation {
    enum class EGroupByFeatures {
        Begin,
        Ordinary = Begin,
        Expression,
        Rollup,
        Cube,
        GroupingSet,
        Empty,
        End,
    };
    typedef TEnumBitSet<EGroupByFeatures, static_cast<int>(EGroupByFeatures::Begin), static_cast<int>(EGroupByFeatures::End)> TGroupingSetFeatures;

    class TGroupByClauseCtx: public TSimpleRefCount<TGroupByClauseCtx> {
    public:
        typedef TIntrusivePtr<TGroupByClauseCtx> TPtr;

        TGroupingSetFeatures GroupFeatures;
        TMap<TString, TNodePtr> NodeAliases;
        size_t UnnamedCount = 0;
    };

public:
    TGroupByClause(TContext& ctx, NSQLTranslation::ESqlMode mode, TGroupByClauseCtx::TPtr groupSetContext = {})
        : TSqlTranslation(ctx, mode)
        , GroupSetContext(groupSetContext ? groupSetContext : TGroupByClauseCtx::TPtr(new TGroupByClauseCtx()))
        , CompactGroupBy(false)
    {}

    bool Build(const TRule_group_by_clause& node);
    bool ParseList(const TRule_grouping_element_list& groupingListNode, EGroupByFeatures featureContext);

    void SetFeatures(const TString& field) const;
    TVector<TNodePtr>& Content();
    TMap<TString, TNodePtr>& Aliases();
    TLegacyHoppingWindowSpecPtr GetLegacyHoppingWindow() const;
    bool IsCompactGroupBy() const;
    TString GetSuffix() const;

private:
    TMaybe<TVector<TNodePtr>> MultiplyGroupingSets(const TVector<TNodePtr>& lhs, const TVector<TNodePtr>& rhs) const;
    bool ResolveGroupByAndGrouping();
    bool GroupingElement(const TRule_grouping_element& node, EGroupByFeatures featureContext);
    void FeedCollection(const TNodePtr& elem, TVector<TNodePtr>& collection, bool& hasEmpty) const;
    bool OrdinaryGroupingSet(const TRule_ordinary_grouping_set& node, EGroupByFeatures featureContext);
    bool OrdinaryGroupingSetList(const TRule_ordinary_grouping_set_list& node, EGroupByFeatures featureContext);
    bool HoppingWindow(const TRule_hopping_window_specification& node);

    bool AllowUnnamed(TPosition pos, EGroupByFeatures featureContext);

    TGroupingSetFeatures& Features();
    const TGroupingSetFeatures& Features() const;
    bool AddAlias(const TString& label, const TNodePtr& node);
    TString GenerateGroupByExprName();
    bool IsAutogenerated(const TString* name) const;

    TVector<TNodePtr> GroupBySet;
    TGroupByClauseCtx::TPtr GroupSetContext;
    TLegacyHoppingWindowSpecPtr LegacyHoppingWindowSpec; // stream queries
    static const TString AutogenerateNamePrefix;
    bool CompactGroupBy;
    TString Suffix;
};

} // namespace NSQLTranslationV1
