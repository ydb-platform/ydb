Registering pre-existing tables
	onek
	int4_tbl
	INT4_TBL
	tenk1
	VARCHAR_TBL
	aggtest
	student
	varchar_tbl
	int8_tbl
<sql-statement>
--
-- AGGREGATES
--
-- avoid bit-exact output here because operations may not be bit-exact.
SET extra_float_digits = 0;
</sql-statement>
<sql-statement>
SELECT avg(four) AS avg_1 FROM onek;
</sql-statement>
<sql-statement>
SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
</sql-statement>
<sql-statement>
-- In 7.1, avg(float4) is computed using float8 arithmetic.
-- Round the result to 3 digits to avoid platform-specific results.
SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
</sql-statement>
<sql-statement>
SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
</sql-statement>
<sql-statement>
SELECT sum(four) AS sum_1500 FROM onek;
</sql-statement>
<sql-statement>
SELECT sum(a) AS sum_198 FROM aggtest;
</sql-statement>
<sql-statement>
SELECT sum(b) AS avg_431_773 FROM aggtest;
</sql-statement>
<sql-statement>
SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
</sql-statement>
<sql-statement>
SELECT max(four) AS max_3 FROM onek;
</sql-statement>
<sql-statement>
SELECT max(a) AS max_100 FROM aggtest;
</sql-statement>
<sql-statement>
SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
</sql-statement>
<sql-statement>
SELECT max(student.gpa) AS max_3_7 FROM student;
</sql-statement>
<sql-statement>
SELECT stddev_pop(b) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT stddev_samp(b) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT var_pop(b) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT var_samp(b) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT stddev_pop(b::numeric) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT stddev_samp(b::numeric) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT var_pop(b::numeric) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT var_samp(b::numeric) FROM aggtest;
</sql-statement>
<sql-statement>
-- population variance is defined for a single tuple, sample variance
-- is not
SELECT var_pop(1.0::float8), var_samp(2.0::float8);
</sql-statement>
<sql-statement>
SELECT stddev_pop(3.0::float8), stddev_samp(4.0::float8);
</sql-statement>
<sql-statement>
SELECT var_pop('inf'::float8), var_samp('inf'::float8);
</sql-statement>
<sql-statement>
SELECT stddev_pop('inf'::float8), stddev_samp('inf'::float8);
</sql-statement>
<sql-statement>
SELECT var_pop('nan'::float8), var_samp('nan'::float8);
</sql-statement>
<sql-statement>
SELECT stddev_pop('nan'::float8), stddev_samp('nan'::float8);
</sql-statement>
<sql-statement>
SELECT var_pop(1.0::float4), var_samp(2.0::float4);
</sql-statement>
<sql-statement>
SELECT stddev_pop(3.0::float4), stddev_samp(4.0::float4);
</sql-statement>
<sql-statement>
SELECT var_pop('inf'::float4), var_samp('inf'::float4);
</sql-statement>
<sql-statement>
SELECT stddev_pop('inf'::float4), stddev_samp('inf'::float4);
</sql-statement>
<sql-statement>
SELECT var_pop('nan'::float4), var_samp('nan'::float4);
</sql-statement>
<sql-statement>
SELECT stddev_pop('nan'::float4), stddev_samp('nan'::float4);
</sql-statement>
<sql-statement>
SELECT var_pop(1.0::numeric), var_samp(2.0::numeric);
</sql-statement>
<sql-statement>
SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
</sql-statement>
<sql-statement>
SELECT var_pop('inf'::numeric), var_samp('inf'::numeric);
</sql-statement>
<sql-statement>
SELECT stddev_pop('inf'::numeric), stddev_samp('inf'::numeric);
</sql-statement>
<sql-statement>
SELECT var_pop('nan'::numeric), var_samp('nan'::numeric);
</sql-statement>
<sql-statement>
SELECT stddev_pop('nan'::numeric), stddev_samp('nan'::numeric);
</sql-statement>
<sql-statement>
-- verify correct results for null and NaN inputs
select sum(null::int4) from generate_series(1,3);
</sql-statement>
<sql-statement>
select sum(null::int8) from generate_series(1,3);
</sql-statement>
<sql-statement>
select sum(null::numeric) from generate_series(1,3);
</sql-statement>
<sql-statement>
select sum(null::float8) from generate_series(1,3);
</sql-statement>
<sql-statement>
select avg(null::int4) from generate_series(1,3);
</sql-statement>
<sql-statement>
select avg(null::int8) from generate_series(1,3);
</sql-statement>
<sql-statement>
select avg(null::numeric) from generate_series(1,3);
</sql-statement>
<sql-statement>
select avg(null::float8) from generate_series(1,3);
</sql-statement>
<sql-statement>
select sum('NaN'::numeric) from generate_series(1,3);
</sql-statement>
<sql-statement>
select avg('NaN'::numeric) from generate_series(1,3);
</sql-statement>
<sql-statement>
-- verify correct results for infinite inputs
SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('1'), ('infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('infinity'), ('1')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('infinity'), ('infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('-infinity'), ('infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('-infinity'), ('-infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('1'), ('infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('infinity'), ('1')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('infinity'), ('infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('-infinity'), ('infinity')) v(x);
</sql-statement>
<sql-statement>
SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('-infinity'), ('-infinity')) v(x);
</sql-statement>
<sql-statement>
-- test accuracy with a large input offset
SELECT avg(x::float8), var_pop(x::float8)
FROM (VALUES (100000003), (100000004), (100000006), (100000007)) v(x);
</sql-statement>
<sql-statement>
SELECT avg(x::float8), var_pop(x::float8)
FROM (VALUES (7000000000005), (7000000000007)) v(x);
</sql-statement>
<sql-statement>
-- SQL2003 binary aggregates
SELECT regr_count(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT regr_sxx(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT regr_syy(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT regr_sxy(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT regr_r2(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
SELECT corr(b, a) FROM aggtest;
</sql-statement>
<sql-statement>
-- check single-tuple behavior
SELECT covar_pop(1::float8,2::float8), covar_samp(3::float8,4::float8);
</sql-statement>
<sql-statement>
SELECT covar_pop(1::float8,'inf'::float8), covar_samp(3::float8,'inf'::float8);
</sql-statement>
<sql-statement>
SELECT covar_pop(1::float8,'nan'::float8), covar_samp(3::float8,'nan'::float8);
</sql-statement>
<sql-statement>
-- test accum and combine functions directly
CREATE TABLE regr_test (x float8, y float8);
</sql-statement>
<sql-statement>
INSERT INTO regr_test VALUES (10,150),(20,250),(30,350),(80,540),(100,200);
</sql-statement>
<sql-statement>
SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test WHERE x IN (10,20,30,80);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
        -stdin-:<main>:1:1: Error: Duplicated member: sum
        	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
<sql-statement>
SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
        -stdin-:<main>:1:1: Error: Duplicated member: sum
        	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
<sql-statement>
SELECT float8_accum('{4,140,2900}'::float8[], 100);
</sql-statement>
<sql-statement>
SELECT float8_regr_accum('{4,140,2900,1290,83075,15050}'::float8[], 200, 100);
</sql-statement>
<sql-statement>
SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test WHERE x IN (10,20,30);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
        -stdin-:<main>:1:1: Error: Duplicated member: sum
        	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
<sql-statement>
SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test WHERE x IN (80,100);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
        -stdin-:<main>:1:1: Error: Duplicated member: sum
        	SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
	^
<sql-statement>
SELECT float8_combine('{3,60,200}'::float8[], '{0,0,0}'::float8[]);
</sql-statement>
<sql-statement>
SELECT float8_combine('{0,0,0}'::float8[], '{2,180,200}'::float8[]);
</sql-statement>
<sql-statement>
SELECT float8_combine('{3,60,200}'::float8[], '{2,180,200}'::float8[]);
</sql-statement>
<sql-statement>
SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                           '{0,0,0,0,0,0}'::float8[]);
</sql-statement>
<sql-statement>
SELECT float8_regr_combine('{0,0,0,0,0,0}'::float8[],
                           '{2,180,200,740,57800,-3400}'::float8[]);
</sql-statement>
<sql-statement>
SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                           '{2,180,200,740,57800,-3400}'::float8[]);
</sql-statement>
<sql-statement>
DROP TABLE regr_test;
</sql-statement>
<sql-statement>
-- test count, distinct
SELECT count(four) AS cnt_1000 FROM onek;
</sql-statement>
<sql-statement>
SELECT count(DISTINCT four) AS cnt_4 FROM onek;
</sql-statement>
<sql-statement>
select ten, count(*), sum(four) from onek
group by ten order by ten;
</sql-statement>
<sql-statement>
select ten, count(four), sum(DISTINCT four) from onek
group by ten order by ten;
</sql-statement>
<sql-statement>
-- user-defined aggregates
SELECT newavg(four) AS avg_1 FROM onek;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- user-defined aggregates
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	SELECT newavg(four) AS avg_1 FROM onek;
	       ^
            -stdin-:<main>:2:8: Error: No such proc: newavg
            	SELECT newavg(four) AS avg_1 FROM onek;
	       ^
<sql-statement>
SELECT newsum(four) AS sum_1500 FROM onek;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT newsum(four) AS sum_1500 FROM onek;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT newsum(four) AS sum_1500 FROM onek;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: newsum
            	SELECT newsum(four) AS sum_1500 FROM onek;
	       ^
<sql-statement>
SELECT newcnt(four) AS cnt_1000 FROM onek;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT newcnt(four) AS cnt_1000 FROM onek;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT newcnt(four) AS cnt_1000 FROM onek;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: newcnt
            	SELECT newcnt(four) AS cnt_1000 FROM onek;
	       ^
<sql-statement>
SELECT newcnt(*) AS cnt_1000 FROM onek;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: * is expected only in count function
    	SELECT newcnt(*) AS cnt_1000 FROM onek;
	       ^
<sql-statement>
SELECT oldcnt(*) AS cnt_1000 FROM onek;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: * is expected only in count function
    	SELECT oldcnt(*) AS cnt_1000 FROM onek;
	       ^
<sql-statement>
SELECT sum2(q1,q2) FROM int8_tbl;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT sum2(q1,q2) FROM int8_tbl;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT sum2(q1,q2) FROM int8_tbl;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: sum2
            	SELECT sum2(q1,q2) FROM int8_tbl;
	       ^
<sql-statement>
-- test for outer-level aggregates
-- this should work
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:5:43: Error: Aggregate functions are not allowed in: WHERE
    	having exists (select 1 from onek b where sum(distinct a.four) = b.four);
	                                          ^
<sql-statement>
-- this should fail because subquery has an agg of its own in WHERE
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b
               where sum(distinct a.four + b.four) = b.four);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:5:22: Error: Aggregate functions are not allowed in: WHERE
    	               where sum(distinct a.four + b.four) = b.four);
	                     ^
<sql-statement>
-- Test handling of sublinks within outer-level aggregates.
-- Per bug report from Daniel Grace.
select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
from tenk1 o;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- Test handling of sublinks within outer-level aggregates.
	^
        -stdin-:<main>:4:3: Error: At function: PgSubLink, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
        	  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
	  ^
            -stdin-:<main>:4:11: Error: At function: PgAgg
            	  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
	          ^
                -stdin-:<main>:4:15: Error: At function: PgSubLink, At function: PgSelect, At function: PgSetItem
                	  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
	              ^
                    -stdin-:<main>:4:64: Error: No such column: unique1
                    	  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
	                                                               ^
<sql-statement>
-- Test handling of Params within aggregate arguments in hashed aggregation.
-- Per bug report from Jeevan Chalke.
explain (verbose, costs off)
select s1, s2, sm
from generate_series(1, 3) s1,
     lateral (select s2, sum(s1 + s2) sm
              from generate_series(1, 3) s2 group by s2) ss
order by 1, 2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Test handling of Params within aggregate arguments in hashed aggregation.
	^
<sql-statement>
select s1, s2, sm
from generate_series(1, 3) s1,
     lateral (select s2, sum(s1 + s2) sm
              from generate_series(1, 3) s2 group by s2) ss
order by 1, 2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeSubselect: unsupported lateral
    	select s1, s2, sm
	^
<sql-statement>
explain (verbose, costs off)
select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (verbose, costs off)
	^
<sql-statement>
select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
</sql-statement>
<sql-statement>
--
-- test for bitwise integer aggregates
--
CREATE TEMPORARY TABLE bitwise_test(
  i2 INT2,
  i4 INT4,
  i8 INT8,
  i INTEGER,
  x INT2,
  y BIT(4)
);
</sql-statement>
<sql-statement>
-- empty case
SELECT
  BIT_AND(i2) AS "?",
  BIT_OR(i4)  AS "?",
  BIT_XOR(i8) AS "?"
FROM bitwise_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- empty case
	^
        -stdin-:<main>:1:1: Error: Duplicated member: ?
        	-- empty case
	^
<sql-statement>
COPY bitwise_test FROM STDIN NULL 'null';
1	1	1	1	1	B0101
3	3	3	null	2	B0100
7	7	7	3	4	B1100
\.
</sql-statement>
Metacommand \. is not supported
<sql-statement>
SELECT
  BIT_AND(i2) AS "1",
  BIT_AND(i4) AS "1",
  BIT_AND(i8) AS "1",
  BIT_AND(i)  AS "?",
  BIT_AND(x)  AS "0",
  BIT_AND(y)  AS "0100",
  BIT_OR(i2)  AS "7",
  BIT_OR(i4)  AS "7",
  BIT_OR(i8)  AS "7",
  BIT_OR(i)   AS "?",
  BIT_OR(x)   AS "7",
  BIT_OR(y)   AS "1101",
  BIT_XOR(i2) AS "5",
  BIT_XOR(i4) AS "5",
  BIT_XOR(i8) AS "5",
  BIT_XOR(i)  AS "?",
  BIT_XOR(x)  AS "7",
  BIT_XOR(y)  AS "1101"
FROM bitwise_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT
	^
        -stdin-:<main>:1:1: Error: Duplicated member: 1
        	SELECT
	^
<sql-statement>
--
-- test boolean aggregates
--
-- first test all possible transition and final states
SELECT
  -- boolean and transitions
  -- null because strict
  booland_statefunc(NULL, NULL)  IS NULL AS "t",
  booland_statefunc(TRUE, NULL)  IS NULL AS "t",
  booland_statefunc(FALSE, NULL) IS NULL AS "t",
  booland_statefunc(NULL, TRUE)  IS NULL AS "t",
  booland_statefunc(NULL, FALSE) IS NULL AS "t",
  -- and actual computations
  booland_statefunc(TRUE, TRUE) AS "t",
  NOT booland_statefunc(TRUE, FALSE) AS "t",
  NOT booland_statefunc(FALSE, TRUE) AS "t",
  NOT booland_statefunc(FALSE, FALSE) AS "t";
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	--
	^
        -stdin-:<main>:1:1: Error: Duplicated member: t
        	--
	^
<sql-statement>
SELECT
  -- boolean or transitions
  -- null because strict
  boolor_statefunc(NULL, NULL)  IS NULL AS "t",
  boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
  boolor_statefunc(FALSE, NULL) IS NULL AS "t",
  boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
  boolor_statefunc(NULL, FALSE) IS NULL AS "t",
  -- actual computations
  boolor_statefunc(TRUE, TRUE) AS "t",
  boolor_statefunc(TRUE, FALSE) AS "t",
  boolor_statefunc(FALSE, TRUE) AS "t",
  NOT boolor_statefunc(FALSE, FALSE) AS "t";
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT
	^
        -stdin-:<main>:1:1: Error: Duplicated member: t
        	SELECT
	^
<sql-statement>
CREATE TEMPORARY TABLE bool_test(
  b1 BOOL,
  b2 BOOL,
  b3 BOOL,
  b4 BOOL);
</sql-statement>
<sql-statement>
-- empty case
SELECT
  BOOL_AND(b1)   AS "n",
  BOOL_OR(b3)    AS "n"
FROM bool_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- empty case
	^
        -stdin-:<main>:1:1: Error: Duplicated member: n
        	-- empty case
	^
<sql-statement>
COPY bool_test FROM STDIN NULL 'null';
TRUE	null	FALSE	null
FALSE	TRUE	null	null
null	TRUE	FALSE	null
\.
</sql-statement>
Metacommand \. is not supported
<sql-statement>
SELECT
  BOOL_AND(b1)     AS "f",
  BOOL_AND(b2)     AS "t",
  BOOL_AND(b3)     AS "f",
  BOOL_AND(b4)     AS "n",
  BOOL_AND(NOT b2) AS "f",
  BOOL_AND(NOT b3) AS "t"
FROM bool_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT
	^
        -stdin-:<main>:1:1: Error: Duplicated member: f
        	SELECT
	^
<sql-statement>
SELECT
  EVERY(b1)     AS "f",
  EVERY(b2)     AS "t",
  EVERY(b3)     AS "f",
  EVERY(b4)     AS "n",
  EVERY(NOT b2) AS "f",
  EVERY(NOT b3) AS "t"
FROM bool_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT
	^
        -stdin-:<main>:1:1: Error: Duplicated member: f
        	SELECT
	^
<sql-statement>
SELECT
  BOOL_OR(b1)      AS "t",
  BOOL_OR(b2)      AS "t",
  BOOL_OR(b3)      AS "f",
  BOOL_OR(b4)      AS "n",
  BOOL_OR(NOT b2)  AS "f",
  BOOL_OR(NOT b3)  AS "t"
FROM bool_test;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	SELECT
	^
        -stdin-:<main>:1:1: Error: Duplicated member: f
        	SELECT
	^
<sql-statement>
--
-- Test cases that should be optimized into indexscans instead of
-- the generic aggregate implementation.
--
-- Basic cases
explain (costs off)
  select min(unique1) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	--
	^
<sql-statement>
select min(unique1) from tenk1;
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique1) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique1) from tenk1;
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique1) from tenk1 where unique1 < 42;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique1) from tenk1 where unique1 < 42;
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique1) from tenk1 where unique1 > 42;
</sql-statement>
<sql-statement>
-- the planner may choose a generic aggregate here if parallel query is
-- enabled, since that plan will be parallel safe and the "optimized"
-- plan, which has almost identical cost, will not be.  we want to test
-- the optimized plan, so temporarily disable parallel query.
begin;
</sql-statement>
<sql-statement>
set local max_parallel_workers_per_gather = 0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: max_parallel_workers_per_gather
    	set local max_parallel_workers_per_gather = 0;
	^
<sql-statement>
explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42000;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique1) from tenk1 where unique1 > 42000;
</sql-statement>
<sql-statement>
rollback;
</sql-statement>
<sql-statement>
-- multi-column index (uses tenk1_thous_tenthous)
explain (costs off)
  select max(tenthous) from tenk1 where thousand = 33;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- multi-column index (uses tenk1_thous_tenthous)
	^
<sql-statement>
select max(tenthous) from tenk1 where thousand = 33;
</sql-statement>
<sql-statement>
explain (costs off)
  select min(tenthous) from tenk1 where thousand = 33;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select min(tenthous) from tenk1 where thousand = 33;
</sql-statement>
<sql-statement>
-- check parameter propagation into an indexscan subquery
explain (costs off)
  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
    from int4_tbl;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- check parameter propagation into an indexscan subquery
	^
<sql-statement>
select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
  from int4_tbl;
</sql-statement>
<sql-statement>
-- check some cases that were handled incorrectly in 8.3.0
explain (costs off)
  select distinct max(unique2) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- check some cases that were handled incorrectly in 8.3.0
	^
<sql-statement>
select distinct max(unique2) from tenk1;
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique2) from tenk1 order by 1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique2) from tenk1 order by 1;
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique2) from tenk1 order by max(unique2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique2) from tenk1 order by max(unique2);
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique2) from tenk1 order by max(unique2)+1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique2) from tenk1 order by max(unique2)+1;
</sql-statement>
<sql-statement>
explain (costs off)
  select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:22: Error: Generator functions are not allowed in: SELECT
    	select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
	                     ^
<sql-statement>
-- interesting corner case: constant gets optimized into a seqscan
explain (costs off)
  select max(100) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- interesting corner case: constant gets optimized into a seqscan
	^
<sql-statement>
select max(100) from tenk1;
</sql-statement>
<sql-statement>
-- try it on an inheritance tree
create table minmaxtest(f1 int);
</sql-statement>
<sql-statement>
create table minmaxtest1() inherits (minmaxtest);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table minmaxtest1() inherits (minmaxtest);
	^
<sql-statement>
create table minmaxtest2() inherits (minmaxtest);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table minmaxtest2() inherits (minmaxtest);
	^
<sql-statement>
create table minmaxtest3() inherits (minmaxtest);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table minmaxtest3() inherits (minmaxtest);
	^
<sql-statement>
create index minmaxtesti on minmaxtest(f1);
</sql-statement>
<sql-statement>
create index minmaxtest1i on minmaxtest1(f1);
</sql-statement>
<sql-statement>
create index minmaxtest2i on minmaxtest2(f1 desc);
</sql-statement>
<sql-statement>
create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: partial index is not supported yet
    	create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
	^
<sql-statement>
insert into minmaxtest values(11), (12);
</sql-statement>
<sql-statement>
insert into minmaxtest1 values(13), (14);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.minmaxtest1
    
<sql-statement>
insert into minmaxtest2 values(15), (16);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.minmaxtest2
    
<sql-statement>
insert into minmaxtest3 values(17), (18);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.minmaxtest3
    
<sql-statement>
explain (costs off)
  select min(f1), max(f1) from minmaxtest;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
select min(f1), max(f1) from minmaxtest;
</sql-statement>
<sql-statement>
-- DISTINCT doesn't do anything useful here, but it shouldn't fail
explain (costs off)
  select distinct min(f1), max(f1) from minmaxtest;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- DISTINCT doesn't do anything useful here, but it shouldn't fail
	^
<sql-statement>
select distinct min(f1), max(f1) from minmaxtest;
</sql-statement>
<sql-statement>
drop table minmaxtest cascade;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: CASCADE is not implemented
    	drop table minmaxtest cascade;
	^
<sql-statement>
-- check for correct detection of nested-aggregate errors
select max(min(unique1)) from tenk1;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- check for correct detection of nested-aggregate errors
	^
        -stdin-:<main>:1:1: Fatal: ydb/library/yql/providers/common/mkql/yql_provider_mkql.cpp:364  GetCallable(): requirement Callables.cend() != compiler failed, message: Missed callable: PgAgg
        	-- check for correct detection of nested-aggregate errors
	^
<sql-statement>
select (select max(min(unique1)) from int8_tbl) from tenk1;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:8: Fatal: Execution of node: YtMapReduce!
    	select (select max(min(unique1)) from int8_tbl) from tenk1;
	       ^
        -stdin-:<main>:1:8: Fatal: ydb/library/yql/providers/common/mkql/yql_provider_mkql.cpp:364  GetCallable(): requirement Callables.cend() != compiler failed, message: Missed callable: PgAgg
        	select (select max(min(unique1)) from int8_tbl) from tenk1;
	       ^
<sql-statement>
--
-- Test removal of redundant GROUP BY columns
--
create temp table t1 (a int, b int, c int, d int, primary key (a, b));
</sql-statement>
<sql-statement>
create temp table t2 (x int, y int, z int, primary key (x, y));
</sql-statement>
<sql-statement>
create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DEFERRABLE constraints not supported
    	create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
	^
<sql-statement>
-- Non-primary-key columns can be removed from GROUP BY
explain (costs off) select * from t1 group by a,b,c,d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Non-primary-key columns can be removed from GROUP BY
	^
<sql-statement>
-- No removal can happen if the complete PK is not present in GROUP BY
explain (costs off) select a,c from t1 group by a,c,d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- No removal can happen if the complete PK is not present in GROUP BY
	^
<sql-statement>
-- Test removal across multiple relations
explain (costs off) select *
from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Test removal across multiple relations
	^
<sql-statement>
-- Test case where t1 can be optimized but not t2
explain (costs off) select t1.*,t2.x,t2.z
from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Test case where t1 can be optimized but not t2
	^
<sql-statement>
-- Cannot optimize when PK is deferrable
explain (costs off) select * from t3 group by a,b,c;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Cannot optimize when PK is deferrable
	^
<sql-statement>
create temp table t1c () inherits (t1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create temp table t1c () inherits (t1);
	^
<sql-statement>
-- Ensure we don't remove any columns when t1 has a child table
explain (costs off) select * from t1 group by a,b,c,d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Ensure we don't remove any columns when t1 has a child table
	^
<sql-statement>
-- Okay to remove columns if we're only querying the parent.
explain (costs off) select * from only t1 group by a,b,c,d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Okay to remove columns if we're only querying the parent.
	^
<sql-statement>
create temp table p_t1 (
  a int,
  b int,
  c int,
  d int,
  primary key(a,b)
) partition by list(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	create temp table p_t1 (
	^
<sql-statement>
create temp table p_t1_1 partition of p_t1 for values in(1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create temp table p_t1_1 partition of p_t1 for values in(1);
	^
<sql-statement>
create temp table p_t1_2 partition of p_t1 for values in(2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create temp table p_t1_2 partition of p_t1 for values in(2);
	^
<sql-statement>
-- Ensure we can remove non-PK columns for partitioned tables.
explain (costs off) select * from p_t1 group by a,b,c,d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- Ensure we can remove non-PK columns for partitioned tables.
	^
<sql-statement>
drop table t1 cascade;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: CASCADE is not implemented
    	drop table t1 cascade;
	^
<sql-statement>
drop table t2;
</sql-statement>
<sql-statement>
drop table t3;
</sql-statement>
<sql-statement>
drop table p_t1;
</sql-statement>
<sql-statement>
--
-- Test GROUP BY matching of join columns that are type-coerced due to USING
--
create temp table t1(f1 int, f2 bigint);
</sql-statement>
<sql-statement>
create temp table t2(f1 bigint, f22 bigint);
</sql-statement>
<sql-statement>
select f1 from t1 left join t2 using (f1) group by f1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	select f1 from t1 left join t2 using (f1) group by f1;
	^
        -stdin-:<main>:1:1: Error: Can't find column: f1
        	select f1 from t1 left join t2 using (f1) group by f1;
	^
<sql-statement>
select f1 from t1 left join t2 using (f1) group by t1.f1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	select f1 from t1 left join t2 using (f1) group by t1.f1;
	^
        -stdin-:<main>:1:1: Error: Can't find column: f1
        	select f1 from t1 left join t2 using (f1) group by t1.f1;
	^
<sql-statement>
select t1.f1 from t1 left join t2 using (f1) group by t1.f1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	select t1.f1 from t1 left join t2 using (f1) group by t1.f1;
	^
        -stdin-:<main>:1:1: Error: Can't find column: f1
        	select t1.f1 from t1 left join t2 using (f1) group by t1.f1;
	^
<sql-statement>
-- only this one should fail:
select t1.f1 from t1 left join t2 using (f1) group by f1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- only this one should fail:
	^
        -stdin-:<main>:1:1: Error: Can't find column: f1
        	-- only this one should fail:
	^
<sql-statement>
drop table t1, t2;
</sql-statement>
<sql-statement>
--
-- Test combinations of DISTINCT and/or ORDER BY
--
select array_agg(a order by b)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:8: Error: FuncCall: unsupported agg_order
    	select array_agg(a order by b)
	       ^
<sql-statement>
select array_agg(a order by a)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select array_agg(a order by a)
	       ^
<sql-statement>
select array_agg(a order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select array_agg(a order by a desc)
	       ^
<sql-statement>
select array_agg(b order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select array_agg(b order by a desc)
	       ^
<sql-statement>
select array_agg(distinct a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
</sql-statement>
<sql-statement>
select array_agg(distinct a order by a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select array_agg(distinct a order by a)
	       ^
<sql-statement>
select array_agg(distinct a order by a desc)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select array_agg(distinct a order by a desc)
	       ^
<sql-statement>
select array_agg(distinct a order by a desc nulls last)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select array_agg(distinct a order by a desc nulls last)
	       ^
<sql-statement>
-- multi-arg aggs, strict/nonstrict, distinct/order by
select aggfstr(a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- multi-arg aggs, strict/nonstrict, distinct/order by
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select aggfstr(a,b,c)
	       ^
            -stdin-:<main>:2:8: Error: No such proc: aggfstr
            	select aggfstr(a,b,c)
	       ^
<sql-statement>
select aggfns(a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select aggfns(a,b,c)
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select aggfns(a,b,c)
	       ^
            -stdin-:<main>:1:8: Error: No such proc: aggfns
            	select aggfns(a,b,c)
	       ^
<sql-statement>
select aggfstr(distinct a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: agg_distinct must be set only for aggregate functions
    	select aggfstr(distinct a,b,c)
	       ^
<sql-statement>
select aggfns(distinct a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: agg_distinct must be set only for aggregate functions
    	select aggfns(distinct a,b,c)
	       ^
<sql-statement>
select aggfstr(distinct a,b,c order by b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfstr(distinct a,b,c order by b)
	       ^
<sql-statement>
select aggfns(distinct a,b,c order by b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,b,c order by b)
	       ^
<sql-statement>
-- test specific code paths
select aggfns(distinct a,a,c order by c using ~<~,a)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,a,c order by c using ~<~,a)
	       ^
<sql-statement>
select aggfns(distinct a,a,c order by c using ~<~)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,a,c order by c using ~<~)
	       ^
<sql-statement>
select aggfns(distinct a,a,c order by a)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,a,c order by a)
	       ^
<sql-statement>
select aggfns(distinct a,b,c order by a,c using ~<~,b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,b,c order by a,c using ~<~,b)
	       ^
<sql-statement>
-- check node I/O via view creation and usage, also deparsing logic
create view agg_view1 as
  select aggfns(a,b,c)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	-- check node I/O via view creation and usage, also deparsing logic
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
create or replace view agg_view1 as
  select aggfns(distinct a,b,c)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,3) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	create or replace view agg_view1 as
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
create or replace view agg_view1 as
  select aggfns(distinct a,b,c order by b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,3) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	create or replace view agg_view1 as
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
create or replace view agg_view1 as
  select aggfns(a,b,c order by b+1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	create or replace view agg_view1 as
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
create or replace view agg_view1 as
  select aggfns(a,a,c order by b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	create or replace view agg_view1 as
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
create or replace view agg_view1 as
  select aggfns(a,b,c order by c using ~<~)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	create or replace view agg_view1 as
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
create or replace view agg_view1 as
  select aggfns(distinct a,b,c order by a,c using ~<~,b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	create or replace view agg_view1 as
	^
<sql-statement>
select * from agg_view1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_view1
    
<sql-statement>
select pg_get_viewdef('agg_view1'::regclass);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('agg_view1'::regclass);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "agg_view1" does not exist

        	select pg_get_viewdef('agg_view1'::regclass);
	^
<sql-statement>
drop view agg_view1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: View not found: 'agg_view1'
    	drop view agg_view1;
	^
<sql-statement>
-- incorrect DISTINCT usage errors
select aggfns(distinct a,b,c order by i)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,b,c order by i)
	       ^
<sql-statement>
select aggfns(distinct a,b,c order by a,b+1)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,b,c order by a,b+1)
	       ^
<sql-statement>
select aggfns(distinct a,b,c order by a,b,i,c)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,b,c order by a,b,i,c)
	       ^
<sql-statement>
select aggfns(distinct a,a,c order by a,b)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,a,c order by a,b)
	       ^
<sql-statement>
-- string_agg tests
select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
</sql-statement>
<sql-statement>
select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
</sql-statement>
<sql-statement>
select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
</sql-statement>
<sql-statement>
select string_agg(a,',') from (values(null),(null)) g(a);
</sql-statement>
<sql-statement>
-- check some implicit casting cases, as per bug #5564
select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
	       ^
<sql-statement>
select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
	       ^
<sql-statement>
select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
	       ^
<sql-statement>
select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
	       ^
<sql-statement>
-- string_agg bytea tests
create table bytea_test_table(v bytea);
</sql-statement>
<sql-statement>
select string_agg(v, '') from bytea_test_table;
</sql-statement>
<sql-statement>
insert into bytea_test_table values(decode('ff','hex'));
</sql-statement>
<sql-statement>
select string_agg(v, '') from bytea_test_table;
</sql-statement>
<sql-statement>
insert into bytea_test_table values(decode('aa','hex'));
</sql-statement>
<sql-statement>
select string_agg(v, '') from bytea_test_table;
</sql-statement>
<sql-statement>
select string_agg(v, NULL) from bytea_test_table;
</sql-statement>
<sql-statement>
select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
</sql-statement>
<sql-statement>
drop table bytea_test_table;
</sql-statement>
<sql-statement>
-- FILTER tests
select min(unique1) filter (where unique1 > 100) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_filter
    	select min(unique1) filter (where unique1 > 100) from tenk1;
	       ^
<sql-statement>
select sum(1/ten) filter (where ten > 0) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_filter
    	select sum(1/ten) filter (where ten > 0) from tenk1;
	       ^
<sql-statement>
select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
group by ten;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:13: Error: FuncCall: unsupported agg_filter
    	select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
	            ^
<sql-statement>
select ten, sum(distinct four) filter (where four > 10) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:3:43: Error: Aggregate functions are not allowed in: WHERE
    	having exists (select 1 from onek b where sum(distinct a.four) = b.four);
	                                          ^
<sql-statement>
select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
from (values ('a', 'b')) AS v(foo,bar);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_filter
    	select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
	       ^
<sql-statement>
-- outer reference in FILTER (PostgreSQL extension)
select (select count(*)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
</sql-statement>
<sql-statement>
select (select count(*) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:16: Error: FuncCall: unsupported agg_filter
    	select (select count(*) filter (where outer_c <> 0)
	               ^
<sql-statement>
select (select count(inner_c) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:16: Error: FuncCall: unsupported agg_filter
    	select (select count(inner_c) filter (where outer_c <> 0)
	               ^
<sql-statement>
select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
     filter (where o.unique1 < 10))
from tenk1 o;					-- outer query is aggregation query
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:11: Error: FuncCall: unsupported agg_filter
    	  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
	          ^
<sql-statement>
-- subquery in FILTER clause (PostgreSQL extension)
select sum(unique1) FILTER (WHERE
  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_filter
    	select sum(unique1) FILTER (WHERE
	       ^
<sql-statement>
-- exercise lots of aggregate parts with FILTER
select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
    generate_series(1,2) i;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
	       ^
<sql-statement>
-- check handling of bare boolean Var in FILTER
select max(0) filter (where b1) from bool_test;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_filter
    	select max(0) filter (where b1) from bool_test;
	       ^
<sql-statement>
select (select max(0) filter (where b1)) from bool_test;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:16: Error: FuncCall: unsupported agg_filter
    	select (select max(0) filter (where b1)) from bool_test;
	               ^
<sql-statement>
-- check for correct detection of nested-aggregate errors in FILTER
select max(unique1) filter (where sum(ten) > 0) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_filter
    	select max(unique1) filter (where sum(ten) > 0) from tenk1;
	       ^
<sql-statement>
select (select max(unique1) filter (where sum(ten) > 0) from int8_tbl) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:16: Error: FuncCall: unsupported agg_filter
    	select (select max(unique1) filter (where sum(ten) > 0) from int8_tbl) from tenk1;
	               ^
<sql-statement>
select max(unique1) filter (where bool_or(ten > 0)) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_filter
    	select max(unique1) filter (where bool_or(ten > 0)) from tenk1;
	       ^
<sql-statement>
select (select max(unique1) filter (where bool_or(ten > 0)) from int8_tbl) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:16: Error: FuncCall: unsupported agg_filter
    	select (select max(unique1) filter (where bool_or(ten > 0)) from int8_tbl) from tenk1;
	               ^
<sql-statement>
-- ordered-set aggregates
select p, percentile_cont(p) within group (order by x::float8)
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:11: Error: FuncCall: unsupported agg_order
    	select p, percentile_cont(p) within group (order by x::float8)
	          ^
<sql-statement>
select p, percentile_cont(p order by p) within group (order by x)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:42: Error: ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP

    	select p, percentile_cont(p order by p) within group (order by x)  -- error
	                                         ^
<sql-statement>
select p, sum() within group (order by x::float8)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:11: Error: FuncCall: unsupported agg_order
    	select p, sum() within group (order by x::float8)  -- error
	          ^
<sql-statement>
select p, percentile_cont(p,p)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select p, percentile_cont(p,p)  -- error
	^
        -stdin-:<main>:1:11: Error: At function: PgResolvedCall
        	select p, percentile_cont(p,p)  -- error
	          ^
            -stdin-:<main>:1:11: Error: Aggregate function percentile_cont cannot be called directly
            	select p, percentile_cont(p,p)  -- error
	          ^
<sql-statement>
select percentile_cont(0.5) within group (order by b) from aggtest;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_cont(0.5) within group (order by b) from aggtest;
	       ^
<sql-statement>
select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
	       ^
<sql-statement>
select percentile_cont(0.5) within group (order by thousand) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_cont(0.5) within group (order by thousand) from tenk1;
	       ^
<sql-statement>
select percentile_disc(0.5) within group (order by thousand) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_disc(0.5) within group (order by thousand) from tenk1;
	       ^
<sql-statement>
select rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select rank(3) within group (order by x)
	       ^
<sql-statement>
select cume_dist(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select cume_dist(3) within group (order by x)
	       ^
<sql-statement>
select percent_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percent_rank(3) within group (order by x)
	       ^
<sql-statement>
select dense_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select dense_rank(3) within group (order by x)
	       ^
<sql-statement>
select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
	       ^
<sql-statement>
select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
	       ^
<sql-statement>
select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
	       ^
<sql-statement>
select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
from generate_series(1,6) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
	       ^
<sql-statement>
select ten, mode() within group (order by string4) from tenk1 group by ten;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:13: Error: FuncCall: unsupported agg_order
    	select ten, mode() within group (order by string4) from tenk1 group by ten;
	            ^
<sql-statement>
select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
	       ^
<sql-statement>
-- check collation propagates up in suitable cases:
select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
  from (values ('fred'),('jim')) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:25: Error: FuncCall: unsupported agg_order
    	select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
	                        ^
<sql-statement>
-- ordered-set aggs created with CREATE AGGREGATE
select test_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select test_rank(3) within group (order by x)
	       ^
<sql-statement>
select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
	       ^
<sql-statement>
-- ordered-set aggs can't use ungrouped vars in direct args:
select rank(x) within group (order by x) from generate_series(1,5) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select rank(x) within group (order by x) from generate_series(1,5) x;
	       ^
<sql-statement>
-- outer-level agg can't use a grouped arg of a lower level, either:
select array(select percentile_disc(a) within group (order by x)
               from (values (0.3),(0.7)) v(a) group by a)
  from generate_series(1,5) g(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:21: Error: FuncCall: unsupported agg_order
    	select array(select percentile_disc(a) within group (order by x)
	                    ^
<sql-statement>
-- agg in the direct args is a grouping violation, too:
select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
	       ^
<sql-statement>
-- hypothetical-set type unification and argument-count failures:
select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
	       ^
<sql-statement>
select rank(3) within group (order by stringu1,stringu2) from tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select rank(3) within group (order by stringu1,stringu2) from tenk1;
	       ^
<sql-statement>
select rank('fred') within group (order by x) from generate_series(1,5) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select rank('fred') within group (order by x) from generate_series(1,5) x;
	       ^
<sql-statement>
select rank('adam'::text collate "C") within group (order by x collate "POSIX")
  from (values ('fred'),('jim')) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select rank('adam'::text collate "C") within group (order by x collate "POSIX")
	       ^
<sql-statement>
-- hypothetical-set type unification successes:
select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
	       ^
<sql-statement>
select rank('3') within group (order by x) from generate_series(1,5) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	select rank('3') within group (order by x) from generate_series(1,5) x;
	       ^
<sql-statement>
-- divide by zero check
select percent_rank(0) within group (order by x) from generate_series(1,0) x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	select percent_rank(0) within group (order by x) from generate_series(1,0) x;
	       ^
<sql-statement>
-- deparse and multiple features:
create view aggordview1 as
select ten,
       percentile_disc(0.5) within group (order by thousand) as p50,
       percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
       rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
  from tenk1
 group by ten order by ten;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	-- deparse and multiple features:
	^
<sql-statement>
select pg_get_viewdef('aggordview1');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select pg_get_viewdef('aggordview1');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "aggordview1" does not exist

        	select pg_get_viewdef('aggordview1');
	^
<sql-statement>
select * from aggordview1 order by ten;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.aggordview1
    
<sql-statement>
drop view aggordview1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: View not found: 'aggordview1'
    	drop view aggordview1;
	^
<sql-statement>
-- variadic aggregates
select least_agg(q1,q2) from int8_tbl;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- variadic aggregates
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select least_agg(q1,q2) from int8_tbl;
	       ^
            -stdin-:<main>:2:8: Error: No such proc: least_agg
            	select least_agg(q1,q2) from int8_tbl;
	       ^
<sql-statement>
select least_agg(variadic array[q1,q2]) from int8_tbl;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	select least_agg(variadic array[q1,q2]) from int8_tbl;
	       ^
<sql-statement>
select cleast_agg(q1,q2) from int8_tbl;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select cleast_agg(q1,q2) from int8_tbl;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select cleast_agg(q1,q2) from int8_tbl;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: cleast_agg
            	select cleast_agg(q1,q2) from int8_tbl;
	       ^
<sql-statement>
select cleast_agg(4.5,f1) from int4_tbl;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select cleast_agg(4.5,f1) from int4_tbl;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select cleast_agg(4.5,f1) from int4_tbl;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: cleast_agg
            	select cleast_agg(4.5,f1) from int4_tbl;
	       ^
<sql-statement>
select cleast_agg(variadic array[4.5,f1]) from int4_tbl;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	select cleast_agg(variadic array[4.5,f1]) from int4_tbl;
	       ^
<sql-statement>
select pg_typeof(cleast_agg(variadic array[4.5,f1])) from int4_tbl;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:18: Error: FuncCall: unsupported func_variadic
    	select pg_typeof(cleast_agg(variadic array[4.5,f1])) from int4_tbl;
	                 ^
<sql-statement>
-- test aggregates with common transition functions share the same states
begin work;
</sql-statement>
<sql-statement>
create type avg_state as (total bigint, count bigint);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 314
    	create type avg_state as (total bigint, count bigint);
	^
<sql-statement>
create or replace function avg_transfn(state avg_state, n int) returns avg_state as
$$
declare new_state avg_state;
begin
	raise notice 'avg_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;
	return null;
end
$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create or replace function avg_transfn(state avg_state, n int) returns avg_state as
	^
<sql-statement>
create function avg_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total / state.count;
	end if;
end
$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create function avg_finalfn(state avg_state) returns int4 as
	^
<sql-statement>
create function sum_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total;
	end if;
end
$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create function sum_finalfn(state avg_state) returns int4 as
	^
<sql-statement>
create aggregate my_avg(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = avg_finalfn
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	create aggregate my_avg(int4)
	^
<sql-statement>
create aggregate my_sum(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = sum_finalfn
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	create aggregate my_sum(int4)
	^
<sql-statement>
-- aggregate state should be shared as aggs are the same.
select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- aggregate state should be shared as aggs are the same.
	^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- aggregate state should be shared as aggs are the same.
	^
            -stdin-:<main>:2:8: Error: At function: PgCall
            	select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
	       ^
                -stdin-:<main>:2:8: Error: No such proc: my_avg
                	select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
	       ^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- aggregate state should be shared as aggs are the same.
	^
            -stdin-:<main>:2:20: Error: At function: PgCall
            	select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
	                   ^
                -stdin-:<main>:2:20: Error: No such proc: my_avg
                	select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
	                   ^
<sql-statement>
-- aggregate state should be shared as transfn is the same for both aggs.
select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- aggregate state should be shared as transfn is the same for both aggs.
	^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- aggregate state should be shared as transfn is the same for both aggs.
	^
            -stdin-:<main>:2:8: Error: At function: PgCall
            	select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
	       ^
                -stdin-:<main>:2:8: Error: No such proc: my_avg
                	select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
	       ^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- aggregate state should be shared as transfn is the same for both aggs.
	^
            -stdin-:<main>:2:20: Error: At function: PgCall
            	select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
	                   ^
                -stdin-:<main>:2:20: Error: No such proc: my_sum
                	select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
	                   ^
<sql-statement>
-- same as previous one, but with DISTINCT, which requires sorting the input.
select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: agg_distinct must be set only for aggregate functions
    	select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
	       ^
<sql-statement>
-- shouldn't share states due to the distinctness not matching.
select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: agg_distinct must be set only for aggregate functions
    	select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
	       ^
<sql-statement>
-- shouldn't share states due to the filter clause not matching.
select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_filter
    	select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
	       ^
<sql-statement>
-- this should not share the state due to different input columns.
select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- this should not share the state due to different input columns.
	^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- this should not share the state due to different input columns.
	^
            -stdin-:<main>:2:8: Error: At function: PgCall
            	select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
	       ^
                -stdin-:<main>:2:8: Error: No such proc: my_avg
                	select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
	       ^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- this should not share the state due to different input columns.
	^
            -stdin-:<main>:2:20: Error: At function: PgCall
            	select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
	                   ^
                -stdin-:<main>:2:20: Error: No such proc: my_sum
                	select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
	                   ^
<sql-statement>
-- exercise cases where OSAs share state
select
  percentile_cont(0.5) within group (order by a),
  percentile_disc(0.5) within group (order by a)
from (values(1::float8),(3),(5),(7)) t(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:3:3: Error: FuncCall: unsupported agg_order
    	  percentile_cont(0.5) within group (order by a),
	  ^
<sql-statement>
select
  percentile_cont(0.25) within group (order by a),
  percentile_disc(0.5) within group (order by a)
from (values(1::float8),(3),(5),(7)) t(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:3: Error: FuncCall: unsupported agg_order
    	  percentile_cont(0.25) within group (order by a),
	  ^
<sql-statement>
-- these can't share state currently
select
  rank(4) within group (order by a),
  dense_rank(4) within group (order by a)
from (values(1),(3),(5),(7)) t(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:3:3: Error: FuncCall: unsupported agg_order
    	  rank(4) within group (order by a),
	  ^
<sql-statement>
-- test that aggs with the same sfunc and initcond share the same agg state
create aggregate my_sum_init(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = sum_finalfn,
   initcond = '(10,0)'
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	-- test that aggs with the same sfunc and initcond share the same agg state
	^
<sql-statement>
create aggregate my_avg_init(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = avg_finalfn,
   initcond = '(10,0)'
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	create aggregate my_avg_init(int4)
	^
<sql-statement>
create aggregate my_avg_init2(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = avg_finalfn,
   initcond = '(4,0)'
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	create aggregate my_avg_init2(int4)
	^
<sql-statement>
-- state should be shared if INITCONDs are matching
select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- state should be shared if INITCONDs are matching
	^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- state should be shared if INITCONDs are matching
	^
            -stdin-:<main>:2:8: Error: At function: PgCall
            	select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
	       ^
                -stdin-:<main>:2:8: Error: No such proc: my_sum_init
                	select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
	       ^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- state should be shared if INITCONDs are matching
	^
            -stdin-:<main>:2:25: Error: At function: PgCall
            	select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
	                        ^
                -stdin-:<main>:2:25: Error: No such proc: my_avg_init
                	select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
	                        ^
<sql-statement>
-- Varying INITCONDs should cause the states not to be shared.
select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- Varying INITCONDs should cause the states not to be shared.
	^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- Varying INITCONDs should cause the states not to be shared.
	^
            -stdin-:<main>:2:8: Error: At function: PgCall
            	select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
	       ^
                -stdin-:<main>:2:8: Error: No such proc: my_sum_init
                	select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
	       ^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- Varying INITCONDs should cause the states not to be shared.
	^
            -stdin-:<main>:2:25: Error: At function: PgCall
            	select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
	                        ^
                -stdin-:<main>:2:25: Error: No such proc: my_avg_init2
                	select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
	                        ^
<sql-statement>
rollback;
</sql-statement>
<sql-statement>
-- test aggregate state sharing to ensure it works if one aggregate has a
-- finalfn and the other one has none.
begin work;
</sql-statement>
<sql-statement>
create or replace function sum_transfn(state int4, n int4) returns int4 as
$$
declare new_state int4;
begin
	raise notice 'sum_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state := state + n;
		return state;
	end if;
	return null;
end
$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create or replace function sum_transfn(state int4, n int4) returns int4 as
	^
<sql-statement>
create function halfsum_finalfn(state int4) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state / 2;
	end if;
end
$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create function halfsum_finalfn(state int4) returns int4 as
	^
<sql-statement>
create aggregate my_sum(int4)
(
   stype = int4,
   sfunc = sum_transfn
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	create aggregate my_sum(int4)
	^
<sql-statement>
create aggregate my_half_sum(int4)
(
   stype = int4,
   sfunc = sum_transfn,
   finalfunc = halfsum_finalfn
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	create aggregate my_half_sum(int4)
	^
<sql-statement>
-- Agg state should be shared even though my_sum has no finalfn
select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem
    	-- Agg state should be shared even though my_sum has no finalfn
	^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- Agg state should be shared even though my_sum has no finalfn
	^
            -stdin-:<main>:2:8: Error: At function: PgCall
            	select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
	       ^
                -stdin-:<main>:2:8: Error: No such proc: my_sum
                	select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
	       ^
        -stdin-:<main>:1:1: Error: At function: PgResultItem
        	-- Agg state should be shared even though my_sum has no finalfn
	^
            -stdin-:<main>:2:20: Error: At function: PgCall
            	select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
	                   ^
                -stdin-:<main>:2:20: Error: No such proc: my_half_sum
                	select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
	                   ^
<sql-statement>
rollback;
</sql-statement>
<sql-statement>
-- test that the aggregate transition logic correctly handles
-- transition / combine functions returning NULL
-- First test the case of a normal transition function returning NULL
BEGIN;
</sql-statement>
<sql-statement>
CREATE FUNCTION balkifnull(int8, int4)
RETURNS int8
STRICT
LANGUAGE plpgsql AS $$
BEGIN
    IF $1 IS NULL THEN
       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$$;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	CREATE FUNCTION balkifnull(int8, int4)
	^
<sql-statement>
CREATE AGGREGATE balk(int4)
(
    SFUNC = balkifnull(int8, int4),
    STYPE = int8,
    PARALLEL = SAFE,
    INITCOND = '0'
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	CREATE AGGREGATE balk(int4)
	^
<sql-statement>
SELECT balk(hundred) FROM tenk1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT balk(hundred) FROM tenk1;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT balk(hundred) FROM tenk1;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: balk
            	SELECT balk(hundred) FROM tenk1;
	       ^
<sql-statement>
ROLLBACK;
</sql-statement>
<sql-statement>
-- Secondly test the case of a parallel aggregate combiner function
-- returning NULL. For that use normal transition function, but a
-- combiner function returning NULL.
BEGIN;
</sql-statement>
<sql-statement>
CREATE FUNCTION balkifnull(int8, int8)
RETURNS int8
PARALLEL SAFE
STRICT
LANGUAGE plpgsql AS $$
BEGIN
    IF $1 IS NULL THEN
       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$$;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	CREATE FUNCTION balkifnull(int8, int8)
	^
<sql-statement>
CREATE AGGREGATE balk(int4)
(
    SFUNC = int4_sum(int8, int4),
    STYPE = int8,
    COMBINEFUNC = balkifnull(int8, int8),
    PARALLEL = SAFE,
    INITCOND = '0'
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 255
    	CREATE AGGREGATE balk(int4)
	^
<sql-statement>
-- force use of parallelism
ALTER TABLE tenk1 set (parallel_workers = 4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	-- force use of parallelism
	^
<sql-statement>
SET LOCAL parallel_setup_cost=0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: parallel_setup_cost
    	SET LOCAL parallel_setup_cost=0;
	^
<sql-statement>
SET LOCAL max_parallel_workers_per_gather=4;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: max_parallel_workers_per_gather
    	SET LOCAL max_parallel_workers_per_gather=4;
	^
<sql-statement>
EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
	^
<sql-statement>
SELECT balk(hundred) FROM tenk1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT balk(hundred) FROM tenk1;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT balk(hundred) FROM tenk1;
	       ^
            -stdin-:<main>:1:8: Error: No such proc: balk
            	SELECT balk(hundred) FROM tenk1;
	       ^
<sql-statement>
ROLLBACK;
</sql-statement>
<sql-statement>
-- test coverage for aggregate combine/serial/deserial functions
BEGIN;
</sql-statement>
<sql-statement>
SET parallel_setup_cost = 0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: parallel_setup_cost
    	SET parallel_setup_cost = 0;
	^
<sql-statement>
SET parallel_tuple_cost = 0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: parallel_tuple_cost
    	SET parallel_tuple_cost = 0;
	^
<sql-statement>
SET min_parallel_table_scan_size = 0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: min_parallel_table_scan_size
    	SET min_parallel_table_scan_size = 0;
	^
<sql-statement>
SET max_parallel_workers_per_gather = 4;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: max_parallel_workers_per_gather
    	SET max_parallel_workers_per_gather = 4;
	^
<sql-statement>
SET parallel_leader_participation = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: parallel_leader_participation
    	SET parallel_leader_participation = off;
	^
<sql-statement>
SET enable_indexonlyscan = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_indexonlyscan
    	SET enable_indexonlyscan = off;
	^
<sql-statement>
-- variance(int4) covers numeric_poly_combine
-- sum(int8) covers int8_avg_combine
-- regr_count(float8, float8) covers int8inc_float8_float8 and aggregates with > 1 arg
EXPLAIN (COSTS OFF, VERBOSE)
SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- variance(int4) covers numeric_poly_combine
	^
<sql-statement>
SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
</sql-statement>
<sql-statement>
-- variance(int8) covers numeric_combine
-- avg(numeric) covers numeric_avg_combine
EXPLAIN (COSTS OFF, VERBOSE)
SELECT variance(unique1::int8), avg(unique1::numeric)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	-- variance(int8) covers numeric_combine
	^
<sql-statement>
SELECT variance(unique1::int8), avg(unique1::numeric)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
</sql-statement>
<sql-statement>
ROLLBACK;
</sql-statement>
<sql-statement>
-- test coverage for dense_rank
SELECT dense_rank(x) WITHIN GROUP (ORDER BY x) FROM (VALUES (1),(1),(2),(2),(3),(3)) v(x) GROUP BY (x) ORDER BY 1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: FuncCall: unsupported agg_order
    	SELECT dense_rank(x) WITHIN GROUP (ORDER BY x) FROM (VALUES (1),(1),(2),(2),(3),(3)) v(x) GROUP BY (x) ORDER BY 1;
	       ^
<sql-statement>
-- Ensure that the STRICT checks for aggregates does not take NULLness
-- of ORDER BY columns into account. See bug report around
-- 2a505161-2727-2473-7c46-591ed108ac52@email.cz
SELECT min(x ORDER BY y) FROM (VALUES(1, NULL)) AS d(x,y);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:8: Error: FuncCall: unsupported agg_order
    	SELECT min(x ORDER BY y) FROM (VALUES(1, NULL)) AS d(x,y);
	       ^
<sql-statement>
SELECT min(x ORDER BY y) FROM (VALUES(1, 2)) AS d(x,y);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT min(x ORDER BY y) FROM (VALUES(1, 2)) AS d(x,y);
	       ^
<sql-statement>
-- check collation-sensitive matching between grouping expressions
select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
</sql-statement>
<sql-statement>
select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
</sql-statement>
<sql-statement>
-- Make sure that generation of HashAggregate for uniqification purposes
-- does not lead to array overflow due to unexpected duplicate hash keys
-- see CAFeeJoKKu0u+A_A9R9316djW-YW3-+Gtgvy3ju655qRHR3jtdA@mail.gmail.com
set enable_memoize to off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_memoize
    	-- Make sure that generation of HashAggregate for uniqification purposes
	^
<sql-statement>
explain (costs off)
  select 1 from tenk1
   where (hundred, thousand) in (select twothousand, twothousand from onek);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
reset enable_memoize;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	reset enable_memoize;
	^
<sql-statement>
--
-- Hash Aggregation Spill tests
--
set enable_sort=false;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_sort
    	--
	^
<sql-statement>
set work_mem='64kB';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: work_mem
    	set work_mem='64kB';
	^
<sql-statement>
select unique1, count(*), sum(twothousand) from tenk1
group by unique1
having sum(fivethous) > 4975
order by sum(twothousand);
</sql-statement>
<sql-statement>
set work_mem to default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 1
    	set work_mem to default;
	^
<sql-statement>
set enable_sort to default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 1
    	set enable_sort to default;
	^
<sql-statement>
--
-- Compare results between plans using sorting and plans using hash
-- aggregation. Force spilling in both cases by setting work_mem low.
--
set work_mem='64kB';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: work_mem
    	--
	^
<sql-statement>
create table agg_data_2k as
select g from generate_series(0, 1999) g;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_data_2k as
	^
<sql-statement>
analyze agg_data_2k;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 275
    	analyze agg_data_2k;
	^
<sql-statement>
create table agg_data_20k as
select g from generate_series(0, 19999) g;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_data_20k as
	^
<sql-statement>
analyze agg_data_20k;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 275
    	analyze agg_data_20k;
	^
<sql-statement>
-- Produce results with sorting.
set enable_hashagg = false;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_hashagg
    	-- Produce results with sorting.
	^
<sql-statement>
set jit_above_cost = 0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: jit_above_cost
    	set jit_above_cost = 0;
	^
<sql-statement>
explain (costs off)
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
create table agg_group_1 as
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_group_1 as
	^
<sql-statement>
create table agg_group_2 as
select * from
  (values (100), (300), (500)) as r(a),
  lateral (
    select (g/2)::numeric as c1,
           array_agg(g::numeric) as c2,
	   count(*) as c3
    from agg_data_2k
    where g < r.a
    group by g/2) as s;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_group_2 as
	^
<sql-statement>
set jit_above_cost to default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 1
    	set jit_above_cost to default;
	^
<sql-statement>
create table agg_group_3 as
select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
  from agg_data_2k group by g/2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_group_3 as
	^
<sql-statement>
create table agg_group_4 as
select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
  from agg_data_2k group by g/2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_group_4 as
	^
<sql-statement>
-- Produce results with hash aggregation
set enable_hashagg = true;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_hashagg
    	-- Produce results with hash aggregation
	^
<sql-statement>
set enable_sort = false;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_sort
    	set enable_sort = false;
	^
<sql-statement>
set jit_above_cost = 0;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: jit_above_cost
    	set jit_above_cost = 0;
	^
<sql-statement>
explain (costs off)
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	explain (costs off)
	^
<sql-statement>
create table agg_hash_1 as
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_hash_1 as
	^
<sql-statement>
create table agg_hash_2 as
select * from
  (values (100), (300), (500)) as r(a),
  lateral (
    select (g/2)::numeric as c1,
           array_agg(g::numeric) as c2,
	   count(*) as c3
    from agg_data_2k
    where g < r.a
    group by g/2) as s;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_hash_2 as
	^
<sql-statement>
set jit_above_cost to default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 1
    	set jit_above_cost to default;
	^
<sql-statement>
create table agg_hash_3 as
select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
  from agg_data_2k group by g/2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_hash_3 as
	^
<sql-statement>
create table agg_hash_4 as
select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
  from agg_data_2k group by g/2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	create table agg_hash_4 as
	^
<sql-statement>
set enable_sort = true;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_sort
    	set enable_sort = true;
	^
<sql-statement>
set work_mem to default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 1
    	set work_mem to default;
	^
<sql-statement>
-- Compare group aggregation results to hash aggregation results
(select * from agg_hash_1 except select * from agg_group_1)
  union all
(select * from agg_group_1 except select * from agg_hash_1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_group_1
    
<sql-statement>
(select * from agg_hash_2 except select * from agg_group_2)
  union all
(select * from agg_group_2 except select * from agg_hash_2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_group_2
    
<sql-statement>
(select * from agg_hash_3 except select * from agg_group_3)
  union all
(select * from agg_group_3 except select * from agg_hash_3);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_hash_3
    
<sql-statement>
(select * from agg_hash_4 except select * from agg_group_4)
  union all
(select * from agg_group_4 except select * from agg_hash_4);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.agg_hash_4
    
<sql-statement>
drop table agg_group_1;
</sql-statement>
<sql-statement>
drop table agg_group_2;
</sql-statement>
<sql-statement>
drop table agg_group_3;
</sql-statement>
<sql-statement>
drop table agg_group_4;
</sql-statement>
<sql-statement>
drop table agg_hash_1;
</sql-statement>
<sql-statement>
drop table agg_hash_2;
</sql-statement>
<sql-statement>
drop table agg_hash_3;
</sql-statement>
<sql-statement>
drop table agg_hash_4;
</sql-statement>
