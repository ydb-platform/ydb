<sql-statement>
--
-- insert with DEFAULT in the target_list
--
create table inserttest (col1 int4, col2 int4 NOT NULL, col3 text default 'testing');
</sql-statement>
<sql-statement>
insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
	^
<sql-statement>
insert into inserttest (col2, col3) values (3, DEFAULT);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest (col2, col3) values (3, DEFAULT);
	^
<sql-statement>
insert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
	^
<sql-statement>
insert into inserttest values (DEFAULT, 5, 'test');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest values (DEFAULT, 5, 'test');
	^
<sql-statement>
insert into inserttest values (DEFAULT, 7);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest values (DEFAULT, 7);
	^
<sql-statement>
select * from inserttest;
</sql-statement>
<sql-statement>
--
-- insert with similar expression / target_list values (all fail)
--
insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	--
	^
<sql-statement>
insert into inserttest (col1, col2, col3) values (1, 2);
</sql-statement>
<sql-statement>
insert into inserttest (col1) values (1, 2);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: YtWriteTable!
    	insert into inserttest (col1) values (1, 2);
	^
        -stdin-:<main>:1:1: Error: values have 2 columns, INSERT INTO expects: 1
        	insert into inserttest (col1) values (1, 2);
	^
<sql-statement>
insert into inserttest (col1) values (DEFAULT, DEFAULT);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest (col1) values (DEFAULT, DEFAULT);
	^
<sql-statement>
select * from inserttest;
</sql-statement>
<sql-statement>
--
-- VALUES test
--
insert into inserttest values(10, 20, '40'), (-1, 2, DEFAULT),
    ((select 2), (select i from (values(3)) as foo (i)), 'values are fun!');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	--
	^
<sql-statement>
select * from inserttest;
</sql-statement>
<sql-statement>
--
-- TOASTed value test
--
insert into inserttest values(30, 50, repeat('x', 10000));
</sql-statement>
<sql-statement>
select col1, col2, char_length(col3) from inserttest;
</sql-statement>
<sql-statement>
drop table inserttest;
</sql-statement>
<sql-statement>
--
-- tuple larger than fillfactor
--
CREATE TABLE large_tuple_test (a int, b text) WITH (fillfactor = 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table options not supported
    	--
	^
<sql-statement>
ALTER TABLE large_tuple_test ALTER COLUMN b SET STORAGE plain;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	ALTER TABLE large_tuple_test ALTER COLUMN b SET STORAGE plain;
	^
<sql-statement>
-- create page w/ free space in range [nearlyEmptyFreeSpace, MaxHeapTupleSize)
INSERT INTO large_tuple_test (select 1, NULL);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.large_tuple_test
    
<sql-statement>
-- should still fit on the page
INSERT INTO large_tuple_test (select 2, repeat('a', 1000));
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.large_tuple_test
    
<sql-statement>
SELECT pg_size_pretty(pg_relation_size('large_tuple_test'::regclass, 'main'));
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT pg_size_pretty(pg_relation_size('large_tuple_test'::regclass, 'main'));
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  relation "large_tuple_test" does not exist

        	SELECT pg_size_pretty(pg_relation_size('large_tuple_test'::regclass, 'main'));
	^
<sql-statement>
-- add small record to the second page
INSERT INTO large_tuple_test (select 3, NULL);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.large_tuple_test
    
<sql-statement>
-- now this tuple won't fit on the second page, but the insert should
-- still succeed by extending the relation
INSERT INTO large_tuple_test (select 4, repeat('a', 8126));
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.large_tuple_test
    
<sql-statement>
DROP TABLE large_tuple_test;
</sql-statement>
<sql-statement>
--
-- check indirection (field/array assignment), cf bug #14265
--
-- these tests are aware that transformInsertStmt has 3 separate code paths
--
create type insert_test_type as (if1 int, if2 text[]);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 314
    	--
	^
<sql-statement>
create table inserttest (f1 int, f2 int[],
                         f3 insert_test_type, f4 insert_test_type[]);
</sql-statement>
<sql-statement>
insert into inserttest (f2[1], f2[2]) values (1,2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f2[1], f2[2]) values (3,4), (5,6);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f2[1], f2[2]) select 7,8;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supported
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supported
	^
<sql-statement>
insert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f3.if1, f3.if2) values (1,'{foo}'), (2,'{bar}');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f3.if1, f3.if2) select 3, '{baz,quux}';
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f3.if1, f3.if2) values (1,default);  -- not supported
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 148
    	insert into inserttest (f3.if1, f3.if2) values (1,default);  -- not supported
	^
<sql-statement>
insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar'), ('baz', 'quux');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f3.if2[1], f3.if2[2]) select 'bear', 'beer';
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar'), ('baz', 'quux');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) select 'bear', 'beer';
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
select * from inserttest;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.inserttest
    
<sql-statement>
-- also check reverse-listing
create table inserttest2 (f1 bigint, f2 text);
</sql-statement>
<sql-statement>
create rule irule1 as on insert to inserttest2 do also
  insert into inserttest (f3.if2[1], f3.if2[2])
  values (new.f1,new.f2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 265
    	create rule irule1 as on insert to inserttest2 do also
	^
<sql-statement>
create rule irule2 as on insert to inserttest2 do also
  insert into inserttest (f4[1].if1, f4[1].if2[2])
  values (1,'fool'),(new.f1,new.f2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 265
    	create rule irule2 as on insert to inserttest2 do also
	^
<sql-statement>
create rule irule3 as on insert to inserttest2 do also
  insert into inserttest (f4[1].if1, f4[1].if2[2])
  select new.f1, new.f2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 265
    	create rule irule3 as on insert to inserttest2 do also
	^
<sql-statement>
\d+ inserttest2
</sql-statement>
Metacommand \d+ inserttest2 is not supported
<sql-statement>
drop table inserttest2;
</sql-statement>
<sql-statement>
drop table inserttest;
</sql-statement>
<sql-statement>
drop type insert_test_type;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	drop type insert_test_type;
	^
<sql-statement>
-- direct partition inserts should check partition bound constraint
create table range_parted (
	a text,
	b int
) partition by range (a, (b+0));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- direct partition inserts should check partition bound constraint
	^
<sql-statement>
-- no partitions, so fail
insert into range_parted values ('a', 11);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part1 partition of range_parted for values from ('a', 1) to ('a', 10);
	^
<sql-statement>
create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part2 partition of range_parted for values from ('a', 10) to ('a', 20);
	^
<sql-statement>
create table part3 partition of range_parted for values from ('b', 1) to ('b', 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part3 partition of range_parted for values from ('b', 1) to ('b', 10);
	^
<sql-statement>
create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part4 partition of range_parted for values from ('b', 10) to ('b', 20);
	^
<sql-statement>
-- fail
insert into part1 values ('a', 11);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part1
    
<sql-statement>
insert into part1 values ('b', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part1
    
<sql-statement>
-- ok
insert into part1 values ('a', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part1
    
<sql-statement>
-- fail
insert into part4 values ('b', 21);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part4
    
<sql-statement>
insert into part4 values ('a', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part4
    
<sql-statement>
-- ok
insert into part4 values ('b', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part4
    
<sql-statement>
-- fail (partition key a has a NOT NULL constraint)
insert into part1 values (null);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part1
    
<sql-statement>
-- fail (expression key (b+0) cannot be null either)
insert into part1 values (1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part1
    
<sql-statement>
create table list_parted (
	a text,
	b int
) partition by list (lower(a));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	create table list_parted (
	^
<sql-statement>
create table part_aa_bb partition of list_parted FOR VALUES IN ('aa', 'bb');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_aa_bb partition of list_parted FOR VALUES IN ('aa', 'bb');
	^
<sql-statement>
create table part_cc_dd partition of list_parted FOR VALUES IN ('cc', 'dd');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_cc_dd partition of list_parted FOR VALUES IN ('cc', 'dd');
	^
<sql-statement>
create table part_null partition of list_parted FOR VALUES IN (null);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_null partition of list_parted FOR VALUES IN (null);
	^
<sql-statement>
-- fail
insert into part_aa_bb values ('cc', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_aa_bb
    
<sql-statement>
insert into part_aa_bb values ('AAa', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_aa_bb
    
<sql-statement>
insert into part_aa_bb values (null);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_aa_bb
    
<sql-statement>
-- ok
insert into part_cc_dd values ('cC', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_cc_dd
    
<sql-statement>
insert into part_null values (null, 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_null
    
<sql-statement>
-- check in case of multi-level partitioned table
create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- check in case of multi-level partitioned table
	^
<sql-statement>
create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_ee_ff1 partition of part_ee_ff for values from (1) to (10);
	^
<sql-statement>
create table part_ee_ff2 partition of part_ee_ff for values from (10) to (20);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_ee_ff2 partition of part_ee_ff for values from (10) to (20);
	^
<sql-statement>
-- test default partition
create table part_default partition of list_parted default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- test default partition
	^
<sql-statement>
-- Negative test: a row, which would fit in other partition, does not fit
-- default partition, even when inserted directly
insert into part_default values ('aa', 2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
insert into part_default values (null, 2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
-- ok
insert into part_default values ('Zz', 2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
-- test if default partition works as expected for multi-level partitioned
-- table as well as when default partition itself is further partitioned
drop table part_default;
</sql-statement>
<sql-statement>
create table part_xx_yy partition of list_parted for values in ('xx', 'yy') partition by list (a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_xx_yy partition of list_parted for values in ('xx', 'yy') partition by list (a);
	^
<sql-statement>
create table part_xx_yy_p1 partition of part_xx_yy for values in ('xx');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_xx_yy_p1 partition of part_xx_yy for values in ('xx');
	^
<sql-statement>
create table part_xx_yy_defpart partition of part_xx_yy default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_xx_yy_defpart partition of part_xx_yy default;
	^
<sql-statement>
create table part_default partition of list_parted default partition by range(b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_default partition of list_parted default partition by range(b);
	^
<sql-statement>
create table part_default_p1 partition of part_default for values from (20) to (30);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_default_p1 partition of part_default for values from (20) to (30);
	^
<sql-statement>
create table part_default_p2 partition of part_default for values from (30) to (40);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_default_p2 partition of part_default for values from (30) to (40);
	^
<sql-statement>
-- fail
insert into part_ee_ff1 values ('EE', 11);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_ee_ff1
    
<sql-statement>
insert into part_default_p2 values ('gg', 43);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default_p2
    
<sql-statement>
-- fail (even the parent's, ie, part_ee_ff's partition constraint applies)
insert into part_ee_ff1 values ('cc', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_ee_ff1
    
<sql-statement>
insert into part_default values ('gg', 43);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
-- ok
insert into part_ee_ff1 values ('ff', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_ee_ff1
    
<sql-statement>
insert into part_ee_ff2 values ('ff', 11);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_ee_ff2
    
<sql-statement>
insert into part_default_p1 values ('cd', 25);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default_p1
    
<sql-statement>
insert into part_default_p2 values ('de', 35);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default_p2
    
<sql-statement>
insert into list_parted values ('ab', 21);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into list_parted values ('xx', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into list_parted values ('yy', 2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
select tableoid::regclass, * from list_parted;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
-- Check tuple routing for partitioned tables
-- fail
insert into range_parted values ('a', 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
-- ok
insert into range_parted values ('a', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
insert into range_parted values ('a', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
-- fail
insert into range_parted values ('a', 20);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
-- ok
insert into range_parted values ('b', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
insert into range_parted values ('b', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
-- fail (partition key (b+0) is null)
insert into range_parted values ('a');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
-- Check default partition
create table part_def partition of range_parted default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- Check default partition
	^
<sql-statement>
-- fail
insert into part_def values ('b', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_def
    
<sql-statement>
-- ok
insert into part_def values ('c', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_def
    
<sql-statement>
insert into range_parted values (null, null);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
insert into range_parted values ('a', null);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
insert into range_parted values (null, 19);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
insert into range_parted values ('b', 20);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
select tableoid::regclass, * from range_parted;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.range_parted
    
<sql-statement>
-- ok
insert into list_parted values (null, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into list_parted (a) values ('aA');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
-- fail (partition of part_ee_ff not found in both cases)
insert into list_parted values ('EE', 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into part_ee_ff values ('EE', 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_ee_ff
    
<sql-statement>
-- ok
insert into list_parted values ('EE', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into part_ee_ff values ('EE', 10);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_ee_ff
    
<sql-statement>
select tableoid::regclass, * from list_parted;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
-- some more tests to exercise tuple-routing with multi-level partitioning
create table part_gg partition of list_parted for values in ('gg') partition by range (b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- some more tests to exercise tuple-routing with multi-level partitioning
	^
<sql-statement>
create table part_gg1 partition of part_gg for values from (minvalue) to (1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_gg1 partition of part_gg for values from (minvalue) to (1);
	^
<sql-statement>
create table part_gg2 partition of part_gg for values from (1) to (10) partition by range (b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_gg2 partition of part_gg for values from (1) to (10) partition by range (b);
	^
<sql-statement>
create table part_gg2_1 partition of part_gg2 for values from (1) to (5);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_gg2_1 partition of part_gg2 for values from (1) to (5);
	^
<sql-statement>
create table part_gg2_2 partition of part_gg2 for values from (5) to (10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_gg2_2 partition of part_gg2 for values from (5) to (10);
	^
<sql-statement>
create table part_ee_ff3 partition of part_ee_ff for values from (20) to (30) partition by range (b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_ee_ff3 partition of part_ee_ff for values from (20) to (30) partition by range (b);
	^
<sql-statement>
create table part_ee_ff3_1 partition of part_ee_ff3 for values from (20) to (25);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_ee_ff3_1 partition of part_ee_ff3 for values from (20) to (25);
	^
<sql-statement>
create table part_ee_ff3_2 partition of part_ee_ff3 for values from (25) to (30);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_ee_ff3_2 partition of part_ee_ff3 for values from (25) to (30);
	^
<sql-statement>
truncate list_parted;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 257
    	truncate list_parted;
	^
<sql-statement>
insert into list_parted values ('aa'), ('cc');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into list_parted select 'Ff', s.a from generate_series(1, 29) s(a);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into list_parted select 'gg', s.a from generate_series(1, 9) s(a);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
insert into list_parted (b) values (1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
select tableoid::regclass::text, a, min(b) as min_b, max(b) as max_b from list_parted group by 1, 2 order by 1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
-- direct partition inserts should check hash partition bound constraint
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different machines.  The hash function for int4 simply returns
-- the sum of the values passed to it and the one for text returns the length
-- of the non-empty string value passed to it or 0.
create or replace function part_hashint4_noop(value int4, seed int8)
returns int8 as $$
select value + seed;
$$ language sql immutable;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	-- direct partition inserts should check hash partition bound constraint
	^
<sql-statement>
create operator class part_test_int4_ops
for type int4
using hash as
operator 1 =,
function 2 part_hashint4_noop(int4, int8);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 298
    	create operator class part_test_int4_ops
	^
<sql-statement>
create or replace function part_hashtext_length(value text, seed int8)
RETURNS int8 AS $$
select length(coalesce(value, ''))::int8
$$ language sql immutable;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create or replace function part_hashtext_length(value text, seed int8)
	^
<sql-statement>
create operator class part_test_text_ops
for type text
using hash as
operator 1 =,
function 2 part_hashtext_length(text, int8);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 298
    	create operator class part_test_text_ops
	^
<sql-statement>
create table hash_parted (
	a int
) partition by hash (a part_test_int4_ops);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	create table hash_parted (
	^
<sql-statement>
create table hpart0 partition of hash_parted for values with (modulus 4, remainder 0);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table hpart0 partition of hash_parted for values with (modulus 4, remainder 0);
	^
<sql-statement>
create table hpart1 partition of hash_parted for values with (modulus 4, remainder 1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table hpart1 partition of hash_parted for values with (modulus 4, remainder 1);
	^
<sql-statement>
create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table hpart2 partition of hash_parted for values with (modulus 4, remainder 2);
	^
<sql-statement>
create table hpart3 partition of hash_parted for values with (modulus 4, remainder 3);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table hpart3 partition of hash_parted for values with (modulus 4, remainder 3);
	^
<sql-statement>
insert into hash_parted values(generate_series(1,10));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:32: Error: Generator functions are not allowed in: VALUES
    	insert into hash_parted values(generate_series(1,10));
	                               ^
<sql-statement>
-- direct insert of values divisible by 4 - ok;
insert into hpart0 values(12),(16);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.hpart0
    
<sql-statement>
-- fail;
insert into hpart0 values(11);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.hpart0
    
<sql-statement>
-- 11 % 4 -> 3 remainder i.e. valid data for hpart3 partition
insert into hpart3 values(11);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.hpart3
    
<sql-statement>
-- view data
select tableoid::regclass as part, a, a%4 as "remainder = a % 4"
from hash_parted order by part;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.hash_parted
    
<sql-statement>
-- test \d+ output on a table which has both partitioned and unpartitioned
-- partitions
\d+ list_parted
</sql-statement>
Metacommand \d+ list_parted is not supported
<sql-statement>
-- cleanup
drop table range_parted, list_parted;
</sql-statement>
<sql-statement>
drop table hash_parted;
</sql-statement>
<sql-statement>
-- test that a default partition added as the first partition accepts any value
-- including null
create table list_parted (a int) partition by list (a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- test that a default partition added as the first partition accepts any value
	^
<sql-statement>
create table part_default partition of list_parted default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table part_default partition of list_parted default;
	^
<sql-statement>
\d+ part_default
</sql-statement>
Metacommand \d+ part_default is not supported
<sql-statement>
insert into part_default values (null);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
insert into part_default values (1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
insert into part_default values (-1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.part_default
    
<sql-statement>
select tableoid::regclass, a from list_parted;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.list_parted
    
<sql-statement>
-- cleanup
drop table list_parted;
</sql-statement>
<sql-statement>
-- more tests for certain multi-level partitioning scenarios
create table mlparted (a int, b int) partition by range (a, b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- more tests for certain multi-level partitioning scenarios
	^
<sql-statement>
create table mlparted1 (b int not null, a int not null) partition by range ((b+0));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	create table mlparted1 (b int not null, a int not null) partition by range ((b+0));
	^
<sql-statement>
create table mlparted11 (like mlparted1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: CreateStmt: alternative is not implemented yet : 389
    	create table mlparted11 (like mlparted1);
	^
<sql-statement>
alter table mlparted11 drop a;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted11 drop a;
	^
<sql-statement>
alter table mlparted11 add a int;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted11 add a int;
	^
<sql-statement>
alter table mlparted11 drop a;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted11 drop a;
	^
<sql-statement>
alter table mlparted11 add a int not null;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted11 add a int not null;
	^
<sql-statement>
-- attnum for key attribute 'a' is different in mlparted, mlparted1, and mlparted11
select attrelid::regclass, attname, attnum
from pg_attribute
where attname = 'a'
 and (attrelid = 'mlparted'::regclass
   or attrelid = 'mlparted1'::regclass
   or attrelid = 'mlparted11'::regclass)
order by attrelid::regclass::text;
</sql-statement>
<sql-statement>
alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
	^
<sql-statement>
alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
	^
<sql-statement>
-- check that "(1, 2)" is correctly routed to mlparted11.
insert into mlparted values (1, 2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
select tableoid::regclass, * from mlparted;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
-- check that proper message is shown after failure to route through mlparted1
insert into mlparted (a, b) values (1, 5);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
truncate mlparted;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 257
    	truncate mlparted;
	^
<sql-statement>
alter table mlparted add constraint check_b check (b = 3);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted add constraint check_b check (b = 3);
	^
<sql-statement>
-- have a BR trigger modify the row such that the check_b is violated
create function mlparted11_trig_fn()
returns trigger AS
$$
begin
  NEW.b := 4;
  return NEW;
end;
$$
language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	-- have a BR trigger modify the row such that the check_b is violated
	^
<sql-statement>
create trigger mlparted11_trig before insert ON mlparted11
  for each row execute procedure mlparted11_trig_fn();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 283
    	create trigger mlparted11_trig before insert ON mlparted11
	^
<sql-statement>
-- check that the correct row is shown when constraint check_b fails after
-- "(1, 2)" is routed to mlparted11 (actually "(1, 4)" would be shown due
-- to the BR trigger mlparted11_trig_fn)
insert into mlparted values (1, 2);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
drop trigger mlparted11_trig on mlparted11;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: Not supported object type for DROP
    	drop trigger mlparted11_trig on mlparted11;
	^
<sql-statement>
drop function mlparted11_trig_fn();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 386
    	drop function mlparted11_trig_fn();
	^
<sql-statement>
-- check that inserting into an internal partition successfully results in
-- checking its partition constraint before inserting into the leaf partition
-- selected by tuple-routing
insert into mlparted1 (a, b) values (2, 3);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted1
    
<sql-statement>
-- check routing error through a list partitioned table when the key is null
create table lparted_nonullpart (a int, b char) partition by list (b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- check routing error through a list partitioned table when the key is null
	^
<sql-statement>
create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a');
	^
<sql-statement>
insert into lparted_nonullpart values (1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.lparted_nonullpart
    
<sql-statement>
drop table lparted_nonullpart;
</sql-statement>
<sql-statement>
-- check that RETURNING works correctly with tuple-routing
alter table mlparted drop constraint check_b;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	-- check that RETURNING works correctly with tuple-routing
	^
<sql-statement>
create table mlparted12 partition of mlparted1 for values from (5) to (10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted12 partition of mlparted1 for values from (5) to (10);
	^
<sql-statement>
create table mlparted2 (b int not null, a int not null);
</sql-statement>
<sql-statement>
alter table mlparted attach partition mlparted2 for values from (1, 10) to (1, 20);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted attach partition mlparted2 for values from (1, 10) to (1, 20);
	^
<sql-statement>
create table mlparted3 partition of mlparted for values from (1, 20) to (1, 30);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted3 partition of mlparted for values from (1, 20) to (1, 30);
	^
<sql-statement>
create table mlparted4 (like mlparted);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: CreateStmt: alternative is not implemented yet : 389
    	create table mlparted4 (like mlparted);
	^
<sql-statement>
alter table mlparted4 drop a;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted4 drop a;
	^
<sql-statement>
alter table mlparted4 add a int not null;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted4 add a int not null;
	^
<sql-statement>
alter table mlparted attach partition mlparted4 for values from (1, 30) to (1, 40);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted attach partition mlparted4 for values from (1, 30) to (1, 40);
	^
<sql-statement>
with ins (a, b, c) as
  (insert into mlparted (b, a) select s.a, 1 from generate_series(2, 39) s(a) returning tableoid::regclass, *)
  select a, b, min(c), max(c) from ins group by a, b order by 1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:6: Error: Expected Select statement as CTE query
    	with ins (a, b, c) as
	     ^
<sql-statement>
alter table mlparted add c text;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted add c text;
	^
<sql-statement>
create table mlparted5 (c text, a int not null, b int not null) partition by list (c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	create table mlparted5 (c text, a int not null, b int not null) partition by list (c);
	^
<sql-statement>
create table mlparted5a (a int not null, c text, b int not null);
</sql-statement>
<sql-statement>
alter table mlparted5 attach partition mlparted5a for values in ('a');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted5 attach partition mlparted5a for values in ('a');
	^
<sql-statement>
alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
	^
<sql-statement>
alter table mlparted add constraint check_b check (a = 1 and b < 45);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted add constraint check_b check (a = 1 and b < 45);
	^
<sql-statement>
insert into mlparted values (1, 45, 'a');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
	^
<sql-statement>
create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 283
    	create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
	^
<sql-statement>
insert into mlparted5 (a, b, c) values (1, 40, 'a');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted5
    
<sql-statement>
drop table mlparted5;
</sql-statement>
<sql-statement>
alter table mlparted drop constraint check_b;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted drop constraint check_b;
	^
<sql-statement>
-- Check multi-level default partition
create table mlparted_def partition of mlparted default partition by range(a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- Check multi-level default partition
	^
<sql-statement>
create table mlparted_def1 partition of mlparted_def for values from (40) to (50);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted_def1 partition of mlparted_def for values from (40) to (50);
	^
<sql-statement>
create table mlparted_def2 partition of mlparted_def for values from (50) to (60);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted_def2 partition of mlparted_def for values from (50) to (60);
	^
<sql-statement>
insert into mlparted values (40, 100);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted_def1 values (42, 100);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted_def1
    
<sql-statement>
insert into mlparted_def2 values (54, 50);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted_def2
    
<sql-statement>
-- fail
insert into mlparted values (70, 100);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted_def1 values (52, 50);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted_def1
    
<sql-statement>
insert into mlparted_def2 values (34, 50);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted_def2
    
<sql-statement>
-- ok
create table mlparted_defd partition of mlparted_def default;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- ok
	^
<sql-statement>
insert into mlparted values (70, 100);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
select tableoid::regclass, * from mlparted_def;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted_def
    
<sql-statement>
-- Check multi-level tuple routing with attributes dropped from the
-- top-most parent.  First remove the last attribute.
alter table mlparted add d int, add e int;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	-- Check multi-level tuple routing with attributes dropped from the
	^
<sql-statement>
alter table mlparted drop e;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted drop e;
	^
<sql-statement>
create table mlparted5 partition of mlparted
  for values from (1, 40) to (1, 50) partition by range (c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted5 partition of mlparted
	^
<sql-statement>
create table mlparted5_ab partition of mlparted5
  for values from ('a') to ('c') partition by list (c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted5_ab partition of mlparted5
	^
<sql-statement>
-- This partitioned table should remain with no partitions.
create table mlparted5_cd partition of mlparted5
  for values from ('c') to ('e') partition by list (c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- This partitioned table should remain with no partitions.
	^
<sql-statement>
create table mlparted5_a partition of mlparted5_ab for values in ('a');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mlparted5_a partition of mlparted5_ab for values in ('a');
	^
<sql-statement>
create table mlparted5_b (d int, b int, c text, a int);
</sql-statement>
<sql-statement>
alter table mlparted5_ab attach partition mlparted5_b for values in ('b');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted5_ab attach partition mlparted5_b for values in ('b');
	^
<sql-statement>
truncate mlparted;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 257
    	truncate mlparted;
	^
<sql-statement>
insert into mlparted values (1, 2, 'a', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 40, 'a', 1);  -- goes to mlparted5_a
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 45, 'b', 1);  -- goes to mlparted5_b
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 45, 'c', 1);  -- goes to mlparted5_cd, fails
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 45, 'f', 1);  -- goes to mlparted5, fails
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
select tableoid::regclass, * from mlparted order by a, b, c, d;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
alter table mlparted drop d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted drop d;
	^
<sql-statement>
truncate mlparted;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 257
    	truncate mlparted;
	^
<sql-statement>
-- Remove the before last attribute.
alter table mlparted add e int, add d int;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	-- Remove the before last attribute.
	^
<sql-statement>
alter table mlparted drop e;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted drop e;
	^
<sql-statement>
insert into mlparted values (1, 2, 'a', 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 40, 'a', 1);  -- goes to mlparted5_a
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 45, 'b', 1);  -- goes to mlparted5_b
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 45, 'c', 1);  -- goes to mlparted5_cd, fails
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
insert into mlparted values (1, 45, 'f', 1);  -- goes to mlparted5, fails
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
select tableoid::regclass, * from mlparted order by a, b, c, d;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mlparted
    
<sql-statement>
alter table mlparted drop d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table mlparted drop d;
	^
<sql-statement>
drop table mlparted5;
</sql-statement>
<sql-statement>
-- check that message shown after failure to find a partition shows the
-- appropriate key description (or none) in various situations
create table key_desc (a int, b int) partition by list ((a+0));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- check that message shown after failure to find a partition shows the
	^
<sql-statement>
create table key_desc_1 partition of key_desc for values in (1) partition by range (b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table key_desc_1 partition of key_desc for values in (1) partition by range (b);
	^
<sql-statement>
create user regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 285
    	create user regress_insert_other_user;
	^
<sql-statement>
grant select (a) on key_desc_1 to regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	grant select (a) on key_desc_1 to regress_insert_other_user;
	^
<sql-statement>
grant insert on key_desc to regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	grant insert on key_desc to regress_insert_other_user;
	^
<sql-statement>
set role regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: role
    	set role regress_insert_other_user;
	^
<sql-statement>
-- no key description is shown
insert into key_desc values (1, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.key_desc
    
<sql-statement>
reset role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	reset role;
	^
<sql-statement>
grant select (b) on key_desc_1 to regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	grant select (b) on key_desc_1 to regress_insert_other_user;
	^
<sql-statement>
set role regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: role
    	set role regress_insert_other_user;
	^
<sql-statement>
-- key description (b)=(1) is now shown
insert into key_desc values (1, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.key_desc
    
<sql-statement>
-- key description is not shown if key contains expression
insert into key_desc values (2, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.key_desc
    
<sql-statement>
reset role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	reset role;
	^
<sql-statement>
revoke all on key_desc from regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	revoke all on key_desc from regress_insert_other_user;
	^
<sql-statement>
revoke all on key_desc_1 from regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	revoke all on key_desc_1 from regress_insert_other_user;
	^
<sql-statement>
drop role regress_insert_other_user;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 287
    	drop role regress_insert_other_user;
	^
<sql-statement>
drop table key_desc, key_desc_1;
</sql-statement>
<sql-statement>
-- test minvalue/maxvalue restrictions
create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- test minvalue/maxvalue restrictions
	^
<sql-statement>
create table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue);
	^
<sql-statement>
create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue);
	^
<sql-statement>
create table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue);
	^
<sql-statement>
-- check multi-column range partitioning expression enforces the same
-- constraint as what tuple-routing would determine it to be
create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, maxvalue, maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	-- check multi-column range partitioning expression enforces the same
	^
<sql-statement>
create table mcrparted1 partition of mcrparted for values from (2, 1, minvalue) to (10, 5, 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted1 partition of mcrparted for values from (2, 1, minvalue) to (10, 5, 10);
	^
<sql-statement>
create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, maxvalue);
	^
<sql-statement>
create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
	^
<sql-statement>
create table mcrparted4 partition of mcrparted for values from (21, minvalue, minvalue) to (30, 20, maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted4 partition of mcrparted for values from (21, minvalue, minvalue) to (30, 20, maxvalue);
	^
<sql-statement>
create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue);
	^
<sql-statement>
-- null not allowed in range partition
insert into mcrparted values (null, null, null);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
-- routed to mcrparted0
insert into mcrparted values (0, 1, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted0 values (0, 1, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted0
    
<sql-statement>
-- routed to mcparted1
insert into mcrparted values (9, 1000, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted1 values (9, 1000, 1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted1
    
<sql-statement>
insert into mcrparted values (10, 5, -1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted1 values (10, 5, -1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted1
    
<sql-statement>
insert into mcrparted values (2, 1, 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted1 values (2, 1, 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted1
    
<sql-statement>
-- routed to mcparted2
insert into mcrparted values (10, 6, 1000);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted2 values (10, 6, 1000);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted2
    
<sql-statement>
insert into mcrparted values (10, 1000, 1000);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted2 values (10, 1000, 1000);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted2
    
<sql-statement>
-- no partition exists, nor does mcrparted3 accept it
insert into mcrparted values (11, 1, -1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted3 values (11, 1, -1);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted3
    
<sql-statement>
-- routed to mcrparted5
insert into mcrparted values (30, 21, 20);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
insert into mcrparted5 values (30, 21, 20);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted5
    
<sql-statement>
insert into mcrparted4 values (30, 21, 20);	-- error
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted4
    
<sql-statement>
-- check rows
select tableoid::regclass::text, * from mcrparted order by 1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
-- cleanup
drop table mcrparted;
</sql-statement>
<sql-statement>
-- check that a BR constraint can't make partition contain violating rows
create table brtrigpartcon (a int, b text) partition by list (a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- check that a BR constraint can't make partition contain violating rows
	^
<sql-statement>
create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table brtrigpartcon1 partition of brtrigpartcon for values in (1);
	^
<sql-statement>
create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
	^
<sql-statement>
create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 283
    	create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
	^
<sql-statement>
insert into brtrigpartcon values (1, 'hi there');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.brtrigpartcon
    
<sql-statement>
insert into brtrigpartcon1 values (1, 'hi there');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.brtrigpartcon1
    
<sql-statement>
-- check that the message shows the appropriate column description in a
-- situation where the partitioned table is not the primary ModifyTable node
create table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int);
</sql-statement>
<sql-statement>
create role regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 285
    	create role regress_coldesc_role;
	^
<sql-statement>
grant insert on inserttest3 to regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	grant insert on inserttest3 to regress_coldesc_role;
	^
<sql-statement>
grant insert on brtrigpartcon to regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	grant insert on brtrigpartcon to regress_coldesc_role;
	^
<sql-statement>
revoke select on brtrigpartcon from regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	revoke select on brtrigpartcon from regress_coldesc_role;
	^
<sql-statement>
set role regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: role
    	set role regress_coldesc_role;
	^
<sql-statement>
with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
  insert into inserttest3 (f3) select * from result;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: InsertStmt: not supported withClause
    	with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
	^
<sql-statement>
reset role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	reset role;
	^
<sql-statement>
-- cleanup
revoke all on inserttest3 from regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	-- cleanup
	^
<sql-statement>
revoke all on brtrigpartcon from regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 248
    	revoke all on brtrigpartcon from regress_coldesc_role;
	^
<sql-statement>
drop role regress_coldesc_role;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 287
    	drop role regress_coldesc_role;
	^
<sql-statement>
drop table inserttest3;
</sql-statement>
<sql-statement>
drop table brtrigpartcon;
</sql-statement>
<sql-statement>
drop function brtrigpartcon1trigf();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 386
    	drop function brtrigpartcon1trigf();
	^
<sql-statement>
-- check that "do nothing" BR triggers work with tuple-routing
create table donothingbrtrig_test (a int, b text) partition by list (a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- check that "do nothing" BR triggers work with tuple-routing
	^
<sql-statement>
create table donothingbrtrig_test1 (b text, a int);
</sql-statement>
<sql-statement>
create table donothingbrtrig_test2 (c text, b text, a int);
</sql-statement>
<sql-statement>
alter table donothingbrtrig_test2 drop column c;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table donothingbrtrig_test2 drop column c;
	^
<sql-statement>
create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 261
    	create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
	^
<sql-statement>
create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 283
    	create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
	^
<sql-statement>
create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 283
    	create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
	^
<sql-statement>
alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
	^
<sql-statement>
alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
	^
<sql-statement>
insert into donothingbrtrig_test values (1, 'foo'), (2, 'bar');
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.donothingbrtrig_test
    
<sql-statement>
copy donothingbrtrig_test from stdout;
1	baz
2	qux
\.
</sql-statement>
Metacommand \. is not supported
<sql-statement>
select tableoid::regclass, * from donothingbrtrig_test;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.donothingbrtrig_test
    
<sql-statement>
-- cleanup
drop table donothingbrtrig_test;
</sql-statement>
<sql-statement>
drop function donothingbrtrig_func();
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 386
    	drop function donothingbrtrig_func();
	^
<sql-statement>
-- check multi-column range partitioning with minvalue/maxvalue constraints
create table mcrparted (a text, b int) partition by range(a, b);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- check multi-column range partitioning with minvalue/maxvalue constraints
	^
<sql-statement>
create table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue);
	^
<sql-statement>
create table mcrparted2_b partition of mcrparted for values from ('b', minvalue) to ('c', minvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted2_b partition of mcrparted for values from ('b', minvalue) to ('c', minvalue);
	^
<sql-statement>
create table mcrparted3_c_to_common partition of mcrparted for values from ('c', minvalue) to ('common', minvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted3_c_to_common partition of mcrparted for values from ('c', minvalue) to ('common', minvalue);
	^
<sql-statement>
create table mcrparted4_common_lt_0 partition of mcrparted for values from ('common', minvalue) to ('common', 0);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted4_common_lt_0 partition of mcrparted for values from ('common', minvalue) to ('common', 0);
	^
<sql-statement>
create table mcrparted5_common_0_to_10 partition of mcrparted for values from ('common', 0) to ('common', 10);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted5_common_0_to_10 partition of mcrparted for values from ('common', 0) to ('common', 10);
	^
<sql-statement>
create table mcrparted6_common_ge_10 partition of mcrparted for values from ('common', 10) to ('common', maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted6_common_ge_10 partition of mcrparted for values from ('common', 10) to ('common', maxvalue);
	^
<sql-statement>
create table mcrparted7_gt_common_lt_d partition of mcrparted for values from ('common', maxvalue) to ('d', minvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted7_gt_common_lt_d partition of mcrparted for values from ('common', maxvalue) to ('d', minvalue);
	^
<sql-statement>
create table mcrparted8_ge_d partition of mcrparted for values from ('d', minvalue) to (maxvalue, maxvalue);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table mcrparted8_ge_d partition of mcrparted for values from ('d', minvalue) to (maxvalue, maxvalue);
	^
<sql-statement>
\d+ mcrparted
</sql-statement>
Metacommand \d+ mcrparted is not supported
<sql-statement>
\d+ mcrparted1_lt_b
</sql-statement>
Metacommand \d+ mcrparted1_lt_b is not supported
<sql-statement>
\d+ mcrparted2_b
</sql-statement>
Metacommand \d+ mcrparted2_b is not supported
<sql-statement>
\d+ mcrparted3_c_to_common
</sql-statement>
Metacommand \d+ mcrparted3_c_to_common is not supported
<sql-statement>
\d+ mcrparted4_common_lt_0
</sql-statement>
Metacommand \d+ mcrparted4_common_lt_0 is not supported
<sql-statement>
\d+ mcrparted5_common_0_to_10
</sql-statement>
Metacommand \d+ mcrparted5_common_0_to_10 is not supported
<sql-statement>
\d+ mcrparted6_common_ge_10
</sql-statement>
Metacommand \d+ mcrparted6_common_ge_10 is not supported
<sql-statement>
\d+ mcrparted7_gt_common_lt_d
</sql-statement>
Metacommand \d+ mcrparted7_gt_common_lt_d is not supported
<sql-statement>
\d+ mcrparted8_ge_d
</sql-statement>
Metacommand \d+ mcrparted8_ge_d is not supported
<sql-statement>
insert into mcrparted values ('aaa', 0), ('b', 0), ('bz', 10), ('c', -10),
    ('comm', -10), ('common', -10), ('common', 0), ('common', 10),
    ('commons', 0), ('d', -10), ('e', 0);
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
select tableoid::regclass, * from mcrparted order by a, b;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.mcrparted
    
<sql-statement>
drop table mcrparted;
</sql-statement>
<sql-statement>
-- check that wholerow vars in the RETURNING list work with partitioned tables
create table returningwrtest (a int) partition by list (a);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: PARTITION BY clause not supported
    	-- check that wholerow vars in the RETURNING list work with partitioned tables
	^
<sql-statement>
create table returningwrtest1 partition of returningwrtest for values in (1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: table inheritance not supported
    	create table returningwrtest1 partition of returningwrtest for values in (1);
	^
<sql-statement>
insert into returningwrtest values (1) returning returningwrtest;
</sql-statement>
-stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'returning' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 

<sql-statement>
-- check also that the wholerow vars in RETURNING list are converted as needed
alter table returningwrtest add b text;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	-- check also that the wholerow vars in RETURNING list are converted as needed
	^
<sql-statement>
create table returningwrtest2 (b text, c int, a int);
</sql-statement>
<sql-statement>
alter table returningwrtest2 drop c;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table returningwrtest2 drop c;
	^
<sql-statement>
alter table returningwrtest attach partition returningwrtest2 for values in (2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 245
    	alter table returningwrtest attach partition returningwrtest2 for values in (2);
	^
<sql-statement>
insert into returningwrtest values (2, 'foo') returning returningwrtest;
</sql-statement>
-stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'returning' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 

<sql-statement>
drop table returningwrtest;
</sql-statement>
