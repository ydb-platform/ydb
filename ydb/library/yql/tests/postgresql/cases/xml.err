<sql-statement>
CREATE TABLE xmltest (
    id int,
    data xml
);
</sql-statement>
<sql-statement>
INSERT INTO xmltest VALUES (1, '<value>one</value>');
</sql-statement>
<sql-statement>
INSERT INTO xmltest VALUES (2, '<value>two</value>');
</sql-statement>
<sql-statement>
INSERT INTO xmltest VALUES (3, '<wrong');
</sql-statement>
<sql-statement>
SELECT * FROM xmltest;
</sql-statement>
<sql-statement>
SELECT xmlcomment('test');
</sql-statement>
<sql-statement>
SELECT xmlcomment('-test');
</sql-statement>
<sql-statement>
SELECT xmlcomment('test-');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT xmlcomment('test-');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid XML comment

        	SELECT xmlcomment('test-');
	^
<sql-statement>
SELECT xmlcomment('--test');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT xmlcomment('--test');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid XML comment

        	SELECT xmlcomment('--test');
	^
<sql-statement>
SELECT xmlcomment('te st');
</sql-statement>
<sql-statement>
SELECT xmlconcat(xmlcomment('hello'),
                 xmlelement(NAME qux, 'foo'),
                 xmlcomment('world'));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat(xmlcomment('hello'),
	^
<sql-statement>
SELECT xmlconcat('hello', 'you');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat('hello', 'you');
	^
<sql-statement>
SELECT xmlconcat(1, 2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat(1, 2);
	^
<sql-statement>
SELECT xmlconcat('bad', '<syntax');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat('bad', '<syntax');
	^
<sql-statement>
SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
	^
<sql-statement>
SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
	^
<sql-statement>
SELECT xmlconcat(NULL);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat(NULL);
	^
<sql-statement>
SELECT xmlconcat(NULL, NULL);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlconcat(NULL, NULL);
	^
<sql-statement>
SELECT xmlelement(name element,
                  xmlattributes (1 as one, 'deuce' as two),
                  'content');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name element,
	^
<sql-statement>
SELECT xmlelement(name element,
                  xmlattributes ('unnamed and wrong'));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name element,
	^
<sql-statement>
SELECT xmlelement(name element, xmlelement(name nested, 'stuff'));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name element, xmlelement(name nested, 'stuff'));
	^
<sql-statement>
SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
	^
<sql-statement>
SELECT xmlelement(name duplicate, xmlattributes(1 as a, 2 as b, 3 as a));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name duplicate, xmlattributes(1 as a, 2 as b, 3 as a));
	^
<sql-statement>
SELECT xmlelement(name num, 37);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name num, 37);
	^
<sql-statement>
SELECT xmlelement(name foo, text 'bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, text 'bar');
	^
<sql-statement>
SELECT xmlelement(name foo, xml 'bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, xml 'bar');
	^
<sql-statement>
SELECT xmlelement(name foo, text 'b<a/>r');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, text 'b<a/>r');
	^
<sql-statement>
SELECT xmlelement(name foo, xml 'b<a/>r');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, xml 'b<a/>r');
	^
<sql-statement>
SELECT xmlelement(name foo, array[1, 2, 3]);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, array[1, 2, 3]);
	^
<sql-statement>
SET xmlbinary TO base64;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: xmlbinary
    	SET xmlbinary TO base64;
	^
<sql-statement>
SELECT xmlelement(name foo, bytea 'bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, bytea 'bar');
	^
<sql-statement>
SET xmlbinary TO hex;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: xmlbinary
    	SET xmlbinary TO hex;
	^
<sql-statement>
SELECT xmlelement(name foo, bytea 'bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, bytea 'bar');
	^
<sql-statement>
SELECT xmlelement(name foo, xmlattributes(true as bar));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, xmlattributes(true as bar));
	^
<sql-statement>
SELECT xmlelement(name foo, xmlattributes('2009-04-09 00:24:37'::timestamp as bar));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, xmlattributes('2009-04-09 00:24:37'::timestamp as bar));
	^
<sql-statement>
SELECT xmlelement(name foo, xmlattributes('infinity'::timestamp as bar));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, xmlattributes('infinity'::timestamp as bar));
	^
<sql-statement>
SELECT xmlelement(name foo, xmlattributes('<>&"''' as funny, xml 'b<a/>r' as funnier));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name foo, xmlattributes('<>&"''' as funny, xml 'b<a/>r' as funnier));
	^
<sql-statement>
SELECT xmlparse(content '');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '');
	^
<sql-statement>
SELECT xmlparse(content '  ');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '  ');
	^
<sql-statement>
SELECT xmlparse(content 'abc');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content 'abc');
	^
<sql-statement>
SELECT xmlparse(content '<abc>x</abc>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<abc>x</abc>');
	^
<sql-statement>
SELECT xmlparse(content '<invalidentity>&</invalidentity>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<invalidentity>&</invalidentity>');
	^
<sql-statement>
SELECT xmlparse(content '<undefinedentity>&idontexist;</undefinedentity>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<undefinedentity>&idontexist;</undefinedentity>');
	^
<sql-statement>
SELECT xmlparse(content '<invalidns xmlns=''&lt;''/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<invalidns xmlns=''&lt;''/>');
	^
<sql-statement>
SELECT xmlparse(content '<relativens xmlns=''relative''/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<relativens xmlns=''relative''/>');
	^
<sql-statement>
SELECT xmlparse(content '<twoerrors>&idontexist;</unbalanced>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<twoerrors>&idontexist;</unbalanced>');
	^
<sql-statement>
SELECT xmlparse(content '<nosuchprefix:tag/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(content '<nosuchprefix:tag/>');
	^
<sql-statement>
SELECT xmlparse(document '   ');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '   ');
	^
<sql-statement>
SELECT xmlparse(document 'abc');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document 'abc');
	^
<sql-statement>
SELECT xmlparse(document '<abc>x</abc>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<abc>x</abc>');
	^
<sql-statement>
SELECT xmlparse(document '<invalidentity>&</abc>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<invalidentity>&</abc>');
	^
<sql-statement>
SELECT xmlparse(document '<undefinedentity>&idontexist;</abc>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<undefinedentity>&idontexist;</abc>');
	^
<sql-statement>
SELECT xmlparse(document '<invalidns xmlns=''&lt;''/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<invalidns xmlns=''&lt;''/>');
	^
<sql-statement>
SELECT xmlparse(document '<relativens xmlns=''relative''/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<relativens xmlns=''relative''/>');
	^
<sql-statement>
SELECT xmlparse(document '<twoerrors>&idontexist;</unbalanced>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<twoerrors>&idontexist;</unbalanced>');
	^
<sql-statement>
SELECT xmlparse(document '<nosuchprefix:tag/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlparse(document '<nosuchprefix:tag/>');
	^
<sql-statement>
SELECT xmlpi(name foo);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name foo);
	^
<sql-statement>
SELECT xmlpi(name xml);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name xml);
	^
<sql-statement>
SELECT xmlpi(name xmlstuff);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name xmlstuff);
	^
<sql-statement>
SELECT xmlpi(name foo, 'bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name foo, 'bar');
	^
<sql-statement>
SELECT xmlpi(name foo, 'in?>valid');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name foo, 'in?>valid');
	^
<sql-statement>
SELECT xmlpi(name foo, null);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name foo, null);
	^
<sql-statement>
SELECT xmlpi(name xml, null);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name xml, null);
	^
<sql-statement>
SELECT xmlpi(name xmlstuff, null);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name xmlstuff, null);
	^
<sql-statement>
SELECT xmlpi(name "xml-stylesheet", 'href="mystyle.css" type="text/css"');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name "xml-stylesheet", 'href="mystyle.css" type="text/css"');
	^
<sql-statement>
SELECT xmlpi(name foo, '   bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name foo, '   bar');
	^
<sql-statement>
SELECT xmlroot(xml '<foo/>', version no value, standalone no value);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot(xml '<foo/>', version no value, standalone no value);
	^
<sql-statement>
SELECT xmlroot(xml '<foo/>', version '2.0');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot(xml '<foo/>', version '2.0');
	^
<sql-statement>
SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
	^
<sql-statement>
SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no value, standalone yes);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no value, standalone yes);
	^
<sql-statement>
SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version '1.1', standalone no);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version '1.1', standalone no);
	^
<sql-statement>
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no);
	^
<sql-statement>
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no value);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no value);
	^
<sql-statement>
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value);
	^
<sql-statement>
SELECT xmlroot (
  xmlelement (
    name gazonk,
    xmlattributes (
      'val' AS name,
      1 + 1 AS num
    ),
    xmlelement (
      NAME qux,
      'foo'
    )
  ),
  version '1.0',
  standalone yes
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlroot (
	^
<sql-statement>
SELECT xmlserialize(content data as character varying(20)) FROM xmltest;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 393
    	SELECT xmlserialize(content data as character varying(20)) FROM xmltest;
	^
<sql-statement>
SELECT xmlserialize(content 'good' as char(10));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 393
    	SELECT xmlserialize(content 'good' as char(10));
	^
<sql-statement>
SELECT xmlserialize(document 'bad' as text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 393
    	SELECT xmlserialize(document 'bad' as text);
	^
<sql-statement>
SELECT xml '<foo>bar</foo>' IS DOCUMENT;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xml '<foo>bar</foo>' IS DOCUMENT;
	^
<sql-statement>
SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT;
	^
<sql-statement>
SELECT xml '<abc/>' IS NOT DOCUMENT;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:21: Error: alternative is not implemented yet : 143
    	SELECT xml '<abc/>' IS NOT DOCUMENT;
	                    ^
<sql-statement>
SELECT xml 'abc' IS NOT DOCUMENT;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:18: Error: alternative is not implemented yet : 143
    	SELECT xml 'abc' IS NOT DOCUMENT;
	                 ^
<sql-statement>
SELECT '<>' IS NOT DOCUMENT;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:13: Error: alternative is not implemented yet : 143
    	SELECT '<>' IS NOT DOCUMENT;
	            ^
<sql-statement>
SELECT xmlagg(data) FROM xmltest;
</sql-statement>
<sql-statement>
SELECT xmlagg(data) FROM xmltest WHERE id > 10;
</sql-statement>
<sql-statement>
SELECT xmlelement(name employees, xmlagg(xmlelement(name name, name))) FROM emp;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlelement(name employees, xmlagg(xmlelement(name name, name))) FROM emp;
	^
<sql-statement>
-- Check mapping SQL identifier to XML name
SELECT xmlpi(name ":::_xml_abc135.%-&_");
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	-- Check mapping SQL identifier to XML name
	^
<sql-statement>
SELECT xmlpi(name "123");
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT xmlpi(name "123");
	^
<sql-statement>
PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 301
    	PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
	^
<sql-statement>
SET XML OPTION DOCUMENT;
</sql-statement>
<sql-statement>
EXECUTE foo ('<bar/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 302
    	EXECUTE foo ('<bar/>');
	^
<sql-statement>
EXECUTE foo ('bad');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 302
    	EXECUTE foo ('bad');
	^
<sql-statement>
SELECT xml '<!DOCTYPE a><a/><b/>';
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT xml '<!DOCTYPE a><a/><b/>';
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid XML document
DETAIL:  line 1: Extra content at the end of the document
	<!DOCTYPE a><a/><b/>
	                ^

        	SELECT xml '<!DOCTYPE a><a/><b/>';
	^
<sql-statement>
SET XML OPTION CONTENT;
</sql-statement>
<sql-statement>
EXECUTE foo ('<bar/>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 302
    	EXECUTE foo ('<bar/>');
	^
<sql-statement>
EXECUTE foo ('good');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 302
    	EXECUTE foo ('good');
	^
<sql-statement>
SELECT xml '<!-- in SQL:2006+ a doc is content too--> <?y z?> <!DOCTYPE a><a/>';
</sql-statement>
<sql-statement>
SELECT xml '<?xml version="1.0"?> <!-- hi--> <!DOCTYPE a><a/>';
</sql-statement>
<sql-statement>
SELECT xml '<!DOCTYPE a><a/>';
</sql-statement>
<sql-statement>
SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>';
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>';
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid XML document
DETAIL:  line 1: Start tag expected, '<' not found
	<!-- hi--> oops <!DOCTYPE a><a/>
	           ^

        	SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>';
	^
<sql-statement>
SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>';
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>';
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid XML document
DETAIL:  line 1: Extra content at the end of the document
	<!-- hi--> <oops/> <!DOCTYPE a><a/>
	                   ^

        	SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>';
	^
<sql-statement>
SELECT xml '<!DOCTYPE a><a/><b/>';
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT xml '<!DOCTYPE a><a/><b/>';
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid XML document
DETAIL:  line 1: Extra content at the end of the document
	<!DOCTYPE a><a/><b/>
	                ^

        	SELECT xml '<!DOCTYPE a><a/><b/>';
	^
<sql-statement>
-- Test backwards parsing
CREATE VIEW xmlview1 AS SELECT xmlcomment('test');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	-- Test backwards parsing
	^
<sql-statement>
CREATE VIEW xmlview2 AS SELECT xmlconcat('hello', 'you');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview2 AS SELECT xmlconcat('hello', 'you');
	^
<sql-statement>
CREATE VIEW xmlview3 AS SELECT xmlelement(name element, xmlattributes (1 as ":one:", 'deuce' as two), 'content&');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview3 AS SELECT xmlelement(name element, xmlattributes (1 as ":one:", 'deuce' as two), 'content&');
	^
<sql-statement>
CREATE VIEW xmlview4 AS SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview4 AS SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
	^
<sql-statement>
CREATE VIEW xmlview5 AS SELECT xmlparse(content '<abc>x</abc>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview5 AS SELECT xmlparse(content '<abc>x</abc>');
	^
<sql-statement>
CREATE VIEW xmlview6 AS SELECT xmlpi(name foo, 'bar');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview6 AS SELECT xmlpi(name foo, 'bar');
	^
<sql-statement>
CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
	^
<sql-statement>
CREATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as char(10));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as char(10));
	^
<sql-statement>
CREATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: expected at least one target column
    	CREATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as text);
	^
<sql-statement>
SELECT table_name, view_definition FROM information_schema.views
  WHERE table_name LIKE 'xmlview%' ORDER BY 1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:41: Error: Unknown cluster: information_schema
    	SELECT table_name, view_definition FROM information_schema.views
	                                        ^
<sql-statement>
-- Text XPath expressions evaluation
SELECT xpath('/value', data) FROM xmltest;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- Text XPath expressions evaluation
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	SELECT xpath('/value', data) FROM xmltest;
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,xml)
            	SELECT xpath('/value', data) FROM xmltest;
	       ^
<sql-statement>
SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
	^
        -stdin-:<main>:1:26: Error: At function: ToPg, At function: Not, At function: Exists
        	SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
	                         ^
            -stdin-:<main>:1:8: Error: At function: PgCall
            	SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
	       ^
                -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
                	SELECT xpath(NULL, NULL) IS NULL FROM xmltest;
	       ^
<sql-statement>
SELECT xpath('', '<!-- error -->');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('', '<!-- error -->');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('', '<!-- error -->');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('', '<!-- error -->');
	       ^
<sql-statement>
SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
	       ^
<sql-statement>
SELECT xpath('//loc:piece/@id', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
</sql-statement>
<sql-statement>
SELECT xpath('//loc:piece', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
</sql-statement>
<sql-statement>
SELECT xpath('//loc:piece', '<local:data xmlns:local="http://127.0.0.1" xmlns="http://127.0.0.2"><local:piece id="1"><internal>number one</internal><internal2/></local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
</sql-statement>
<sql-statement>
SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>');
	       ^
<sql-statement>
SELECT xpath('//text()', '<root>&lt;</root>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('//text()', '<root>&lt;</root>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('//text()', '<root>&lt;</root>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('//text()', '<root>&lt;</root>');
	       ^
<sql-statement>
SELECT xpath('//@value', '<root value="&lt;"/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('//@value', '<root value="&lt;"/>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('//@value', '<root value="&lt;"/>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('//@value', '<root value="&lt;"/>');
	       ^
<sql-statement>
SELECT xpath('''<<invalid>>''', '<root/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('''<<invalid>>''', '<root/>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('''<<invalid>>''', '<root/>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('''<<invalid>>''', '<root/>');
	       ^
<sql-statement>
SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
	       ^
<sql-statement>
SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
	       ^
<sql-statement>
SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
	       ^
<sql-statement>
SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
	       ^
<sql-statement>
SELECT xpath('/nosuchtag', '<root/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('/nosuchtag', '<root/>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('/nosuchtag', '<root/>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('/nosuchtag', '<root/>');
	       ^
<sql-statement>
SELECT xpath('root', '<root/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('root', '<root/>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('root', '<root/>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('root', '<root/>');
	       ^
<sql-statement>
-- Round-trip non-ASCII data through xpath().
DO $$
DECLARE
  xml_declaration text := '<?xml version="1.0" encoding="ISO-8859-1"?>';
  degree_symbol text;
  res xml[];
BEGIN
  -- Per the documentation, except when the server encoding is UTF8, xpath()
  -- may not work on non-ASCII data.  The untranslatable_character and
  -- undefined_function traps below, currently dead code, will become relevant
  -- if we remove this limitation.
  IF current_setting('server_encoding') <> 'UTF8' THEN
    RAISE LOG 'skip: encoding % unsupported for xpath',
      current_setting('server_encoding');
    RETURN;
  END IF;
  degree_symbol := convert_from('\xc2b0', 'UTF8');
  res := xpath('text()', (xml_declaration ||
    '<x>' || degree_symbol || '</x>')::xml);
  IF degree_symbol <> res[1]::text THEN
    RAISE 'expected % (%), got % (%)',
      degree_symbol, convert_to(degree_symbol, 'UTF8'),
      res[1], convert_to(res[1]::text, 'UTF8');
  END IF;
EXCEPTION
  -- character with byte sequence 0xc2 0xb0 in encoding "UTF8" has no equivalent in encoding "LATIN8"
  WHEN untranslatable_character
  -- default conversion function for encoding "UTF8" to "MULE_INTERNAL" does not exist
  OR undefined_function
  -- unsupported XML feature
  OR feature_not_supported THEN
    RAISE LOG 'skip: %', SQLERRM;
END
$$;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 263
    	-- Round-trip non-ASCII data through xpath().
	^
<sql-statement>
-- Test xmlexists and xpath_exists
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
</sql-statement>
<sql-statement>
SELECT xmlexists('//town[text() = ''Cwmbran'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
</sql-statement>
<sql-statement>
SELECT xmlexists('count(/nosuchtag)' PASSING BY REF '<root/>');
</sql-statement>
<sql-statement>
SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath_exists with given argument types: (unknown,xml)
            	SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
	       ^
<sql-statement>
SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath_exists with given argument types: (unknown,xml)
            	SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
	       ^
<sql-statement>
SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath_exists with given argument types: (unknown,xml)
            	SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
	       ^
<sql-statement>
INSERT INTO xmltest VALUES (4, '<menu><beers><name>Budvar</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml);
</sql-statement>
<sql-statement>
INSERT INTO xmltest VALUES (5, '<menu><beers><name>Molson</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml);
</sql-statement>
<sql-statement>
INSERT INTO xmltest VALUES (6, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Budvar</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml);
</sql-statement>
<sql-statement>
INSERT INTO xmltest VALUES (7, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Molson</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING data);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING BY REF data BY REF);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers' PASSING BY REF data);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers/name[text() = ''Molson'']' PASSING BY REF data);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect
    	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data);
	^
        -stdin-:<main>: Error: At function: PgSetItem
        
            -stdin-:<main>:1:1: Error: At function: PgWhere
            	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data);
	^
                -stdin-:<main>:1:37: Error: At function: PgCall
                	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data);
	                                    ^
                    -stdin-:<main>:1:37: Error: Unable to find an overload for proc xpath_exists with given argument types: (unknown,xml)
                    	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data);
	                                    ^
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect
    	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data);
	^
        -stdin-:<main>: Error: At function: PgSetItem
        
            -stdin-:<main>:1:1: Error: At function: PgWhere
            	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data);
	^
                -stdin-:<main>:1:37: Error: At function: PgCall
                	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data);
	                                    ^
                    -stdin-:<main>:1:37: Error: Unable to find an overload for proc xpath_exists with given argument types: (unknown,xml)
                    	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data);
	                                    ^
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect
    	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data);
	^
        -stdin-:<main>: Error: At function: PgSetItem
        
            -stdin-:<main>:1:1: Error: At function: PgWhere
            	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data);
	^
                -stdin-:<main>:1:37: Error: At function: PgCall
                	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data);
	                                    ^
                    -stdin-:<main>:1:37: Error: Unable to find an overload for proc xpath_exists with given argument types: (unknown,xml)
                    	SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data);
	                                    ^
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beer',data,ARRAY[ARRAY['myns','http://myns.com']]);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beers',data,ARRAY[ARRAY['myns','http://myns.com']]);
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beers/myns:name[text() = ''Molson'']',data,ARRAY[ARRAY['myns','http://myns.com']]);
</sql-statement>
<sql-statement>
CREATE TABLE query ( expr TEXT );
</sql-statement>
<sql-statement>
INSERT INTO query VALUES ('/menu/beers/cost[text() = ''lots'']');
</sql-statement>
<sql-statement>
SELECT COUNT(id) FROM xmltest, query WHERE xmlexists(expr PASSING BY REF data);
</sql-statement>
<sql-statement>
-- Test xml_is_well_formed and variants
SELECT xml_is_well_formed_document('<foo>bar</foo>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed_document('abc');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed_content('<foo>bar</foo>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed_content('abc');
</sql-statement>
<sql-statement>
SET xmloption TO DOCUMENT;
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('abc');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<abc/>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<foo>bar</foo>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<foo>bar</foo');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<foo><bar>baz</foo>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<invalidentity>&</abc>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<undefinedentity>&idontexist;</abc>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<invalidns xmlns=''&lt;''/>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<relativens xmlns=''relative''/>');
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('<twoerrors>&idontexist;</unbalanced>');
</sql-statement>
<sql-statement>
SET xmloption TO CONTENT;
</sql-statement>
<sql-statement>
SELECT xml_is_well_formed('abc');
</sql-statement>
<sql-statement>
-- Since xpath() deals with namespaces, it's a bit stricter about
-- what's well-formed and what's not. If we don't obey these rules
-- (i.e. ignore namespace-related errors from libxml), xpath()
-- fails in subtle ways. The following would for example produce
-- the xml value
--   <invalidns xmlns='<'/>
-- which is invalid because '<' may not appear un-escaped in
-- attribute values.
-- Since different libxml versions emit slightly different
-- error messages, we suppress the DETAIL in this test.
\set VERBOSITY terse
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:11:1: Error: ERROR:  syntax error at or near "\"

    	\set VERBOSITY terse
	^
<sql-statement>
SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
	       ^
<sql-statement>
\set VERBOSITY default
</sql-statement>
Metacommand \set VERBOSITY default is not supported
<sql-statement>
-- Again, the XML isn't well-formed for namespace purposes
SELECT xpath('/*', '<nosuchprefix:tag/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- Again, the XML isn't well-formed for namespace purposes
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	SELECT xpath('/*', '<nosuchprefix:tag/>');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('/*', '<nosuchprefix:tag/>');
	       ^
<sql-statement>
-- XPath deprecates relative namespaces, but they're not supposed to
-- throw an error, only a warning.
SELECT xpath('/*', '<relativens xmlns=''relative''/>');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- XPath deprecates relative namespaces, but they're not supposed to
	^
        -stdin-:<main>:3:8: Error: At function: PgCall
        	SELECT xpath('/*', '<relativens xmlns=''relative''/>');
	       ^
            -stdin-:<main>:3:8: Error: Unable to find an overload for proc xpath with given argument types: (unknown,unknown)
            	SELECT xpath('/*', '<relativens xmlns=''relative''/>');
	       ^
<sql-statement>
-- External entity references should not leak filesystem information.
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/passwd">]><foo>&c;</foo>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	-- External entity references should not leak filesystem information.
	^
<sql-statement>
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c;</foo>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c;</foo>');
	^
<sql-statement>
-- This might or might not load the requested DTD, but it mustn't throw error.
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"><chapter>&nbsp;</chapter>');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 143
    	-- This might or might not load the requested DTD, but it mustn't throw error.
	^
<sql-statement>
-- XMLPATH tests
CREATE TABLE xmldata(data xml);
</sql-statement>
<sql-statement>
INSERT INTO xmldata VALUES('<ROWS>
<ROW id="1">
  <COUNTRY_ID>AU</COUNTRY_ID>
  <COUNTRY_NAME>Australia</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="2">
  <COUNTRY_ID>CN</COUNTRY_ID>
  <COUNTRY_NAME>China</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="3">
  <COUNTRY_ID>HK</COUNTRY_ID>
  <COUNTRY_NAME>HongKong</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="4">
  <COUNTRY_ID>IN</COUNTRY_ID>
  <COUNTRY_NAME>India</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="5">
  <COUNTRY_ID>JP</COUNTRY_ID>
  <COUNTRY_NAME>Japan</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID><PREMIER_NAME>Sinzo Abe</PREMIER_NAME>
</ROW>
<ROW id="6">
  <COUNTRY_ID>SG</COUNTRY_ID>
  <COUNTRY_NAME>Singapore</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID><SIZE unit="km">791</SIZE>
</ROW>
</ROWS>');
</sql-statement>
<sql-statement>
-- XMLTABLE with columns
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:6:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
CREATE VIEW xmltableview1 AS SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:5:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
SELECT * FROM xmltableview1;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.xmltableview1
    
<sql-statement>
\sv xmltableview1
</sql-statement>
Metacommand \sv xmltableview1 is not supported
<sql-statement>
EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1;
	^
<sql-statement>
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM xmltableview1;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM xmltableview1;
	^
<sql-statement>
-- errors
SELECT * FROM XMLTABLE (ROW () PASSING null COLUMNS v1 timestamp) AS f (v1, v2);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	-- errors
	^
<sql-statement>
-- XMLNAMESPACES tests
SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),
                      '/zz:rows/zz:row'
                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
                      COLUMNS a int PATH 'zz:a');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:5:37: Error: ERROR:  unrecognized column option "PATH"

    	                      COLUMNS a int PATH 'zz:a');
	                                    ^
<sql-statement>
CREATE VIEW xmltableview2 AS SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),
                      '/zz:rows/zz:row'
                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
                      COLUMNS a int PATH 'zz:a');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:37: Error: ERROR:  unrecognized column option "PATH"

    	                      COLUMNS a int PATH 'zz:a');
	                                    ^
<sql-statement>
SELECT * FROM xmltableview2;
</sql-statement>
-stdin-:<main>: Fatal: Table metadata loading

    -stdin-:<main>: Fatal: ydb/library/yql/providers/yt/gateway/file/yql_yt_file_services.cpp:44: Table not found: plato.xmltableview2
    
<sql-statement>
SELECT * FROM XMLTABLE(XMLNAMESPACES(DEFAULT 'http://x.y'),
                      '/rows/row'
                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
                      COLUMNS a int PATH 'a');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:37: Error: ERROR:  unrecognized column option "PATH"

    	                      COLUMNS a int PATH 'a');
	                                    ^
<sql-statement>
SELECT * FROM XMLTABLE('.'
                       PASSING '<foo/>'
                       COLUMNS a text PATH 'foo/namespace::node()');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:3:39: Error: ERROR:  unrecognized column option "PATH"

    	                       COLUMNS a text PATH 'foo/namespace::node()');
	                                      ^
<sql-statement>
-- used in prepare statements
PREPARE pp AS
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:7:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
EXECUTE pp;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 302
    	EXECUTE pp;
	^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int);
	^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY, "COUNTRY_NAME" text, "REGION_ID" int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY, "COUNTRY_NAME" text, "REGION_ID" int);
	^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:137: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int);
	                                                                                                                                        ^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:137: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id');
	                                                                                                                                        ^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY);
	^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH '.');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:137: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH '.');
	                                                                                                                                        ^
<sql-statement>
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH './*');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:137: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH './*');
	                                                                                                                                        ^
<sql-statement>
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text);
	^
<sql-statement>
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text PATH 'element/text()'); -- should fail
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:154: Error: ERROR:  unrecognized column option "PATH"

    	SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text PATH 'element/text()'); -- should fail
	                                                                                                                                                         ^
<sql-statement>
-- CDATA test
select * from xmltable('d/r' passing '<d><r><c><![CDATA[<hello> &"<>!<a>foo</a>]]></c></r><r><c>2</c></r></d>' columns c text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	-- CDATA test
	^
<sql-statement>
-- XML builtin entities
SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	-- XML builtin entities
	^
<sql-statement>
SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent xml);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent xml);
	^
<sql-statement>
EXPLAIN (VERBOSE, COSTS OFF)
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:6:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
-- test qual
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) WHERE "COUNTRY_NAME" = 'Japan';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: SelectStmt: alternative is not implemented yet : 371
    	-- test qual
	^
<sql-statement>
EXPLAIN (VERBOSE, COSTS OFF)
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) WHERE "COUNTRY_NAME" = 'Japan';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (VERBOSE, COSTS OFF)
	^
<sql-statement>
-- should to work with more data
INSERT INTO xmldata VALUES('<ROWS>
<ROW id="10">
  <COUNTRY_ID>CZ</COUNTRY_ID>
  <COUNTRY_NAME>Czech Republic</COUNTRY_NAME>
  <REGION_ID>2</REGION_ID><PREMIER_NAME>Milos Zeman</PREMIER_NAME>
</ROW>
<ROW id="11">
  <COUNTRY_ID>DE</COUNTRY_ID>
  <COUNTRY_NAME>Germany</COUNTRY_NAME>
  <REGION_ID>2</REGION_ID>
</ROW>
<ROW id="12">
  <COUNTRY_ID>FR</COUNTRY_ID>
  <COUNTRY_NAME>France</COUNTRY_NAME>
  <REGION_ID>2</REGION_ID>
</ROW>
</ROWS>');
</sql-statement>
<sql-statement>
INSERT INTO xmldata VALUES('<ROWS>
<ROW id="20">
  <COUNTRY_ID>EG</COUNTRY_ID>
  <COUNTRY_NAME>Egypt</COUNTRY_NAME>
  <REGION_ID>1</REGION_ID>
</ROW>
<ROW id="21">
  <COUNTRY_ID>SD</COUNTRY_ID>
  <COUNTRY_NAME>Sudan</COUNTRY_NAME>
  <REGION_ID>1</REGION_ID>
</ROW>
</ROWS>');
</sql-statement>
<sql-statement>
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:5:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
  WHERE region_id = 2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:5:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
EXPLAIN (VERBOSE, COSTS OFF)
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
  WHERE region_id = 2;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:6:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
-- should fail, NULL value
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE' NOT NULL,
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:6:41: Error: ERROR:  unrecognized column option "PATH"

    	                         COLUMNS id int PATH '@id',
	                                        ^
<sql-statement>
-- if all is ok, then result is empty
-- one line xml test
WITH
   x AS (SELECT proname, proowner, procost::numeric, pronargs,
                array_to_string(proargnames,',') as proargnames,
                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
           FROM pg_proc WHERE proname = 'f_leak'),
   y AS (SELECT xmlelement(name proc,
                           xmlforest(proname, proowner,
                                     procost, pronargs,
                                     proargnames, proargtypes)) as proc
           FROM x),
   z AS (SELECT xmltable.*
           FROM y,
                LATERAL xmltable('/proc' PASSING proc
                                 COLUMNS proname name,
                                         proowner oid,
                                         procost float,
                                         pronargs int,
                                         proargnames text,
                                         proargtypes text))
   SELECT * FROM z
   EXCEPT SELECT * FROM x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:8:4: Error: alternative is not implemented yet : 143
    	   y AS (SELECT xmlelement(name proc,
	   ^
<sql-statement>
-- multi line xml test, result should be empty too
WITH
   x AS (SELECT proname, proowner, procost::numeric, pronargs,
                array_to_string(proargnames,',') as proargnames,
                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
           FROM pg_proc),
   y AS (SELECT xmlelement(name data,
                           xmlagg(xmlelement(name proc,
                                             xmlforest(proname, proowner, procost,
                                                       pronargs, proargnames, proargtypes)))) as doc
           FROM x),
   z AS (SELECT xmltable.*
           FROM y,
                LATERAL xmltable('/data/proc' PASSING doc
                                 COLUMNS proname name,
                                         proowner oid,
                                         procost float,
                                         pronargs int,
                                         proargnames text,
                                         proargtypes text))
   SELECT * FROM z
   EXCEPT SELECT * FROM x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:7:4: Error: alternative is not implemented yet : 143
    	   y AS (SELECT xmlelement(name data,
	   ^
<sql-statement>
CREATE TABLE xmltest2(x xml, _path text);
</sql-statement>
<sql-statement>
INSERT INTO xmltest2 VALUES('<d><r><ac>1</ac></r></d>', 'A');
</sql-statement>
<sql-statement>
INSERT INTO xmltest2 VALUES('<d><r><bc>2</bc></r></d>', 'B');
</sql-statement>
<sql-statement>
INSERT INTO xmltest2 VALUES('<d><r><cc>3</cc></r></d>', 'C');
</sql-statement>
<sql-statement>
INSERT INTO xmltest2 VALUES('<d><r><dc>2</dc></r></d>', 'D');
</sql-statement>
<sql-statement>
SELECT xmltable.* FROM xmltest2, LATERAL xmltable('/d/r' PASSING x COLUMNS a int PATH '' || lower(_path) || 'c');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:83: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmltest2, LATERAL xmltable('/d/r' PASSING x COLUMNS a int PATH '' || lower(_path) || 'c');
	                                                                                  ^
<sql-statement>
SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH '.');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:109: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH '.');
	                                                                                                            ^
<sql-statement>
SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH 'x' DEFAULT ascii(_path) - 54);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:109: Error: ERROR:  unrecognized column option "PATH"

    	SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH 'x' DEFAULT ascii(_path) - 54);
	                                                                                                            ^
<sql-statement>
-- XPath result can be boolean or number too
SELECT * FROM XMLTABLE('*' PASSING '<a>a</a>' COLUMNS a xml PATH '.', b text PATH '.', c text PATH '"hi"', d boolean PATH '. = "a"', e integer PATH 'string-length(.)');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:61: Error: ERROR:  unrecognized column option "PATH"

    	SELECT * FROM XMLTABLE('*' PASSING '<a>a</a>' COLUMNS a xml PATH '.', b text PATH '.', c text PATH '"hi"', d boolean PATH '. = "a"', e integer PATH 'string-length(.)');
	                                                            ^
<sql-statement>
\x
</sql-statement>
Metacommand \x is not supported
<sql-statement>
SELECT * FROM XMLTABLE('*' PASSING '<e>pre<!--c1--><?pi arg?><![CDATA[&ent1]]><n2>&amp;deep</n2>post</e>' COLUMNS x xml PATH 'node()', y xml PATH '/');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:122: Error: ERROR:  unrecognized column option "PATH"

    	SELECT * FROM XMLTABLE('*' PASSING '<e>pre<!--c1--><?pi arg?><![CDATA[&ent1]]><n2>&amp;deep</n2>post</e>' COLUMNS x xml PATH 'node()', y xml PATH '/');
	                                                                                                                         ^
<sql-statement>
\x
</sql-statement>
Metacommand \x is not supported
<sql-statement>
SELECT * FROM XMLTABLE('.' PASSING XMLELEMENT(NAME a) columns a varchar(20) PATH '"<foo/>"', b xml PATH '"<foo/>"');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:78: Error: ERROR:  unrecognized column option "PATH"

    	SELECT * FROM XMLTABLE('.' PASSING XMLELEMENT(NAME a) columns a varchar(20) PATH '"<foo/>"', b xml PATH '"<foo/>"');
	                                                                             ^
