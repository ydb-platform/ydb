syntax = "proto3";
import "ydb/public/api/protos/ydb_operation.proto";
import "ydb/public/api/protos/ydb_scheme.proto";
import "ydb/public/api/protos/ydb_status_codes.proto";
import "ydb/public/api/protos/ydb_issue_message.proto";
import "ydb/public/api/protos/annotations/sensitive.proto";
import "ydb/public/api/protos/annotations/validation.proto";

import "google/protobuf/duration.proto";

package Ydb.PersQueue.V1;

option java_package = "com.yandex.ydb.persqueue";

option cc_enable_arenas = true;

// NOTE:
// * We use 'ms' suffix instead of google.protobuf.Timestamp and google.protobuf.Duration in order to utilize
// packed encoding ('message' types can't be packed encoded). In non-repeated fields we use 'ms' for consistency.
// * Any message with non-empty 'issues' property leads to streaming RPC termination.

enum Codec {
    CODEC_UNSPECIFIED = 0;
    CODEC_RAW = 1;
    CODEC_GZIP = 2;
    CODEC_LZOP = 3;
    CODEC_ZSTD = 4;
}

message MetaValue {
    map<string, string> value = 1;
}

/**
 * Represents range [start_offset, end_offset).
 */
message OffsetsRange {
    int64 start_offset = 1;
    int64 end_offset = 2;
}

// In-session reauthentication and reauthorization, lets user increase session lifetime. You should wait for 'update_token_response' before sending next 'update_token_request'.
message UpdateTokenRequest {
    string token = 1 [(Ydb.sensitive) = true];
}

message UpdateTokenResponse {
}

/**
 * Request for write session. Contains one of:
 *      InitRequest - handshake request.
 *      WriteRequest - portion of data to be written.
 *      UpdateTokenRequest - user credentials if update is needed.
 */
message StreamingWriteClientMessage {
    oneof client_message {
        InitRequest init_request = 1;
        WriteRequest write_request = 2;
        UpdateTokenRequest update_token_request = 3;
    }


    // Handshake request that must be sent to server first.
    message InitRequest {
        // Path of topic to write to.
        string topic = 1;
        // message group identifier of client data stream a.k.a. sourceId.
        string message_group_id = 2 [(Ydb.length).le = 2048];
        // Some user metadata attached to this write session.
        map<string, string> session_meta = 3;
        // Partition group to write to.
        // Zero means any group.
        int64 partition_group_id = 4;

        int64 max_supported_format_version = 5;

        string session_id = 100;
        // 0 for first init message and incremental value for connect retries. Used for server logging.
        int64 connection_attempt = 101;
        // Opaque blob. Take last one from previous connect.
        bytes connection_meta = 102;

        // Optinal preferred cluster name. Sever will close session If preferred cluster is not server cluster and preferred cluster is enabled after delay TPQConfig::CloseClientSessionWithEnabledRemotePreferredClusterDelaySec
        string preferred_cluster = 103;

        // Sanity check option. When no writing activity is done in idle_timeout_sec seconds, then session will be destroyed. Zero means infinity.
        int64 idle_timeout_ms = 200;
    }

    // Represents portion of client messages.
    message WriteRequest {
        // Sequence numbers of messages in order that client will provide to server.
        repeated int64 sequence_numbers = 2;
        // Message creation timestamps for client messages.
        // Same size as sequence_numbers.
        repeated int64 created_at_ms = 3;
        // Message creation timestamps for client messages.
        // Same size as sequence_numbers.
        repeated int64 sent_at_ms = 4;
        // Client message sizes.
        // Same size as sequence_numbers.
        repeated int64 message_sizes = 5;

        // Block must contain whole client message when it's size is not bigger that max_block_size.
        // If message is bigger than max_block_size - it will be transferred as SIZE/max_block_size blocks. All of
        // this blocks will be with block_count = 0 but not the last one - last one's block_count will be greater than 0;
        // Blocks can be reordered upto max_flush_window_size of uncompressed data.
        // Each block contains concatenated client messages, compressed by chosen codec.
        // If there is not full client message inside block, then all block contains only this part of message.
        // blocks:      A A A B B B BCDE
        // offset:      1 1 1 2 2 2 2
        // part_number: 0 1 2 0 1 2 3
        // count:       0 0 1 0 0 1 4

        repeated int64 blocks_offsets = 6;
        repeated int64 blocks_part_numbers = 7;
        // How many complete messages and imcomplete messages end parts (one at most) this block contains
        repeated int64 blocks_message_counts = 8;
        repeated int64 blocks_uncompressed_sizes = 9;
        // In block format version 0 each byte contains only block codec identifier
        repeated bytes blocks_headers = 10;
        repeated bytes blocks_data = 11;
    }
}

/**
 * Response for write session. Contains one of:
 *      InitResponse - correct handshake response.
 *      BatchWriteResponse - acknowledgment of storing client messages.
 *      UpdateTokenResponse - acknowledgment of reauthentication and reauthorization.
 */
message StreamingWriteServerMessage {
    // Server status of response.
    Ydb.StatusIds.StatusCode status = 1;

    // Issues if any.
    repeated Ydb.Issue.IssueMessage issues = 2;

    oneof server_message {
        InitResponse init_response = 3;
        BatchWriteResponse batch_write_response = 4;
        UpdateTokenResponse update_token_response = 5;
    }

    // Response for handshake.
    message InitResponse {
        // Last persisted message's sequence number for this message group.
        int64 last_sequence_number = 1;
        // Unique identifier of write session. Used for debug purposes.
        string session_id = 2;
        // Path of topic that matched for this write session. Used for debug purposes, will be the same as in Init request from client.
        string topic = 3;
        // Write session is established to this cluster. Client data will be in instance of topic in this cluster.
        string cluster = 4;
        // Identifier of partition that is matched for this write session.
        int64 partition_id = 5;

        // Block (see StreamingWriteClientMessage.WriteRequest.blocks_data) format version supported by server or configured for a topic. Client must write data only with them.
        int64 block_format_version = 6;
        // Client can only use compression codecs from this set to write messages to topic, session will be closed with BAD_REQUEST otherwise.
        repeated Codec supported_codecs = 10;

        // Maximal flush window size choosed by server. Size of uncompressed data not sended to server must not be bigger than flush window size.
        // In other words, this is maximal size of gap inside uncompressed data, which is not sended to server yet.
        int64 max_flush_window_size = 7; // will be 2048kb
        // How big blocks per stream could be(in uncompressed size). When block contains more than max_block_size of uncompressed data - block must be truncated.
        int64 max_block_size = 8; // will be 512kb

        // Opaque blob, used for fast reconnects.
        bytes connection_meta = 9;
    }

    // Message that represents acknowledgment for sequence of client messages. This sequence is persisted together so write statistics is for messages batch.
    message BatchWriteResponse {
        // Sequence numbers of persisted client messages.
        repeated int64 sequence_numbers = 1;
        // Assigned partition offsets.
        // Zero for skipped messages.
        repeated int64 offsets = 2;
        // Per message flag. False if message is written for the first time and True otherwise.
        repeated bool already_written = 3;

        // Assigned partition for all client messages inside this batch.
        int64 partition_id = 4;

        // Write statistics for this sequence of client messages.
        WriteStatistics write_statistics = 5;
    }

    // Message with write statistics.
    message WriteStatistics {
        // Time spent in persisting of data.
        int64 persist_duration_ms = 1;
        // Time spent in queue before persisting.
        int64 queued_in_partition_duration_ms = 2;
        // Time spent awaiting for partition write quota.
        int64 throttled_on_partition_duration_ms = 3;
        // Time spent awaiting for topic write quota.
        int64 throttled_on_topic_duration_ms = 4;
    }
}


message Path {
    // Path of object (topic/consumer).
    string path = 1;
}

message KeyValue {
    string key = 1;
    string value = 2;
}

/**
 * Single read parameters for server.
 */
message ReadParams {
    // Max messages to give to client in one read request.
    uint32 max_read_messages_count = 1;
    // Max size in bytes to give to client in one read request.
    uint32 max_read_size = 2;
}

/**
 * Message that is used for addressing read for commiting.
 */
message CommitCookie {
    // Assign identitifier of assigned partition from which read was done.
    uint64 assign_id = 1;
    // Incremental identifier of concrete partition read batch.
    uint64 partition_cookie = 2;
}

message CommitOffsetRange {
    uint64 assign_id = 1;
    uint64 start_offset = 2;
    uint64 end_offset = 3;
}

/**
 * Message that represents concrete partition session.
 */
 message PartitionSession {
    // Topic path of partition.
    string topic = 1;
    // Cluster of topic instance.
    string cluster = 2;
    // Partition identifier. Explicit only for debug purposes.
    int64 partition_id = 3;
    // Partition group identifier. Explicit only for debug purposes.
    int64 partition_group_id = 4;

    // Identitifier of partition stream. Unique inside one RPC call.
    int64 partition_session_id = 6;

    // Opaque blob. Provide it with partition stream in state for session reconnects.
    bytes connection_meta = 7;
}

/**
 * Request for read session. Contains one of:
 *      InitRequest - handshake request.
 *      ReadRequest - request for data.
 *      CommitRequest - request for commit of some read data.
 *      StartPartitionSessionResponse - signal for server that client is ready to get data from partition.
 *      StopPartitionSessionResponse - signal for server that client finished working with partition. Must be sent only after corresponding request from server.
 *      PauseReadRequest - signal for server that client is not ready to get more data from this partition.
 *      ResumeReadRequest - signal for server that client is ready to get more data from this partition.
 *      PartitionSessionStatusRequest - request for session status
 *      AddTopicRequest - request for add topic
 *      RemoveTopicRequest - request for topic removal
 *      UpdateTokenRequest - request to update auth token
 */
message StreamingReadClientMessage {
    oneof client_message {
        InitRequest init_request = 1;
        ReadRequest read_request = 2;
        StartPartitionSessionResponse start_partition_session_response = 3;
        CommitRequest commit_request = 4;
        StopPartitionSessionResponse stop_partition_session_response = 5;
        PauseReadRequest pause_read_request = 6;
        ResumeReadRequest resume_read_request = 7;
        PartitionSessionStatusRequest partition_session_status_request = 8;
        AddTopicRequest add_topic_request = 9;
        RemoveTopicRequest remove_topic_request = 10;
        UpdateTokenRequest update_token_request = 11;
    }

    // Handshake request.
    message InitRequest {
        // Message that describes topic to read.
        // Topics that will be read by this session.
        repeated TopicReadSettings topics_read_settings = 1;
        // Flag that indicates reading only of original topics in cluster or all including mirrored.
        bool read_only_original = 2;
        // Path of consumer that is used for reading by this session.
        string consumer = 3;

        // Skip all messages that has write timestamp smaller than now - max_time_lag_ms.
        int64 max_lag_duration_ms = 4;
        // Read data only after this timestamp from all topics.
        int64 start_from_written_at_ms = 5;

        // Maximum block format version supported by the client. Server will asses this parameter and return actual data blocks version in
        // StreamingReadServerMessage.InitResponse.block_format_version_by_topic (and StreamingReadServerMessage.AddTopicResponse.block_format_version)
        // or error if client will not be able to read data.
        int64 max_supported_format_version = 6;

        // Maximal size of client cache for message_group_id, ip and meta, per partition.
        // There are separate caches for each partition partition sessions.
        // There are separate caches for message group identifiers, ip and meta inside one partition session.
        int64 max_meta_cache_size = 10;

        // State of client read session. Could be provided to server for retries.
        message State {
            message PartitionSessionState {
                enum Status {
                    // Not used state.
                    STATUS_UNSPECIFIED = 0;
                    // Client saw StartPartitionSessionRequest message but not yet responded.
                    STARTING = 1;
                    // Client saw StopPartitionSessionRequest message but not yet responded.
                    STOPPING = 2;
                    // Client sent StartPartitionSessionResponse or ResumeReadRequest message to server for this partition session.
                    READING = 3;
                    // Client sent PauseReadRequest for this partition session.
                    PAUSED = 4;
                }
                // Partition partition session.
                PartitionSession partition_session = 1;
                // Current read offset if has one. Actual for states DESTROYING, READING and STOPPED.
                int64 read_offset = 2;
                // Ranges of committed by client offsets.
                repeated OffsetsRange offsets_ranges = 3;
                // Status of partition session.
                Status status = 4;
            }
            repeated PartitionSessionState partition_sessions_states = 1;
        }

        // Session identifier for retries. Must be the same as session_id from Inited server response. If this is first connect, not retry - do not use this field.
        string session_id = 100;
        // 0 for first init message and incremental value for connect retries.
        int64 connection_attempt = 101;
        // Formed state for retries. If not retry - do not use this field.
        State state = 102;

        int64 idle_timeout_ms = 200;
    }

    // TODO: add topics/groups and remove them from reading

    // Message that represents client readiness for receiving more data.
    message ReadRequest {
        // Client acquired this amount of free bytes more for buffer. Server can send more data at most of this uncompressed size.
        // Subsequent messages with 5 and 10 request_uncompressed_size are treated by server that it can send messages for at most 15 bytes.
        int64 request_uncompressed_size = 1;
    }

    // Signal for server that cient is ready to recive data for partition.
    message StartPartitionSessionResponse {
        // Partition session identifier of partition to start read.
        int64 partition_session_id = 1;

        // Start reading from partition offset that is not less than read_offset.
        // Init.max_time_lag_ms and Init.read_timestamp_ms could lead to skip of more messages.
        // The same with actual committed offset. Regardless of set read_offset server will return data from maximal offset from read_offset, actual committed offset
        // and offsets calculated from Init.max_time_lag_ms and Init.read_timestamp_ms.
        int64 read_offset = 2;
        // All messages with offset less than commit_offset are processed by client. Server will commit this position if this is not done yet.
        int64 commit_offset = 3;

        // This option will enable sanity check on server for read_offset. Server will verify that read_offset is no less that actual committed offset.
        // If verification will fail then server will kill this read session and client will find out error in reading logic.
        // If client is not setting read_offset, sanity check will fail so do not set verify_read_offset if you not setting correct read_offset.
        bool verify_read_offset = 4;

    }

    // Signal for server that client finished working with this partition. Must be sent only after corresponding Release request from server.
    // Server will give this partition to other read session only after Released signal.
    message StopPartitionSessionResponse {
        // Partition session identifier of partition session that is released by client.
        int64 partition_session_id = 1;
    }

    // Signal for server that client is not ready to recieve more data from this partition.
    message PauseReadRequest {
        repeated int64 partition_session_ids = 1;
    }

    // Signal for server that client is ready to receive more data from this partition.
    message ResumeReadRequest {
        repeated int64 partition_session_ids = 1;

        // Offset to start reading - may be smaller than known one in case of dropping of read-ahead in client lib.
        repeated int64 read_offsets = 2;

        // Cookie for matching data from PartitionSession after resuming. Must be greater than zero.
        repeated int64 resume_cookies = 3;
    }

    // Signal for server that client processed some read data.
    message CommitRequest {
        // Partition offsets that indicates processed data.
        repeated PartitionCommit commits = 1;
    }

    message PartitionSessionStatusRequest {
        int64 partition_session_id = 1;
    }

    // Add topic to current read session.
    message AddTopicRequest {
        TopicReadSettings topic_read_settings = 1;
    }

    // Remove topic from current read session.
    message RemoveTopicRequest {
        string topic = 1;
    }

    message TopicReadSettings {
        // Topic path.
        string topic = 1;
        // Partition groups that will be read by this session.
        // If list is empty - then session will read all partition groups.
        repeated int64 partition_group_ids = 2;
        // Read data only after this timestamp from this topic.
        int64 start_from_written_at_ms = 3;
    }

    /**
     * Message that is used for describing commit.
     */
    message PartitionCommit {
        // Identifier of partition session with data to commit.
        int64 partition_session_id = 1;
        // Processed ranges.
        repeated OffsetsRange offsets = 2;
    }
}

/**
 * Response for read session. Contains one of :
 *      InitResponse - handshake response from server.
 *      ReadResponse - portion of data.
 *      StartPartitionSessionRequest - command from server to create a partition partition session.
 *      StopPartitionSessionRequest - command from server to destroy a partition partition session.
 *      CommitResponse - acknowledgment for commit.
 *      PartitionSessionStatusResponse - server response with partition session status.
 *      PauseReadResponse - acknowledgment for pausing read from this partition.
 *      ResumeReadResponse - acknowledgment for resuming read from this partition.
 *      AddTopicResponse - acknowledgment of topic adding.
 *      RemoveTopicResponse - acknowledgment of topic removal.
 *      UpdateTokenResponse - acknowledgment of token update.
 */
message StreamingReadServerMessage {
    // Server status of response.
    Ydb.StatusIds.StatusCode status = 1;

    // Issues if any.
    repeated Ydb.Issue.IssueMessage issues = 2;

    oneof server_message {
        InitResponse init_response = 3;
        ReadResponse read_response = 4;
        StartPartitionSessionRequest start_partition_session_request = 6;
        StopPartitionSessionRequest stop_partition_session_request = 7;
        CommitResponse commit_response = 8;
        PartitionSessionStatusResponse partition_session_status_response = 9;
        PauseReadResponse pause_read_response = 10;
        ResumeReadResponse resume_read_response = 11;
        AddTopicResponse add_topic_response = 12;
        RemoveTopicResponse remove_topic_response = 13;
        UpdateTokenResponse update_token_response = 14;
    }

    // Handshake response.
    message InitResponse {
        // Read session identifier for debug purposes.
        string session_id = 1;
        // Block format version of data client will receive from topics.
        map<string, int64> block_format_version_by_topic = 2;

        // Chosen maximal cache size by server.
        // Client must use cache of this size. Could change on retries - reduce size of cache in this case.
        int64 max_meta_cache_size = 10;
    }

    // Command to create and start a partition session.
    // Client must react on this signal by sending StartRead when ready recieve data from this partition.
    message StartPartitionSessionRequest {
        // Partition partition stream description.
        PartitionSession partition_session = 1;

        // Actual committed offset.
        int64 committed_offset = 2;
        // Offset of first not existing message in partition till now.
        int64 end_offset = 3;

    }

    // Command to stop and destroy concrete partition session.
    message StopPartitionSessionRequest {
        // Identifier of partition partition session that is ready to be closed by server.
        int64 partition_session_id = 1;

        // Flag of graceful stop.
        // If True then server is waiting for response from client before giving of this partition for other read session.
        // Server will not send more data from this partition.
        // Client can process all received data and wait for commit and only after send response.
        // If False then server gives partition for other session right now.
        // All further commits for this PartitionSession has no effect. Server is not waiting for response.
        bool graceful = 2;

        // Last known committed offset.
        int64 committed_offset = 3;
    }

    // Acknowledgement for commits.
    message CommitResponse {
        // Per-partition commit representation.
        message PartitionCommittedOffset {
            // Partition partition session identifier.
            int64 partition_session_id = 1;
            // Last committed offset.
            int64 committed_offset = 2;
        }
        // Partitions with progress.
        repeated PartitionCommittedOffset partitions_committed_offsets = 1;
    }

    // Data read.
    message ReadResponse {
        // One client message representation.
        message MessageData {
            // Partition offset in partition that assigned for message.
            int64 offset = 1; //unique value for clientside deduplication - Topic:Cluster:Partition:Offset
            // Sequence number that provided with message on write from client.
            int64 seq_no = 2;
            // Timestamp of creation of message provided on write from client.
            int64 create_timestamp_ms = 3;
            // Codec that is used for data compressing.
            Codec codec = 4;
            // Compressed client message body.
            bytes data = 5;
            // Uncompressed size of client message body.
            int64 uncompressed_size = 6;
            // kinesis data
            string partition_key = 7;
            bytes explicit_hash = 8;
        }

        // Representation of sequence of client messages from one write session.
        message Batch {
            // Source identifier provided by client for this batch of client messages.
            bytes message_group_id = 2 [(Ydb.length).le = 2048];
            // Client metadata attached to write session, the same for all messages in batch.
            MetaValue session_meta = 3;
            // Persist timestamp on server for batch.
            int64 write_timestamp_ms = 4;
            // Peer address of node that created write session.
            string ip = 5;

            // List of client messages.
            repeated MessageData message_data = 1;
        }

        // Representation of sequence of messages from one partition.
        message PartitionData {
            int64 partition_session_id = 1;

            // Client messages, divided by write sessions.
            repeated Batch batches = 2;
        }

        // Client messages, divided by partitions.
        repeated PartitionData partition_data = 1;
    }

    // Response for status request.
    message PartitionSessionStatusResponse {
        // Identifier of partition partition session that is ready to be closed by server.
        int64 partition_session_id = 1;

        int64 committed_offset = 2;
        int64 end_offset = 3;

        // WriteTimestamp of next message (and end_offset) will be not less that WriteWatermarkMs.
        int64 written_at_watermark_ms = 4;
    }

    message PauseReadResponse {
    }

    message ResumeReadResponse {
    }

    message AddTopicResponse {
        // Block format version of data client will receive from the topic.
        int64 block_format_version = 1;
    }

    message RemoveTopicResponse {
    }
}

/**
 * Message that represens concrete partition partition stream.
 */
message PartitionStream {
    // Topic path of partition.
    string topic = 1;
    // Cluster of topic instance.
    string cluster = 2;
    // Partition identifier. Explicit only for debug purposes.
    int64 partition_id = 3;
    // Partition group identifier. Explicit only for debug purposes.
    int64 partition_group_id = 4;

    // Identitifier of partition stream. Unique inside one RPC call.
    int64 partition_stream_id = 6;

    // Opaque blob. Provide it with partition stream in state for session reconnects.
    bytes connection_meta = 7;
}

/**
 * Request for read session. Contains one of :
 *      Init - handshake request.
 *      Read - request for data.
 *      Commit - request for commit of some read data.
 *      Start_read - signal for server that client is ready to get data from partition.
 *      Released - signal for server that client finished working with partition. Must be sent only after corresponding Release request from server.
 */
message MigrationStreamingReadClientMessage {
    message TopicReadSettings {
        // Topic path.
        string topic = 1;
        // Partition groups that will be read by this session.
        // If list is empty - then session will read all partition groups.
        repeated int64 partition_group_ids = 2;
        // Read data only after this timestamp from this topic.
        int64 start_from_written_at_ms = 3;
    }

    // Handshake request.
    message InitRequest {
        // Message that describes topic to read.
        // Topics that will be read by this session.
        repeated TopicReadSettings topics_read_settings = 1;
        // Flag that indicates reading only of original topics in cluster or all including mirrored.
        bool read_only_original = 2;
        // Path of consumer that is used for reading by this session.
        string consumer = 3;

        // Skip all messages that has write timestamp smaller than now - max_time_lag_ms.
        int64 max_lag_duration_ms = 4;
        // Read data only after this timestamp from all topics.
        int64 start_from_written_at_ms = 5;

        // Maximum block format version supported by the client. Server will asses this parameter and return actual data blocks version in
        // StreamingReadServerMessage.InitResponse.block_format_version_by_topic (and StreamingReadServerMessage.AddTopicResponse.block_format_version)
        // or error if client will not be able to read data.
        int64 max_supported_block_format_version = 6;

        // Maximal size of client cache for message_group_id, ip and meta, per partition.
        // There is separate caches for each partition partition streams.
        // There is separate caches for message group identifiers, ip and meta inside one partition partition stream.
        int64 max_meta_cache_size = 10;

        // State of client read session. Could be provided to server for retries.
        message State {
            message PartitionStreamState {
                enum Status {
                    // Not used state.
                    STATUS_UNSPECIFIED = 0;
                    // Client seen Create message but not yet responded to server with Created message.
                    CREATING = 1;
                    // Client seen Destroy message but not yet responded with Released message.
                    DESTROYING = 2;
                    // Client sent Created or ResumeReadRequest message to server for this partition stream.
                    READING = 3;
                    // Client sent StopReadRequest for this partition stream.
                    STOPPED = 4;
                }
                // Partition partition stream.
                PartitionStream partition_stream = 1;
                // Current read offset if has one. Actual for states DESTROYING, READING and STOPPED.
                int64 read_offset = 2;
                // Ranges of committed by client offsets.
                repeated OffsetsRange offset_ranges = 3;
                // Status of partition stream.
                Status status = 4;
            }
            repeated PartitionStreamState partition_streams_states = 1;
        }

        // Session identifier for retries. Must be the same as session_id from Inited server response. If this is first connect, not retry - do not use this field.
        string session_id = 100;
        // 0 for first init message and incremental value for connect retries.
        int64 connection_attempt = 101;
        // Formed state for retries. If not retry - do not use this field.
        State state = 102;

        int64 idle_timeout_ms = 200;


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // TODO: remove after refactoring
        // Single read request params.
        ReadParams read_params = 42;

        bool ranges_mode = 442;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }

    // Request of single read.
    message Read {
    }

    message StartRead {
        // Topic path of partition.
        Path topic = 1;
        // Cluster of topic instance.
        string cluster = 2;
        // Partition identifier. Explicit only for debug purposes.
        uint64 partition = 3;

        // Assign identifier of Assign request from server. Used for mathing Assign requests from server with StartRead responses from client.
        uint64 assign_id = 5;

        // Start reading from partition offset that is not less than read_offset.
        // ReadParams.max_time_lag_ms and ReadParams.read_timestamp_ms could lead to skip of more messages.
        // The same with actual committed offset. Regardless of set read_offset server will return data from maximal offset from read_offset, actual committed offset
        // and offsets calculated from ReadParams.max_time_lag_ms and ReadParams.read_timestamp_ms.
        uint64 read_offset = 6;
        // All messages with offset less than commit_offset are processed by client. Server will commit this position if this is not done yet.
        uint64 commit_offset = 7;

        // This option will enable sanity check on server for read_offset. Server will verify that read_offset is no less that actual committed offset.
        // If verification will fail then server will kill this read session and client will find out error in reading logic.
        // If client is not setting read_offset, sanity check will fail so do not set verify_read_offset if you not setting correct read_offset.
        bool verify_read_offset = 8; //if true then check that committed position is <= ReadOffset; otherwise it means error in client logic

    }
    // Signal for server that client finished working with this partition. Must be sent only after corresponding Release request from server.
    // Server will give this partition to other read session only after Released signal.
    message Released {
        // Topic path of partition.
        Path topic = 1;
        // Cluster of topic instance.
        string cluster = 2;
        // Partition identifier. Explicit only for debug purposes.
        uint64 partition = 3;

        // Assign identifier of Assign request from server. Used for mathing Assign requests from server with Released responses from client.
        uint64 assign_id = 5;
    }

    // Signal for server that client processed some read data.
    message Commit {
        // Partition read cookies that indicates processed data.
        repeated CommitCookie cookies = 1;

        repeated CommitOffsetRange offset_ranges = 2;
    }

    message Status {
        // Topic path of partition.
        Path topic = 1;
        // Cluster of topic instance.
        string cluster = 2;
        // Partition identifier. Explicit only for debug purposes.
        uint64 partition = 3;

        // Assign identifier of Assign request from server. Used for mathing Assign requests from server with Released responses from client.
        uint64 assign_id = 5;

    }

    oneof request {
        InitRequest init_request = 1;
        Read read = 2;
        StartRead start_read = 3;
        Commit commit = 4;
        Released released = 5;
        Status status = 6;
    }

    // User credentials if update is needed or empty string.
    bytes token = 20 [(Ydb.sensitive) = true];
}

/**
 * Response for read session. Contains one of :
 *      Inited - handshake response from server.
 *      Batched_data - result of single read.
 *      Committed - acknowledgment for commit.
 *      Assigned - signal from server for assigning of partition.
 *      Release - signal from server for releasing of partition.
 */
message MigrationStreamingReadServerMessage {
    // Handshake response.
    message InitResponse {
        // Read session identifier for debug purposes.
        string session_id = 1;
        // Block format version of data client will receive from topics.
        map<string, int64> block_format_version_by_topic = 2;

        // Choosed maximan cache size by server.
        // Client must use cache of this size. Could change on retries - reduce size of cache in this case.
        int64 max_meta_cache_size = 10;
    }

    // Signal that partition is assigned to this read session. Client must react on this signal by sending StartRead when ready.
    message Assigned {
        // Partition's topic path.
        Path topic = 1;
        // Topic's instance cluster name.
        string cluster = 2;
        // Partition identifier. topic:cluster:partition is unique addressing of partition.
        uint64 partition = 3;

        // Assign idenfier. Is not unique between diffrent partitions. Used for matching Assigned request from server and StartRead response from client.
        uint64 assign_id = 5;

        // Actual read offset. Equeal to last committed offset.
        uint64 read_offset = 6;
        // Offset of first not existing message in partition at this time.
        uint64 end_offset = 7;
    }

    // Partition release request from server.
    message Release {
        // Partition's topic path.
        Path topic = 1;
        // Topic's instance cluster name.
        string cluster = 2;
        // Partition identifier. topic:cluster:partition is unique addressing of partition.
        uint64 partition = 3;

        // Assign idenfier. Used for matching Assigned and Release requests from server.
        uint64 assign_id = 5;

        // If False then server is waiting for Released signal from client before giving of this partition for other read session.
        // If True then server gives partition for other session right now. All futher commits for this partition has no effect. Server is not waiting for Released signal.
        bool forceful_release = 6;
        // Last known committed offset.
        uint64 commit_offset = 7;
    }

    // Acknowledgement for commits.
    message Committed {
        // List of cookies that correspond to commit of processing read data.
        repeated CommitCookie cookies = 1;

        repeated CommitOffsetRange offset_ranges = 2;

    }

    // Readed data.
    message DataBatch {
        // One client message representation.
        message MessageData {
            // Partition offset in partition that assigned for message.
            uint64 offset = 1; //unique value for clientside deduplication - Topic:Cluster:Partition:Offset
            // Sequence number that provided with message on write from client.
            uint64 seq_no = 2;
            // Timestamp of creation of message provided on write from client.
            uint64 create_timestamp_ms = 3;
            // Codec that is used for data compressing.
            Codec codec = 4;
            // Compressed client message body.
            bytes data = 5;
            // Uncompressed size of client message body.
            uint64 uncompressed_size = 6;
            // kinesis data
            string partition_key = 7;
            bytes explicit_hash = 8;
        }

        // Representation of sequence of client messages from one write session.
        message Batch {
            // Source identifier provided by client for this batch of client messages.
            bytes source_id = 2 [(Ydb.length).le = 2048];
            // Client metadata attached to write session, the same for all messages in batch.
            repeated KeyValue extra_fields = 3;
            // Persist timestamp on server for batch.
            uint64 write_timestamp_ms = 4;
            // Peer address of node that created write session.
            string ip = 5;

            // List of client messages.
            repeated MessageData message_data = 1;
        }

        // Representation of sequence of messages from one partition.
        message PartitionData {
            // Partition's topic path.
            Path topic = 1;
            // Topic's instance cluster name.
            string cluster = 2;
            // Partition identifier. topic:cluster:partition is unique addressing for partition.
            uint64 partition = 3;

            // Client messages, divided by write sessions.
            repeated Batch batches = 4;

            // Cookie for addressing this partition messages batch for committing.
            CommitCookie cookie = 5;

             // Old formatted topic name with cluster inside.
            string deprecated_topic = 10;
        }

        // Client messages, divided by partitions.
        repeated PartitionData partition_data = 1;
    }

    // Response for status requst.
    message PartitionStatus {
        // Partition's topic path.
        Path topic = 1;
        // Topic's instance cluster name.
        string cluster = 2;
        // Partition identifier. topic:cluster:partition is unique addressing of partition.
        uint64 partition = 3;

        // Assign idenfier. Used for matching Assigned and Release requests from server.
        uint64 assign_id = 5;

        uint64 committed_offset = 6;
        uint64 end_offset = 7;
        uint64 write_watermark_ms = 8;
    }
    Ydb.StatusIds.StatusCode status = 1;

    repeated Ydb.Issue.IssueMessage issues = 2;

    oneof response {
        InitResponse init_response = 3;
        DataBatch data_batch = 4;
        Assigned assigned = 5;
        Release release = 6;
        Committed committed = 7;
        PartitionStatus partition_status = 8;
    }
}

/**
 * Reading information request sent from client to server.
 */
message ReadInfoRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // List of topics that are beeing read.
    repeated Path topics = 2;
    // If get_only_original == false then return info about mirrored topics too.
    bool get_only_original = 3;
    // Consumer path that is reading specified topics.
    Path consumer = 4;
}


/**
 * Reading information response sent from server to client.
 */
message ReadInfoResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Reading information message that will be inside ReadInfoResponse.operation.
 */
message ReadInfoResult {
    // Message containing information about concrete topic reading.
    message TopicInfo {
        // Message containing information about concrete topic's partition reading.
        message PartitionInfo {
            // Patition identifier inside topic.
            uint64 partition = 1;

            // Request status of partition.
            Ydb.StatusIds.StatusCode status = 2;
            // Issues if any.
            repeated Ydb.Issue.IssueMessage issues = 3;

            // Offset of first message in partition.
            uint64 start_offset = 4;
            // Offset of next not yet existing message in partition.
            uint64 end_offset = 5;

            // Offset of consumer committed message a.k.a. first not processed message.
            // If commit_offset == end_offset then all messages from partition are processed.
            uint64 commit_offset = 6;
            // Consumer lag in time between committed and last messages in partition.
            uint64 commit_time_lag_ms = 7;

            // Offset of first not read message by consumer from this partition.
            // read_offset can be bigger that committed_offset - consumer could read some messages but not yet commit them.
            uint64 read_offset = 8;
            // Consumer lag in time between read and last messages in partition.
            uint64 read_time_lag_ms = 9;

            // Session identifier that locked and reading this partition right now.
            string session_id = 10;
            // Ip if node that created reading this session.
            string client_node = 11;
            // Host name of proxy node that processing this reading session.
            string proxy_node = 12;
            // Host name of node where partition leader is running.
            string tablet_node = 13;

            // Assign identifier of actual partition assignment.
            uint64 assign_id = 14;
            // Timestamp of assignment.
            uint64 assign_timestamp_ms = 15;
            // Cookie of last performed read in session.
            uint64 last_read_cookie = 16;
            // Cookie upto whitch commits done.
            uint64 committed_read_cookie = 17;
            // Cookie that client wants to commit, but server is waiting for committed_read_cookie + 1.
            repeated uint64 out_of_order_read_cookies_to_commit = 18;
        }
        // Topic path.
        Path topic = 1;
        // Topic original cluster.
        string cluster = 2;

        // Status of whole topic.
        Ydb.StatusIds.StatusCode status = 3;
        // Issues if any.
        repeated Ydb.Issue.IssueMessage issues = 4;

        // Reading info for partitions of this topic.
        repeated PartitionInfo partitions = 5;
    }

    // List of topics info.
    repeated TopicInfo topics = 1;
}

/**
 * Drop topic request sent from client to server.
 */
message DropTopicRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // Topic path.
    string path = 2;
}


/**
 * Drop topic response sent from server to client. If topic is not existed then response status will be "SCHEME_ERROR".
 */
message DropTopicResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Drop topic result message that will be inside DropTopicResponse.operation.
 */
message DropTopicResult {
}

/**
 * Credentials settings
 */
message Credentials {
    message Iam {
        string endpoint = 1;
        string service_account_key = 2;
    }
    oneof credentials {
        string oauth_token = 1 [(Ydb.sensitive) = true];
        string jwt_params = 2 [(Ydb.sensitive) = true];
        Iam iam = 3;
    }
}

enum AutoPartitioningStrategy {
    // The auto partitioning algorithm is not specified. The default value will be used.
    AUTO_PARTITIONING_STRATEGY_UNSPECIFIED = 0;
    // The auto partitioning is disabled.
    AUTO_PARTITIONING_STRATEGY_DISABLED = 1;
    // The auto partitioning algorithm will increase partitions count depending on the load characteristics.
    // The auto partitioning algorithm will never decrease the number of partitions.
    AUTO_PARTITIONING_STRATEGY_SCALE_UP = 2;
    // The auto partitioning algorithm will both increase and decrease partitions count depending on the load characteristics.
    AUTO_PARTITIONING_STRATEGY_SCALE_UP_AND_DOWN = 3;
    // The auto partitioning is paused.
    AUTO_PARTITIONING_STRATEGY_PAUSED = 4;
}

/**
 * Message for describing topic internals.
 */
message TopicSettings {
    enum Format {
        FORMAT_UNSPECIFIED = 0;
        FORMAT_BASE = 1;
    }


    // How many partitions in topic. Must less than database limit. Default limit - 10.
    int32 partitions_count = 1 [(value) = "> 0"];
    // Settings for the partitions count auto partitioning.
    AutoPartitioningSettings auto_partitioning_settings = 15;


    oneof retention {
        // How long data in partition should be stored. Must be greater than 0 and less than limit for this database.
        // Default limit - 36 hours.
        int64 retention_period_ms = 2 [(value) = "> 0"];
        // How much data in partition should be stored. Must be greater than 0 and less than limit for this database.
        int64 retention_storage_bytes = 14 [(value) = ">= 0"];
    }
    // How long last written seqno for message group should be stored. Must be greater then retention_period_ms and less then limit for this database.  Default limit - 16 days.
    int64 message_group_seqno_retention_period_ms = 12 [(value) = ">= 0"];
    // How many last written seqno for various message groups should be stored per partition. Must be less than limit for this database.  Default limit - 6*10^6 values.
    int64 max_partition_message_groups_seqno_stored = 13 [(value) = ">= 0"];
    // Max format version that is allowed for writers. Must be value from enum FormatVersion.
    // Writes with greater format version are forbiden.
    Format supported_format = 3;
    // List of allowed codecs for writers.
    // Writes with codec not from this list are forbiden.
    repeated Codec supported_codecs = 4 [(size).le = 100];
    // Max storage usage for each topic's partition. Must be less than database limit. Default limit - 130 GB.
    int64 max_partition_storage_size = 5 [(value) = ">= 0"];
    // Partition write speed in bytes per second. Must be less than database limit. Default limit - 1 MB/s.
    int64 max_partition_write_speed = 6 [(value) = ">= 0"];
    // Burst size for write in partition, in bytes. Must be less than database limit. Default limit - 1 MB.
    int64 max_partition_write_burst = 7 [(value) = ">= 0"];

    // Disallows client writes. Used for mirrored topics in federation.
    bool client_write_disabled = 8;
    // Message for read rules description.
    message ReadRule {
        // For what consumer this read rule is. Must be valid not empty consumer name.
        // Is key for read rules. There could be only one read rule with corresponding consumer name.
        string consumer_name = 1 [(required) = true];
        // Flag that this consumer is important.
        bool important = 2;
        // All messages with smaller timestamp of write will be skipped.
        int64 starting_message_timestamp_ms = 3 [(value) = ">= 0"];
        // Max format version that is supported by this consumer.
        // supported_format on topic must not be greater.
        Format supported_format = 4;
        // List of supported codecs by this consumer.
        // supported_codecs on topic must be contained inside this list.
        repeated Codec supported_codecs = 5 [(size).le = 100];

        // Read rule version. Any non-negative integer.
        int64 version = 6 [(value) = ">= 0"];

        // Client service type.
        string service_type = 7;
    }

    // List of consumer read rules for this topic.
    repeated ReadRule read_rules = 9 [(size).le = 3000];

    // User and server attributes of topic. Server attributes starts from "_" and will be validated by server.
    map<string, string> attributes = 10;

    // Message for remote mirror rule description.
    message RemoteMirrorRule {
        // Source cluster endpoint in format server:port.
        string endpoint = 1;
        // Source topic that we want to mirror.
        string topic_path = 2;
        // Source consumer for reading source topic.
        string consumer_name = 3;
        // Credentials for reading source topic by source consumer.
        Credentials credentials = 4;
        // All messages with smaller timestamp of write will be skipped.
        int64 starting_message_timestamp_ms = 5 [(value) = ">= 0"];
        // Database
        string database = 6;
    }
    // remote mirror rule for this topic.
    RemoteMirrorRule remote_mirror_rule = 11;
}

message AutoPartitioningSettings {
    // Strategy of auto partitioning.
    AutoPartitioningStrategy strategy = 1;

    // Auto merge would stop working when the partitions count reaches min_active_partitions.
    // Zero value means default - 1.
    int64 min_active_partitions = 2 [(Ydb.value) = ">= 0"];
    // Auto split would stop working when the partitions count reaches max_active_partitions.
    // Zero value means default - 1.
    int64 max_active_partitions = 3 [(Ydb.value) = ">= 0"];
    // Limit for total partition count, including active (open for write) and read-only partitions.
    // Zero value means default - 100.
    int64 partition_count_limit = 4 [(Ydb.value) = ">= 0", deprecated = true];

    // Partition write speed auto partitioning options.
    AutoPartitioningWriteSpeedStrategy partition_write_speed = 5;
}

message AutoPartitioningWriteSpeedStrategy {
    //Partition will be auto partitioning up (divided into 2 partitions)
    //after write speed to the partition exceeds up_utilization_percent (in percentage of maximum write speed to the partition) for the period of time stabilization_window

    //Partition will become a candidate to the auto partitioning down
    //after write speed doesnt reach down_utilization_percent (in percentage of maximum write speed to the partition) for the period of time stabilization_window
    //This candidate partition will be auto partitioned down when other neighbour partition will become a candidate to the auto partitioning down and not earlier than a retention period.

    // Zero value means default - 300.
    google.protobuf.Duration stabilization_window = 1;
    // Zero value means default - 90.
    int32 up_utilization_percent  = 2 [(Ydb.value) = ">= 0"];
    // Zero value means default - 30.
    int32 down_utilization_percent  = 3 [(Ydb.value) = ">= 0"];
}

/**
 * Create topic request sent from client to server.
 */
message CreateTopicRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // Topic path.
    string path = 2 [(required) = true];
    // Topic settings.
    TopicSettings settings = 4;
}


/**
 * Create topic response sent from server to client. If topic is already exists then response status will be "ALREADY_EXISTS".
 */
message CreateTopicResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Create topic result message that will be inside CreateTopicResponse.operation.
 */
message CreateTopicResult {
}

/**
 * Update existing topic request sent from client to server.
 */
message AlterTopicRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // Topic path.
    string path = 2 [(required) = true];
    // New topic settings to be set. All options inside should be set despite same value.
    TopicSettings settings = 4;
}

/**
 * Update topic response sent from server to client.
 */
message AlterTopicResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Update topic result message that will be inside UpdateTopicResponse.operation.
 */
message AlterTopicResult {
}

/**
 * Add read rules for existing topic request.
 */
message AddReadRuleRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // Topic path.
    string path = 2 [(required) = true];
    // read rules to add
    TopicSettings.ReadRule read_rule = 3;
}

/**
 * Add read rules for existing topic response.
 */
message AddReadRuleResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Add read rules result message that will be inside AddReadRuleReponse.operation.
 */
message AddReadRuleResult {
}

/**
 * Remove read rules request for existing topic.
 */
message RemoveReadRuleRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // Topic path.
    string path = 2 [(required) = true];
    // read rules to remove. Only consumer names
    string consumer_name = 3;
}

/**
 * Remove read rules response for existing topic.
 */
message RemoveReadRuleResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Remove read rules result message that will be inside RemoveReadRuleReponse.operation.
 */
message RemoveReadRuleResult {
}

/**
 * Describe topic request sent from client to server.
 */
message DescribeTopicRequest {
    Ydb.Operations.OperationParams operation_params = 1;
    // Topic path.
    string path = 2 [(required) = true];
}

/**
 * Describe topic response sent from server to client. If topic is not existed then response status will be "SCHEME_ERROR".
 */
message DescribeTopicResponse {
    // Result of request will be inside operation.
    Ydb.Operations.Operation operation = 1;
}

/**
 * Describe topic result message that will be inside DescribeTopicResponse.operation.
 */
message DescribeTopicResult {
    // Topic path.
    Ydb.Scheme.Entry self = 1;
    // Settings of topic.
    TopicSettings settings = 2;

}
