// Auto-generated by {{ generator }}, do not modify.

{% set nNspace = ENV("NODES_NAMESPACE") %}

{%- if nNspace != "" %}

{% set nPrefix = nNspace + "::" %}
{% set nNspaceOpen = "namespace " +  nNspace + " {" %}
{% set nNspaceClose = "} // namespace " +  nNspace %}

{% else %}
{% set nPrefix, nNspaceOpen, nNspaceClose = "", "", "" %}
{%- endif %}

{% if genType == "Header" %}
#pragma once

#include <yql/essentials/core/expr_nodes_gen/yql_expr_nodes_gen.h>
#include <util/generic/hash_set.h>

namespace NYql {
namespace NNodes {
{{ nNspaceOpen }}
namespace NGenerated {

{% for node in nodes -%}
template<{{ node.aux.typenames | join(", ") }}>
class {{ node.aux.stubName }} :
{%- if node.Base == model.FreeArgCallableBase %}
    public {{ node.Base }}<{{ node.aux.allChildren | length}}> {
{% else %}
    public {{ node.Base }} {
{%- endif %}
public:
    explicit {{ node.aux.stubName }}(const TExprNode* node)
        : {{ node.Base }}(node)
    {
    {%- if node.Match %}
        YQL_ENSURE(Match(node));
    {%- endif %}
    }

    explicit {{ node.aux.stubName }}(const TExprNode::TPtr& node)
        : {{ node.Base }}(node)
    {
    {%- if node.Match %}
        YQL_ENSURE(Match(node.Get()));
    {%- endif %}
    }

    {%- if node.Content %}
        {% if node.Content.Type == "TStringBuf" %}
    TStringBuf {{ node.Content.Name }}() const {
        return this->Ref().Content();
    }
        {% else %}
    static_assert(false, "Node {{node.Name}}: {{node.Content.Type}} is not supported as content type.");
        {% endif %}
    {% endif %}
    {% for child in node.Children %}
    static const size_t idx_{{child.Name}} = {{child.Index}};
        {% if child.Optional %}
    TMaybeNode<{{child.Type}}> {{child.Name}}() const {
        return idx_{{child.Name}} < this->Ref().ChildrenSize()
            ? {{child.Type}}(this->Ref().ChildPtr(idx_{{child.Name}}))
            : TMaybeNode<{{child.Type}}>();
    }
        {% else %}
    {{child.Type}} {{child.Name}}() const {
        return {{child.Type}}(this->Ref().ChildPtr(idx_{{child.Name}}));
    }
        {% endif -%}
    {%- endfor %}

    {%- if node.Match %}

    static bool Match(const TExprNode* node) {
        {%- if node.Match.Type == "Callable" %}
        return node->IsCallable(TStringBuf("{{ node.Match.Name }}"));
        {% elif node.Match.Type == "NodeType" %}
        return node->Type() == TExprNode::{{ node.Match.TypeName }};
        {% elif node.Match.Type == "CallableBase" %}
        static THashSet<TStringBuf> namesToMatch = {
            {%- for name in node.aux.namesToMatch %}
            TStringBuf("{{ name }}"),
            {%- endfor %}
        };
        return node->IsCallable(namesToMatch);
        {% elif node.Match.Type == "Tuple" %}
        return node->IsList()
            && node->ChildrenSize() >= {{ node.aux.fixedChildrenCount }}
            && node->ChildrenSize() <= {{ node.aux.allChildrenCount }};
        {% else %}
        static_assert(false, "Don't know how to match {{ node.Name }}.");
        {% endif %}
    }
        {%- if node.Match.Type == "Callable" %}
    static const TStringBuf CallableName() {
        return "{{ node.Match.Name }}"sv;
    }
        {%- endif %}
    {%- endif %}
};

template<template<typename> class TMaybe, typename TDerived, {{ node.aux.typenames | join(", ") }}>
class {{ node.aux.stubMaybeName }} : public TMaybe<{{node.Base}}> {
protected:
    {{ node.aux.stubMaybeName }}(const TExprNode* node)
        : TMaybe<{{ node.Base }}>(node && TDerived::Match(node) ? node : nullptr) {}
    {{ node.aux.stubMaybeName }}(const TExprNode::TPtr& node)
        : TMaybe<{{ node.Base }}>(node && TDerived::Match(node.Get()) ? node : TExprNode::TPtr()) {}
public:
    {% for child in node.Children %}
    TMaybe<{{child.Type}}> {{child.Name}}() const {
        return TMaybe<{{child.Type}}>(this->IsValid() {% if child.Optional %}&& {{child.Index}} < this->Ref().ChildrenSize() {% endif %}? this->Ref().ChildPtr({{child.Index}}) : TExprNode::TPtr());
    }
    {% endfor %}
    TDerived Cast() const {
        return TMaybe<{{node.Base}}>::Cast().template Cast<TDerived>();
    }
};

    {% if node.aux.generateBuilderStub %}
template<typename TBase, typename TParent, template<typename, typename> class TBuilder, typename TDerived, template<typename> class TMaybe, {{ node.aux.builderTypenames | join(", ") }}>
class {{ node.aux.stubBuilderName }} : public TBase {
protected:
    typedef std::function<TParent& (const TDerived&)> BuildFuncType;

    {{ node.aux.stubBuilderName }}(TExprContext& ctx, TPositionHandle pos, BuildFuncType buildFunc, typename TBase::GetArgFuncType getArgFunc)
        : TBase(ctx, pos, getArgFunc)
        , BuildFunc(buildFunc) {}

    void Check() {
        {% if node.Match and node.Match.Type == "CallableBase" %}
        if (CallableNameHolder.empty()) {
            ythrow yexception() << "{{node.Name}} builder: CallableName not defined.";
        }

        static THashSet<TStringBuf> namesToMatch = {
            {%- for name in node.aux.namesToMatch %}
            TStringBuf("{{ name }}"),
            {%- endfor %}
        };
        if (namesToMatch.find(CallableNameHolder) == namesToMatch.end()) {
            ythrow yexception() << "{{node.Name}} builder: Invalid CallableName: " << CallableNameHolder;
        }
        {% endif %}
        {% if node.aux.allChildren | count > 0 %}
        bool argsValid = true;
        bool argValid;
            {%- for child in node.aux.allChildren %}
        argValid = {{child.aux.holderName}}.IsValid();
                {% if child.Optional %}
        if (!argsValid && argValid) {
            ythrow yexception() << "{{node.Name}} builder: optional args mismatch: {{child.Name}}.";
        }
                {% else %}
        if (!argValid || !argsValid) {
            ythrow yexception() << "{{node.Name}} builder: {{child.Name}} not defined.";
        }
                {% endif %}
        argsValid = argValid;
            {%- endfor %}
        {% endif %}
    }

    {% if node.Match and node.Match.Type == "CallableBase" %}
    TString CallableNameHolder;
    {% endif %}
    {% for child in node.aux.allChildren %}
    TMaybe<{{child.Type}}> {{child.aux.holderName}};
    {%- endfor %}

    BuildFuncType BuildFunc;

public:
    typedef TDerived ResultType;

    TParent& Build() {
        Check();
        TDerived node = static_cast<TBuilder<TParent, TDerived>*>(this)->DoBuild();
        return BuildFunc(node);
    }

    typename TParent::ResultType Done() {
        TParent& parent = Build();
        return parent.Value();
    }

    {% if node.aux.allChildren | count > 0 %}
    TNodeBuilder<TParent, TDerived>& InitFrom(const ResultType& item) {
        {% if node.Match.Type == "CallableBase" %}
        CallableNameHolder = item.Ref().Content();
        {% endif %}
        {%- for child in node.aux.allChildren %}
        {%- if child.Optional %}
        if (item.{{child.Name}}()) {
            {{child.aux.holderName}} = item.{{child.Name}}().Cast();
        }
        {%- else %}
        {{child.aux.holderName}} = item.{{child.Name}}();
        {%- endif %}
        {%- endfor %}

        {%- if node.Builder.Kind == "FreeArg" %}
        TBase::FreeArgsHolder.assign(item.FreeArgs().begin(), item.FreeArgs().end());
        {%- endif %}

        return *static_cast<TNodeBuilder<TParent, TDerived>*>(this);
    }
    {% endif %}

    {% if node.Match and node.Match.Type == "CallableBase" %}
    TBuilder<TParent, TDerived>& CallableName(TStringBuf name) { CallableNameHolder = name; return *static_cast<TBuilder<TParent, TDerived>*>(this); }
    {% endif %}

    {%- for child in node.aux.allChildren %}
    TBuilder<TParent, TDerived>& {{child.Name}}(const TStringBuf& argName) { {{child.aux.holderName}} = {{child.Type}}(this->GetArgFunc(argName)); return *static_cast<TBuilder<TParent, TDerived>*>(this); }
        {% if child.Optional %}
    TBuilder<TParent, TDerived>& {{child.Name}}(const TMaybe<{{child.Type}}>& node) { {{child.aux.holderName}} = node; return *static_cast<TBuilder<TParent, TDerived>*>(this); }
        {% endif %}
    TBuilder<TParent, TDerived>& {{child.Name}}(const {{child.Type}}& node) { {{child.aux.holderName}} = node; return *static_cast<TBuilder<TParent, TDerived>*>(this); }

    TBuilder<TParent, TDerived>& {{child.Name}}(const TExprNode::TPtr& node) { {{child.aux.holderName}} = {{child.Type}}(node); return *static_cast<TBuilder<TParent, TDerived>*>(this); }

    TBuilder<TParent, TDerived>& {{child.Name}}(std::function<void(TExprNodeBuilder&)> fluentFunc) {
        TExprNodeBuilder fluentBuilder(this->Pos, this->Ctx, [this] (const TStringBuf& argName) {
            return this->GetArgFunc(argName).Ptr();
        });

        fluentFunc(fluentBuilder);
        {{child.aux.holderName}} = fluentBuilder.Build();
        return *static_cast<TBuilder<TParent, TDerived>*>(this);
    }

    TBuilder<TBuilder<TParent, TDerived>, {{child.Type}}> {{child.Name}}() {
        return TBuilder<TBuilder<TParent, TDerived>, {{child.Type}}>(this->Ctx, this->Pos,
            [this] (const {{child.Type}}& node) mutable -> TBuilder<TParent, TDerived>& {
                {{child.aux.holderName}} = node;
                return *static_cast<TBuilder<TParent, TDerived>*>(this);
            }, this->GetArgFunc);
    }

    template<typename TNode>
    TBuilder<TBuilder<TParent, TDerived>, TNode> {{child.Name}}() {
        return TBuilder<TBuilder<TParent, TDerived>, TNode>(this->Ctx, this->Pos,
            [this] (const TNode& node) mutable -> TBuilder<TParent, TDerived>&{
                {{child.aux.holderName}} = node;
                return *static_cast<TBuilder<TParent, TDerived>*>(this);
            }, this->GetArgFunc);
    }
    {%- endfor %}
};
    {% endif %}

{% endfor %}

} // namespace NGenerated
{{ nNspaceClose }}
} // namespace NNodes
} // namespace NYql
{% elif genType == "Declarations" -%}

{{ nNspaceOpen }}
{% for node in nodes %}
    {%- if node.Definition == "Custom" %}
class {{ node.Name }};
    {% else %}
using {{ node.Name }} = NGenerated::{{ node.aux.stubName }}<{{ node.aux.usages | join(", ") }}>;
    {% endif %}
{%- endfor %}
{{ nNspaceClose }}

{% elif genType == "Definitions" -%}

{{ nNspaceOpen }}
{% for node in nodes %}
static_assert(std::is_constructible<{{ node.Name }}, const TExprNode*>::value,
    "{{ node.Name }} isn't defined correctly.");
static_assert(std::is_constructible<{{ node.Name }}, const TExprNode::TPtr&>::value,
    "{{ node.Name }} isn't defined correctly.");
{% endfor %}
{{ nNspaceClose }}

{% for node in nodes %}
template<>
class TMaybeNode<{{ node.aux.qName }}> : public {{ nPrefix }}NGenerated::
    {{ node.aux.stubMaybeName }}<TMaybeNode, {{ node.aux.qName }}, {{ node.aux.qUsages | join(", ") }}>
{
public:
    TMaybeNode(const TExprNode* node = nullptr) : {{ node.aux.stubMaybeName }}(node) {}
    TMaybeNode(const TExprNode::TPtr& node) : {{ node.aux.stubMaybeName }}(node) {}
    TMaybeNode(const {{ node.aux.qName }}& node) : {{ node.aux.stubMaybeName }}(node.template Maybe<{{ node.aux.qName }}>()) {}
};
{% endfor %}

{{ nNspaceOpen }}
namespace NGenerated {
{% for node in nodes %}
    {%- if node.aux.generateBuilderStub %}
        {%- if node.Builder.Kind == "Node" %}
template<typename TParent>
using {{ node.aux.stubBuilderAliasName }} =
    NGenerated::{{ node.aux.stubBuilderName }}<{{ model.NodeBuilderBase }}, TParent, TNodeBuilder, {{ node.Name }},
        TMaybeNode, {{ node.aux.builderUsages | join(", ") }}>;
        {% elif node.Builder.Kind == "FreeArg" %}
template<typename TParent>
using {{ node.aux.stubBuilderAliasName }} =
    NGenerated::{{ node.aux.stubBuilderName }}<{{ model.FreeArgBuilderBase }}<TParent, {{ node.Name }}>, TParent, TNodeBuilder, {{ node.Name }},
        TMaybeNode, {{ node.aux.builderUsages | join(", ") }}>;
        {% endif %}
    {% endif %}
{%- endfor %}
} // namespace NGenerated
{{ nNspaceClose }}

{% for node in nodes %}
    {%- if node.aux.generateBuilder %}
        {% if node.Builder.Kind == "Node" or node.Builder.Kind == "FreeArg" %}
template<typename TParent>
class TNodeBuilder<TParent, {{ node.aux.qName }}> : public {{ nPrefix }}NGenerated::{{ node.aux.stubBuilderAliasName }}<TParent>
{
private:
    typedef typename {{ nPrefix }}NGenerated::{{ node.aux.stubBuilderAliasName }}<TParent>::BuildFuncType BuildFuncType;
    typedef typename {{ nPrefix }}NGenerated::{{ node.aux.stubBuilderAliasName }}<TParent>::GetArgFuncType GetArgFuncType;
public:
    TNodeBuilder(TExprContext& ctx, TPositionHandle pos, BuildFuncType buildFunc, GetArgFuncType getArgFunc)
        : {{ nPrefix }}NGenerated::{{ node.aux.stubBuilderAliasName }}<TParent>(ctx, pos, buildFunc, getArgFunc) {}
        {% elif node.Builder.Kind == "List" %}
template<typename TParent>
class TNodeBuilder<TParent, {{ node.aux.qName }}> : public TListBuilderBase<TParent, {{ node.aux.qName }}, {{ node.aux.qListItemType }}>
{
private:
    typedef typename TListBuilderBase<TParent, {{ node.aux.qName }}, {{ node.aux.qListItemType }}>::BuildFuncType BuildFuncType;
    typedef typename TListBuilderBase<TParent, {{ node.aux.qName }}, {{ node.aux.qListItemType }}>::GetArgFuncType GetArgFuncType;
public:
    TNodeBuilder(TExprContext& ctx, TPositionHandle pos, BuildFuncType buildFunc, GetArgFuncType getArgFunc)
        : TListBuilderBase<TParent, {{ node.aux.qName }}, {{ node.aux.qListItemType }}>(ctx, pos, buildFunc, getArgFunc) {}
        {% else %}
class UnknownBuilder {
    static_assert(false, "Unknown builder kind: {{ node.Builder.Kind }}.");
        {% endif %}
    {{ node.aux.qName }} DoBuild() {
        {%- if node.Match and (node.Match.Type == "Callable" or node.Match.Type == "CallableBase") %}
        TExprNode::TListType argsList;
            {%- if node.Builder.Kind == "List" %}
        for (auto child : this->Items) {
            argsList.push_back(child.Ptr());
        }
            {%- else %}
                {%- for child in node.aux.allChildren %}
        if (this->{{ child.aux.holderName }}) {
            YQL_ENSURE(argsList.size() == {{ child.Index }});
            argsList.push_back(this->{{ child.aux.holderName }}.Cast().Ptr());
        }
                {%- endfor %}
                {% if node.Builder.Kind == "FreeArg" %}
        size_t fixedChildCount = {{ node.aux.allChildren | length }};
        YQL_ENSURE(argsList.size() == fixedChildCount);
        for (size_t i = 0; i < this->FreeArgsHolder.size(); ++i) {
            argsList.push_back(this->FreeArgsHolder[i].Ptr());
        }
                {% endif %}
            {%- endif %}
            {%- if node.Match.Type == "CallableBase" %}
        auto node = this->Ctx.NewCallable(this->Pos, this->CallableNameHolder, std::move(argsList));
            {%- else %}
        auto node = this->Ctx.NewCallable(this->Pos, "{{ node.Match.Name }}", std::move(argsList));
            {%- endif %}
        return {{ node.aux.qName }}(node);
        {%- elif node.Match and node.Match.Type == "Tuple"%}
        TExprNode::TListType tupleItems;
            {%- for child in node.aux.allChildren %}
        if (this->{{ child.aux.holderName }}) {
            YQL_ENSURE(tupleItems.size() == {{ child.Index }});
            tupleItems.push_back(this->{{ child.aux.holderName }}.Cast().Ptr());
        }
            {%- endfor %}
        auto node = this->Ctx.NewList(this->Pos, std::move(tupleItems));
        return {{ node.aux.qName }}(node);
        {%- elif node.ListBase and node.Builder.Kind == "List"%}
        TExprNode::TListType nodeChildren;
        for (auto child : this->Items) {
            nodeChildren.push_back(child.Ptr());
        }
        auto node = this->Ctx.NewList(this->Pos, std::move(nodeChildren));
        return {{ node.aux.qName }}(node);
        {%- else %}
        static_assert(false, "Don't know how to build {{ node.Name }}.");
        {% endif %}
    }
};
    {%- endif %}
{%- endfor %}

{% endif %}
