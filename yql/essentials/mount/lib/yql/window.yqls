# library
(

(let empty_list (lambda '(list_type) (MatchType list_type 'Null (lambda '() (EmptyList)) (lambda '() (List list_type)))))

# list_type:type function:lambda
# doesn't support optional values
# simple function not support shift and recalculated on whole window
(let simple_traits_factory (lambda '(list_type function) (block '(
  (let init (lambda '(value) value))
  (let update (lambda '(value state) (Apply function value state)))
  (let shift (lambda '(value state) (Void)))
  (let current (lambda '(state) state))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type function:lambda
# doesn't support optional values
# easy function with update/shift
(let easy_traits_factory (lambda '(list_type function_update function_shift) (block '(
  (let init (lambda '(value) value))
  (let update (lambda '(value state) (Apply function_update value state)))
  (let shift (lambda '(value state) (Apply function_shift value state)))
  (let current (lambda '(state) state))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type function:lambda
# doesn't support optional values
# easy function with update/shift
(let easy_traits_factory_map (lambda '(list_type function_update function_shift function_map function_finish) (block '(
  (let init (lambda '(value) (Apply function_map value)))
  (let update (lambda '(value state) (Apply function_update (Apply function_map value) state)))
  (let shift (lambda '(value state) (Apply function_shift (Apply function_map value) state)))
  (let current (lambda '(state) (Apply function_finish state)))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type, factory:lambda, extractor:lambda
(let extractor_traits_factory (lambda '(list_type extractor factory) (block '(
  (let traits (Apply factory (ListType (TypeOf (Apply extractor (InstanceOf (ListItemType list_type)))))))
  (let init (NthArg '1 traits))
  (let update (NthArg '2 traits))
  (let shift (lambda '(value state) (Void)))
  (let current (NthArg '4 traits))
  (let defval (NthArg '5 traits))
  (let init_ext (lambda '(row) (Apply init (Apply extractor row))))
  (let update_ext (lambda '(row state) (Apply update (Apply extractor row) state)))
  (return (WindowTraits (ListItemType list_type) init_ext update_ext shift current defval))
))))

(let rank_traits_factory_raw (lambda '(list_type) (block '(
  (let init (lambda '(value) '((Uint64 '1) (Uint64 '1) value)))
  (let update (lambda '(value state) '((If (== value (Nth state '2)) (Nth state '0) (Inc (Nth state '1))) (Inc (Nth state '1)) value)))
  (let shift (lambda '(value state) (Void)))
  (let current (lambda '(state) (Nth state '0)))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

(let dense_rank_traits_factory_raw (lambda '(list_type) (block '(
  (let init (lambda '(value) '((Uint64 '1) value)))
  (let update (lambda '(value state) '((If (== value (Nth state '1)) (Nth state '0) (Inc (Nth state '0))) value)))
  (let shift (lambda '(value state) (Void)))
  (let current (lambda '(state) (Nth state '0)))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type
# doesn't support optional values
(let some_traits_factory_raw (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (Coalesce two one)))))
(let bit_and_traits_factory_raw (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (BitAnd one two)))))
(let bit_or_traits_factory_raw (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (BitOr one two)))))

(let bit_xor_traits_factory_raw (lambda '(list_type) (Apply easy_traits_factory list_type (lambda '(one two) (BitXor one two)) (lambda '(val state) (BitXor state val)))))

# list_type:type
# support optional values
(let bool_and_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (And one two)))))
(let bool_or_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (Or one two)))))
(let first_value_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) two))))
(let last_value_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) one))))
(let first_value_ignore_nulls_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type
  (lambda '(one two) (MatchType (TypeOf two) 'Optional (lambda '() (IfPresent two (lambda '(value) two) one)) (lambda '() two)))
)))
(let last_value_ignore_nulls_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type
  (lambda '(one two) (MatchType (TypeOf one) 'Optional (lambda '() (IfPresent one (lambda '(value) one) two)) (lambda '() one)))
)))

(let bool_xor_traits_factory_opt (lambda '(list_type) (Apply easy_traits_factory list_type (lambda '(one two) (Xor one two)) (lambda '(val state) (Xor state val)))))

# list_type:type n
# supports optional values
(let nth_value_traits_factory_opt (lambda '(list_type n) (block '(
  (let msg (String '"Expected positive integral number for second argument of nth_value"))
  (let n (Unwrap (SafeCast n 'Uint64) msg))
  (let n (Ensure n (> n (Uint64 '0)) msg))
  (let init (lambda '(value) '((If (== n (Uint64 '1)) value (Null)) (Uint64 '1))))
  (let update (lambda '(value state) '((If (== n (+ (Nth state '1) (Uint64 '1))) value (Nth state '0)) (+ (Nth state '1) (Uint64 '1)))))
  (let shift (lambda '(value state) (Void)))
  (let current (lambda '(state) (Nth state '0)))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type n
# supports optional values
(let nth_value_ignore_nulls_traits_factory_opt (lambda '(list_type n) (block '(
  (let msg (String '"Expected positive integral number for second argument of nth_value"))
  (let n (Unwrap (SafeCast n 'Uint64) msg))
  (let n (Ensure n (> n (Uint64 '0)) msg))
  (let init (lambda '(value) '((If (== n (Convert (Exists value) 'Uint64)) value (Null)) (Convert (Exists value) 'Uint64))))
  (let update (lambda '(value state) '((If (And (Exists value) (== n (+ (Nth state '1) (Convert (Exists value) 'Uint64)))) value (Nth state '0)) (+ (Nth state '1) (Convert (Exists value) 'Uint64)))))
  (let shift (lambda '(value state) (Void)))
  (let current (lambda '(state) (Nth state '0)))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type init:lambda
# doesn't support optional values
(let count_traits_factory (lambda '(list_type init) (block '(
  (let update (lambda '(value state) (AggrAdd state (Apply init value))))
  (let shift (lambda '(value state) (AggrAdd state (Minus (Apply init value)))))
  (let current (lambda '(state) state))
  (return (WindowTraits (ListItemType list_type) init update shift current (Uint64 '0)))
))))

# list_type:type
# support optional values
(let count_traits_factory_opt (lambda '(list_type) (block '(
  (let init (lambda '(value) (AggrCountInit value)))
  (let update (lambda '(value state) (AggrCountUpdate value state)))
  (let shift (lambda '(value state) (Void)))
  (let current (lambda '(state) state))
  (return (WindowTraits (ListItemType list_type) init update shift current (Uint64 '0)))
))))

# list_type:type
# support optional values
(let count_if_traits_factory_opt (lambda '(list_type) (Apply count_traits_factory list_type (lambda '(value) (Convert (Coalesce value (Bool '0)) 'Uint64)))))
(let count_all_traits_factory_opt (lambda '(list_type) (Apply count_traits_factory list_type (lambda '(value) (Uint64 '1)))))

(let remove_optional_type (lambda '(type) (MatchType type 'Optional (lambda '() (OptionalItemType type)) (lambda '() type))))
(let convert_interval_to_decimal (lambda '(value) (StrictCast (StrictCast value (DataType 'Int64)) (DataType 'Decimal '35 '0))))
(let convert_decimal_to_interval (lambda '(value) (StrictCast (StrictCast value (DataType 'Int64)) (DataType 'Interval))))

# list_type:type
# doesn't support optional values
(let avg_traits_factory_raw (lambda '(list_type) (block '(
  (let init (lambda '(value) '((MatchType (TypeOf value) 'Decimal (lambda '() (WidenIntegral value)) 'Interval (lambda '() (Apply convert_interval_to_decimal value )) (lambda '() (Convert value 'Double))) (Uint64 '1))))
  (let update (lambda '(value state) '((AggrAdd (Nth state '0) (MatchType (TypeOf value) 'Decimal (lambda '() (WidenIntegral value)) 'Interval (lambda '() (Apply convert_interval_to_decimal value )) (lambda '() (Convert value 'Double)))) (Inc (Nth state '1)))))
  (let shift (lambda '(value state) '((- (Nth state '0) value) (Dec (Nth state '1)))))
  (let current (lambda '(state) (MatchType (ListItemType list_type)
                                           'Decimal (lambda '() (Cast (Div (Nth state '0) (Nth state '1)) (ListItemType list_type)))
                                           'Interval (lambda '() (Unwrap (Apply convert_decimal_to_interval (Div (Nth state '0) (Nth state '1)) ) ))
                                           (lambda '() (Div (Nth state '0) (Nth state '1))))))
  (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type
# support optional values
(let list_traits_factory_opt_gen (lambda '(limit defval) (block '(
(return (lambda '(list_type) (block '(
    (let item_type (ListItemType list_type))
    (let init (lambda '(value) (MatchType item_type
        'Optional (lambda '() (ToList value))
        'Null (lambda '() (EmptyList))
        (lambda '() (AsList value)))))
    (let update (lambda '(value state) (block '(
       (let x (MatchType item_type
        'Optional (lambda '() (IfPresent value (lambda '(value) (Insert state value)) state))
        'Null (lambda '() (EmptyList))
        (lambda '() (Insert state value))))
       (return (If (== limit (Uint64 '0)) x (Take x limit)))))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) state))
    (return (WindowTraits item_type init update shift current defval))
))))))))

# list_type:type stddev:bool sample:bool
# doesn't support optional values
(let variance_traits_factory_raw (lambda '(list_type stddev sample) (block '(
    (let init (lambda '(value) '(
        (Convert value 'Double)
        (Double '1)
        (Double '0))))
    (let update (lambda '(value state) (block '(
        (let delta (- (Convert value 'Double) (Nth state '0)))
        (let next_n (Inc (Nth state '1)))
        (return '(
            (AggrAdd (Nth state '0) (/ delta next_n))
            next_n
            (AggrAdd (Nth state '2) (/ (* (* delta delta) (Nth state '1)) next_n))
         ))))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (block '(
                 (let count (Nth state '1))
                 (let result (/ (Nth state '2) (If sample (Dec count) count)))
                 (return (If stddev (Apply (Udf 'Math.Sqrt) result) result))))))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type
# doesn't support optional values
(let variance_0_0_traits_factory_raw (lambda '(list_type) (Apply variance_traits_factory_raw list_type (Bool '0) (Bool '0))))
(let variance_1_0_traits_factory_raw (lambda '(list_type) (Apply variance_traits_factory_raw list_type (Bool '1) (Bool '0))))
(let variance_0_1_traits_factory_raw (lambda '(list_type) (Apply variance_traits_factory_raw list_type (Bool '0) (Bool '1))))
(let variance_1_1_traits_factory_raw (lambda '(list_type) (Apply variance_traits_factory_raw list_type (Bool '1) (Bool '1))))


# list_type:type
# doesn't support optional values
(let correlation_traits_factory_raw (lambda '(list_type) (block '(
    (let init (lambda '(value) '((Uint64 '1) (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)) (* (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0))) (* (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0))) (* (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0))))))
    (let update (lambda '(value state) '((Inc (Nth state '0)) (AggrAdd (Nth state '1) (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0))) (AggrAdd (Nth state '2) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0))) (AggrAdd (Nth state '3) (* (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)))) (AggrAdd (Nth state '4) (* (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)))) (AggrAdd (Nth state '5) (* (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)))))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (block '(
        # Math comes from ISO9075-2:2011(E) and differs from what Excel uses
        (let dividend (* (Nth state '3) (Nth state '0)))
        (let dividend (- dividend (* (Nth state '1) (Nth state '2))))
        (let divisor1 (* (Nth state '4) (Nth state '0)))
        (let divisor1 (- divisor1 (* (Nth state '1) (Nth state '1))))
        (let divisor2 (* (Nth state '5) (Nth state '0)))
        (let divisor2 (- divisor2 (* (Nth state '2) (Nth state '2))))
        (return (/ dividend (Apply (Udf 'Math.Sqrt) (* divisor1 divisor2))))
    ))))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type sample:bool
# doesn't support optional values
(let covariance_traits_factory_raw (lambda '(list_type sample) (block '(
    (let init (lambda '(value) '((Uint64 '1) (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)) (* (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0))))))
    (let update (lambda '(value state) '((Inc (Nth state '0)) (AggrAdd (Nth state '1) (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0))) (AggrAdd (Nth state '2) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0))) (AggrAdd (Nth state '3) (* (Coalesce (Convert (Nth value '0) 'Double) (Double '0.0)) (Coalesce (Convert (Nth value '1) 'Double) (Double '0.0)))))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (block '(
        (let covariance_result (- (Nth state '3) (/ (* (Nth state '1) (Nth state '2)) (Nth state '0))))
        (let covariance_result (/ covariance_result (If sample (Dec (Nth state '0)) (Nth state '0))))
        (return covariance_result)
    ))))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type
# doesn't support optional values
(let covariance_population_traits_factory_raw (lambda '(list_type) (Apply covariance_traits_factory_raw list_type (Bool '0))))
(let covariance_sample_traits_factory_raw (lambda '(list_type) (Apply covariance_traits_factory_raw list_type (Bool '1))))

# list_type:type histogram:atom value:lamba weight:lambda intervals:integer
# doesn't support optional values
(let histogram_traits_factory_raw (lambda '(list_type histogram value weight intervals) (block '(
    (let init (lambda '(row parent) (NamedApply (Udf (Combine histogram '_Create)) '((Apply value row) (Apply weight row) intervals) (AsStruct) (DependsOn parent))))
    (let update (lambda '(row state parent) (NamedApply (Udf (Combine histogram '_AddValue)) '(state (Apply value row) (Apply weight row)) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply (Udf (Combine histogram '_GetResult)) state)))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type n:ui32 buffer:ui32
# doesn't support optional values
(let set_traits_factory_raw (lambda '(list_type count) (block '(
    (let value_type (ListItemType list_type))

    (let UdfSetCreate (Udf 'Set.Create (Void) (TupleType (TupleType value_type (DataType 'Uint32)) (StructType) value_type)))

    (let resource_type (TypeOf (Apply UdfSetCreate (InstanceOf value_type) (Uint32 '0))))

    (let UdfSetAddValue (Udf 'Set.AddValue (Void) (TupleType (TupleType resource_type value_type) (StructType) value_type)))
    (let UdfSetGetResult (Udf 'Set.GetResult (Void) (TupleType (TupleType resource_type) (StructType) value_type)))

    (let init (lambda '(value parent) (NamedApply UdfSetCreate '(value count) (AsStruct) (DependsOn parent))))
    (let update (lambda '(value state parent) (NamedApply UdfSetAddValue '(state value) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply UdfSetGetResult state)))

    (return (WindowTraits value_type init update shift current (EmptyList)))
))))

# list_type:type n:ui32 buffer:ui32
# doesn't support optional values
(let topfreq_traits_factory_raw (lambda '(list_type n buffer) (block '(
    (let value_type (ListItemType list_type))

    (let UdfTopFreqCreate (Udf 'TopFreq.TopFreq_Create (Void) (TupleType (TupleType value_type (DataType 'Uint32)) (StructType) value_type)))

    (let resource_type (TypeOf (Apply UdfTopFreqCreate (InstanceOf value_type) (Uint32 '0))))

    (let UdfTopFreqAddValue (Udf 'TopFreq.TopFreq_AddValue (Void) (TupleType (TupleType resource_type value_type) (StructType) value_type)))
    (let UdfTopFreqGet (Udf 'TopFreq.TopFreq_Get (Void) (TupleType (TupleType resource_type (DataType 'Uint32)) (StructType) value_type)))

    (let init (lambda '(value parent) (NamedApply UdfTopFreqCreate '(value buffer) (AsStruct) (DependsOn parent))))
    (let update (lambda '(value state parent) (NamedApply UdfTopFreqAddValue '(state value) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply UdfTopFreqGet state n)))

    (return (WindowTraits value_type init update shift current (EmptyList)))
))))

# list_type:type extractor:lambda count:ui32 is_top:atom
# doesn't support optional values
(let top_traits_factory_raw (lambda '(list_type extractor count is_top) (block '(
    (let value_type (ListItemType list_type))
    (let type_config (Combine '0 is_top))

    (let UdfTopCreate (Udf 'Top.Create (Void) (TupleType (TupleType value_type (DataType 'Uint32)) (StructType) value_type) type_config))

    (let resource_type (TypeOf (Apply UdfTopCreate (InstanceOf value_type) (Uint32 '0))))

    (let UdfTopAddValue (Udf 'Top.AddValue (Void) (TupleType (TupleType resource_type value_type) (StructType) value_type) type_config))
    (let UdfTopGetResult (Udf 'Top.GetResult (Void) (TupleType (TupleType resource_type) (StructType) value_type) type_config))

    (let init (lambda '(value parent) (NamedApply UdfTopCreate '(value count) (AsStruct) (DependsOn parent))))
    (let update (lambda '(value state parent) (NamedApply UdfTopAddValue '(state value) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply UdfTopGetResult state)))

    (return (WindowTraits value_type init update shift current (EmptyList)))
))))

# list_type:type key_extractor:lambda payload_extractor:lambda count:ui32 is_top:atom
# doesn't support optional values
(let top_by_traits_factory_raw (lambda '(list_type key_extractor payload_extractor count is_top) (block '(
    (let value_type (ListItemType list_type))
    (let key_type (TypeOf (Apply key_extractor (InstanceOf value_type))))
    (let payload_type (TypeOf (Apply payload_extractor (InstanceOf value_type))))
    (let key_payload_type (TupleType key_type payload_type))
    (let type_config (Combine '1 is_top))

    (let UdfTopCreate (Udf 'Top.Create (Void) (TupleType (TupleType key_type payload_type (DataType 'Uint32)) (StructType) key_payload_type) type_config))

    (let resource_type (TypeOf (Apply UdfTopCreate (InstanceOf key_type) (InstanceOf payload_type) (Uint32 '0))))

    (let UdfTopAddValue (Udf 'Top.AddValue (Void) (TupleType (TupleType resource_type key_type payload_type) (StructType) key_payload_type) type_config))
    (let UdfTopGetResult (Udf 'Top.GetResult (Void) (TupleType (TupleType resource_type) (StructType) key_payload_type) type_config))

    (let init (lambda '(value parent) (NamedApply UdfTopCreate '((Apply key_extractor value) (Apply payload_extractor value) count) (AsStruct) (DependsOn parent))))
    (let update (lambda '(value state parent) (NamedApply UdfTopAddValue '(state (Apply key_extractor value) (Apply payload_extractor value)) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply UdfTopGetResult state)))

    (return (WindowTraits value_type init update shift current (List (ListType payload_type))))
))))

# list_type:type n:double
# doesn't support optional values
(let percentile_traits_factory_raw (lambda '(list_type n) (block '(
    (let convert_into (lambda  '(value) (MatchType (ListItemType list_type)
                                 'Interval (lambda '() (SafeCast value (DataType 'Double)) ) # TODO:YQL-14129 cast to Decimal
                                 (lambda '() value)
                      ))
    )
    # Currently for Intervals: converts double value back to interval
    (let convert_out (lambda '(value) (MatchType (ListItemType list_type)
                                 'Interval (lambda '() (Unwrap (StrictCast (ToIntegral value (DataType 'Int64)) (DataType 'Interval))) ) # TODO:YQL-14129 cast from Decimal
                                 (lambda '() value)
                      ))
    )
    # this function get required percentile and converts it to proper type
    (let get_convert_percentile (lambda '(state n) (Apply convert_out (Apply (Udf 'Stat.TDigest_GetPercentile) state n))))
    (let init (lambda '(value parent) (NamedApply (Udf 'Stat.TDigest_Create) '((Apply convert_into value)) (AsStruct) (DependsOn parent))))
    (let update (lambda '(value state parent) (NamedApply (Udf 'Stat.TDigest_AddValue) '(state (Apply convert_into value)) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (MatchType n
                                             'Tuple (lambda '() (StaticMap n (lambda '(n) (Apply get_convert_percentile state n))))
                                             (lambda '() (Apply get_convert_percentile state n))
                                             )))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type
# doesn't support optional values
(let hyperloglog_traits_factory_raw (lambda '(list_type n) (block '(
    (let init (lambda '(value parent) (NamedApply (Udf 'HyperLogLog.Create) '((Apply (Udf 'Digest.MurMurHash) (Pickle value)) n) (AsStruct) (DependsOn parent))))
    (let update (lambda '(value state parent) (NamedApply (Udf 'HyperLogLog.AddValue) '(state (Apply (Udf 'Digest.MurMurHash) (Pickle value))) (AsStruct) (DependsOn parent))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply (Udf 'HyperLogLog.GetResult) state)))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type value:lambda weight:lambda intervals:integer
# doesn't support optional values
(let histogram_adaptive_ward_traits_factory_raw (lambda '(list_type value weight intervals) (Apply histogram_traits_factory_raw list_type 'Histogram.AdaptiveWardHistogram value weight intervals)))
(let histogram_adaptive_weight_traits_factory_raw (lambda '(list_type value weight intervals) (Apply histogram_traits_factory_raw list_type 'Histogram.AdaptiveWeightHistogram value weight intervals)))
(let histogram_adaptive_distance_traits_factory_raw (lambda '(list_type value weight intervals) (Apply histogram_traits_factory_raw list_type 'Histogram.AdaptiveDistanceHistogram value weight intervals)))
(let histogram_block_ward_traits_factory_raw (lambda '(list_type value weight intervals) (Apply histogram_traits_factory_raw list_type 'Histogram.BlockWardHistogram value weight intervals)))
(let histogram_block_weight_traits_factory_raw (lambda '(list_type value weight intervals) (Apply histogram_traits_factory_raw list_type 'Histogram.BlockWeightHistogram value weight intervals)))

# list_type:type histogram:atom value:lamba binsize:double minimum:double maximum:double
# doesn't support optional values
(let linear_histogram_traits_factory_impl (lambda '(list_type histogram value binsize minimum maximum) (block '(
    (let init (lambda '(row parent) (NamedApply (Udf (Combine histogram '_Create)) '((Apply value row) binsize minimum maximum) (AsStruct) (DependsOn parent))))
    (let update (lambda '(row state parent) (NamedApply (Udf (Combine histogram '_AddValue)) '(state (Apply value row) (Double '"1.0") (AsStruct) (DependsOn parent)))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Apply (Udf (Combine histogram '_GetResult)) state)))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type value:lambda binsize:double minimum:double maximum:double
# doesn't support optional values
(let histogram_linear_traits_factory_raw (lambda '(list_type value binsize minimum maximum) (Apply linear_histogram_traits_factory_impl list_type 'Histogram.LinearHistogram value binsize minimum maximum)))
(let histogram_logarithmic_traits_factory_raw (lambda '(list_type value binsize minimum maximum) (Apply linear_histogram_traits_factory_impl list_type 'Histogram.LogarithmicHistogram value binsize minimum maximum)))

# list_type:type factory:lambda
# support optional values
(let optional_traits_factory (lambda '(list_type factory) (block '(
    (let item_type (ListItemType list_type))
    (let traits (Apply factory (MatchType item_type 'Optional (lambda '() (ListType (OptionalItemType item_type))) (lambda '() (ListType item_type)))))
    (let init (NthArg '1 traits))
    (let update (NthArg '2 traits))
    (let shift (NthArg '3 traits))
    (let current (NthArg '4 traits))
    (let defval (NthArg '5 traits))

    (let init_optional
        (lambda '(value)
            (MatchType item_type
                'Optional (lambda '()
                    (IfPresent value
                        (lambda '(value) (Just (Apply init value)))
                        (Nothing (OptionalType (TypeOf (Apply init (InstanceOf (OptionalItemType (TypeOf value)))))))
                    )
                )
                'Null (lambda '() defval)
                (lambda '() (Apply init value))
            )
        )
    )

    (let update_optional
        (lambda '(value state)
            (MatchType item_type
                'Optional (lambda '()
                    (IfPresent state
                        (lambda '(state)
                            (IfPresent value
                                (lambda '(value) (Just (Apply update value state)))
                                (Just state)
                            )
                        )
                        (Apply init_optional value)
                    )
                )
                'Null (lambda '() defval)
                (lambda '() (Apply update value state))
            )
        )
    )

# todo: fill the body
    (let shift_optional (lambda '(value state) (Void)))

    (let current_optional (lambda '(state) (MatchType item_type 'Optional (lambda '() (Map state current)) 'Null (lambda '() defval) (lambda '() (Apply current state)))))
    (return (WindowTraits item_type init_optional update_optional shift_optional current_optional defval))
))))

# list_type:type factory:lambda
# support optional values, init and update with parent
(let optional_traits_factory_parent (lambda '(list_type factory) (block '(
    (let item_type (ListItemType list_type))
    (let traits (Apply factory (MatchType item_type 'Optional (lambda '() (ListType (OptionalItemType item_type))) (lambda '() (ListType item_type)))))
    (let init (NthArg '1 traits))
    (let update (NthArg '2 traits))
    (let shift (NthArg '3 traits))
    (let current (NthArg '4 traits))
    (let defval (NthArg '5 traits))

    (let init_optional
        (lambda '(value parent)
            (MatchType item_type
                'Optional (lambda '()
                    (IfPresent value
                        (lambda '(value) (Just (Apply init value parent)))
                        (Nothing (OptionalType (TypeOf (Apply init (InstanceOf (OptionalItemType (TypeOf value))) parent))))
                    )
                )
                'Null (lambda '() defval)
                (lambda '() (Apply init value parent))
            )
        )
    )

    (let shift_optional (lambda '(value state) (Void)))

    (let update_optional
        (lambda '(value state parent)
            (MatchType item_type
                'Optional (lambda '()
                    (IfPresent state
                        (lambda '(state)
                            (IfPresent value
                                (lambda '(value) (Just (Apply update value state parent)))
                                (Just state)
                            )
                        )
                        (Apply init_optional value parent)
                    )
                )
                'Null (lambda '() defval)
                (lambda '() (Apply update value state parent))
            )
        )
    )

    (let current_optional (lambda '(state) (MatchType item_type 'Optional (lambda '() (Map state current)) 'Null (lambda '() defval) (lambda '() (Apply current state)))))
    (return (WindowTraits item_type init_optional update_optional shift_optional current_optional defval))
))))

# list_type:type factory:lambda
# support optional values, init and update with parent
(let flatten_traits_factory_parent (lambda '(list_type factory) (block '(
    (let item_type (ListItemType list_type))
    (let traits (Apply factory (MatchType item_type 'Optional (lambda '() (ListType (OptionalItemType item_type))) (lambda '() (ListType item_type)))))
    (let init (NthArg '1 traits))
    (let update (NthArg '2 traits))
    (let shift (NthArg '3 traits))
    (let current (NthArg '4 traits))
    (let defval (NthArg '5 traits))

    (let init_optional
        (lambda '(value parent)
            (MatchType item_type
                'Optional (lambda '()
                    (IfPresent value
                        (lambda '(value) (Just (Apply init value parent)))
                        (Nothing (OptionalType (TypeOf (Apply init (InstanceOf (OptionalItemType (TypeOf value))) parent))))
                    )
                )
                'Null (lambda '() defval)
                (lambda '() (Apply init value parent))
            )
        )
    )

    (let shift_optional (lambda '(value state) (Void)))

    (let update_optional
        (lambda '(value state parent)
            (MatchType item_type
                'Optional (lambda '()
                    (IfPresent state
                        (lambda '(state)
                            (IfPresent value
                                (lambda '(value) (Just (Apply update value state parent)))
                                (Just state)
                            )
                        )
                        (Apply init_optional value parent)
                    )
                )
                'Null (lambda '() defval)
                (lambda '() (Apply update value state parent))
            )
        )
    )

    (let current_optional (lambda '(state) (MatchType item_type 'Optional (lambda '() (FlatMap state current)) 'Null (lambda '() defval) (lambda '() (Apply current state)))))
    (return (WindowTraits item_type init_optional update_optional shift_optional current_optional defval))
))))

# list_type:type
# support optional values
(let min_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (AggrMin one two)))))
(let max_traits_factory_opt (lambda '(list_type) (Apply simple_traits_factory list_type (lambda '(one two) (AggrMax one two)))))
(let sum_traits_factory_opt (lambda '(list_type) (block '(
    (let item_type (Apply remove_optional_type (ListItemType list_type)))
    (return (Apply easy_traits_factory_map list_type 
        (lambda '(val state) (AggrAdd val state)) 
        (lambda '(val state) (AggrAdd state (Minus val))) 
        (lambda '(value) (MatchType item_type 'Interval (lambda '() (Apply convert_interval_to_decimal value)) (lambda '() (WidenIntegral value))))
        (lambda '(value) (MatchType item_type 'Interval (lambda '() (Apply convert_decimal_to_interval value)) (lambda '() value)))
))))))
(let bit_and_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type bit_and_traits_factory_raw)))
(let bit_or_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type bit_or_traits_factory_raw)))
(let bit_xor_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type bit_xor_traits_factory_raw)))
(let avg_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type avg_traits_factory_raw)))
(let rank_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type rank_traits_factory_raw)))
(let dense_rank_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type dense_rank_traits_factory_raw)))
(let variance_0_0_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type variance_0_0_traits_factory_raw)))
(let variance_1_0_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type variance_1_0_traits_factory_raw)))
(let variance_0_1_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type variance_0_1_traits_factory_raw)))
(let variance_1_1_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type variance_1_1_traits_factory_raw)))
(let correlation_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type correlation_traits_factory_raw)))
(let covariance_population_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type covariance_population_traits_factory_raw)))
(let covariance_sample_traits_factory_opt (lambda '(list_type) (Apply optional_traits_factory list_type covariance_sample_traits_factory_raw)))
(let correlation_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor correlation_traits_factory_opt)))
(let covariance_population_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor covariance_population_traits_factory_opt)))
(let covariance_sample_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor covariance_sample_traits_factory_opt)))


# list_type:type n:double
# support optional values
(let percentile_traits_factory_opt (lambda '(list_type n) (Apply optional_traits_factory_parent list_type (lambda '(list_type) (Apply percentile_traits_factory_raw list_type n)))))

# list_type:type count:ui32
# support optional values
(let set_traits_factory_opt (lambda '(list_type count) (Apply flatten_traits_factory_parent list_type (lambda '(list_type) (Apply set_traits_factory_raw list_type count)))))

# list_type:type n:ui32 buffer:ui32
# support optional values
(let topfreq_traits_factory_opt (lambda '(list_type n buffer) (Apply flatten_traits_factory_parent list_type (lambda '(list_type) (Apply topfreq_traits_factory_raw list_type n buffer)))))

# list_type:type
# support optional values
(let hyperloglog_traits_factory_opt (lambda '(list_type n) (Apply optional_traits_factory_parent list_type (lambda '(list_type) (Apply hyperloglog_traits_factory_raw list_type n)))))

# list_type:type init:lambda update:lambda shift:lambda current:lambda
# support optional values
(let udwf_traits_factory_opt (lambda '(list_type init update shift current defval) (Apply optional_traits_factory_parent list_type (lambda '(list_type) (WindowTraits (ListItemType list_type) init update shift current defval)))))

# list_type:type, factory:lambda, extractor:lambda
(let extractor_traits_factory (lambda '(list_type extractor factory) (block '(
  (let traits (Apply factory (ListType (TypeOf (Apply extractor (InstanceOf (ListItemType list_type)))))))
  (let init (NthArg '1 traits))
  (let update (NthArg '2 traits))
  (let shift (NthArg '3 traits))
  (let current (NthArg '4 traits))
  (let defval (NthArg '5 traits))
  (let init_ext (lambda '(row) (Apply init (Apply extractor row))))
  (let update_ext (lambda '(row state) (Apply update (Apply extractor row) state)))
  (let shift_ext (lambda '(row state) (Apply shift (Apply extractor row) state)))
  (return (WindowTraits (ListItemType list_type) init_ext update_ext shift_ext current defval))
))))

# list_type:type, factory:lambda, extractor:lambda
(let extractor_traits_factory_parent (lambda '(list_type extractor factory) (block '(
  (let traits (Apply factory (ListType (TypeOf (Apply extractor (InstanceOf (ListItemType list_type)))))))
  (let init (NthArg '1 traits))
  (let update (NthArg '2 traits))
  (let shift (NthArg '3 traits))
  (let current (NthArg '4 traits))
  (let defval (NthArg '5 traits))
  (let init_ext (lambda '(row parent) (Apply init (Apply extractor row) parent)))
  (let update_ext (lambda '(row state parent) (Apply update (Apply extractor row) state parent)))
  (let shift_ext (lambda '(row state) (Apply shift (Apply extractor row) state)))
  (return (WindowTraits (ListItemType list_type) init_ext update_ext shift_ext current defval))
))))

# list_type:type, extractor:lambda
# support optional columns
(let min_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor min_traits_factory_opt)))
(let max_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor max_traits_factory_opt)))
(let sum_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor sum_traits_factory_opt)))
(let count_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor count_traits_factory_opt)))
(let count_all_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor count_all_traits_factory_opt)))
(let count_if_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor count_if_traits_factory_opt)))
(let some_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor some_traits_factory_raw)))
(let bit_and_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor bit_and_traits_factory_opt)))
(let bit_or_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor bit_or_traits_factory_opt)))
(let bit_xor_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor bit_xor_traits_factory_opt)))
(let and_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type (lambda '(v) (SafeCast (Apply extractor v) (DataType 'Bool))) bool_and_traits_factory_opt)))
(let or_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type (lambda '(v) (SafeCast (Apply extractor v) (DataType 'Bool))) bool_or_traits_factory_opt)))
(let xor_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type (lambda '(v) (SafeCast (Apply extractor v) (DataType 'Bool))) bool_xor_traits_factory_opt)))
(let avg_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor avg_traits_factory_opt)))
(let list_traits_factory (lambda '(list_type extractor limit) (Apply extractor_traits_factory list_type extractor (Apply list_traits_factory_opt_gen limit (Null)))))
(let list2_traits_factory (lambda '(list_type extractor limit) (Apply extractor_traits_factory list_type extractor (Apply list_traits_factory_opt_gen limit empty_list))))
(let variance_0_0_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor variance_0_0_traits_factory_opt)))
(let variance_1_0_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor variance_1_0_traits_factory_opt)))
(let variance_0_1_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor variance_0_1_traits_factory_opt)))
(let variance_1_1_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor variance_1_1_traits_factory_opt)))

# TODO: rank_traits_factory and dense_rank_traits_factory are only used in v0 syntax
(let rank_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor rank_traits_factory_opt)))
(let dense_rank_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor dense_rank_traits_factory_opt)))

(let first_value_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor first_value_traits_factory_opt)))
(let last_value_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor last_value_traits_factory_opt)))
(let nth_value_traits_factory (lambda '(list_type extractor n) (Apply extractor_traits_factory list_type extractor (lambda '(list_type) (Apply nth_value_traits_factory_opt list_type n)))))
(let first_value_ignore_nulls_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor first_value_ignore_nulls_traits_factory_opt)))
(let last_value_ignore_nulls_traits_factory (lambda '(list_type extractor) (Apply extractor_traits_factory list_type extractor last_value_ignore_nulls_traits_factory_opt)))
(let nth_value_ignore_nulls_traits_factory (lambda '(list_type extractor n) (Apply extractor_traits_factory list_type extractor (lambda '(list_type) (Apply nth_value_ignore_nulls_traits_factory_opt list_type n)))))

# list_type:type extractor:lambda n:double
# support optional values
(let percentile_traits_factory (lambda '(list_type extractor n) (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type) (Apply percentile_traits_factory_opt list_type n)))))

# list_type:type extractor:lambda count:ui32
# support optional values
(let set_traits_factory (lambda '(list_type extractor count) (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type) (Apply set_traits_factory_opt list_type count)))))

# list_type:type extractor:lambda n:ui32 buffer:ui32
# support optional values
(let topfreq_traits_factory (lambda '(list_type extractor n buffer) (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type) (Apply topfreq_traits_factory_opt list_type n buffer)))))

# list_type:type extractor:lambda
# support optional values
(let hyperloglog_traits_factory (lambda '(list_type extractor n) (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type) (Apply hyperloglog_traits_factory_opt list_type n)))))

# list_type:type extractor:lambda init:lambda update:lambda shift:lambda current:lambda
# support optional values
(let udwf_traits_factory (lambda '(list_type extractor init update shift current defval) (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type) (Apply udwf_traits_factory_opt list_type init update shift current defval)))))

# list_type:type compare:lambda first:lambda second:lambda stub
# doesn't support optional values
(let compare_traits_factory_raw (lambda '(list_type compare first second stub) (block '(
    (let key_type (TypeOf (Apply first (InstanceOf (ListItemType list_type)))))
    (let init (lambda '(row) '((Apply second row) (Apply first row))))
    (let update (lambda '(row state) (If (Apply compare (Apply first row) (Nth state '1)) (Apply init row) state)))
    (let shift (lambda '(row state) (lambda '(value state) (Void))))
    (let current (lambda '(state) (Nth state '0)))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# list_type:type compare:lambda first:lambda second:lambda limit:Uint64
# doesn't support optional values
(let compare_traits_factory_list_raw (lambda '(list_type compare first second limit) (block '(
    (let key_type (TypeOf (Apply first (InstanceOf (ListItemType list_type)))))
    (let init (lambda '(row) '((AsList (Apply second row)) (Apply first row))))
    (let update (lambda '(row state) (If (AggrEquals (Apply first row) (Nth state '1)) '((Take (Insert (Nth state '0) (Apply second row)) limit) (Nth state '1)) (If (Apply compare (Apply first row) (Nth state '1)) (Apply init row) state))))
    (let shift (lambda '(value state) (Void)))
    (let current (lambda '(state) (Nth state '0)))
    (return (WindowTraits (ListItemType list_type) init update shift current (Null)))
))))

# factory:lambda list_type:type first:lambda second:lambda
# support optional values
(let double_traits_factory_opt (lambda '(factory list_type first second) (block '(
    (let item_type (ListItemType list_type))
    (let key_type (TypeOf (Apply first (InstanceOf item_type))))
    (let test_type (MatchType item_type 'Optional (lambda '() item_type) (lambda '() key_type)))
    (let traits (Apply factory (ListType (MatchType item_type 'Optional (lambda '() (OptionalItemType item_type)) (lambda '() item_type)))
        (lambda '(row) (MatchType key_type 'Optional
            (lambda '() (Unwrap (Apply first row)))
            (lambda '() (Apply first row))
        ))
        second
    ))
    (let init (NthArg '1 traits))
    (let update (NthArg '2 traits))
    (let shift (NthArg '3 traits))
    (let current (NthArg '4 traits))
    (let defval (NthArg '5 traits))

    (let init_opt (lambda '(row) (MatchType test_type 'Optional
        (lambda '() (Map (Apply first row) (lambda '(key) (Apply init row))))
        (lambda '() (Apply init row))
    )))
    (let update_opt (lambda '(row state)
        (MatchType test_type 'Optional
            (lambda '() (IfPresent state (lambda '(state) (Just (If (Exists (Apply first row)) (Apply update row state) state))) (Apply init_opt row)))
            (lambda '() (Apply update row state))
        )
    ))
    (let shift_opt (lambda '(value state) (Void)))
    (let current_opt (lambda '(state) (MatchType test_type 'Optional
        (lambda '() (MatchType (TypeOf (Apply current (InstanceOf (OptionalItemType (TypeOf state))))) 'Optional
            (lambda '() (FlatMap state current))
            (lambda '() (Map state current))
        ))
        (lambda '() (Apply current state))
    )))
    (return (WindowTraits item_type init_opt update_opt shift_opt current_opt defval))
))))

# factory:lambda list_type:type first:lambda second:lambda
# support optional values, init and update has parent arg
(let double_traits_factory_opt_parent (lambda '(factory list_type first second) (block '(
    (let item_type (ListItemType list_type))
    (let key_type (TypeOf (Apply first (InstanceOf item_type))))
    (let test_type (MatchType item_type 'Optional (lambda '() item_type) (lambda '() key_type)))
    (let traits (Apply factory (ListType (MatchType item_type 'Optional (lambda '() (OptionalItemType item_type)) (lambda '() item_type)))
        (lambda '(row) (MatchType key_type 'Optional
            (lambda '() (Unwrap (Apply first row)))
            (lambda '() (Apply first row))
        ))
        second
    ))
    (let init (NthArg '1 traits))
    (let update (NthArg '2 traits))
    (let shift (NthArg '3 traits))
    (let current (NthArg '4 traits))
    (let defval (NthArg '5 traits))

    (let init_opt (lambda '(row parent) (MatchType test_type 'Optional
        (lambda '() (Map (Apply first row) (lambda '(key) (Apply init row parent))))
        (lambda '() (Apply init row parent))
    )))
    (let update_opt (lambda '(row state parent)
        (MatchType test_type 'Optional
            (lambda '() (IfPresent state (lambda '(state) (Just (If (Exists (Apply first row)) (Apply update row state parent) state))) (Apply init_opt row parent)))
            (lambda '() (Apply update row state parent))
        )
    ))
    (let shift_opt (lambda '(value state) (Void)))
    (let current_opt (lambda '(state) (MatchType test_type 'Optional (lambda '() (Map state current)) (lambda '() (Apply current state)))))
    (return (WindowTraits item_type init_opt update_opt shift_opt current_opt defval))
))))

# factory:lambda list_type:type first:lambda second:lambda
# support optional values, init and update has parent arg
(let list_by_traits_factory_opt_parent (lambda '(factory list_type first second) (block '(
    (let item_type (ListItemType list_type))
    (let key_type (TypeOf (Apply first (InstanceOf item_type))))
    (let traits (Apply factory list_type first second))
    (let init (NthArg '1 traits))
    (let update (NthArg '2 traits))
    (let shift (NthArg '3 traits))
    (let current (NthArg '4 traits))
    (let defval (NthArg '5 traits))

    (let init_opt (lambda '(row parent) (MatchType key_type
        'Optional (lambda '()
            (IfPresent (Apply first row)
                (lambda '(key) (Just (Apply init row parent)))
                (Nothing (OptionalType (TypeOf (Apply init (InstanceOf (TypeOf row)) parent))))
            )
        )
        'Null (lambda '() defval)
        (lambda '() (Apply init row parent))
    )))
    (let update_opt (lambda '(row state parent) (MatchType key_type
        'Optional (lambda '()
            (IfPresent state
                (lambda '(state)
                    (IfPresent (Apply first row)
                        (lambda '(key) (Just (Apply update row state parent)))
                        (Just state)
                    )
                )
                (Apply init_opt row parent)
            )
        )
        'Null (lambda '() defval)
        (lambda '() (Apply update row state parent))
    )))

    (let shift_opt (lambda '(value state) (Void)))
    (let current_opt (lambda '(state) (MatchType key_type 'Optional (lambda '() (FlatMap state current)) 'Null (lambda '() defval) (lambda '() (Apply current state)))))
    (return (WindowTraits item_type init_opt update_opt shift_opt current_opt defval))
))))

# list_type:type value:lambda weight:lambda intervals:integer
# support optional values
(let histogram_adaptive_ward_traits_factory (lambda '(list_type value weight intervals) (Apply double_traits_factory_opt_parent (lambda '(list_type value weight) (Apply histogram_adaptive_ward_traits_factory_raw list_type value weight intervals)) list_type value weight)))
(let histogram_adaptive_weight_traits_factory (lambda '(list_type value weight intervals) (Apply double_traits_factory_opt_parent (lambda '(list_type value weight) (Apply histogram_adaptive_weight_traits_factory_raw list_type value weight intervals)) list_type value weight)))
(let histogram_adaptive_distance_traits_factory (lambda '(list_type value weight intervals) (Apply double_traits_factory_opt_parent (lambda '(list_type value weight) (Apply histogram_adaptive_distance_traits_factory_raw list_type value weight intervals)) list_type value weight)))
(let histogram_block_ward_traits_factory (lambda '(list_type value weight intervals) (Apply double_traits_factory_opt_parent (lambda '(list_type value weight) (Apply histogram_block_ward_traits_factory_raw list_type value weight intervals)) list_type value weight)))
(let histogram_block_weight_traits_factory (lambda '(list_type value weight intervals) (Apply double_traits_factory_opt_parent (lambda '(list_type value weight) (Apply histogram_block_weight_traits_factory_raw list_type value weight intervals)) list_type value weight)))

# list_type:type value:lambda weight:lambda intervals:integer
# support optional values
(let histogram_linear_traits_factory (lambda '(list_type value binsize minimum maximum) (Apply double_traits_factory_opt_parent (lambda '(list_type value binsize) (Apply histogram_linear_traits_factory_raw list_type value binsize minimum maximum)) list_type value binsize)))
(let histogram_logarithmic_traits_factory (lambda '(list_type value binsize minimum maximum) (Apply double_traits_factory_opt_parent (lambda '(list_type value binsize) (Apply histogram_logarithmic_traits_factory_raw list_type value binsize minimum maximum)) list_type value binsize)))

(let compare_by_traits_factory_opt (lambda '(list_type compare first second limit) (Apply double_traits_factory_opt (lambda '(list_type first second) (Apply compare_traits_factory_raw list_type compare first second limit)) list_type first second)))
(let list_compare_by_traits_factory_opt (lambda '(list_type compare first second limit) (Apply double_traits_factory_opt (lambda '(list_type first second) (Apply compare_traits_factory_list_raw list_type compare first second limit)) list_type first second)))

#deprecated
(let compare_by_traits_factory (lambda '(list_type compare first second limit) (IfType limit (VoidType)
    (lambda '() (Apply compare_by_traits_factory_opt list_type compare first second limit))
    (lambda '() (Apply list_compare_by_traits_factory_opt list_type compare first second limit))
)))

#deprecated
(let min_by_traits_factory (lambda '(list_type first second limit) (Apply compare_by_traits_factory list_type (lambda '(one two) (AggrLess one two)) first second limit)))
(let max_by_traits_factory (lambda '(list_type first second limit) (Apply compare_by_traits_factory list_type (lambda '(one two) (AggrLess two one)) first second limit)))

(let min_by_traits_factory1 (lambda '(list_type first second) (Apply compare_by_traits_factory_opt list_type (lambda '(one two) (AggrLess one two)) first second (Void))))
(let max_by_traits_factory1 (lambda '(list_type first second) (Apply compare_by_traits_factory_opt list_type (lambda '(one two) (AggrLess two one)) first second (Void))))

(let min_by_traits_factory2 (lambda '(list_type first second limit) (Apply list_compare_by_traits_factory_opt list_type (lambda '(one two) (AggrLess one two)) first second limit)))
(let max_by_traits_factory2 (lambda '(list_type first second limit) (Apply list_compare_by_traits_factory_opt list_type (lambda '(one two) (AggrLess two one)) first second limit)))

(let avg_if_traits_factory (lambda '(list_type payload predicate)
(Apply avg_traits_factory list_type (lambda '(value) (FlatOptionalIf (Coalesce (Apply predicate value) (Bool '0)) (block '(
    (let pl (Apply payload value))
    (return (MatchType pl 'Optional (lambda '() pl) (lambda '() (Just pl)))))))))))
(let sum_if_traits_factory (lambda '(list_type payload predicate)
(Apply sum_traits_factory list_type (lambda '(value) (FlatOptionalIf (Coalesce (Apply predicate value) (Bool '0)) (block '(
    (let pl (Apply payload value))
    (return (MatchType pl 'Optional (lambda '() pl) (lambda '() (Just pl)))))))))))

# list_type:type init:lambda update:lambda finish:lambda
# support optional values
(let udaf_traits_factory_opt (lambda '(list_type init update finish defval) (Apply optional_traits_factory_parent list_type (lambda '(list_type) (WindowTraits (ListItemType list_type) init update (lambda '(value state) (Void)) finish defval)))))

(let udaf_traits_factory (lambda '(list_type extractor init update merge finish save load defval) (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type) (Apply udaf_traits_factory_opt list_type init update finish defval)))))

(let top_bottom_traits_factory (lambda '(list_type extractor count is_top)
    (Apply extractor_traits_factory_parent list_type extractor (lambda '(list_type)
        (Apply flatten_traits_factory_parent list_type (lambda '(list_type)
            (Apply top_traits_factory_raw list_type extractor count is_top)))))))

(let top_traits_factory (lambda '(list_type extractor count)
    (Apply top_bottom_traits_factory list_type extractor count '1)))

(let bottom_traits_factory (lambda '(list_type extractor count)
    (Apply top_bottom_traits_factory list_type extractor count '0)))

(let top_bottom_by_traits_factory (lambda '(list_type key_extractor payload_extractor count is_top)
    (Apply list_by_traits_factory_opt_parent (lambda '(list_type key_extractor payload_extractor)
        (Apply top_by_traits_factory_raw list_type key_extractor payload_extractor count is_top)) list_type key_extractor payload_extractor)))

(let top_by_traits_factory (lambda '(list_type key_extractor payload_extractor count)
    (Apply top_bottom_by_traits_factory list_type key_extractor payload_extractor count '1)))

(let bottom_by_traits_factory (lambda '(list_type key_extractor payload_extractor count)
    (Apply top_bottom_by_traits_factory list_type key_extractor payload_extractor count '0)))

(export min_traits_factory)
(export max_traits_factory)
(export sum_traits_factory)
(export sum_if_traits_factory)
(export count_traits_factory)
(export count_all_traits_factory)
(export count_if_traits_factory)
(export some_traits_factory)
(export bit_and_traits_factory)
(export bit_or_traits_factory)
(export bit_xor_traits_factory)
(export and_traits_factory)
(export or_traits_factory)
(export xor_traits_factory)
(export avg_traits_factory)
(export avg_if_traits_factory)
(export list_traits_factory)
(export list2_traits_factory)
(export min_by_traits_factory)
(export max_by_traits_factory)
(export min_by_traits_factory1)
(export max_by_traits_factory1)
(export min_by_traits_factory2)
(export max_by_traits_factory2)
(export variance_0_0_traits_factory)
(export variance_1_0_traits_factory)
(export variance_0_1_traits_factory)
(export variance_1_1_traits_factory)
(export correlation_traits_factory)
(export covariance_population_traits_factory)
(export covariance_sample_traits_factory)
(export histogram_adaptive_ward_traits_factory)
(export histogram_adaptive_weight_traits_factory)
(export histogram_adaptive_distance_traits_factory)
(export histogram_block_ward_traits_factory)
(export histogram_block_weight_traits_factory)
(export histogram_linear_traits_factory)
(export histogram_logarithmic_traits_factory)
(export udwf_traits_factory)
(export percentile_traits_factory)
(export set_traits_factory)
(export topfreq_traits_factory)
(export hyperloglog_traits_factory)
(export rank_traits_factory)
(export dense_rank_traits_factory)
(export first_value_traits_factory)
(export last_value_traits_factory)
(export nth_value_traits_factory)
(export first_value_ignore_nulls_traits_factory)
(export last_value_ignore_nulls_traits_factory)
(export nth_value_ignore_nulls_traits_factory)
(export udaf_traits_factory)
(export top_traits_factory)
(export bottom_traits_factory)
(export top_by_traits_factory)
(export bottom_by_traits_factory)

)
