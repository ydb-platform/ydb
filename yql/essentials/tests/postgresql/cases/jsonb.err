Registering pre-existing tables
	testjsonb
<sql-statement>
-- Strings.
SELECT '""'::jsonb;				-- OK.
</sql-statement>
<sql-statement>
SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "'" is invalid.
CONTEXT:  JSON data, line 1: '...

        	SELECT $$''$$::jsonb;			-- ERROR, single quotes are not allowed
	^
<sql-statement>
SELECT '"abc"'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token ""abc" is invalid.
CONTEXT:  JSON data, line 1: "abc

        	SELECT '"abc'::jsonb;			-- ERROR, quotes not closed
	^
<sql-statement>
SELECT '"abc
def"'::jsonb;					-- ERROR, unescaped newline in string constant
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"abc
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Character with value 0x0a must be escaped.
CONTEXT:  JSON data, line 1: "abc

        	SELECT '"abc
	^
<sql-statement>
SELECT '"\n\"\\"'::jsonb;		-- OK, legal escapes
</sql-statement>
<sql-statement>
SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Escape sequence "\v" is invalid.
CONTEXT:  JSON data, line 1: "\v...

        	SELECT '"\v"'::jsonb;			-- ERROR, not a valid JSON escape
	^
<sql-statement>
-- see json_encoding test for input with unicode escapes
-- Numbers.
SELECT '1'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '0'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "01" is invalid.
CONTEXT:  JSON data, line 1: 01

        	SELECT '01'::jsonb;				-- ERROR, not valid according to JSON spec
	^
<sql-statement>
SELECT '0.1'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '9223372036854775808'::jsonb;	-- OK, even though it's too large for int8
</sql-statement>
<sql-statement>
SELECT '1e100'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '1.3e100'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '1f2'::jsonb;				-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '1f2'::jsonb;				-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "1f2" is invalid.
CONTEXT:  JSON data, line 1: 1f2

        	SELECT '1f2'::jsonb;				-- ERROR
	^
<sql-statement>
SELECT '0.x1'::jsonb;			-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '0.x1'::jsonb;			-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "0.x1" is invalid.
CONTEXT:  JSON data, line 1: 0.x1

        	SELECT '0.x1'::jsonb;			-- ERROR
	^
<sql-statement>
SELECT '1.3ex100'::jsonb;		-- ERROR
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '1.3ex100'::jsonb;		-- ERROR
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "1.3ex100" is invalid.
CONTEXT:  JSON data, line 1: 1.3ex100

        	SELECT '1.3ex100'::jsonb;		-- ERROR
	^
<sql-statement>
-- Arrays.
SELECT '[]'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'::jsonb;  -- OK
</sql-statement>
<sql-statement>
SELECT '[1,2]'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found "]".
CONTEXT:  JSON data, line 1: [1,2,]

        	SELECT '[1,2,]'::jsonb;			-- ERROR, trailing comma
	^
<sql-statement>
SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: [1,2

        	SELECT '[1,2'::jsonb;			-- ERROR, no closing bracket
	^
<sql-statement>
SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: [1,[2]

        	SELECT '[1,[2]'::jsonb;			-- ERROR, no closing bracket
	^
<sql-statement>
-- Objects.
SELECT '{}'::jsonb;				-- OK
</sql-statement>
<sql-statement>
SELECT '{"abc"}'::jsonb;			-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"}'::jsonb;			-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected ":", but found "}".
CONTEXT:  JSON data, line 1: {"abc"}

        	SELECT '{"abc"}'::jsonb;			-- ERROR, no value
	^
<sql-statement>
SELECT '{"abc":1}'::jsonb;		-- OK
</sql-statement>
<sql-statement>
SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected string or "}", but found "1".
CONTEXT:  JSON data, line 1: {1...

        	SELECT '{1:"abc"}'::jsonb;		-- ERROR, keys must be strings
	^
<sql-statement>
SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected ":", but found ",".
CONTEXT:  JSON data, line 1: {"abc",...

        	SELECT '{"abc",1}'::jsonb;		-- ERROR, wrong separator
	^
<sql-statement>
SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "=" is invalid.
CONTEXT:  JSON data, line 1: {"abc"=...

        	SELECT '{"abc"=1}'::jsonb;		-- ERROR, totally wrong separator
	^
<sql-statement>
SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found ":".
CONTEXT:  JSON data, line 1: {"abc"::...

        	SELECT '{"abc"::1}'::jsonb;		-- ERROR, another wrong separator
	^
<sql-statement>
SELECT '{"abc":1,"def":2,"ghi":[3,4],"hij":{"klm":5,"nop":[6]}}'::jsonb; -- OK
</sql-statement>
<sql-statement>
SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected "," or "}", but found ":".
CONTEXT:  JSON data, line 1: {"abc":1:...

        	SELECT '{"abc":1:2}'::jsonb;		-- ERROR, colon in wrong spot
	^
<sql-statement>
SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected string, but found "3".
CONTEXT:  JSON data, line 1: {"abc":1,3...

        	SELECT '{"abc":1,3}'::jsonb;		-- ERROR, no value
	^
<sql-statement>
-- Miscellaneous stuff.
SELECT 'true'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT 'false'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT 'null'::jsonb;			-- OK
</sql-statement>
<sql-statement>
SELECT ' true '::jsonb;			-- OK, even with extra whitespace
</sql-statement>
<sql-statement>
SELECT 'true false'::jsonb;		-- ERROR, too many values
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'true false'::jsonb;		-- ERROR, too many values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected end of input, but found "false".
CONTEXT:  JSON data, line 1: true false

        	SELECT 'true false'::jsonb;		-- ERROR, too many values
	^
<sql-statement>
SELECT 'true, false'::jsonb;		-- ERROR, too many values
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'true, false'::jsonb;		-- ERROR, too many values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected end of input, but found ",".
CONTEXT:  JSON data, line 1: true,...

        	SELECT 'true, false'::jsonb;		-- ERROR, too many values
	^
<sql-statement>
SELECT 'truf'::jsonb;			-- ERROR, not a keyword
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'truf'::jsonb;			-- ERROR, not a keyword
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "truf" is invalid.
CONTEXT:  JSON data, line 1: truf

        	SELECT 'truf'::jsonb;			-- ERROR, not a keyword
	^
<sql-statement>
SELECT 'trues'::jsonb;			-- ERROR, not a keyword
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT 'trues'::jsonb;			-- ERROR, not a keyword
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Token "trues" is invalid.
CONTEXT:  JSON data, line 1: trues

        	SELECT 'trues'::jsonb;			-- ERROR, not a keyword
	^
<sql-statement>
SELECT ''::jsonb;				-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT ''::jsonb;				-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1: 

        	SELECT ''::jsonb;				-- ERROR, no value
	^
<sql-statement>
SELECT '    '::jsonb;			-- ERROR, no value
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '    '::jsonb;			-- ERROR, no value
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  The input string ended unexpectedly.
CONTEXT:  JSON data, line 1:     

        	SELECT '    '::jsonb;			-- ERROR, no value
	^
<sql-statement>
-- Multi-line JSON input to check ERROR reporting
SELECT '{
		"one": 1,
		"two":"two",
		"three":
		true}'::jsonb; -- OK
</sql-statement>
<sql-statement>
SELECT '{
		"one": 1,
		"two":,"two",  -- ERROR extraneous comma before field "two"
		"three":
		true}'::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found ",".
CONTEXT:  JSON data, line 3: 		"two":,...

        	SELECT '{
	^
<sql-statement>
SELECT '{
		"one": 1,
		"two":"two",
		"averyveryveryveryveryveryveryveryveryverylongfieldname":}'::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT '{
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  invalid input syntax for type json
DETAIL:  Expected JSON value, but found "}".
CONTEXT:  JSON data, line 4: ...yveryveryveryveryveryveryveryverylongfieldname":}

        	SELECT '{
	^
<sql-statement>
-- ERROR missing value for last field
-- make sure jsonb is passed through json generators without being escaped
SELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
</sql-statement>
<sql-statement>
-- anyarray column
CREATE TEMP TABLE rows AS
SELECT x, 'txt' || x as y
FROM generate_series(1,3) AS x;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 277
    	-- anyarray column
	^
<sql-statement>
analyze rows;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 275
    	analyze rows;
	^
<sql-statement>
select attname, to_jsonb(histogram_bounds) histogram_bounds
from pg_stats
where tablename = 'rows' and
      schemaname = pg_my_temp_schema()::regnamespace::text
order by 1;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select attname, to_jsonb(histogram_bounds) histogram_bounds
	^
        -stdin-:<main>:1:17: Error: At function: PgCall
        	select attname, to_jsonb(histogram_bounds) histogram_bounds
	                ^
            -stdin-:<main>:1:17: Error: Unable to find an overload for proc to_jsonb with given argument types: (anyarray)
            	select attname, to_jsonb(histogram_bounds) histogram_bounds
	                ^
<sql-statement>
-- to_jsonb, timestamps
select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- to_jsonb, timestamps
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamp)
            	select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
	       ^
<sql-statement>
BEGIN;
</sql-statement>
<sql-statement>
SET LOCAL TIME ZONE 10.5;
</sql-statement>
<sql-statement>
select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
<sql-statement>
SET LOCAL TIME ZONE -8;
</sql-statement>
<sql-statement>
select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz '2014-05-28 12:22:35.614298-04');
	       ^
<sql-statement>
COMMIT;
</sql-statement>
<sql-statement>
select to_jsonb(date '2014-05-28');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(date '2014-05-28');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(date '2014-05-28');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (date)
            	select to_jsonb(date '2014-05-28');
	       ^
<sql-statement>
select to_jsonb(date 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(date 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(date 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (date)
            	select to_jsonb(date 'Infinity');
	       ^
<sql-statement>
select to_jsonb(date '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(date '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(date '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (date)
            	select to_jsonb(date '-Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamp 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamp 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamp 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamp)
            	select to_jsonb(timestamp 'Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamp '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamp '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamp '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamp)
            	select to_jsonb(timestamp '-Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamptz 'Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz 'Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz 'Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz 'Infinity');
	       ^
<sql-statement>
select to_jsonb(timestamptz '-Infinity');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select to_jsonb(timestamptz '-Infinity');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select to_jsonb(timestamptz '-Infinity');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc to_jsonb with given argument types: (timestamptz)
            	select to_jsonb(timestamptz '-Infinity');
	       ^
<sql-statement>
--jsonb_agg
SELECT jsonb_agg(q)
  FROM ( SELECT $$a$$ || x AS b, y AS c,
               ARRAY[ROW(x.*,ARRAY[1,2,3]),
               ROW(y.*,ARRAY[4,5,6])] AS z
         FROM generate_series(1,2) x,
              generate_series(4,5) y) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:4:16: Error: alternative is not implemented yet : 138
    	               ARRAY[ROW(x.*,ARRAY[1,2,3]),
	               ^
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect
    	--jsonb_agg
	^
        -stdin-:<main>:1:1: Error: Recursive query does not have the form non-recursive-term UNION [ALL] recursive-term
        	--jsonb_agg
	^
<sql-statement>
SELECT jsonb_agg(q ORDER BY x, y)
  FROM rows q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT jsonb_agg(q ORDER BY x, y)
	       ^
<sql-statement>
UPDATE rows SET x = NULL WHERE x = 1;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)
  FROM rows q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported agg_order
    	SELECT jsonb_agg(q ORDER BY x NULLS FIRST, y)
	       ^
<sql-statement>
-- jsonb extraction functions
CREATE TEMP TABLE test_jsonb (
       json_type text,
       test_json jsonb
);
</sql-statement>
<sql-statement>
INSERT INTO test_jsonb VALUES
('scalar','"a scalar"'),
('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
('object','{"field1":"val1","field2":"val2","field3":null, "field4": 4, "field5": [1,2,3], "field6": {"f1":9}}');
</sql-statement>
<sql-statement>
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json -> 'field2' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field4' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field5' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 'field6' FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
<sql-statement>
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
	       ^
<sql-statement>
SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
	       ^
<sql-statement>
SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'object';
	       ^
<sql-statement>
-- nulls
SELECT (test_json->'field3') IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT (test_json->>'field3') IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'object';
</sql-statement>
<sql-statement>
SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
</sql-statement>
<sql-statement>
-- corner cases
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::text;
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> null::int;
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 1;
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> 'z';
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb -> '';
</sql-statement>
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 1;
</sql-statement>
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 3;
</sql-statement>
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb -> 'z';
</sql-statement>
<sql-statement>
select '{"a": "c", "b": null}'::jsonb -> 'b';
</sql-statement>
<sql-statement>
select '"foo"'::jsonb -> 1;
</sql-statement>
<sql-statement>
select '"foo"'::jsonb -> 'z';
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::text;
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> null::int;
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 1;
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> 'z';
</sql-statement>
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb ->> '';
</sql-statement>
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 1;
</sql-statement>
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 3;
</sql-statement>
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb ->> 'z';
</sql-statement>
<sql-statement>
select '{"a": "c", "b": null}'::jsonb ->> 'b';
</sql-statement>
<sql-statement>
select '"foo"'::jsonb ->> 1;
</sql-statement>
<sql-statement>
select '"foo"'::jsonb ->> 'z';
</sql-statement>
<sql-statement>
-- equality and inequality
SELECT '{"x":"y"}'::jsonb = '{"x":"y"}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"x":"y"}'::jsonb = '{"x":"z"}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"x":"y"}'::jsonb <> '{"x":"y"}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"x":"y"}'::jsonb <> '{"x":"z"}'::jsonb;
</sql-statement>
<sql-statement>
-- containment
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
</sql-statement>
<sql-statement>
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "g":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"g":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"c"}');
</sql-statement>
<sql-statement>
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b"}');
</sql-statement>
<sql-statement>
SELECT jsonb_contains('{"a":"b", "b":1, "c":null}', '{"a":"b", "c":"q"}');
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "g":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"g":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"c"}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b"}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "b":1, "c":null}'::jsonb @> '{"a":"b", "c":"q"}';
</sql-statement>
<sql-statement>
SELECT '[1,2]'::jsonb @> '[1,2,2]'::jsonb;
</sql-statement>
<sql-statement>
SELECT '[1,1,2]'::jsonb @> '[1,2,2]'::jsonb;
</sql-statement>
<sql-statement>
SELECT '[[1,2]]'::jsonb @> '[[1,2,2]]'::jsonb;
</sql-statement>
<sql-statement>
SELECT '[1,2,2]'::jsonb <@ '[1,2]'::jsonb;
</sql-statement>
<sql-statement>
SELECT '[1,2,2]'::jsonb <@ '[1,1,2]'::jsonb;
</sql-statement>
<sql-statement>
SELECT '[[1,2,2]]'::jsonb <@ '[[1,2]]'::jsonb;
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"a":"b", "c":null}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"a":"b", "g":null}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"g":null}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"a":"c"}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"a":"b"}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT jsonb_contained('{"a":"b", "c":"q"}', '{"a":"b", "b":1, "c":null}');
</sql-statement>
<sql-statement>
SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "c":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"g":null}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"c"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
SELECT '{"a":"b", "c":"q"}'::jsonb <@ '{"a":"b", "b":1, "c":null}';
</sql-statement>
<sql-statement>
-- Raw scalar may contain another raw scalar, array may contain a raw scalar
SELECT '[5]'::jsonb @> '[5]';
</sql-statement>
<sql-statement>
SELECT '5'::jsonb @> '5';
</sql-statement>
<sql-statement>
SELECT '[5]'::jsonb @> '5';
</sql-statement>
<sql-statement>
-- But a raw scalar cannot contain an array
SELECT '5'::jsonb @> '[5]';
</sql-statement>
<sql-statement>
-- In general, one thing should always contain itself. Test array containment:
SELECT '["9", ["7", "3"], 1]'::jsonb @> '["9", ["7", "3"], 1]'::jsonb;
</sql-statement>
<sql-statement>
SELECT '["9", ["7", "3"], ["1"]]'::jsonb @> '["9", ["7", "3"], ["1"]]'::jsonb;
</sql-statement>
<sql-statement>
-- array containment string matching confusion bug
SELECT '{ "name": "Bob", "tags": [ "enim", "qui"]}'::jsonb @> '{"tags":["qu"]}';
</sql-statement>
<sql-statement>
-- array length
SELECT jsonb_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
</sql-statement>
<sql-statement>
SELECT jsonb_array_length('[]');
</sql-statement>
<sql-statement>
SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot get array length of a non-array

        	SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
	^
<sql-statement>
SELECT jsonb_array_length('4');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_array_length('4');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot get array length of a scalar

        	SELECT jsonb_array_length('4');
	^
<sql-statement>
-- each
SELECT jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null}');
	       ^
<sql-statement>
SELECT jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
	       ^
<sql-statement>
SELECT * FROM jsonb_each('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
</sql-statement>
<sql-statement>
SELECT * FROM jsonb_each('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
</sql-statement>
<sql-statement>
SELECT jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":"null"}');
	       ^
<sql-statement>
SELECT jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
	       ^
<sql-statement>
SELECT * FROM jsonb_each_text('{"f1":[1,2,3],"f2":{"f3":1},"f4":null,"f5":99,"f6":"stringy"}') q;
</sql-statement>
<sql-statement>
SELECT * FROM jsonb_each_text('{"a":{"b":"c","c":"b","1":"first"},"b":[1,2],"c":"cc","1":"first","n":null}'::jsonb) AS q;
</sql-statement>
<sql-statement>
-- exists
SELECT jsonb_exists('{"a":null, "b":"qq"}', 'a');
</sql-statement>
<sql-statement>
SELECT jsonb_exists('{"a":null, "b":"qq"}', 'b');
</sql-statement>
<sql-statement>
SELECT jsonb_exists('{"a":null, "b":"qq"}', 'c');
</sql-statement>
<sql-statement>
SELECT jsonb_exists('{"a":"null", "b":"qq"}', 'a');
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ? 'a';
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ? 'b';
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ? 'c';
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":"null", "b":"qq"}' ? 'a';
</sql-statement>
<sql-statement>
-- array exists - array elements should behave as keys
SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
</sql-statement>
<sql-statement>
-- type sensitive array exists - should return no rows (since "exists" only
-- matches strings that are either object keys or array elements)
SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
</sql-statement>
<sql-statement>
-- However, a raw scalar is *contained* within the array
SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
</sql-statement>
<sql-statement>
SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['a','b']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['b','a']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['c','a']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_any('{"a":null, "b":"qq"}', ARRAY['c','d']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_any('{"a":null, "b":"qq"}', '{}'::text[]);
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['a','b'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['b','a'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','a'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?| ARRAY['c','d'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?| '{}'::text[];
</sql-statement>
<sql-statement>
SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['a','b']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['b','a']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['c','a']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_all('{"a":null, "b":"qq"}', ARRAY['c','d']);
</sql-statement>
<sql-statement>
SELECT jsonb_exists_all('{"a":null, "b":"qq"}', '{}'::text[]);
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','b'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['b','a'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','a'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['c','d'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?& ARRAY['a','a', 'b', 'b', 'b'];
</sql-statement>
<sql-statement>
SELECT jsonb '{"a":null, "b":"qq"}' ?& '{}'::text[];
</sql-statement>
<sql-statement>
-- typeof
SELECT jsonb_typeof('{}') AS object;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('{"c":3,"p":"o"}') AS object;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('[]') AS array;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('["a", 1]') AS array;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('null') AS "null";
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('1') AS number;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('-1') AS number;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('1.0') AS number;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('1e2') AS number;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('-1.0') AS number;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('true') AS boolean;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('false') AS boolean;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('"hello"') AS string;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('"true"') AS string;
</sql-statement>
<sql-statement>
SELECT jsonb_typeof('"1.0"') AS string;
</sql-statement>
<sql-statement>
-- jsonb_build_array, jsonb_build_object, jsonb_object_agg
SELECT jsonb_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb_build_array, jsonb_build_object, jsonb_object_agg
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	-- jsonb_build_array, jsonb_build_object, jsonb_object_agg
	^
<sql-statement>
SELECT jsonb_build_array('a', NULL); -- ok
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_array('a', NULL); -- ok
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_array('a', NULL); -- ok
	^
<sql-statement>
SELECT jsonb_build_array(VARIADIC NULL::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC NULL::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_array(VARIADIC '{}'::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC '{}'::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_array(VARIADIC '{a,b,c}'::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC '{a,b,c}'::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::int[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::int[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_object('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
	^
<sql-statement>
SELECT jsonb_build_object(
       'a', jsonb_build_object('b',false,'c',99),
       'd', jsonb_build_object('e',array[9,8,7]::int[],
           'f', (select row_to_json(r) from ( select relkind, oid::regclass as name from pg_class where relname = 'pg_class') r)));
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object(
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_object(
	^
<sql-statement>
SELECT jsonb_build_object('{a,b,c}'::text[]); -- error
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object('{a,b,c}'::text[]); -- error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  argument list must have even number of elements
HINT:  The arguments of jsonb_build_object() must consist of alternating keys and values.

        	SELECT jsonb_build_object('{a,b,c}'::text[]); -- error
	^
<sql-statement>
SELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  key value must be scalar, not array, composite, or json

        	SELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
	^
<sql-statement>
SELECT jsonb_build_object('a', 'b', 'c'); -- error
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object('a', 'b', 'c'); -- error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_object('a', 'b', 'c'); -- error
	^
<sql-statement>
SELECT jsonb_build_object(NULL, 'a'); -- error, key cannot be NULL
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object(NULL, 'a'); -- error, key cannot be NULL
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_object(NULL, 'a'); -- error, key cannot be NULL
	^
<sql-statement>
SELECT jsonb_build_object('a', NULL); -- ok
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object('a', NULL); -- ok
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_object('a', NULL); -- ok
	^
<sql-statement>
SELECT jsonb_build_object(VARIADIC NULL::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC NULL::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC '{}'::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC '{}'::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC '{a,b,c}'::text[]); -- error
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC '{a,b,c}'::text[]); -- error
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC ARRAY['a', NULL]::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC ARRAY['a', NULL]::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC ARRAY[NULL, 'a']::text[]); -- error, key cannot be NULL
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC ARRAY[NULL, 'a']::text[]); -- error, key cannot be NULL
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC '{1,2,3,4}'::text[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC '{1,2,3,4}'::text[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC '{1,2,3,4}'::int[]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC '{1,2,3,4}'::int[]); -- ok
	       ^
<sql-statement>
SELECT jsonb_build_object(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: FuncCall: unsupported func_variadic
    	SELECT jsonb_build_object(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
	       ^
<sql-statement>
-- empty objects/arrays
SELECT jsonb_build_array();
</sql-statement>
<sql-statement>
SELECT jsonb_build_object();
</sql-statement>
<sql-statement>
-- make sure keys are quoted
SELECT jsonb_build_object(1,2);
</sql-statement>
<sql-statement>
-- keys must be scalar and not null
SELECT jsonb_build_object(null,2);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- keys must be scalar and not null
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	-- keys must be scalar and not null
	^
<sql-statement>
SELECT jsonb_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  key value must be scalar, not array, composite, or json

        	SELECT jsonb_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
	^
<sql-statement>
SELECT jsonb_build_object(json '{"a":1,"b":2}', 3);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object(json '{"a":1,"b":2}', 3);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  key value must be scalar, not array, composite, or json

        	SELECT jsonb_build_object(json '{"a":1,"b":2}', 3);
	^
<sql-statement>
SELECT jsonb_build_object('{1,2,3}'::int[], 3);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_build_object('{1,2,3}'::int[], 3);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  key value must be scalar, not array, composite, or json

        	SELECT jsonb_build_object('{1,2,3}'::int[], 3);
	^
<sql-statement>
-- handling of NULL values
SELECT jsonb_object_agg(1, NULL::jsonb);
</sql-statement>
<sql-statement>
SELECT jsonb_object_agg(NULL, '{"a":1}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	SELECT jsonb_object_agg(NULL, '{"a":1}');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  field name must not be null

        	SELECT jsonb_object_agg(NULL, '{"a":1}');
	^
<sql-statement>
CREATE TEMP TABLE foo (serial_num int, name text, type text);
</sql-statement>
<sql-statement>
INSERT INTO foo VALUES (847001,'t15','GE1043');
</sql-statement>
<sql-statement>
INSERT INTO foo VALUES (847002,'t16','GE1043');
</sql-statement>
<sql-statement>
INSERT INTO foo VALUES (847003,'sub-alpha','GESS90');
</sql-statement>
<sql-statement>
SELECT jsonb_build_object('turbines',jsonb_object_agg(serial_num,jsonb_build_object('name',name,'type',type)))
FROM foo;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: YtMapReduce!
    	SELECT jsonb_build_object('turbines',jsonb_object_agg(serial_num,jsonb_build_object('name',name,'type',type)))
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  could not determine data type for argument 1

        	SELECT jsonb_build_object('turbines',jsonb_object_agg(serial_num,jsonb_build_object('name',name,'type',type)))
	^
<sql-statement>
SELECT jsonb_object_agg(name, type) FROM foo;
</sql-statement>
<sql-statement>
INSERT INTO foo VALUES (999999, NULL, 'bar');
</sql-statement>
<sql-statement>
SELECT jsonb_object_agg(name, type) FROM foo;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: YtMapReduce!
    	SELECT jsonb_object_agg(name, type) FROM foo;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  field name must not be null

        	SELECT jsonb_object_agg(name, type) FROM foo;
	^
<sql-statement>
-- jsonb_object
-- empty object, one dimension
SELECT jsonb_object('{}');
</sql-statement>
<sql-statement>
-- empty object, two dimensions
SELECT jsonb_object('{}', '{}');
</sql-statement>
<sql-statement>
-- one dimension
SELECT jsonb_object('{a,1,b,2,3,NULL,"d e f","a b c"}');
</sql-statement>
<sql-statement>
-- same but with two dimensions
SELECT jsonb_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
</sql-statement>
<sql-statement>
-- odd number error
SELECT jsonb_object('{a,b,c}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- odd number error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  array must have even number of elements

        	-- odd number error
	^
<sql-statement>
-- one column error
SELECT jsonb_object('{{a},{b}}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- one column error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  array must have two columns

        	-- one column error
	^
<sql-statement>
-- too many columns error
SELECT jsonb_object('{{a,b,c},{b,c,d}}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- too many columns error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  array must have two columns

        	-- too many columns error
	^
<sql-statement>
-- too many dimensions error
SELECT jsonb_object('{{{a,b},{c,d}},{{b,c},{d,e}}}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- too many dimensions error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  wrong number of array subscripts

        	-- too many dimensions error
	^
<sql-statement>
--two argument form of jsonb_object
select jsonb_object('{a,b,c,"d e f"}','{1,2,3,"a b c"}');
</sql-statement>
<sql-statement>
-- too many dimensions
SELECT jsonb_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}', '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- too many dimensions
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  wrong number of array subscripts

        	-- too many dimensions
	^
<sql-statement>
-- mismatched dimensions
select jsonb_object('{a,b,c,"d e f",g}','{1,2,3,"a b c"}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- mismatched dimensions
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  mismatched array dimensions

        	-- mismatched dimensions
	^
<sql-statement>
select jsonb_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  mismatched array dimensions

        	select jsonb_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
	^
<sql-statement>
-- null key error
select jsonb_object('{a,b,NULL,"d e f"}','{1,2,3,"a b c"}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- null key error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  null value not allowed for object key

        	-- null key error
	^
<sql-statement>
-- empty key is allowed
select jsonb_object('{a,b,"","d e f"}','{1,2,3,"a b c"}');
</sql-statement>
<sql-statement>
-- extract_path, extract_path_as_text
SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f4','f6');
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}','f2');
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',0::text);
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path_text('{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}','f2',1::text);
</sql-statement>
<sql-statement>
-- extract_path nulls
SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') IS NULL AS expect_false;
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":{"f5":null,"f6":"stringy"}}','f4','f5') IS NULL AS expect_true;
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') IS NULL AS expect_false;
</sql-statement>
<sql-statement>
SELECT jsonb_extract_path_text('{"f2":{"f3":1},"f4":[0,1,2,null]}','f4','3') IS NULL AS expect_true;
</sql-statement>
<sql-statement>
-- extract_path operators
SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- extract_path operators
	^
        -stdin-:<main>:2:62: Error: At function: PgOp
        	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
	                                                             ^
            -stdin-:<main>:2:62: Error: No such operator: #>
            	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
	                                                             ^
<sql-statement>
SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>
            	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
	                                                             ^
<sql-statement>
SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>
            	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
	                                                             ^
<sql-statement>
SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>
            	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
	                                                             ^
<sql-statement>
SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>>
            	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
	                                                             ^
<sql-statement>
SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>>
            	SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
	                                                             ^
<sql-statement>
SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>>
            	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
	                                                             ^
<sql-statement>
SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
	^
        -stdin-:<main>:1:62: Error: At function: PgOp
        	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
	                                                             ^
            -stdin-:<main>:1:62: Error: No such operator: #>>
            	SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
	                                                             ^
<sql-statement>
-- corner cases for same
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- corner cases for same
	^
        -stdin-:<main>:2:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> '{}';
	                                          ^
            -stdin-:<main>:2:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> '{}';
	                                          ^
<sql-statement>
select '[1,2,3]'::jsonb #> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[1,2,3]'::jsonb #> '{}';
	^
        -stdin-:<main>:1:25: Error: At function: PgOp
        	select '[1,2,3]'::jsonb #> '{}';
	                        ^
            -stdin-:<main>:1:25: Error: No such operator: #>
            	select '[1,2,3]'::jsonb #> '{}';
	                        ^
<sql-statement>
select '"foo"'::jsonb #> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '"foo"'::jsonb #> '{}';
	^
        -stdin-:<main>:1:23: Error: At function: PgOp
        	select '"foo"'::jsonb #> '{}';
	                      ^
            -stdin-:<main>:1:23: Error: No such operator: #>
            	select '"foo"'::jsonb #> '{}';
	                      ^
<sql-statement>
select '42'::jsonb #> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '42'::jsonb #> '{}';
	^
        -stdin-:<main>:1:20: Error: At function: PgOp
        	select '42'::jsonb #> '{}';
	                   ^
            -stdin-:<main>:1:20: Error: No such operator: #>
            	select '42'::jsonb #> '{}';
	                   ^
<sql-statement>
select 'null'::jsonb #> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select 'null'::jsonb #> '{}';
	^
        -stdin-:<main>:1:22: Error: At function: PgOp
        	select 'null'::jsonb #> '{}';
	                     ^
            -stdin-:<main>:1:22: Error: No such operator: #>
            	select 'null'::jsonb #> '{}';
	                     ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
	                                          ^
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
	^
        -stdin-:<main>:1:50: Error: At function: PgOp
        	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
	                                                 ^
            -stdin-:<main>:1:50: Error: No such operator: #>
            	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
	                                                 ^
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
	^
        -stdin-:<main>:1:50: Error: At function: PgOp
        	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
	                                                 ^
            -stdin-:<main>:1:50: Error: No such operator: #>
            	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
	                                                 ^
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
	                                          ^
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
	                                          ^
<sql-statement>
select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>
            	select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
	                                          ^
<sql-statement>
select '"foo"'::jsonb #> array['z'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '"foo"'::jsonb #> array['z'];
	^
        -stdin-:<main>:1:23: Error: At function: PgOp
        	select '"foo"'::jsonb #> array['z'];
	                      ^
            -stdin-:<main>:1:23: Error: No such operator: #>
            	select '"foo"'::jsonb #> array['z'];
	                      ^
<sql-statement>
select '42'::jsonb #> array['f2'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '42'::jsonb #> array['f2'];
	^
        -stdin-:<main>:1:20: Error: At function: PgOp
        	select '42'::jsonb #> array['f2'];
	                   ^
            -stdin-:<main>:1:20: Error: No such operator: #>
            	select '42'::jsonb #> array['f2'];
	                   ^
<sql-statement>
select '42'::jsonb #> array['0'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '42'::jsonb #> array['0'];
	^
        -stdin-:<main>:1:20: Error: At function: PgOp
        	select '42'::jsonb #> array['0'];
	                   ^
            -stdin-:<main>:1:20: Error: No such operator: #>
            	select '42'::jsonb #> array['0'];
	                   ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> '{}';
	                                          ^
<sql-statement>
select '[1,2,3]'::jsonb #>> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[1,2,3]'::jsonb #>> '{}';
	^
        -stdin-:<main>:1:25: Error: At function: PgOp
        	select '[1,2,3]'::jsonb #>> '{}';
	                        ^
            -stdin-:<main>:1:25: Error: No such operator: #>>
            	select '[1,2,3]'::jsonb #>> '{}';
	                        ^
<sql-statement>
select '"foo"'::jsonb #>> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '"foo"'::jsonb #>> '{}';
	^
        -stdin-:<main>:1:23: Error: At function: PgOp
        	select '"foo"'::jsonb #>> '{}';
	                      ^
            -stdin-:<main>:1:23: Error: No such operator: #>>
            	select '"foo"'::jsonb #>> '{}';
	                      ^
<sql-statement>
select '42'::jsonb #>> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '42'::jsonb #>> '{}';
	^
        -stdin-:<main>:1:20: Error: At function: PgOp
        	select '42'::jsonb #>> '{}';
	                   ^
            -stdin-:<main>:1:20: Error: No such operator: #>>
            	select '42'::jsonb #>> '{}';
	                   ^
<sql-statement>
select 'null'::jsonb #>> '{}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select 'null'::jsonb #>> '{}';
	^
        -stdin-:<main>:1:22: Error: At function: PgOp
        	select 'null'::jsonb #>> '{}';
	                     ^
            -stdin-:<main>:1:22: Error: No such operator: #>>
            	select 'null'::jsonb #>> '{}';
	                     ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
	                                          ^
<sql-statement>
select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
	                                          ^
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
	^
        -stdin-:<main>:1:50: Error: At function: PgOp
        	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
	                                                 ^
            -stdin-:<main>:1:50: Error: No such operator: #>>
            	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
	                                                 ^
<sql-statement>
select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
	^
        -stdin-:<main>:1:50: Error: At function: PgOp
        	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
	                                                 ^
            -stdin-:<main>:1:50: Error: No such operator: #>>
            	select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
	                                                 ^
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
	                                          ^
<sql-statement>
select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
	                                          ^
<sql-statement>
select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
	^
        -stdin-:<main>:1:43: Error: At function: PgOp
        	select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
	                                          ^
            -stdin-:<main>:1:43: Error: No such operator: #>>
            	select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
	                                          ^
<sql-statement>
select '"foo"'::jsonb #>> array['z'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '"foo"'::jsonb #>> array['z'];
	^
        -stdin-:<main>:1:23: Error: At function: PgOp
        	select '"foo"'::jsonb #>> array['z'];
	                      ^
            -stdin-:<main>:1:23: Error: No such operator: #>>
            	select '"foo"'::jsonb #>> array['z'];
	                      ^
<sql-statement>
select '42'::jsonb #>> array['f2'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '42'::jsonb #>> array['f2'];
	^
        -stdin-:<main>:1:20: Error: At function: PgOp
        	select '42'::jsonb #>> array['f2'];
	                   ^
            -stdin-:<main>:1:20: Error: No such operator: #>>
            	select '42'::jsonb #>> array['f2'];
	                   ^
<sql-statement>
select '42'::jsonb #>> array['0'];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '42'::jsonb #>> array['0'];
	^
        -stdin-:<main>:1:20: Error: At function: PgOp
        	select '42'::jsonb #>> array['0'];
	                   ^
            -stdin-:<main>:1:20: Error: No such operator: #>>
            	select '42'::jsonb #>> array['0'];
	                   ^
<sql-statement>
-- array_elements
SELECT jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
	       ^
<sql-statement>
SELECT * FROM jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]') q;
</sql-statement>
<sql-statement>
SELECT jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
	       ^
<sql-statement>
SELECT * FROM jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
</sql-statement>
<sql-statement>
-- populate_record
CREATE TYPE jbpop AS (a text, b int, c timestamp);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 314
    	-- populate_record
	^
<sql-statement>
CREATE DOMAIN jsb_int_not_null  AS int     NOT NULL;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 272
    	CREATE DOMAIN jsb_int_not_null  AS int     NOT NULL;
	^
<sql-statement>
CREATE DOMAIN jsb_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 272
    	CREATE DOMAIN jsb_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
	^
<sql-statement>
CREATE DOMAIN jsb_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 272
    	CREATE DOMAIN jsb_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
	^
<sql-statement>
create type jb_unordered_pair as (x int, y int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 314
    	create type jb_unordered_pair as (x int, y int);
	^
<sql-statement>
create domain jb_ordered_pair as jb_unordered_pair check((value).x <= (value).y);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 272
    	create domain jb_ordered_pair as jb_unordered_pair check((value).x <= (value).y);
	^
<sql-statement>
CREATE TYPE jsbrec AS (
	i	int,
	ia	_int4,
	ia1	int[],
	ia2	int[][],
	ia3	int[][][],
	ia1d	jsb_int_array_1d,
	ia2d	jsb_int_array_2d,
	t	text,
	ta	text[],
	c	char(10),
	ca	char(10)[],
	ts	timestamp,
	js	json,
	jsb	jsonb,
	jsa	json[],
	rec	jbpop,
	reca	jbpop[]
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 314
    	CREATE TYPE jsbrec AS (
	^
<sql-statement>
CREATE TYPE jsbrec_i_not_null AS (
	i	jsb_int_not_null
);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 314
    	CREATE TYPE jsbrec_i_not_null AS (
	^
<sql-statement>
SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
	                                          ^
<sql-statement>
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:71: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
	                                                                      ^
<sql-statement>
SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":"blurfl","x":43.2}') q;
	                                          ^
<sql-statement>
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:71: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":"blurfl","x":43.2}') q;
	                                                                      ^
<sql-statement>
SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":[100,200,false],"x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_record(NULL::jbpop,'{"a":[100,200,false],"x":43.2}') q;
	                                          ^
<sql-statement>
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":[100,200,false],"x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:71: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"a":[100,200,false],"x":43.2}') q;
	                                                                      ^
<sql-statement>
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"c":[100,200,false],"x":43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:71: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"c":[100,200,false],"x":43.2}') q;
	                                                                      ^
<sql-statement>
SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop, '{}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:71: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop, '{}') q;
	                                                                      ^
<sql-statement>
SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"x": 43.2}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec_i_not_null
    	SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"x": 43.2}') q;
	                                          ^
<sql-statement>
SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec_i_not_null
    	SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": null}') q;
	                                          ^
<sql-statement>
SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": 12345}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec_i_not_null
    	SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": 12345}') q;
	                                          ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": null}') q;
	                                           ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": 123}') q;
	                                           ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [1, "2", null, 4]}') q;
	                                           ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1, 2], [3, 4]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1, 2], [3, 4]]}') q;
	                                           ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], 2]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], 2]}') q;
	                                           ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], [2, 3]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], [2, 3]]}') q;
	                                           ^
<sql-statement>
SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": "{1,2,3}"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": "{1,2,3}"}') q;
	                                           ^
<sql-statement>
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": null}') q;
	                                            ^
<sql-statement>
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": 123}') q;
	                                            ^
<sql-statement>
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": [1, "2", null, 4]}') q;
	                                            ^
<sql-statement>
SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": [[1, 2, 3]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": [[1, 2, 3]]}') q;
	                                            ^
<sql-statement>
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": null}') q;
	                                             ^
<sql-statement>
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": 123}') q;
	                                             ^
<sql-statement>
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null, 4]}') q;
	                                             ^
<sql-statement>
SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null]}') q;
	                                             ^
<sql-statement>
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [1, "2", null, 4]}') q;
	                                            ^
<sql-statement>
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [null, 4]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [null, 4]]}') q;
	                                            ^
<sql-statement>
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[], []]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[], []]}') q;
	                                            ^
<sql-statement>
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [3]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [3]]}') q;
	                                            ^
<sql-statement>
SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], 3, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], 3, 4]}') q;
	                                            ^
<sql-statement>
SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2"], [null, 4]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2"], [null, 4]]}') q;
	                                             ^
<sql-statement>
SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2", 3], [null, 5, 6]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2", 3], [null, 5, 6]]}') q;
	                                             ^
<sql-statement>
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [1, "2", null, 4]}') q;
	                                            ^
<sql-statement>
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [[1, 2], [null, 4]]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [[1, 2], [null, 4]]}') q;
	                                            ^
<sql-statement>
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[], []], [[], []], [[], []] ]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[], []], [[], []], [[], []] ]}') q;
	                                            ^
<sql-statement>
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2]], [[3, 4]] ]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2]], [[3, 4]] ]}') q;
	                                            ^
<sql-statement>
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]}') q;
	                                            ^
<sql-statement>
SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]] ]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]] ]}') q;
	                                            ^
<sql-statement>
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": null}') q;
	                                           ^
<sql-statement>
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": 123}') q;
	                                           ^
<sql-statement>
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [1, "2", null, 4]}') q;
	                                           ^
<sql-statement>
SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [[1, 2, 3], {"k": "v"}]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [[1, 2, 3], {"k": "v"}]}') q;
	                                           ^
<sql-statement>
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec
    	SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": null}') q;
	                                          ^
<sql-statement>
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaa"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec
    	SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaa"}') q;
	                                          ^
<sql-statement>
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaa"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec
    	SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaa"}') q;
	                                          ^
<sql-statement>
SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaaaaa"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:43: Error: Unknown type: jsbrec
    	SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaaaaa"}') q;
	                                          ^
<sql-statement>
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": null}') q;
	                                           ^
<sql-statement>
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": 123}') q;
	                                           ^
<sql-statement>
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [1, "2", null, 4]}') q;
	                                           ^
<sql-statement>
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": ["aaaaaaaaaaaaaaaa"]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": ["aaaaaaaaaaaaaaaa"]}') q;
	                                           ^
<sql-statement>
SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [[1, 2, 3], {"k": "v"}]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [[1, 2, 3], {"k": "v"}]}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": null}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": true}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": true}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": 123.45}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": 123.45}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": "123.45"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": "123.45"}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": "abc"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": "abc"}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": [123, "123", null, {"key": "value"}]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": [123, "123", null, {"key": "value"}]}') q;
	                                           ^
<sql-statement>
SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": {"a": "bbb", "b": null, "c": 123.45}}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:44: Error: Unknown type: jsbrec
    	SELECT js FROM jsonb_populate_record(NULL::jsbrec, '{"js": {"a": "bbb", "b": null, "c": 123.45}}') q;
	                                           ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": null}') q;
	                                            ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": true}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": true}') q;
	                                            ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": 123.45}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": 123.45}') q;
	                                            ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": "123.45"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": "123.45"}') q;
	                                            ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": "abc"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": "abc"}') q;
	                                            ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": [123, "123", null, {"key": "value"}]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": [123, "123", null, {"key": "value"}]}') q;
	                                            ^
<sql-statement>
SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": {"a": "bbb", "b": null, "c": 123.45}}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsb FROM jsonb_populate_record(NULL::jsbrec, '{"jsb": {"a": "bbb", "b": null, "c": 123.45}}') q;
	                                            ^
<sql-statement>
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": null}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": null}') q;
	                                            ^
<sql-statement>
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": 123}') q;
	                                            ^
<sql-statement>
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": [1, "2", null, 4]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": [1, "2", null, 4]}') q;
	                                            ^
<sql-statement>
SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": ["aaa", null, [1, 2, "3", {}], { "k" : "v" }]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": ["aaa", null, [1, 2, "3", {}], { "k" : "v" }]}') q;
	                                            ^
<sql-statement>
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": 123}') q;
	                                            ^
<sql-statement>
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": [1, 2]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": [1, 2]}') q;
	                                            ^
<sql-statement>
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}') q;
	                                            ^
<sql-statement>
SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": "(abc,42,01.02.2003)"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:45: Error: Unknown type: jsbrec
    	SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": "(abc,42,01.02.2003)"}') q;
	                                            ^
<sql-statement>
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": 123}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": 123}') q;
	                                             ^
<sql-statement>
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [1, 2]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [1, 2]}') q;
	                                             ^
<sql-statement>
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]}') q;
	                                             ^
<sql-statement>
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": ["(abc,42,01.02.2003)"]}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": ["(abc,42,01.02.2003)"]}') q;
	                                             ^
<sql-statement>
SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": "{\"(abc,42,01.02.2003)\"}"}') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jsbrec
    	SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": "{\"(abc,42,01.02.2003)\"}"}') q;
	                                             ^
<sql-statement>
SELECT rec FROM jsonb_populate_record(
	row(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
		row('x',3,'2012-12-31 15:30:56')::jbpop,NULL)::jsbrec,
	'{"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}}'
) q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:3:50: Error: alternative is not implemented yet : 138
    			row('x',3,'2012-12-31 15:30:56')::jbpop,NULL)::jsbrec,
	                                                 ^
<sql-statement>
-- anonymous record type
SELECT jsonb_populate_record(null::record, '{"x": 0, "y": 1}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- anonymous record type
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	SELECT jsonb_populate_record(null::record, '{"x": 0, "y": 1}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_populate_record with given argument types: (record,unknown)
            	SELECT jsonb_populate_record(null::record, '{"x": 0, "y": 1}');
	       ^
<sql-statement>
SELECT jsonb_populate_record(row(1,2), '{"f1": 0, "f2": 1}');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: alternative is not implemented yet : 138
    	SELECT jsonb_populate_record(row(1,2), '{"f1": 0, "f2": 1}');
	       ^
<sql-statement>
SELECT * FROM
  jsonb_populate_record(null::record, '{"x": 776}') AS (x int, y int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	SELECT * FROM
	^
<sql-statement>
-- composite domain
SELECT jsonb_populate_record(null::jb_ordered_pair, '{"x": 0, "y": 1}');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:36: Error: Unknown type: jb_ordered_pair
    	SELECT jsonb_populate_record(null::jb_ordered_pair, '{"x": 0, "y": 1}');
	                                   ^
<sql-statement>
SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 0}');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:40: Error: alternative is not implemented yet : 138
    	SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 0}');
	                                       ^
<sql-statement>
SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 1, "y": 0}');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:40: Error: alternative is not implemented yet : 138
    	SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 1, "y": 0}');
	                                       ^
<sql-statement>
-- populate_recordset
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:46: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                             ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:60: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                                           ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                             ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:60: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                                           ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:60: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                                           ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:60: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                                           ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                             ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:60: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":"blurfl","x":43.2},{"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                                           ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:60: Error: alternative is not implemented yet : 138
    	SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"a":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
	                                                           ^
<sql-statement>
-- anonymous record type
SELECT jsonb_populate_recordset(null::record, '[{"x": 0, "y": 1}]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(null::record, '[{"x": 0, "y": 1}]');
	       ^
<sql-statement>
SELECT jsonb_populate_recordset(row(1,2), '[{"f1": 0, "f2": 1}]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(row(1,2), '[{"f1": 0, "f2": 1}]');
	       ^
<sql-statement>
SELECT i, jsonb_populate_recordset(row(i,50), '[{"f1":"42"},{"f2":"43"}]')
FROM (VALUES (1),(2)) v(i);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:11: Error: Generator functions are not allowed in: SELECT
    	SELECT i, jsonb_populate_recordset(row(i,50), '[{"f1":"42"},{"f2":"43"}]')
	          ^
<sql-statement>
SELECT * FROM
  jsonb_populate_recordset(null::record, '[{"x": 776}]') AS (x int, y int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	SELECT * FROM
	^
<sql-statement>
-- empty array is a corner case
SELECT jsonb_populate_recordset(null::record, '[]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(null::record, '[]');
	       ^
<sql-statement>
SELECT jsonb_populate_recordset(row(1,2), '[]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(row(1,2), '[]');
	       ^
<sql-statement>
SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[]') q;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:46: Error: Unknown type: jbpop
    	SELECT * FROM jsonb_populate_recordset(NULL::jbpop,'[]') q;
	                                             ^
<sql-statement>
SELECT * FROM
  jsonb_populate_recordset(null::record, '[]') AS (x int, y int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	SELECT * FROM
	^
<sql-statement>
-- composite domain
SELECT jsonb_populate_recordset(null::jb_ordered_pair, '[{"x": 0, "y": 1}]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(null::jb_ordered_pair, '[{"x": 0, "y": 1}]');
	       ^
<sql-statement>
SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 0}, {"y": 3}]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 0}, {"y": 3}]');
	       ^
<sql-statement>
SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 1, "y": 0}]');
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: Generator functions are not allowed in: SELECT
    	SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 1, "y": 0}]');
	       ^
<sql-statement>
-- negative cases where the wrong record type is supplied
select * from jsonb_populate_recordset(row(0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	-- negative cases where the wrong record type is supplied
	^
<sql-statement>
select * from jsonb_populate_recordset(row(0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_populate_recordset(row(0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
	^
<sql-statement>
select * from jsonb_populate_recordset(row(0::int,0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_populate_recordset(row(0::int,0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
	^
<sql-statement>
select * from jsonb_populate_recordset(row(1000000000::int,50::int),'[{"b":"2"},{"a":"3"}]') q (a text, b text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_populate_recordset(row(1000000000::int,50::int),'[{"b":"2"},{"a":"3"}]') q (a text, b text);
	^
<sql-statement>
-- jsonb_to_record and jsonb_to_recordset
select * from jsonb_to_record('{"a":1,"b":"foo","c":"bar"}')
    as x(a int, b text, d text);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	-- jsonb_to_record and jsonb_to_recordset
	^
<sql-statement>
select * from jsonb_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')
    as x(a int, b text, c boolean);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_recordset('[{"a":1,"b":"foo","d":false},{"a":2,"b":"bar","c":true}]')
	^
<sql-statement>
select *, c is null as c_is_null
from jsonb_to_record('{"a":1, "b":{"c":16, "d":2}, "x":8, "ca": ["1 2", 3], "ia": [[1,2],[3,4]], "r": {"a": "aaa", "b": 123}}'::jsonb)
    as t(a int, b jsonb, c text, x int, ca char(5)[], ia int[][], r jbpop);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select *, c is null as c_is_null
	^
<sql-statement>
select *, c is null as c_is_null
from jsonb_to_recordset('[{"a":1, "b":{"c":16, "d":2}, "x":8}]'::jsonb)
    as t(a int, b jsonb, c text, x int);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select *, c is null as c_is_null
	^
<sql-statement>
select * from jsonb_to_record('{"ia": null}') as x(ia _int4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia": null}') as x(ia _int4);
	^
<sql-statement>
select * from jsonb_to_record('{"ia": 123}') as x(ia _int4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia": 123}') as x(ia _int4);
	^
<sql-statement>
select * from jsonb_to_record('{"ia": [1, "2", null, 4]}') as x(ia _int4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia": [1, "2", null, 4]}') as x(ia _int4);
	^
<sql-statement>
select * from jsonb_to_record('{"ia": [[1, 2], [3, 4]]}') as x(ia _int4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia": [[1, 2], [3, 4]]}') as x(ia _int4);
	^
<sql-statement>
select * from jsonb_to_record('{"ia": [[1], 2]}') as x(ia _int4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia": [[1], 2]}') as x(ia _int4);
	^
<sql-statement>
select * from jsonb_to_record('{"ia": [[1], [2, 3]]}') as x(ia _int4);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia": [[1], [2, 3]]}') as x(ia _int4);
	^
<sql-statement>
select * from jsonb_to_record('{"ia2": [1, 2, 3]}') as x(ia2 int[][]);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia2": [1, 2, 3]}') as x(ia2 int[][]);
	^
<sql-statement>
select * from jsonb_to_record('{"ia2": [[1, 2], [3, 4]]}') as x(ia2 int4[][]);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia2": [[1, 2], [3, 4]]}') as x(ia2 int4[][]);
	^
<sql-statement>
select * from jsonb_to_record('{"ia2": [[[1], [2], [3]]]}') as x(ia2 int4[][]);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"ia2": [[[1], [2], [3]]]}') as x(ia2 int4[][]);
	^
<sql-statement>
select * from jsonb_to_record('{"out": {"key": 1}}') as x(out json);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"out": {"key": 1}}') as x(out json);
	^
<sql-statement>
select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out json);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out json);
	^
<sql-statement>
select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out json);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out json);
	^
<sql-statement>
select * from jsonb_to_record('{"out": {"key": 1}}') as x(out jsonb);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"out": {"key": 1}}') as x(out jsonb);
	^
<sql-statement>
select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out jsonb);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out jsonb);
	^
<sql-statement>
select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out jsonb);
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RangeFunction: unsupported coldeflist
    	select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out jsonb);
	^
<sql-statement>
-- test type info caching in jsonb_populate_record()
CREATE TEMP TABLE jsbpoptest (js jsonb);
</sql-statement>
<sql-statement>
INSERT INTO jsbpoptest
SELECT '{
	"jsa": [1, "2", null, 4],
	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2},
	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}]
}'::jsonb
FROM generate_series(1, 3);
</sql-statement>
<sql-statement>
SELECT (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	SELECT (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest;
	^
<sql-statement>
DROP TYPE jsbrec;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP TYPE jsbrec;
	^
<sql-statement>
DROP TYPE jsbrec_i_not_null;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP TYPE jsbrec_i_not_null;
	^
<sql-statement>
DROP DOMAIN jsb_int_not_null;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP DOMAIN jsb_int_not_null;
	^
<sql-statement>
DROP DOMAIN jsb_int_array_1d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP DOMAIN jsb_int_array_1d;
	^
<sql-statement>
DROP DOMAIN jsb_int_array_2d;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP DOMAIN jsb_int_array_2d;
	^
<sql-statement>
DROP DOMAIN jb_ordered_pair;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP DOMAIN jb_ordered_pair;
	^
<sql-statement>
DROP TYPE jb_unordered_pair;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: DropStmt: alternative is not implemented yet : 373
    	DROP TYPE jb_unordered_pair;
	^
<sql-statement>
-- indexing
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ? 'public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ? 'bar';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '"CC" == $.wait';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == "CC" && true == $.public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25.0';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.bar)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) || exists($.disabled)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) && exists($.disabled)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? ("CC" == @)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.wait == "CC" && true == @.public)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.age ? (@ == 25)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.age == 25.0)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.bar';
</sql-statement>
<sql-statement>
CREATE INDEX jidx ON testjsonb USING gin (j);
</sql-statement>
<sql-statement>
SET enable_seqscan = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_seqscan
    	SET enable_seqscan = off;
	^
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
</sql-statement>
<sql-statement>
-- exercise GIN_SEARCH_MODE_ALL
SELECT count(*) FROM testjsonb WHERE j @> '{}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ? 'public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ? 'bar';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ?| ARRAY['public','disabled'];
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j ?& ARRAY['public','disabled'];
</sql-statement>
<sql-statement>
EXPLAIN (COSTS OFF)
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (COSTS OFF)
	^
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.wait == null))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.wait ? (@ == null))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '"CC" == $.wait';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == "CC" && true == $.public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25.0';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "foo"';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "bar"';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.array[*] == "bar"))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array ? (@[*] == "bar"))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array[*] ? (@ == "bar"))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.bar)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) || exists($.disabled)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.public) && exists($.disabled)';
</sql-statement>
<sql-statement>
EXPLAIN (COSTS OFF)
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (COSTS OFF)
	^
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? ("CC" == @)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.wait == "CC" && true == @.public)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.age ? (@ == 25)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.age == 25.0)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.array[*] == "bar")';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.array ? (@[*] == "bar")';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.array[*] ? (@ == "bar")';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.bar';
</sql-statement>
<sql-statement>
-- array exists - array elements should behave as keys (for GIN index scans too)
CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: index expression is not supported yet
    	-- array exists - array elements should behave as keys (for GIN index scans too)
	^
<sql-statement>
SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
</sql-statement>
<sql-statement>
-- type sensitive array exists - should return no rows (since "exists" only
-- matches strings that are either object keys or array elements)
SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
</sql-statement>
<sql-statement>
-- However, a raw scalar is *contained* within the array
SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
</sql-statement>
<sql-statement>
RESET enable_seqscan;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	RESET enable_seqscan;
	^
<sql-statement>
SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
	^
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect
    	SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
	^
        -stdin-:<main>:1:1: Error: Recursive query does not have the form non-recursive-term UNION [ALL] recursive-term
        	SELECT count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow;
	^
<sql-statement>
SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
	^
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect
    	SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
	^
        -stdin-:<main>:1:1: Error: Recursive query does not have the form non-recursive-term UNION [ALL] recursive-term
        	SELECT key, count(*) FROM (SELECT (jsonb_each(j)).key FROM testjsonb) AS wow GROUP BY key ORDER BY count DESC, key;
	^
<sql-statement>
-- sort/hash
SELECT count(distinct j) FROM testjsonb;
</sql-statement>
<sql-statement>
SET enable_hashagg = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_hashagg
    	SET enable_hashagg = off;
	^
<sql-statement>
SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
</sql-statement>
<sql-statement>
SET enable_hashagg = on;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_hashagg
    	SET enable_hashagg = on;
	^
<sql-statement>
SET enable_sort = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_sort
    	SET enable_sort = off;
	^
<sql-statement>
SELECT count(*) FROM (SELECT j FROM (SELECT * FROM testjsonb UNION ALL SELECT * FROM testjsonb) js GROUP BY j) js2;
</sql-statement>
<sql-statement>
SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgSelect, At function: PgSetItem, At function: PgValuesList
    	SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
	^
        -stdin-:<main>:1:44: Error: At function: PgOp
        	SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
	                                           ^
            -stdin-:<main>:1:44: Error: Unable to find an overload for operator || with given argument type(s): (jsonb,text)
            	SELECT distinct * FROM (values (jsonb '{}' || ''::text),('{}')) v(j);
	                                           ^
<sql-statement>
SET enable_sort = on;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_sort
    	SET enable_sort = on;
	^
<sql-statement>
RESET enable_hashagg;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	RESET enable_hashagg;
	^
<sql-statement>
RESET enable_sort;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	RESET enable_sort;
	^
<sql-statement>
DROP INDEX jidx;
</sql-statement>
-stdin-:<main>: Error: Pre type annotation

    -stdin-:<main>:1:1: Error: Unexpected tag: pgObject
    	DROP INDEX jidx;
	^
<sql-statement>
DROP INDEX jidx_array;
</sql-statement>
-stdin-:<main>: Error: Pre type annotation

    -stdin-:<main>:1:1: Error: Unexpected tag: pgObject
    	DROP INDEX jidx_array;
	^
<sql-statement>
-- btree
CREATE INDEX jidx ON testjsonb USING btree (j);
</sql-statement>
<sql-statement>
SET enable_seqscan = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_seqscan
    	SET enable_seqscan = off;
	^
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j > '{"p":1}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j = '{"pos":98, "line":371, "node":"CBA", "indexed":true}';
</sql-statement>
<sql-statement>
--gin path opclass
DROP INDEX jidx;
</sql-statement>
-stdin-:<main>: Error: Pre type annotation

    -stdin-:<main>:1:1: Error: Unexpected tag: pgObject
    	--gin path opclass
	^
<sql-statement>
CREATE INDEX jidx ON testjsonb USING gin (j jsonb_path_ops);
</sql-statement>
<sql-statement>
SET enable_seqscan = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_seqscan
    	SET enable_seqscan = off;
	^
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":null}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC"}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"wait":"CC", "public":true}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"age":25}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @> '{"age":25.0}';
</sql-statement>
<sql-statement>
-- exercise GIN_SEARCH_MODE_ALL
SELECT count(*) FROM testjsonb WHERE j @> '{}';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == null';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.wait == null))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.wait ? (@ == null))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '"CC" == $.wait';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.wait == "CC" && true == $.public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.age == 25.0';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "foo"';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ '$.array[*] == "bar"';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($ ? (@.array[*] == "bar"))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array ? (@[*] == "bar"))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($.array[*] ? (@ == "bar"))';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @@ 'exists($)';
</sql-statement>
<sql-statement>
EXPLAIN (COSTS OFF)
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: RawStmt: alternative is not implemented yet : 276
    	EXPLAIN (COSTS OFF)
	^
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? (@ == null)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.wait ? ("CC" == @)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.wait == "CC" && true == @.public)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.age ? (@ == 25)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.age == 25.0)';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$ ? (@.array[*] == "bar")';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.array ? (@[*] == "bar")';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.array[*] ? (@ == "bar")';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.public';
</sql-statement>
<sql-statement>
SELECT count(*) FROM testjsonb WHERE j @? '$.bar';
</sql-statement>
<sql-statement>
RESET enable_seqscan;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	RESET enable_seqscan;
	^
<sql-statement>
DROP INDEX jidx;
</sql-statement>
-stdin-:<main>: Error: Pre type annotation

    -stdin-:<main>:1:1: Error: Unexpected tag: pgObject
    	DROP INDEX jidx;
	^
<sql-statement>
-- nested tests
SELECT '{"ff":{"a":12,"b":16}}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"ff":{"a":12,"b":16},"qq":123}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"aa":["a","aaa"],"qq":{"a":12,"b":16,"c":["c1","c2"],"d":{"d1":"d1","d2":"d2","d1":"d3"}}}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2"],"d":{"d1":"d1","d2":"d2"}}}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"aa":["a","aaa"],"qq":{"a":"12","b":"16","c":["c1","c2",["c3"],{"c4":4}],"d":{"d1":"d1","d2":"d2"}}}'::jsonb;
</sql-statement>
<sql-statement>
SELECT '{"ff":["a","aaa"]}'::jsonb;
</sql-statement>
<sql-statement>
SELECT
  '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'ff',
  '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'qq',
  ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'Y') IS NULL AS f,
  ('{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb ->> 'Y') IS NULL AS t,
   '{"ff":{"a":12,"b":16},"qq":123,"x":[1,2],"Y":null}'::jsonb -> 'x';
</sql-statement>
<sql-statement>
-- nested containment
SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1,2]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[2,1],"c":"b"}'::jsonb @> '{"a":[1,2]}';
</sql-statement>
<sql-statement>
SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":[1,2]}';
</sql-statement>
<sql-statement>
SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":[1,2]}';
</sql-statement>
<sql-statement>
SELECT '{"a":{"1":2},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
</sql-statement>
<sql-statement>
SELECT '{"a":{"2":1},"c":"b"}'::jsonb @> '{"a":{"1":2}}';
</sql-statement>
<sql-statement>
SELECT '["a","b"]'::jsonb @> '["a","b","c","b"]';
</sql-statement>
<sql-statement>
SELECT '["a","b","c","b"]'::jsonb @> '["a","b"]';
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2]]'::jsonb @> '["a",[1,2]]';
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2]]'::jsonb @> '["b",[1,2]]';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[1]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[2]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2],"c":"b"}'::jsonb @> '{"a":[3]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"c":3}]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4}]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},3]}';
</sql-statement>
<sql-statement>
SELECT '{"a":[1,2,{"c":3,"x":4}],"c":"b"}'::jsonb @> '{"a":[{"x":4},1]}';
</sql-statement>
<sql-statement>
-- check some corner cases for indexed nested containment (bug #13756)
create temp table nestjsonb (j jsonb);
</sql-statement>
<sql-statement>
insert into nestjsonb (j) values ('{"a":[["b",{"x":1}],["b",{"x":2}]],"c":3}');
</sql-statement>
<sql-statement>
insert into nestjsonb (j) values ('[[14,2,3]]');
</sql-statement>
<sql-statement>
insert into nestjsonb (j) values ('[1,[14,2,3]]');
</sql-statement>
<sql-statement>
create index on nestjsonb using gin(j jsonb_path_ops);
</sql-statement>
<sql-statement>
set enable_seqscan = on;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_seqscan
    	set enable_seqscan = on;
	^
<sql-statement>
set enable_bitmapscan = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_bitmapscan
    	set enable_bitmapscan = off;
	^
<sql-statement>
select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
</sql-statement>
<sql-statement>
select * from nestjsonb where j @> '{"c":3}';
</sql-statement>
<sql-statement>
select * from nestjsonb where j @> '[[14]]';
</sql-statement>
<sql-statement>
set enable_seqscan = off;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_seqscan
    	set enable_seqscan = off;
	^
<sql-statement>
set enable_bitmapscan = on;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported name: enable_bitmapscan
    	set enable_bitmapscan = on;
	^
<sql-statement>
select * from nestjsonb where j @> '{"a":[[{"x":2}]]}'::jsonb;
</sql-statement>
<sql-statement>
select * from nestjsonb where j @> '{"c":3}';
</sql-statement>
<sql-statement>
select * from nestjsonb where j @> '[[14]]';
</sql-statement>
<sql-statement>
reset enable_seqscan;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	reset enable_seqscan;
	^
<sql-statement>
reset enable_bitmapscan;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: VariableSetStmt, not supported kind: 4
    	reset enable_bitmapscan;
	^
<sql-statement>
-- nested object field / array index lookup
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'n';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'a';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'b';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'c';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'd' -> '1';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 'e';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb -> 0; --expecting error
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 0;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 1;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 2;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 3;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 3 -> 1;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 4;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> 5;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> -1;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> -5;
</sql-statement>
<sql-statement>
SELECT '["a","b","c",[1,2],null]'::jsonb -> -6;
</sql-statement>
<sql-statement>
--nested path extraction
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{0}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	--nested path extraction
	^
        -stdin-:<main>:2:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{0}';
	                                      ^
            -stdin-:<main>:2:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{0}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{a}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,0}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,1}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,2}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,3}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-1}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-3}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-3}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-3}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-3}';
	                                      ^
<sql-statement>
SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-4}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-4}';
	^
        -stdin-:<main>:1:39: Error: At function: PgOp
        	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-4}';
	                                      ^
            -stdin-:<main>:1:39: Error: No such operator: #>
            	SELECT '{"a":"b","c":[1,2,3]}'::jsonb #> '{c,-4}';
	                                      ^
<sql-statement>
SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
	^
        -stdin-:<main>:1:44: Error: At function: PgOp
        	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
	                                           ^
            -stdin-:<main>:1:44: Error: No such operator: #>
            	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{0}';
	                                           ^
<sql-statement>
SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
	^
        -stdin-:<main>:1:44: Error: At function: PgOp
        	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
	                                           ^
            -stdin-:<main>:1:44: Error: No such operator: #>
            	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{3}';
	                                           ^
<sql-statement>
SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
	^
        -stdin-:<main>:1:44: Error: At function: PgOp
        	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
	                                           ^
            -stdin-:<main>:1:44: Error: No such operator: #>
            	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4}';
	                                           ^
<sql-statement>
SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
	^
        -stdin-:<main>:1:44: Error: At function: PgOp
        	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
	                                           ^
            -stdin-:<main>:1:44: Error: No such operator: #>
            	SELECT '[0,1,2,[3,4],{"5":"five"}]'::jsonb #> '{4,5}';
	                                           ^
<sql-statement>
--nested exists
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'n';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'a';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'b';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'c';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'd';
</sql-statement>
<sql-statement>
SELECT '{"n":null,"a":1,"b":[1,2],"c":{"1":2},"d":{"1":[2,3]}}'::jsonb ? 'e';
</sql-statement>
<sql-statement>
-- jsonb_strip_nulls
select jsonb_strip_nulls(null);
</sql-statement>
<sql-statement>
select jsonb_strip_nulls('1');
</sql-statement>
<sql-statement>
select jsonb_strip_nulls('"a string"');
</sql-statement>
<sql-statement>
select jsonb_strip_nulls('null');
</sql-statement>
<sql-statement>
select jsonb_strip_nulls('[1,2,null,3,4]');
</sql-statement>
<sql-statement>
select jsonb_strip_nulls('{"a":1,"b":null,"c":[2,null,3],"d":{"e":4,"f":null}}');
</sql-statement>
<sql-statement>
select jsonb_strip_nulls('[1,{"a":1,"b":null,"c":2},3]');
</sql-statement>
<sql-statement>
-- an empty object is not null and should not be stripped
select jsonb_strip_nulls('{"a": {"b": null, "c": null}, "d": {} }');
</sql-statement>
<sql-statement>
select jsonb_pretty('{"a": "test", "b": [1, 2, 3], "c": "test3", "d":{"dd": "test4", "dd2":{"ddd": "test5"}}}');
</sql-statement>
<sql-statement>
select jsonb_pretty('[{"f1":1,"f2":null},2,null,[[{"x":true},6,7],8],3]');
</sql-statement>
<sql-statement>
select jsonb_pretty('{"a":["b", "c"], "d": {"e":"f"}}');
</sql-statement>
<sql-statement>
select jsonb_concat('{"d": "test", "a": [1, 2]}', '{"g": "test2", "c": {"c1":1, "c2":2}}');
</sql-statement>
<sql-statement>
select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{"cq":"l", "b":"g", "fg":false}';
</sql-statement>
<sql-statement>
select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{"aq":"l"}';
</sql-statement>
<sql-statement>
select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{"aa":"l"}';
</sql-statement>
<sql-statement>
select '{"aa":1 , "b":2, "cq":3}'::jsonb || '{}';
</sql-statement>
<sql-statement>
select '["a", "b"]'::jsonb || '["c"]';
</sql-statement>
<sql-statement>
select '["a", "b"]'::jsonb || '["c", "d"]';
</sql-statement>
<sql-statement>
select '["c"]' || '["a", "b"]'::jsonb;
</sql-statement>
<sql-statement>
select '["a", "b"]'::jsonb || '"c"';
</sql-statement>
<sql-statement>
select '"c"' || '["a", "b"]'::jsonb;
</sql-statement>
<sql-statement>
select '[]'::jsonb || '["a"]'::jsonb;
</sql-statement>
<sql-statement>
select '[]'::jsonb || '"a"'::jsonb;
</sql-statement>
<sql-statement>
select '"b"'::jsonb || '"a"'::jsonb;
</sql-statement>
<sql-statement>
select '{}'::jsonb || '{"a":"b"}'::jsonb;
</sql-statement>
<sql-statement>
select '[]'::jsonb || '{"a":"b"}'::jsonb;
</sql-statement>
<sql-statement>
select '{"a":"b"}'::jsonb || '[]'::jsonb;
</sql-statement>
<sql-statement>
select '"a"'::jsonb || '{"a":1}';
</sql-statement>
<sql-statement>
select '{"a":1}' || '"a"'::jsonb;
</sql-statement>
<sql-statement>
select '[3]'::jsonb || '{}'::jsonb;
</sql-statement>
<sql-statement>
select '3'::jsonb || '[]'::jsonb;
</sql-statement>
<sql-statement>
select '3'::jsonb || '4'::jsonb;
</sql-statement>
<sql-statement>
select '3'::jsonb || '{}'::jsonb;
</sql-statement>
<sql-statement>
select '["a", "b"]'::jsonb || '{"c":1}';
</sql-statement>
<sql-statement>
select '{"c": 1}'::jsonb || '["a", "b"]';
</sql-statement>
<sql-statement>
select '{}'::jsonb || '{"cq":"l", "b":"g", "fg":false}';
</sql-statement>
<sql-statement>
select pg_column_size('{}'::jsonb || '{}'::jsonb) = pg_column_size('{}'::jsonb);
</sql-statement>
<sql-statement>
select pg_column_size('{"aa":1}'::jsonb || '{"b":2}'::jsonb) = pg_column_size('{"aa":1, "b":2}'::jsonb);
</sql-statement>
<sql-statement>
select pg_column_size('{"aa":1, "b":2}'::jsonb || '{}'::jsonb) = pg_column_size('{"aa":1, "b":2}'::jsonb);
</sql-statement>
<sql-statement>
select pg_column_size('{}'::jsonb || '{"aa":1, "b":2}'::jsonb) = pg_column_size('{"aa":1, "b":2}'::jsonb);
</sql-statement>
<sql-statement>
select jsonb_delete('{"a":1 , "b":2, "c":3}'::jsonb, 'a');
</sql-statement>
<sql-statement>
select jsonb_delete('{"a":null , "b":2, "c":3}'::jsonb, 'a');
</sql-statement>
<sql-statement>
select jsonb_delete('{"a":1 , "b":2, "c":3}'::jsonb, 'b');
</sql-statement>
<sql-statement>
select jsonb_delete('{"a":1 , "b":2, "c":3}'::jsonb, 'c');
</sql-statement>
<sql-statement>
select jsonb_delete('{"a":1 , "b":2, "c":3}'::jsonb, 'd');
</sql-statement>
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - 'a';
</sql-statement>
<sql-statement>
select '{"a":null , "b":2, "c":3}'::jsonb - 'a';
</sql-statement>
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - 'b';
</sql-statement>
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - 'c';
</sql-statement>
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - 'd';
</sql-statement>
<sql-statement>
select pg_column_size('{"a":1 , "b":2, "c":3}'::jsonb - 'b') = pg_column_size('{"a":1, "b":2}'::jsonb);
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - 3;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - 2;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - 1;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - 0;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - -1;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - -2;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - -3;
</sql-statement>
<sql-statement>
select '["a","b","c"]'::jsonb - -4;
</sql-statement>
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - '{b}'::text[];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a":1 , "b":2, "c":3}'::jsonb - '{b}'::text[];
	^
        -stdin-:<main>:1:40: Error: At function: PgOp
        	select '{"a":1 , "b":2, "c":3}'::jsonb - '{b}'::text[];
	                                       ^
            -stdin-:<main>:1:40: Error: Unable to find an overload for operator - with given argument type(s): (jsonb,_text)
            	select '{"a":1 , "b":2, "c":3}'::jsonb - '{b}'::text[];
	                                       ^
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - '{c,b}'::text[];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a":1 , "b":2, "c":3}'::jsonb - '{c,b}'::text[];
	^
        -stdin-:<main>:1:40: Error: At function: PgOp
        	select '{"a":1 , "b":2, "c":3}'::jsonb - '{c,b}'::text[];
	                                       ^
            -stdin-:<main>:1:40: Error: Unable to find an overload for operator - with given argument type(s): (jsonb,_text)
            	select '{"a":1 , "b":2, "c":3}'::jsonb - '{c,b}'::text[];
	                                       ^
<sql-statement>
select '{"a":1 , "b":2, "c":3}'::jsonb - '{}'::text[];
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select '{"a":1 , "b":2, "c":3}'::jsonb - '{}'::text[];
	^
        -stdin-:<main>:1:40: Error: At function: PgOp
        	select '{"a":1 , "b":2, "c":3}'::jsonb - '{}'::text[];
	                                       ^
            -stdin-:<main>:1:40: Error: Unable to find an overload for operator - with given argument type(s): (jsonb,_text)
            	select '{"a":1 , "b":2, "c":3}'::jsonb - '{}'::text[];
	                                       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '[1,2,3]');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '[1,2,3]');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '[1,2,3]');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '[1,2,3]');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '[1,2,3]');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '[1,2,3]');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '[1,2,3]');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '[1,2,3]');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '[1,2,3]');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '[1,2,3]');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '[1,2,3]');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '[1,2,3]');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '[1,2,3]');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '[1,2,3]');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '[1,2,3]');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '[1,2,3]');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '{"1": 2}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '{"1": 2}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '{"1": 2}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{n}', '{"1": 2}');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"1": 2}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"1": 2}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"1": 2}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"1": 2}');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '{"1": 2}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '{"1": 2}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '{"1": 2}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,1,0}', '{"1": 2}');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '{"1": 2}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '{"1": 2}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '{"1": 2}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '{"1": 2}');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '"test"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '"test"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '"test"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '"test"');
	       ^
<sql-statement>
select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"f": "test"}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"f": "test"}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"f": "test"}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (jsonb,unknown,unknown)
            	select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{b,-1}', '{"f": "test"}');
	       ^
<sql-statement>
select jsonb_delete_path('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}', '{n}');
</sql-statement>
<sql-statement>
select jsonb_delete_path('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}', '{b,-1}');
</sql-statement>
<sql-statement>
select jsonb_delete_path('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}', '{d,1,0}');
</sql-statement>
<sql-statement>
select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{n}';
</sql-statement>
<sql-statement>
select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1}';
</sql-statement>
<sql-statement>
select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}'; -- invalid array subscript
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}'; -- invalid array subscript
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  path element at position 2 is not an integer: "-1e"

        	select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}'; -- invalid array subscript
	^
<sql-statement>
select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{d,1,0}';
</sql-statement>
<sql-statement>
-- empty structure and error conditions for delete and replace
select '"a"'::jsonb - 'a'; -- error
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- empty structure and error conditions for delete and replace
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot delete from scalar

        	-- empty structure and error conditions for delete and replace
	^
<sql-statement>
select '{}'::jsonb - 'a';
</sql-statement>
<sql-statement>
select '[]'::jsonb - 'a';
</sql-statement>
<sql-statement>
select '"a"'::jsonb - 1; -- error
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '"a"'::jsonb - 1; -- error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot delete from scalar

        	select '"a"'::jsonb - 1; -- error
	^
<sql-statement>
select '{}'::jsonb -  1; -- error
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '{}'::jsonb -  1; -- error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot delete from object using integer index

        	select '{}'::jsonb -  1; -- error
	^
<sql-statement>
select '[]'::jsonb - 1;
</sql-statement>
<sql-statement>
select '"a"'::jsonb #- '{a}'; -- error
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '"a"'::jsonb #- '{a}'; -- error
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot delete path in scalar

        	select '"a"'::jsonb #- '{a}'; -- error
	^
<sql-statement>
select '{}'::jsonb #- '{a}';
</sql-statement>
<sql-statement>
select '[]'::jsonb #- '{a}';
</sql-statement>
<sql-statement>
select jsonb_set('"a"','{a}','"b"'); --error
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('"a"','{a}','"b"'); --error
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('"a"','{a}','"b"'); --error
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('"a"','{a}','"b"'); --error
	       ^
<sql-statement>
select jsonb_set('{}','{a}','"b"', false);
</sql-statement>
<sql-statement>
select jsonb_set('[]','{1}','"b"', false);
</sql-statement>
<sql-statement>
select jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0}','[2,3,4]', false);
</sql-statement>
<sql-statement>
-- jsonb_set adding instead of replacing
-- prepend to array
select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{b,-33}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- jsonb_set adding instead of replacing
	^
        -stdin-:<main>:3:8: Error: At function: PgCall
        	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{b,-33}','{"foo":123}');
	       ^
            -stdin-:<main>:3:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{b,-33}','{"foo":123}');
	       ^
<sql-statement>
-- append to array
select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{b,33}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- append to array
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{b,33}','{"foo":123}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{b,33}','{"foo":123}');
	       ^
<sql-statement>
-- check nesting levels addition
select jsonb_set('{"a":1,"b":[4,5,[0,1,2],6,7],"c":{"d":4}}','{b,2,33}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- check nesting levels addition
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set('{"a":1,"b":[4,5,[0,1,2],6,7],"c":{"d":4}}','{b,2,33}','{"foo":123}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a":1,"b":[4,5,[0,1,2],6,7],"c":{"d":4}}','{b,2,33}','{"foo":123}');
	       ^
<sql-statement>
-- add new key
select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{c,e}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- add new key
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{c,e}','{"foo":123}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{c,e}','{"foo":123}');
	       ^
<sql-statement>
-- adding doesn't do anything if elements before last aren't present
select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,-33}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- adding doesn't do anything if elements before last aren't present
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,-33}','{"foo":123}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,-33}','{"foo":123}');
	       ^
<sql-statement>
select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,y}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,y}','{"foo":123}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,y}','{"foo":123}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a":1,"b":[0,1,2],"c":{"d":4}}','{x,y}','{"foo":123}');
	       ^
<sql-statement>
-- add to empty object
select jsonb_set('{}','{x}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- add to empty object
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set('{}','{x}','{"foo":123}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{}','{x}','{"foo":123}');
	       ^
<sql-statement>
--add to empty array
select jsonb_set('[]','{0}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	--add to empty array
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set('[]','{0}','{"foo":123}');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('[]','{0}','{"foo":123}');
	       ^
<sql-statement>
select jsonb_set('[]','{99}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('[]','{99}','{"foo":123}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('[]','{99}','{"foo":123}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('[]','{99}','{"foo":123}');
	       ^
<sql-statement>
select jsonb_set('[]','{-99}','{"foo":123}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('[]','{-99}','{"foo":123}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('[]','{-99}','{"foo":123}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('[]','{-99}','{"foo":123}');
	       ^
<sql-statement>
select jsonb_set('{"a": [1, 2, 3]}', '{a, non_integer}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"a": [1, 2, 3]}', '{a, non_integer}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"a": [1, 2, 3]}', '{a, non_integer}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a": [1, 2, 3]}', '{a, non_integer}', '"new_value"');
	       ^
<sql-statement>
select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, non_integer}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, non_integer}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, non_integer}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, non_integer}', '"new_value"');
	       ^
<sql-statement>
select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, NULL}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, NULL}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, NULL}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set with given argument types: (unknown,unknown,unknown)
            	select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, NULL}', '"new_value"');
	       ^
<sql-statement>
-- jsonb_set_lax
\pset null NULL
</sql-statement>
<sql-statement>
-- pass though non nulls to jsonb_set
select jsonb_set_lax('{"a":1,"b":2}','{b}','5') ;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- pass though non nulls to jsonb_set
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set_lax('{"a":1,"b":2}','{b}','5') ;
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set_lax with given argument types: (unknown,unknown,unknown)
            	select jsonb_set_lax('{"a":1,"b":2}','{b}','5') ;
	       ^
<sql-statement>
select jsonb_set_lax('{"a":1,"b":2}','{d}','6', true) ;
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set_lax('{"a":1,"b":2}','{d}','6', true) ;
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set_lax('{"a":1,"b":2}','{d}','6', true) ;
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set_lax with given argument types: (unknown,unknown,unknown,bool)
            	select jsonb_set_lax('{"a":1,"b":2}','{d}','6', true) ;
	       ^
<sql-statement>
-- using the default treatment
select jsonb_set_lax('{"a":1,"b":2}','{b}',null);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- using the default treatment
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_set_lax('{"a":1,"b":2}','{b}',null);
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_set_lax with given argument types: (unknown,unknown,unknown)
            	select jsonb_set_lax('{"a":1,"b":2}','{b}',null);
	       ^
<sql-statement>
select jsonb_set_lax('{"a":1,"b":2}','{d}',null,true);
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_set_lax('{"a":1,"b":2}','{d}',null,true);
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_set_lax('{"a":1,"b":2}','{d}',null,true);
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_set_lax with given argument types: (unknown,unknown,unknown,bool)
            	select jsonb_set_lax('{"a":1,"b":2}','{d}',null,true);
	       ^
<sql-statement>
-- errors
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, true, null);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- errors
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  null_value_treatment must be "delete_key", "return_target", "use_json_null", or "raise_exception"

        	-- errors
	^
<sql-statement>
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, true, 'no_such_treatment');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, true, 'no_such_treatment');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  null_value_treatment must be "delete_key", "return_target", "use_json_null", or "raise_exception"

        	select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, true, 'no_such_treatment');
	^
<sql-statement>
-- explicit treatments
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'raise_exception') as raise_exception;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:8: Error: alternative is not implemented yet : 118
    	select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'raise_exception') as raise_exception;
	       ^
<sql-statement>
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'return_target') as return_target;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: alternative is not implemented yet : 118
    	select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'return_target') as return_target;
	       ^
<sql-statement>
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'delete_key') as delete_key;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: alternative is not implemented yet : 118
    	select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'delete_key') as delete_key;
	       ^
<sql-statement>
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'use_json_null') as use_json_null;
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:8: Error: alternative is not implemented yet : 118
    	select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'use_json_null') as use_json_null;
	       ^
<sql-statement>
\pset null ''
</sql-statement>
<sql-statement>
-- jsonb_insert
select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- jsonb_insert
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": {"b": {"c": [0, 1, "test1", "test2"]}}}', '{a, b, c, 2}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '{"b": "value"}');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '{"b": "value"}');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '{"b": "value"}');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '{"b": "value"}');
	       ^
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '["value1", "value2"]');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '["value1", "value2"]');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '["value1", "value2"]');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '["value1", "value2"]');
	       ^
<sql-statement>
-- edge cases
select jsonb_insert('{"a": [0,1,2]}', '{a, 0}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- edge cases
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, 0}', '"new_value"');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, 0}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 0}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 2}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": [0,1,2]}', '{a, 2}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, 2}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, 2}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 2}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, -1}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": [0,1,2]}', '{a, -1}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, -1}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, -1}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, -1}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('[]', '{1}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('[]', '{1}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('[]', '{1}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('[]', '{1}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('[]', '{1}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": []}', '{a, 1}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": []}', '{a, 1}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": []}', '{a, 1}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": []}', '{a, 1}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": []}', '{a, 1}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, 10}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": [0,1,2]}', '{a, 10}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, 10}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, 10}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": [0,1,2]}', '{a, -10}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": [0,1,2]}', '{a, -10}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": [0,1,2]}', '{a, -10}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": [0,1,2]}', '{a, -10}', '"new_value"');
	       ^
<sql-statement>
-- jsonb_insert should be able to insert new value for objects, but not to replace
select jsonb_insert('{"a": {"b": "value"}}', '{a, c}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- jsonb_insert should be able to insert new value for objects, but not to replace
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select jsonb_insert('{"a": {"b": "value"}}', '{a, c}', '"new_value"');
	       ^
            -stdin-:<main>:2:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": {"b": "value"}}', '{a, c}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": {"b": "value"}}', '{a, c}', '"new_value"', true);
</sql-statement>
<sql-statement>
select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"');
	       ^
            -stdin-:<main>:1:8: Error: Unable to find an overload for proc jsonb_insert with given argument types: (unknown,unknown,unknown)
            	select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"');
	       ^
<sql-statement>
select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"', true);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"', true);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot replace existing key
HINT:  Try using the function jsonb_set to replace key value.

        	select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"', true);
	^
<sql-statement>
-- jsonb subscript
select ('123'::jsonb)['a'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	-- jsonb subscript
	^
<sql-statement>
select ('123'::jsonb)[0];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('123'::jsonb)[0];
	^
<sql-statement>
select ('123'::jsonb)[NULL];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('123'::jsonb)[NULL];
	^
<sql-statement>
select ('{"a": 1}'::jsonb)['a'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1}'::jsonb)['a'];
	^
<sql-statement>
select ('{"a": 1}'::jsonb)[0];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1}'::jsonb)[0];
	^
<sql-statement>
select ('{"a": 1}'::jsonb)['not_exist'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1}'::jsonb)['not_exist'];
	^
<sql-statement>
select ('{"a": 1}'::jsonb)[NULL];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1}'::jsonb)[NULL];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)['a'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)['a'];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[0];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[0];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)['1'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)['1'];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[1.0];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[1.0];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[2];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[2];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[3];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[3];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[-2];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[-2];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[1]['a'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[1]['a'];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[1][0];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[1][0];
	^
<sql-statement>
select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['b'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['b'];
	^
<sql-statement>
select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['d'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['d'];
	^
<sql-statement>
select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['d'][1];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['d'][1];
	^
<sql-statement>
select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['d']['a'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": 1, "b": "c", "d": [1, 2, 3]}'::jsonb)['d']['a'];
	^
<sql-statement>
select ('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}'::jsonb)['a']['a1'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}'::jsonb)['a']['a1'];
	^
<sql-statement>
select ('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}'::jsonb)['a']['a1']['a2'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}'::jsonb)['a']['a1']['a2'];
	^
<sql-statement>
select ('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}'::jsonb)['a']['a1']['a2']['a3'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": {"a1": {"a2": "aaa"}}, "b": "bbb", "c": "ccc"}'::jsonb)['a']['a1']['a2']['a3'];
	^
<sql-statement>
select ('{"a": ["a1", {"b1": ["aaa", "bbb", "ccc"]}], "b": "bb"}'::jsonb)['a'][1]['b1'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": ["a1", {"b1": ["aaa", "bbb", "ccc"]}], "b": "bb"}'::jsonb)['a'][1]['b1'];
	^
<sql-statement>
select ('{"a": ["a1", {"b1": ["aaa", "bbb", "ccc"]}], "b": "bb"}'::jsonb)['a'][1]['b1'][2];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('{"a": ["a1", {"b1": ["aaa", "bbb", "ccc"]}], "b": "bb"}'::jsonb)['a'][1]['b1'][2];
	^
<sql-statement>
-- slices are not supported
select ('{"a": 1}'::jsonb)['a':'b'];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	-- slices are not supported
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[1:2];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[1:2];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[:2];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[:2];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[1:];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[1:];
	^
<sql-statement>
select ('[1, "2", null]'::jsonb)[:];
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:1: Error: alternative is not implemented yet : 360
    	select ('[1, "2", null]'::jsonb)[:];
	^
<sql-statement>
create TEMP TABLE test_jsonb_subscript (
       id int,
       test_json jsonb
);
</sql-statement>
<sql-statement>
insert into test_jsonb_subscript values
(1, '{}'), -- empty jsonb
(2, '{"key": "value"}'); -- jsonb with data
</sql-statement>
<sql-statement>
-- update empty jsonb
update test_jsonb_subscript set test_json['a'] = '1' where id = 1;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- update jsonb with some data
update test_jsonb_subscript set test_json['a'] = '1' where id = 2;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- replace jsonb
update test_jsonb_subscript set test_json['a'] = '"test"';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- replace by object
update test_jsonb_subscript set test_json['a'] = '{"b": 1}'::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- replace by array
update test_jsonb_subscript set test_json['a'] = '[1, 2, 3]'::jsonb;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- use jsonb subscription in where clause
select * from test_jsonb_subscript where test_json['key'] = '"value"';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:2:59: Error: alternative is not implemented yet : 360
    	select * from test_jsonb_subscript where test_json['key'] = '"value"';
	                                                          ^
<sql-statement>
select * from test_jsonb_subscript where test_json['key_doesnt_exists'] = '"value"';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:73: Error: alternative is not implemented yet : 360
    	select * from test_jsonb_subscript where test_json['key_doesnt_exists'] = '"value"';
	                                                                        ^
<sql-statement>
select * from test_jsonb_subscript where test_json['key'] = '"wrong_value"';
</sql-statement>
-stdin-:<main>: Error: Parse Sql

    -stdin-:<main>:1:59: Error: alternative is not implemented yet : 360
    	select * from test_jsonb_subscript where test_json['key'] = '"wrong_value"';
	                                                          ^
<sql-statement>
-- NULL
update test_jsonb_subscript set test_json[NULL] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['another_key'] = NULL;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- NULL as jsonb source
insert into test_jsonb_subscript values (3, NULL);
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a'] = '1' where id = 3;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json = NULL where id = 3;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json[0] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- Fill the gaps logic
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '[0]');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[5] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[-4] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[-8] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- keep consistent values position
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '[]');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[5] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- create the whole path
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a'][0]['b'][0]['c'] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a'][2]['b'][2]['c'][2] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- create the whole path with already existing keys
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{"b": 1}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a'][0] = '2';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- the start jsonb is an object, first subscript is treated as a key
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[0]['a'] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- the start jsonb is an array
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '[]');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[0]['a'] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json[2]['b'] = '2';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- overwriting an existing path
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a']['b'][1] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['a']['b'][10] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '[]');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[0][0][0] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json[0][0][1] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a']['b'][10] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['a'][10][10] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- an empty sub element
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{"a": {}}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a']['b']['c'][2] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{"a": []}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a'][1]['c'][2] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
select * from test_jsonb_subscript;
</sql-statement>
<sql-statement>
-- trying replace assuming a composite object, but it's an element or a value
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, '{"a": 1}');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json['a']['b'] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['a']['b']['c'] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['a'][0] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['a'][0]['c'] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json['a'][0][0] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
-- trying replace assuming a composite object, but it's a raw scalar
delete from test_jsonb_subscript;
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_delete' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
insert into test_jsonb_subscript values (1, 'null');
</sql-statement>
<sql-statement>
update test_jsonb_subscript set test_json[0] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
update test_jsonb_subscript set test_json[0][0] = '1';
</sql-statement>
-stdin-:<main>: Fatal: Pre type annotation

    -stdin-:<main>: Fatal: tools/enum_parser/enum_serialization_runtime/enum_runtime.cpp:70: Key 'pg_update' not found in enum NYql::EYtSettingType. Valid options are: 'initial', 'infer_scheme', 'force_infer_schema', 'do_not_fail_on_invalid_schema', 'direct_read', 'view', 'mode', 'scheme', 'weak_concat', 'anonymous', 'with_qb', 'inline', 'sample', 'joinLabel', 'ignore_non_existing', 'warn_non_existing', 'xlock', 'unordered', 'nonUnique', 'userschema', 'usercolumns', 'statcolumns', 'syscolumns', 'ignoretypev3', 'memUsage', 'itemsCount', 'rowFactor', 'ordered', 'keyFilter', 'keyFilter2', 'take', 'skip', 'limit', 'sortLimitBy', 'sortBy', 'reduceBy', 'reduceFilterBy', 'forceTransform', 'weakFields', 'sharded', 'combineChunks', 'jobCount', 'joinReduce', 'firstAsPrimary', 'flow', 'keepSorted', 'keySwitch', 'uniqueBy', 'opHash', 'mapOutputType', 'reduceInputType', 'noDq', 'split', 'compression_codec', 'erasure_codec', 'expiration', 'replication_factor', 'user_attrs', 'media', 'primary_medium', 'keep_meta', 'monotonic_keys', 'mutationid'. 
    
<sql-statement>
-- jsonb to tsvector
select to_tsvector('{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb to tsvector
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	-- jsonb to tsvector
	^
<sql-statement>
-- jsonb to tsvector with config
select to_tsvector('simple', '{"a": "aaa bbb ddd ccc", "b": ["eee fff ggg"], "c": {"d": "hhh iii"}}'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb to tsvector with config
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "simple" does not exist

        	-- jsonb to tsvector with config
	^
<sql-statement>
-- jsonb to tsvector with stop words
select to_tsvector('english', '{"a": "aaa in bbb ddd ccc", "b": ["the eee fff ggg"], "c": {"d": "hhh. iii"}}'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb to tsvector with stop words
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	-- jsonb to tsvector with stop words
	^
<sql-statement>
-- jsonb to tsvector with numeric values
select to_tsvector('english', '{"a": "aaa in bbb ddd ccc", "b": 123, "c": 456}'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb to tsvector with numeric values
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	-- jsonb to tsvector with numeric values
	^
<sql-statement>
-- jsonb_to_tsvector
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"all"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb_to_tsvector
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	-- jsonb_to_tsvector
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"key"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"key"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"key"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"string"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"string"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"string"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"numeric"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"numeric"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"numeric"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"boolean"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"boolean"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"boolean"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["string", "numeric"]');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["string", "numeric"]');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["string", "numeric"]');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"all"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"all"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"all"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"key"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"key"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"key"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"string"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"string"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"string"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"numeric"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"numeric"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"numeric"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"boolean"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"boolean"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '"boolean"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["string", "numeric"]');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["string", "numeric"]');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["string", "numeric"]');
	^
<sql-statement>
-- to_tsvector corner cases
select to_tsvector('""'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- to_tsvector corner cases
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	-- to_tsvector corner cases
	^
<sql-statement>
select to_tsvector('{}'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select to_tsvector('{}'::jsonb);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	select to_tsvector('{}'::jsonb);
	^
<sql-statement>
select to_tsvector('[]'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select to_tsvector('[]'::jsonb);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	select to_tsvector('[]'::jsonb);
	^
<sql-statement>
select to_tsvector('null'::jsonb);
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select to_tsvector('null'::jsonb);
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	select to_tsvector('null'::jsonb);
	^
<sql-statement>
-- jsonb_to_tsvector corner cases
select jsonb_to_tsvector('""'::jsonb, '"all"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	-- jsonb_to_tsvector corner cases
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	-- jsonb_to_tsvector corner cases
	^
<sql-statement>
select jsonb_to_tsvector('{}'::jsonb, '"all"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('{}'::jsonb, '"all"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	select jsonb_to_tsvector('{}'::jsonb, '"all"');
	^
<sql-statement>
select jsonb_to_tsvector('[]'::jsonb, '"all"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('[]'::jsonb, '"all"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	select jsonb_to_tsvector('[]'::jsonb, '"all"');
	^
<sql-statement>
select jsonb_to_tsvector('null'::jsonb, '"all"');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('null'::jsonb, '"all"');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration isn't set

        	select jsonb_to_tsvector('null'::jsonb, '"all"');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '""');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '""');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '""');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '{}');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '{}');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '{}');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '[]');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '[]');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '[]');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, 'null');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, 'null');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, 'null');
	^
<sql-statement>
select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["all", null]');
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["all", null]');
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  text search configuration "english" does not exist

        	select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["all", null]');
	^
<sql-statement>
-- ts_headline for jsonb
select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- ts_headline for jsonb
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	       ^
            -stdin-:<main>:2:122: Error: At function: PgCall
            	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	                                                                                                                         ^
                -stdin-:<main>:2:122: Error: No such proc: tsquery
                	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	                                                                                                                         ^
<sql-statement>
select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	       ^
            -stdin-:<main>:1:114: Error: At function: PgCall
            	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	                                                                                                                 ^
                -stdin-:<main>:1:114: Error: No such proc: tsquery
                	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
	                                                                                                                 ^
<sql-statement>
select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	       ^
            -stdin-:<main>:1:122: Error: At function: PgCall
            	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	                                                                                                                         ^
                -stdin-:<main>:1:122: Error: No such proc: tsquery
                	select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	                                                                                                                         ^
<sql-statement>
select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	       ^
            -stdin-:<main>:1:133: Error: At function: PgCall
            	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	                                                                                                                                    ^
                -stdin-:<main>:1:133: Error: No such proc: tsquery
                	select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
	                                                                                                                                    ^
<sql-statement>
-- corner cases for ts_headline with jsonb
select ts_headline('null'::jsonb, tsquery('aaa & bbb'));
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	-- corner cases for ts_headline with jsonb
	^
        -stdin-:<main>:2:8: Error: At function: PgCall
        	select ts_headline('null'::jsonb, tsquery('aaa & bbb'));
	       ^
            -stdin-:<main>:2:35: Error: At function: PgCall
            	select ts_headline('null'::jsonb, tsquery('aaa & bbb'));
	                                  ^
                -stdin-:<main>:2:35: Error: No such proc: tsquery
                	select ts_headline('null'::jsonb, tsquery('aaa & bbb'));
	                                  ^
<sql-statement>
select ts_headline('{}'::jsonb, tsquery('aaa & bbb'));
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select ts_headline('{}'::jsonb, tsquery('aaa & bbb'));
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select ts_headline('{}'::jsonb, tsquery('aaa & bbb'));
	       ^
            -stdin-:<main>:1:33: Error: At function: PgCall
            	select ts_headline('{}'::jsonb, tsquery('aaa & bbb'));
	                                ^
                -stdin-:<main>:1:33: Error: No such proc: tsquery
                	select ts_headline('{}'::jsonb, tsquery('aaa & bbb'));
	                                ^
<sql-statement>
select ts_headline('[]'::jsonb, tsquery('aaa & bbb'));
</sql-statement>
-stdin-:<main>: Error: Type annotation

    -stdin-:<main>:1:1: Error: At function: RemovePrefixMembers, At function: PgSelect, At function: PgSetItem, At function: PgResultItem
    	select ts_headline('[]'::jsonb, tsquery('aaa & bbb'));
	^
        -stdin-:<main>:1:8: Error: At function: PgCall
        	select ts_headline('[]'::jsonb, tsquery('aaa & bbb'));
	       ^
            -stdin-:<main>:1:33: Error: At function: PgCall
            	select ts_headline('[]'::jsonb, tsquery('aaa & bbb'));
	                                ^
                -stdin-:<main>:1:33: Error: No such proc: tsquery
                	select ts_headline('[]'::jsonb, tsquery('aaa & bbb'));
	                                ^
<sql-statement>
-- casts
select 'true'::jsonb::bool;
</sql-statement>
<sql-statement>
select '[]'::jsonb::bool;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '[]'::jsonb::bool;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot cast jsonb array to type boolean

        	select '[]'::jsonb::bool;
	^
<sql-statement>
select '1.0'::jsonb::float;
</sql-statement>
<sql-statement>
select '[1.0]'::jsonb::float;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '[1.0]'::jsonb::float;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot cast jsonb array to type double precision

        	select '[1.0]'::jsonb::float;
	^
<sql-statement>
select '12345'::jsonb::int4;
</sql-statement>
<sql-statement>
select '"hello"'::jsonb::int4;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '"hello"'::jsonb::int4;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot cast jsonb string to type integer

        	select '"hello"'::jsonb::int4;
	^
<sql-statement>
select '12345'::jsonb::numeric;
</sql-statement>
<sql-statement>
select '{}'::jsonb::numeric;
</sql-statement>
-stdin-:<main>: Fatal: Execution

    -stdin-:<main>:1:1: Fatal: Execution of node: Result
    	select '{}'::jsonb::numeric;
	^
        -stdin-:<main>:1:1: Fatal: ERROR:  cannot cast jsonb object to type numeric

        	select '{}'::jsonb::numeric;
	^
<sql-statement>
select '12345.05'::jsonb::numeric;
</sql-statement>
<sql-statement>
select '12345.05'::jsonb::float4;
</sql-statement>
<sql-statement>
select '12345.05'::jsonb::float8;
</sql-statement>
<sql-statement>
select '12345.05'::jsonb::int2;
</sql-statement>
<sql-statement>
select '12345.05'::jsonb::int4;
</sql-statement>
<sql-statement>
select '12345.05'::jsonb::int8;
</sql-statement>
<sql-statement>
select '12345.0000000000000000000000000000000000000000000005'::jsonb::numeric;
</sql-statement>
<sql-statement>
select '12345.0000000000000000000000000000000000000000000005'::jsonb::float4;
</sql-statement>
<sql-statement>
select '12345.0000000000000000000000000000000000000000000005'::jsonb::float8;
</sql-statement>
<sql-statement>
select '12345.0000000000000000000000000000000000000000000005'::jsonb::int2;
</sql-statement>
<sql-statement>
select '12345.0000000000000000000000000000000000000000000005'::jsonb::int4;
</sql-statement>
<sql-statement>
select '12345.0000000000000000000000000000000000000000000005'::jsonb::int8;
</sql-statement>
