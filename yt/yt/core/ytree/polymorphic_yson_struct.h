#pragma once

#include "yson_struct.h"

namespace NYT::NYTree {

////////////////////////////////////////////////////////////////////////////////

//! Code for mapping generation.
namespace NDetail {

template <class T, class... TArgs>
constexpr bool DifferentFrom = (!std::same_as<T, TArgs> && ...);

template <class TTuple>
struct TAllDifferentImpl;

template <>
struct TAllDifferentImpl<std::tuple<>>
{
    static constexpr bool Value = true;
};

template <class TCurrent, class... TSuffix>
struct TAllDifferentImpl<std::tuple<TCurrent, TSuffix...>>
{
    static constexpr bool Value =
        DifferentFrom<TCurrent, TSuffix...> &&
        TAllDifferentImpl<std::tuple<TSuffix...>>::Value;
};

template <class... TArgs>
constexpr bool AllDifferent = TAllDifferentImpl<std::tuple<TArgs...>>::Value;

template <class TBase, class... TArgs>
constexpr bool AllDerived = (std::derived_from<TArgs, TBase> && ...);

template <class TBase, class... TArgs>
constexpr bool CHierarchy =
    AllDerived<TBase, TArgs...> &&
    AllDifferent<TBase, TArgs...>;

////////////////////////////////////////////////////////////////////////////////

template <CYsonStructDerived TBase>
using TInstanceFactoryLeaf =
    TIntrusivePtr<TBase>(*)();

template <class TEnum, CYsonStructDerived TBase>
using TInstanceFactory = TEnumIndexedArray<TEnum, TInstanceFactoryLeaf<TBase>>;

template <class TEnum>
    requires TEnumTraits<TEnum>::IsEnum
struct TEnumTraitsExt
{
    using TTraits = TEnumTraits<TEnum>;

    template <class TBase, class... TDerived>
    static constexpr bool CompatibleHierarchy =
        CHierarchy<TBase, TDerived...> &&
        (TTraits::GetDomainSize() == sizeof...(TDerived) + 1);

    template <class TBase, class TDerived>
    static TIntrusivePtr<TBase> ConcreteFactory();

    template <class TBase, class... TDerived>
    static TInstanceFactory<TEnum, TBase> MakeFactory();
};

////////////////////////////////////////////////////////////////////////////////

template <class TEnum, class TB, class... TD>
struct TPolymorphicEnumMapping
{
    using TKey = TEnum;
    using TBase = TB;
    using TDerived = std::tuple<TD...>;
    using THierarchy = std::tuple<TB, TD...>;

    static TIntrusivePtr<TB> MakeInstance(TEnum e);
};

template <class T>
constexpr bool IsMapping = requires (T t) {
    [] <class E, class B, class... D> (TPolymorphicEnumMapping<E, B, D...>) {
    } (t);
};

////////////////////////////////////////////////////////////////////////////////

} // namespace NDetail

////////////////////////////////////////////////////////////////////////////////

template <class TBase, class... TDerived>
concept CHierarchy = NDetail::CHierarchy<TBase, TDerived...>;

template <class TEnum, CYsonStructDerived TBase, class... TDerived>
    requires CHierarchy<TBase, TDerived...>
using TPolymorphicEnumMapping = NDetail::TPolymorphicEnumMapping<TEnum, TBase, TDerived...>;

template <class T>
concept CPolymorphicEnumMapping = NDetail::IsMapping<T>;

////////////////////////////////////////////////////////////////////////////////

//! Wrapper class which allows automatic (de-)serialization
//! of polymorphic types. Without it, one would have
//! to keep type serialized (e.g. in INodePtr form)
//! manually add some type marker like enum inside
//! the base object layout and then do some switches
//! over enum to properly deserialize the struct.
//! TPolymorphicYsonStruct does so almost automatically.
//! "Almost" because it still requires you to define some
//! enum marker and manually describe the hierarchy during
//! the type declaration. For most of the cases one can
//! use DEFINE_POLYMORPHIC_YSON_STRUCT to do that with
//! minimal effort. Yson layout expected/generated by this struct:
/*
    "type"   = "derived2";
    "field1" = ...;
    "field2" = ...;
*/
// NB(arkady-e1ppa): Word "type" is reserved
// and must not be used as a field name of any
// class in the hierarchy.
// TODO(arkady-e1ppa): Add customisation for reserved name.
// Would require constexpr strings and thus certain limitations.
template <CPolymorphicEnumMapping TMapping>
class TPolymorphicYsonStruct
{
    // TODO(arkady-e1ppa): Support non refcounted hierarchies
    // e.g. shared_ptr<TYsonStructLite> or shared_ptr<TExternalizedYsonStruct>.
    // TODO(arkady-e1ppa): Support lookup by enum instead of concrete type.
    // would probably need enum->Type static mapping which can be done
    // with some enum indexed tuple (But one has to implement it first)
    // TODO(arkady-e1ppa): Support ctor from anyone from the
    // hierarchy.
    using TKey = typename TMapping::TKey;
    using TBase = typename TMapping::TBase;

public:
    using TImplementsYsonStructField = void;

    TPolymorphicYsonStruct() = default;

    TPolymorphicYsonStruct(TKey key, TIntrusivePtr<TBase> ptr) noexcept;

    template <CYsonStructSource TSource>
    void Load(
        TSource source,
        bool postprocess = true,
        bool setDefaults = true,
        const NYPath::TYPath& path = {},
        std::optional<EUnrecognizedStrategy> recursiveUnrecognizedStrategy = {});

    void Save(NYson::IYsonConsumer* consumer) const;

    //! Empty if empty or the type is wrong.
    template <std::derived_from<TBase> TConcrete>
    TIntrusivePtr<TConcrete> TryGetConcrete() const;

    TKey GetCurrentType() const;

private:
    TIntrusivePtr<TBase> Storage_;
    TKey HeldType_;

    void PrepareInstance(INodePtr& node);
};

////////////////////////////////////////////////////////////////////////////////

template <CPolymorphicEnumMapping TMapping>
void Serialize(const TPolymorphicYsonStruct<TMapping>& value, NYson::IYsonConsumer* consumer);

template <CPolymorphicEnumMapping TMapping, CYsonStructSource TSource>
void Deserialize(TPolymorphicYsonStruct<TMapping>& value, TSource source);

////////////////////////////////////////////////////////////////////////////////

//! Usage:
/*
    DEFINE_POLYMORPHIC_YSON_STRUCT(Struct,
        ((Base)     (TBaseStruct))
        ((Derived1) (TDerivedStruct1))
        ((Derived2) (TDerivedStruct2))
    );
    .....TypeName.....ActualTypeName

    Macro generates two names:
    1) TStruct -- polymorphic struct which can be
    serialized.
    2) EStructType -- enum which holds short names for
    hierarchy members. They are keys in serialization.
*/
#define DEFINE_POLYMORPHIC_YSON_STRUCT(name, seq)

////////////////////////////////////////////////////////////////////////////////

} // namespace NYT::NYTree

#define POLYMORPHIC_YSON_STRUCT_INL_H_
#include "polymorphic_yson_struct-inl.h"
#undef POLYMORPHIC_YSON_STRUCT_INL_H_
