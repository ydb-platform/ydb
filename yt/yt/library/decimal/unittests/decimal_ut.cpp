#include <yt/yt/core/test_framework/framework.h>

#include <yt/yt/library/decimal/decimal.h>

#include <util/string/hex.h>

namespace NYT::NDecimal {
namespace {

////////////////////////////////////////////////////////////////////////////////

TString RoundConvertText(TStringBuf textValue, int precision, int scale)
{
    auto binary = TDecimal::TextToBinary(textValue, precision, scale);
    return TDecimal::BinaryToText(binary, precision, scale);
}

#define CHECK_ROUND_CONVERSION(text, precision, scale) \
    do { \
        EXPECT_EQ(text, RoundConvertText(text, precision, scale)); \
    } while (0)

////////////////////////////////////////////////////////////////////////////////

TEST(TDecimal, TestTextBinaryConversion)
{
#define TEST_TEXT_BINARY_CONVERSION(precision, scale, text, binary) \
    do {                                                                 \
        EXPECT_EQ(binary, HexEncode(TDecimal::TextToBinary(text, precision, scale))); \
        EXPECT_EQ(text, TDecimal::BinaryToText(HexDecode(binary), precision, scale)); \
    } while (0)

    TEST_TEXT_BINARY_CONVERSION(3, 2, "3.14", "8000013A");
    TEST_TEXT_BINARY_CONVERSION(10, 2, "3.14", "80000000" "0000013A");
    TEST_TEXT_BINARY_CONVERSION(35, 2, "3.14", "80000000" "00000000" "00000000" "0000013A");

    TEST_TEXT_BINARY_CONVERSION(10, 9, "-2.718281828",  "7FFFFFFF" "5DFA4F9C");
    TEST_TEXT_BINARY_CONVERSION(35, 9, "-2.718281828", "7FFFFFFF" "FFFFFFFF" "FFFFFFFF" "5DFA4F9C");

    TEST_TEXT_BINARY_CONVERSION(3, 2, "nan", "FFFFFFFF");
    TEST_TEXT_BINARY_CONVERSION(3, 2, "inf", "FFFFFFFE");
    TEST_TEXT_BINARY_CONVERSION(3, 2, "-inf", "00000002");
    EXPECT_EQ("FFFFFFFE", HexEncode(TDecimal::TextToBinary("+inf", 3, 2)));

    TEST_TEXT_BINARY_CONVERSION(10, 2,"nan", "FFFFFFFF" "FFFFFFFF");
    TEST_TEXT_BINARY_CONVERSION(10, 2,"inf", "FFFFFFFF" "FFFFFFFE");
    TEST_TEXT_BINARY_CONVERSION(10, 2,"-inf", "00000000" "00000002");
    EXPECT_EQ("FFFFFFFF" "FFFFFFFE", HexEncode(TDecimal::TextToBinary("+inf", 10, 2)));

    TEST_TEXT_BINARY_CONVERSION(35, 2,"nan", "FFFFFFFF" "FFFFFFFF" "FFFFFFFF" "FFFFFFFF");
    TEST_TEXT_BINARY_CONVERSION(35, 2,"inf", "FFFFFFFF" "FFFFFFFF" "FFFFFFFF" "FFFFFFFE");
    TEST_TEXT_BINARY_CONVERSION(35, 2,"-inf", "00000000" "00000000" "00000000" "00000002");
    EXPECT_EQ("FFFFFFFF" "FFFFFFFF" "FFFFFFFF" "FFFFFFFE", HexEncode(TDecimal::TextToBinary("+inf", 35, 2)));

    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("-nan", 3, 2), "is not valid Decimal");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("infinity", 3, 2), "is not valid Decimal");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("-infinity", 3, 2), "is not valid Decimal");

    // Few test cases with big numbers generated by python snippet:
    //    import random
    //    def print_test_case(plus):
    //        textval = "".join(random.choice("0123456789") for _ in range(35))
    //        if not plus:
    //            textval = "-" + textval
    //        binval = hex(2 ** 127 + int(textval))
    //        binval = binval[2:].strip('L')  # strip 0x and final 'L'
    //        binval = binval.upper()
    //        print(
    //            "TEST_TEXT_BINARY_CONVERSION(\n"
    //            "   35, 0,\n"
    //            "   \"{text}\",\n"
    //            "   \"{binary}\");\n"
    //            .format(text=textval, binary=binval)
    //        )
    //    random.seed(42)
    //    print_test_case(False)
    //    print_test_case(False)
    //    print_test_case(True)
    //    print_test_case(True)

    TEST_TEXT_BINARY_CONVERSION(
        35, 0,
        "-60227680402501652580863193008687593",
        "7FF4668BCCE002BD685B3A3811CE3617");

    TEST_TEXT_BINARY_CONVERSION(
        35, 0,
        "-58685702202126332296617139656872032",
        "7FF4B2924D28572FF19525515205AFA0");

    TEST_TEXT_BINARY_CONVERSION(
        35, 0,
        "29836394225258329500167403959807652",
        "8005BF0C3D439F6FFD649D99A704EEA4");

    TEST_TEXT_BINARY_CONVERSION(
        35, 0,
        "61449825198266175750309883089040771",
        "800BD5B5D5F0C73E0C9CD4943298B583");

#undef TEST_TEXT_BINARY_CONVERSION

}

TEST(TDecimal, TestPrecisionScaleLimits)
{
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("0", -1, 0), "Invalid decimal precision");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("0", 0, 0), "Invalid decimal precision");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("0", TDecimal::MaxPrecision + 1, 0), "Invalid decimal precision");

    EXPECT_THROW_WITH_SUBSTRING(TDecimal::BinaryToText("0", -1, 0), "Invalid decimal precision");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::BinaryToText("0", 0, 0), "Invalid decimal precision");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::BinaryToText("0", TDecimal::MaxPrecision + 1, 0), "Invalid decimal precision");

    CHECK_ROUND_CONVERSION("0", 1, 0);
    CHECK_ROUND_CONVERSION("0", TDecimal::MaxPrecision, 0);


    CHECK_ROUND_CONVERSION("-3.14", 3, 2);
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::BinaryToText("0000", 3, 4), "Invalid decimal scale");

    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("3.1415", 10, 3), "too many digits after decimal point");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("-3.1415", 10, 3), "too many digits after decimal point");
    EXPECT_EQ("3.140", RoundConvertText("3.14", 10, 3));
    EXPECT_EQ("-3.140", RoundConvertText("-3.14", 10, 3));

    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("314.15", 5, 3), "too many digits before decimal point");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary("-314.15", 5, 3), "too many digits before decimal point");

    // Sometimes we want to print values that are not representable with given precision
    // (e.g. in error messages we sometimes want to print text value of invalid decimal to explain that it has
    // more digits than allowed by precision).
    //
    // Here we test that extreme values are printed ok.
    auto maxBinaryDecimal = HexDecode("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD");
    auto minBinaryDecimal1 = HexDecode("00000000000000000000000000000000");
    auto minBinaryDecimal2 = HexDecode("00000000000000000000000000000003");
    EXPECT_EQ(TDecimal::MaxBinarySize, std::ssize(maxBinaryDecimal));   // If max TDecimal::MaxBinarySize ever increases
    EXPECT_EQ(TDecimal::MaxBinarySize, std::ssize(minBinaryDecimal1));  // please update this test
    EXPECT_EQ(TDecimal::MaxBinarySize, std::ssize(minBinaryDecimal2));  // with better values.
    EXPECT_EQ("1701411834604692317316873037158841057.25", TDecimal::BinaryToText(maxBinaryDecimal, TDecimal::MaxPrecision, 2));
    EXPECT_EQ("-1701411834604692317316873037158841057.28", TDecimal::BinaryToText(minBinaryDecimal1, TDecimal::MaxPrecision, 2));
    EXPECT_EQ("-1701411834604692317316873037158841057.25", TDecimal::BinaryToText(minBinaryDecimal2, TDecimal::MaxPrecision, 2));
}

TEST(TDecimal, TestValidation)
{
    EXPECT_NO_THROW(TDecimal::ValidateBinaryValue(HexDecode("8000013A"), 3, 2));
    EXPECT_NO_THROW(TDecimal::ValidateBinaryValue(HexDecode("80000000" "0000013A"), 10, 2));
    EXPECT_NO_THROW(TDecimal::ValidateBinaryValue(HexDecode("80000000" "00000000" "00000000" "0000013A"), 35, 2));
}

class TDecimalWithPrecisionTest
    : public ::testing::Test
    , public ::testing::WithParamInterface<int>
{
public:
    static std::vector<int> GetAllPossiblePrecisions()
    {
        std::vector<int> result;
        for (int i = 1; i <= TDecimal::MaxPrecision; ++i) {
            result.push_back(i);
        }

        YT_VERIFY(result.back() == TDecimal::MaxPrecision);
        return result;
    }

    static TString GetTextNines(int precision)
    {
        return TString(precision, '9');
    }

    static TString GetTextMinusNines(int precision)
    {
        return "-" + GetTextNines(precision);
    }

    static TString GetTextZillion(int precision)
    {
        return "1" + TString(precision, '0');
    }

    static TString GetTextMinusZillion(int precision)
    {
        return "-" + GetTextZillion(precision);
    }
};

INSTANTIATE_TEST_SUITE_P(
    Precisions,
    TDecimalWithPrecisionTest,
    ::testing::ValuesIn(TDecimalWithPrecisionTest::GetAllPossiblePrecisions())
);

TEST_P(TDecimalWithPrecisionTest, TestTextLimits)
{
    auto precision = GetParam();

    CHECK_ROUND_CONVERSION("0", precision, 0);
    CHECK_ROUND_CONVERSION("1", precision, 0);
    CHECK_ROUND_CONVERSION("-1", precision, 0);
    CHECK_ROUND_CONVERSION("2", precision, 0);
    CHECK_ROUND_CONVERSION("-2", precision, 0);
    CHECK_ROUND_CONVERSION("3", precision, 0);
    CHECK_ROUND_CONVERSION("-3", precision, 0);
    CHECK_ROUND_CONVERSION("4", precision, 0);
    CHECK_ROUND_CONVERSION("-4", precision, 0);
    CHECK_ROUND_CONVERSION("5", precision, 0);
    CHECK_ROUND_CONVERSION("-5", precision, 0);
    CHECK_ROUND_CONVERSION("6", precision, 0);
    CHECK_ROUND_CONVERSION("-6", precision, 0);
    CHECK_ROUND_CONVERSION("7", precision, 0);
    CHECK_ROUND_CONVERSION("-7", precision, 0);
    CHECK_ROUND_CONVERSION("8", precision, 0);
    CHECK_ROUND_CONVERSION("-8", precision, 0);
    CHECK_ROUND_CONVERSION("9", precision, 0);
    CHECK_ROUND_CONVERSION("-9", precision, 0);
    CHECK_ROUND_CONVERSION("inf", precision, 0);
    CHECK_ROUND_CONVERSION("-inf", precision, 0);
    CHECK_ROUND_CONVERSION("nan", precision, 0);

    CHECK_ROUND_CONVERSION(GetTextNines(precision), precision, 0);
    CHECK_ROUND_CONVERSION(GetTextMinusNines(precision), precision, 0);

    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary(GetTextZillion(precision), precision, 0),
        "too many digits before decimal point");
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::TextToBinary(GetTextMinusZillion(precision), precision, 0),
        "too many digits before decimal point");
}

TEST_P(TDecimalWithPrecisionTest, TestBinaryValidation)
{
    auto precision = GetParam();

#define TO_BINARY_THEN_VALIDATE(text, precision, scale) \
    do {                                                \
        auto binaryValue = TDecimal::TextToBinary(text, precision, scale); \
        EXPECT_NO_THROW(TDecimal::ValidateBinaryValue(binaryValue, precision, scale)); \
    } while (0)

    TO_BINARY_THEN_VALIDATE("0", precision, 0);
    TO_BINARY_THEN_VALIDATE("1", precision, 0);
    TO_BINARY_THEN_VALIDATE("-1", precision, 0);
    TO_BINARY_THEN_VALIDATE("2", precision, 0);
    TO_BINARY_THEN_VALIDATE("-2", precision, 0);
    TO_BINARY_THEN_VALIDATE("3", precision, 0);
    TO_BINARY_THEN_VALIDATE("-3", precision, 0);
    TO_BINARY_THEN_VALIDATE("4", precision, 0);
    TO_BINARY_THEN_VALIDATE("-4", precision, 0);
    TO_BINARY_THEN_VALIDATE("5", precision, 0);
    TO_BINARY_THEN_VALIDATE("-5", precision, 0);
    TO_BINARY_THEN_VALIDATE("6", precision, 0);
    TO_BINARY_THEN_VALIDATE("-6", precision, 0);
    TO_BINARY_THEN_VALIDATE("7", precision, 0);
    TO_BINARY_THEN_VALIDATE("-7", precision, 0);
    TO_BINARY_THEN_VALIDATE("8", precision, 0);
    TO_BINARY_THEN_VALIDATE("-8", precision, 0);
    TO_BINARY_THEN_VALIDATE("9", precision, 0);
    TO_BINARY_THEN_VALIDATE("-9", precision, 0);
    TO_BINARY_THEN_VALIDATE("inf", precision, 0);
    TO_BINARY_THEN_VALIDATE("-inf", precision, 0);
    TO_BINARY_THEN_VALIDATE("nan", precision, 0);

#undef TO_BINARY_THEN_VALIDATE

    auto binaryValueIncrement = [] (void* buffer, int size) {
        auto cur = static_cast<ui8*>(buffer) + size -1;
        for (; cur >= buffer; --cur) {
            if (++(*cur) != 0) {
                break;
            }
        }
    };

    auto binaryValueDecrement = [] (void* buffer, int size) {
        auto cur = static_cast<ui8*>(buffer) + size -1;
        for (; cur >= buffer; --cur) {
            if ((*cur)-- != 0) {
                break;
            }
        }
    };

    TStringBuf binValue;
    char binBuffer[TDecimal::MaxBinarySize];
    // Check 99..9
    binValue = TDecimal::TextToBinary(GetTextNines(precision), precision, 0, binBuffer, sizeof(binBuffer));
    EXPECT_NO_THROW(TDecimal::ValidateBinaryValue(binValue, precision, 0));
    // Check 100..0
    binaryValueIncrement(binBuffer, binValue.size());
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::ValidateBinaryValue(binValue, precision, 0), "does not have enough precision to represent");

    // Check -99..9
    binValue = TDecimal::TextToBinary(GetTextMinusNines(precision), precision, 0, binBuffer, sizeof(binBuffer));
    EXPECT_NO_THROW(TDecimal::ValidateBinaryValue(binValue, precision, 0));
    // Check -100..0
    binaryValueDecrement(binBuffer, binValue.size());
    EXPECT_THROW_WITH_SUBSTRING(TDecimal::ValidateBinaryValue(binValue, precision, 0), "does not have enough precision to represent");
}

////////////////////////////////////////////////////////////////////////////////

} // namespace
} // namespace NYT::NDecimal
