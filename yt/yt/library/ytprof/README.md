# ytprof

Библиотека YTProf реализует набор семплирующих профайлеров совместимых с инструментом визуализации [pprof](https://github.com/google/pprof/blob/master/doc/README.md).

Профайлер линкуется в исполняемый файл и запускает HTTP сервер на дебажном порту. HTTP вызовы отдают результат профилирования в формате pprof (сжатый gzip протобуф из [profiler.proto](https://a.yandex-team.ru/arc/trunk/arcadia/yt/yt/library/ytprof/profile.proto)).

Файл с профилем является self contained, содержит внутри себя всю информацию о символах и номерах строк и не требует оригинального бинаря для просмотра.

Для удобного просмотра исходного кода, нужно запускать pprof из корня аркадии с опцией `-trim_path='/-S/:/-B/'`.

## Quick Start

Работа с профайлером, на примере [example/main.cpp](https://a.yandex-team.ru/arc/trunk/arcadia/yt/yt/library/ytprof/example/main.cpp)

(*) Если `ya` запускается через враппер `/usr/local/bin/ya`, то в `ya tool pprof` не работает интерактивный режим. Лучше удалить `/usr/local/bin/ya` со своей машины и использовать другой способ запуска.

```
# Все команды выполняются из корня аркадии

# Собираем пример
ya make --build=profile yt/yt/library/ytprof/example

# Запускаем пример в соседнем терминале на порту 10003
./yt/yt/library/ytprof/example/example 10003

# Смотрим потребление памяти
ya tool pprof -symbolize=none http://localhost:10003/heap
Fetching profile over HTTP from http://localhost:10003/heap
Saved profile in /home/prime/pprof/pprof.example.allocations.space.002.pb.gz
File: example
generated by ytprof 0.2
Type: space
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) list main
Total: 64.80MB
ROUTINE ======================== main in /home/prime/arc/yt/yt/library/ytprof/example/main.cpp
         0    62.38MB (flat, cum) 96.25% of Total
         .          .     30:        Register(server, "");
         .          .     31:        server->Start();
         .          .     32:
         .          .     33:        THashMap<TString, std::vector<int>> data;
         .          .     34:        for (int i = 0; i < 1024 * 16; i++) {
         .    62.38MB     35:            data[ToString(i)].resize(1024);
         .          .     36:        }
         .          .     37:
         .          .     38:        ui64 value = 0;
         .          .     39:        while (true) {
         .          .     40:            THash<TString> hasher;

# Смотрим потребление CPU в течении 15 секунд
ya tool pprof -symbolize=none 'http://localhost:10003/profile?d=15'
Fetching profile over HTTP from http://localhost:10003/profile?d=15
Saved profile in /home/prime/pprof/pprof.example.sample.profile.004.pb.gz
File: example
generated by ytprof 0.2
arc_revision=8788163
build_type=profile
Type: cpu
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top
Showing nodes accounting for 11840ms, 78.83% of 15020ms total
Dropped 45 nodes (cum <= 75.10ms)
Showing top 10 nodes out of 53
      flat  flat%   sum%        cum   cum%
    5250ms 34.95% 34.95%     5250ms 34.95%  (anonymous namespace)::TBasicIntFormatter::Format
    2610ms 17.38% 52.33%     3760ms 25.03%  CityHash64
    1000ms  6.66% 58.99%     1000ms  6.66%  ReadUnaligned (inline)
     980ms  6.52% 65.51%      980ms  6.52%  memcpyU256
     530ms  3.53% 69.04%      530ms  3.53%  (anonymous namespace)::TIntFormatter::Format
     360ms  2.40% 71.44%      360ms  2.40%  TcmallocSlab_Internal_Pop_trampoline_2
     330ms  2.20% 73.64%      330ms  2.20%  TcmallocSlab_Internal_Push_trampoline_7
     280ms  1.86% 75.50%      280ms  1.86%  std::__y1::basic_string::__is_long
     260ms  1.73% 77.23%     4020ms 26.76%  NHashPrivate::ComputeStringHash
     240ms  1.60% 78.83%      240ms  1.60%  tcmalloc::tcmalloc_internal::PageMap2::sizeclass
(pprof) list main
Total: 15.02s
ROUTINE ======================== main in /home/prime/arc/yt/yt/library/ytprof/example/main.cpp
     150ms     13.99s (flat, cum) 93.14% of Total
         .          .      1:#include <yt/yt/core/concurrency/poller.h>
         .          .      2:#include <yt/yt/core/concurrency/thread_pool_poller.h>
         .          .      3:#include <yt/yt/core/concurrency/action_queue.h>
         .          .      4:#include <yt/yt/core/http/server.h>
         .          .      5:
         .          .      6:#include <yt/yt/library/ytprof/http/handler.h>
         .          .      7:#include <yt/yt/library/ytprof/heap_profiler.h>
         .          .      8:
         .          .      9:#include <absl/debugging/stacktrace.h>
         .          .     10:
         .          .     11:using namespace NYT;
         .          .     12:using namespace NYT::NHttp;
         .          .     13:using namespace NYT::NConcurrency;
         .          .     14:using namespace NYT::NYTProf;
         .          .     15:
         .          .     16:int main(int argc, char* argv[])
         .          .     17:{
         .          .     18:    absl::SetStackUnwinder(AbslStackUnwinder);
         .          .     19:    tcmalloc::MallocExtension::SetProfileSamplingRate(2_MB);
         .          .     20:
         .          .     21:    try {
         .          .     22:        if (argc != 2 && argc != 3) {
         .          .     23:            throw yexception() << "usage: " << argv[0] << " PORT";
         .          .     24:        }
         .          .     25:
         .          .     26:        auto port = FromString<int>(argv[1]);
         .          .     27:        auto poller = CreateThreadPoolPoller(1, "Example");
         .          .     28:        auto server = CreateServer(port, poller);
         .          .     29:
         .          .     30:        Register(server, "");
         .          .     31:        server->Start();
         .          .     32:
         .          .     33:        THashMap<TString, std::vector<int>> data;
         .          .     34:        for (int i = 0; i < 1024 * 16; i++) {
         .          .     35:            data[ToString(i)].resize(1024);
         .          .     36:        }
         .          .     37:
         .          .     38:        ui64 value = 0;
         .          .     39:        while (true) {
         .          .     40:            THash<TString> hasher;
         .          .     41:            for (int i = 0; i < 10000000; i++) {
         .     13.75s     42:                value += hasher(ToString(i));
         .          .     43:            }
         .          .     44:
         .          .     45:            std::vector<TString> data;
         .          .     46:            for (int i = 0; i < 10000; i++) {
         .       80ms     47:                data.push_back(TString(1024, 'x'));
         .          .     48:            }
         .          .     49:
         .          .     50:            if (value == 1) {
         .          .     51:                Sleep(TDuration::Seconds(1));
         .          .     52:            }
         .       10ms     53:        }
         .          .     54:    } catch (const std::exception& ex) {
         .          .     55:        Cerr << ex.what() << Endl;
         .          .     56:        _exit(1);
         .          .     57:    }
         .          .     58:
```

## CPU профайлер

CPU профайлер реализован на основе сигнала SIGPROF. В выключенном состоянии
профайлер никак не влияет на работу программы. В включенном состоянии ядро
начинает посылать сигналы всем тредам процесса. Обработчик сигнала собирает текущий стек и пушит его в lock free очередь.

Для работы CPU профайлера нужно чтобы исполняемый файл был собран с опцией `--build=profile`. Добавление этой опции может замедлить исполнение на программы на несколько процентов, поэтому рекомендуется совмещать `--build=profile` с флагом `--thinlto`. Такая конфигурация должна работать на пару процентов быстрее, чем обычный `--build=release`.

### CPU теги

YTProf поддерживает теги. Теги позволяют фильтровать профиль в pprof с помощью команды
`tagfocus`. Например, можно положить в тег id эксперимента или имя текущего пользователя.

`TCpuProfilerTagGuard` кладёт тег в TLS треда. Также есть возможность положить тег в `TTraceContext` запроса, чтобы он автоматически пробрасывался сквозь асинхронный код YT файберов.

### Тяжелые actions

Профайлер умеет тегировать семплы временем исполнения в YT тред пуле. Это позволяет находить код, который надолго заблокировал какой-то тред.

- Можно включить теги, чтобы фильтровать в pprof `/profile?record_action_run_time=1`.
- Можно сразу отфильтровать только семплы из долгих экшенов `/profile?action_min_exec_time=1s`

```
# После этого, можно отфильтровать семплы командой tagfocus.
(pprof) tagfocus=action_run_time_us=1000000:
# И посмотреть список семплов.
(pprof) traces
```

## Memory Profiler

Для работы memory профайлера нужна поддержка в аллокаторе. На текущий момент, такая
поддержка есть только в tcmalloc.

Чтобы включить memory profiler, нужно:

  1. Слинковаться с одной конфигураций tcmalloc, дописав в ya.make своей программы:
  ```
  ALLOCATOR(TCMALLOC)
  ```
  2. На раннем этапе инициализации приложения, до того как началось выделение больших пользовательских объектов
  написать код конфигурации профайлера.
  ```c++
  #include <yt/yt/library/ytprof/heap_profiler.h>
  #include <absl/debugging/stacktrace.h>

  int main() {
    absl::SetStackUnwinder(AbslStackUnwinder);
    tcmalloc::MallocExtension::SetProfileSamplingRate(2_MB);

    ...
  }
  ```

tcmalloc поддерживает 4 вида профилей:
- `heap` - снепшот текущего потребления памяти. Это основной профиль, который вам интересен.
- `peak` - снепшот  потребления памяти в момент, когда приложение потребляло максимальный объем памяти. Профиль удобен, чтобы искать внезапный пик потребления, который уже ушёл.
- `allocations` - профиль выделения памяти за интервал. Полезен для того, чтобы оптимизировать производительность. Код, который выделяет и освобождает вектор в горячем цикле, не будет виден в `heap` профиле потому что в каждый момент времени жив всего один блок памяти. Но будет виден в этом профиле.
- `fragmentation` - профиль фрагментации памяти. Small объекты в tcmalloc
выделяются из спанов. Спан - это массив small объектов одинакового размера. Спан не вернётся назад в общий пул памяти, пока не освободят все объекты в нём. В худшем случае, всю память могут занимать такие спаны с одним живым объектом внутри. Этот тип профиля позволяет находить, какие аллокации приводят к подобной проблеме.

Memory profiler работает в любом типе сборки, кроме сборки с санитайзерами.

## Spinlock Profiler

ytprof поддерживает профилирование 2-х видов спинлоков.
- `lock` - профиль спинлоков из `absl`. Эти спинлоки используются внутри tcmalloc.
- `block` - профиль спинлоков из `library/cpp/yt/threading`

### Быстрые примеры для YT

```
# Текущее потребление ноды
curl http://vla0-8040-co-node-arnold.vla.yp-c.yandex.net:10013/ytprof/heap > ../heap.pb.gz
# Пиковое потребение ноды
curl 'http://vla2-8153-node-seneca-vla.vla.yp-c.yandex.net:10012/ytprof/peak' > ../peak.pb.gz
# Профиль аллокаций ноды
curl 'http://vla2-8153-node-seneca-vla.vla.yp-c.yandex.net:10012/ytprof/allocations?d=60' > ../allocations_node.pb.gz
# CPU профиль мастера
curl 'http://m002-hahn.sas.yp-c.yandex.net:10010/ytprof/profile' > ../profile.pb.gz
# CPU профиль шедулера с повышенной частотой
curl 'http://sas5-9718-scheduler-hahn.sas.yp-c.yandex.net:10011/ytprof/profile?freq=1000' > ../profile_1000.pb.gz

# Смотрим профиль из корня аркадии. trim_path можно поправить, если исходники не находятся.
ya tool pprof -symbolize=none -trim_path='/-S/:/-B/:/home/teamcity/source/Yt_ArcRelease'  ../heap.pb.gz
File: ytserver-node
generated by ytprof 0.3
binary_version=22.1.9091475-stable-ya~b6081b45d6f7f85a
arc_revision=b6081b45d6f7f85ab6f9772f31c277fe01de886c
build_type=profile
Type: space
Entering interactive mode (type "help" for commands, "o" for options)
# Сохраняет svg файл. В нём проще всего найти интересные функции, чтобы потом смотреть на них более подробно
(pprof) svg
# Показывает топ функций. Удобно в cpu, в памяти скорее всего будет показывать функции аллокации
(pprof) top
# Сортирует не по потреблению в функции, а по потреблению в самой функции и всех её детях
(pprof) sort=cum
# Переключает вес семпла на штуки. По дефолту семплы взвешиваются в секундах или мегабайтах
(pprof) sample_index=0
# Показывает код функции. Параметр - это регулярное выражение
(pprof) list IOutputStream::Write
# Фильтрует семплы по треду
(pprof) tagfocus=thread=StorageHeavy
# Аллокации по размеру
(pprof) tagfocus=allocated_size=2mb:
# Фильтрует экшены, которые бежали больше 10ms
(pprof) tagfocus=action_run_time_us=10000:
# Убирает фильтр
(pprof) tagfocus=
# Показывает сырые семплы
(pprof) traces
```
