# ytprof

The YTProf library implements a set of sampling profilers compatible with the [pprof](https://github.com/google/pprof/blob/master/doc/README.md) visualization tool.

The profiler is linked into the executable and starts an HTTP server on the debug port. HTTP calls retrieve profiling results in the pprof format (compressed gzip protobuf from [profiler.proto](https://github.com/ytsaurus/ytsaurus/blob/main/yt/yt/library/ytprof/proto/profile.proto)).

A profile file is self-contained and includes all symbol and line number information. The original binary is not necessary for viewing a profile.

For convenient source code viewing, start pprof from the repository root directory with the `-trim_path='/-S/:/-B/'` option.

## Quick Start

Working with the profiler, using [example/main.cpp](https://github.com/ytsaurus/ytsaurus/blob/main/yt/yt/library/ytprof/example/main.cpp)

Note that if `ya` is started via the wrapper `/usr/local/bin/ya`, then interactive mode in `ya tool pprof` does not work. It is better to remove `/usr/local/bin/ya` from your host and use another startup method.

```bash
# All commands run from Repository root

# Build the example
ya make --build=profile yt/yt/library/ytprof/example

# Run the example in a separate terminal on port 10003
./yt/yt/library/ytprof/example/example 10003

# Check memory usage
ya tool pprof -symbolize=none http://localhost:10003/heap
Fetching profile over HTTP from http://localhost:10003/heap
Saved profile in /home/prime/pprof/pprof.example.allocations.space.002.pb.gz
File: example
generated by ytprof 0.2
Type: space
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) list main
Total: 64.80MB
ROUTINE ======================== main in /home/prime/arc/yt/yt/library/ytprof/example/main.cpp
         0    62.38MB (flat, cum) 96.25% of Total
         .          .     30:        Register(server, "");
         .          .     31:        server->Start();
         .          .     32:
         .          .     33:        THashMap<TString, std::vector<int>> data;
         .          .     34:        for (int i = 0; i < 1024 * 16; i++) {
         .    62.38MB     35:            data[ToString(i)].resize(1024);
         .          .     36:        }
         .          .     37:
         .          .     38:        ui64 value = 0;
         .          .     39:        while (true) {
         .          .     40:            THash<TString> hasher;

# Checking CPU usage for 15 seconds
ya tool pprof -symbolize=none 'http://localhost:10003/profile?d=15'
Fetching profile over HTTP from http://localhost:10003/profile?d=15
Saved profile in /home/prime/pprof/pprof.example.sample.profile.004.pb.gz
File: example
generated by ytprof 0.2
arc_revision=8788163
build_type=profile
Type: cpu
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top
Showing nodes accounting for 11840ms, 78.83% of 15020ms total
Dropped 45 nodes (cum <= 75.10ms)
Showing top 10 nodes out of 53
      flat  flat%   sum%        cum   cum%
    5250ms 34.95% 34.95%     5250ms 34.95%  (anonymous namespace)::TBasicIntFormatter::Format
    2610ms 17.38% 52.33%     3760ms 25.03%  CityHash64
    1000ms  6.66% 58.99%     1000ms  6.66%  ReadUnaligned (inline)
     980ms  6.52% 65.51%      980ms  6.52%  memcpyU256
     530ms  3.53% 69.04%      530ms  3.53%  (anonymous namespace)::TIntFormatter::Format
     360ms  2.40% 71.44%      360ms  2.40%  TcmallocSlab_Internal_Pop_trampoline_2
     330ms  2.20% 73.64%      330ms  2.20%  TcmallocSlab_Internal_Push_trampoline_7
     280ms  1.86% 75.50%      280ms  1.86%  std::__y1::basic_string::__is_long
     260ms  1.73% 77.23%     4020ms 26.76%  NHashPrivate::ComputeStringHash
     240ms  1.60% 78.83%      240ms  1.60%  tcmalloc::tcmalloc_internal::PageMap2::sizeclass
(pprof) list main
Total: 15.02s
ROUTINE ======================== main in /home/prime/arc/yt/yt/library/ytprof/example/main.cpp
     150ms     13.99s (flat, cum) 93.14% of Total
     ....
         .          .     16:int main(int argc, char* argv[])
         .          .     17:{
         .          .     18:    NBacktrace::SetAbslStackUnwinder();
         .          .     19:    tcmalloc::MallocExtension::SetProfileSamplingInterval(2_MB);
         .          .     20:
         .          .     21:    try {
         .          .     22:        if (argc != 2 && argc != 3) {
         .          .     23:            throw yexception() << "usage: " << argv[0] << " PORT";
         .          .     24:        }
         .          .     25:
         .          .     26:        auto port = FromString<int>(argv[1]);
         .          .     27:        auto poller = CreateThreadPoolPoller(1, "Example");
         .          .     28:        auto server = CreateServer(port, poller);
         .          .     29:
         .          .     30:        Register(server, "");
         .          .     31:        server->Start();
         .          .     32:
         .          .     33:        THashMap<TString, std::vector<int>> data;
         .          .     34:        for (int i = 0; i < 1024 * 16; i++) {
         .          .     35:            data[ToString(i)].resize(1024);
         .          .     36:        }
         .          .     37:
         .          .     38:        ui64 value = 0;
         .          .     39:        while (true) {
         .          .     40:            THash<TString> hasher;
         .          .     41:            for (int i = 0; i < 10000000; i++) {
         .     13.75s     42:                value += hasher(ToString(i));
         .          .     43:            }
         .          .     44:
         .          .     45:            std::vector<TString> data;
         .          .     46:            for (int i = 0; i < 10000; i++) {
         .       80ms     47:                data.push_back(TString(1024, 'x'));
         .          .     48:            }
         .          .     49:
         .          .     50:            if (value == 1) {
         .          .     51:                Sleep(TDuration::Seconds(1));
         .          .     52:            }
         .       10ms     53:        }
         .          .     54:    } catch (const std::exception& ex) {
         .          .     55:        Cerr << ex.what() << Endl;
         .          .     56:        _exit(1);
         .          .     57:    }
         .          .     58:
```

## CPU profiler

The CPU profiler is based on the SIGPROF signal. When disabled, it does not affect the program. When enabled, the kernel starts sending signals to all process threads. The signal handler collects the current stack and pushes it into a lock-free queue.

To use the CPU profiler, the executable must be built with `--build=profile`. Adding this option may slow the program by a few percent, so it's recommended to combine `--build=profile` with the `--thinlto` flag. This configuration should run a couple percent faster than regular `--build=release`.

### CPU tags

YTProf supports tags. Tags allow filtering the profile in pprof using the `tagfocus` command. For example, you can put an experiment id or the current username in the tag.

`TCpuProfilerTagGuard` sets a tag in the thread's TLS. You can also put a tag in the request's `TTraceContext` so it is automatically passed through asynchronous YT fibers code.

### Heavy actions

The profiler can tag samples with execution time in the YT thread pool. This helps identify code that blocked a thread for a long time.

- You can enable tags to filter in pprof: `/profile?record_action_run_time=1`
- You can filter only samples from long actions: `/profile?action_min_exec_time=1s`

```bash
# You can filter samples with the tagfocus command.
(pprof) tagfocus=action_run_time_us=1000000:
# View sample list.
(pprof) traces
```

## Memory Profiler

To use the memory profiler, your allocator must support it. Currently, this support exists only in tcmalloc.

To enable the memory profiler:

1. Link with a tcmalloc configuration by adding in your program's ya.make:
   ```
   ALLOCATOR(TCMALLOC)
   ```
2. At the application's initialization stage, before large user objects allocated, write the profiler configuration:
   ```cpp
   #include <library/cpp/yt/backtrace/absl_unwinder/absl_unwinder.h>
   #include <tcmalloc/malloc_extension.h>

   int main() {
       NYT::NBacktrace::SetAbslStackUnwinder();
       tcmalloc::MallocExtension::SetProfileSamplingInterval(2_MB);

       ...
   }
   ```

TCMalloc supports four profile types:
- `heap` — snapshot of current memory usage. This is the main profile you're interested in.
- `peak` — snapshot of memory usage at the peak. Useful when looking for a sudden spike that's already passed.
- `allocations` — profile of allocations by given time interval. Helpful for optimizing performance. Code that frequently allocates and frees a vector in a hot loop will not be visible in the `heap` profile but will appear here.
- `fragmentation` — profile of memory fragmentation. Small tcmalloc objects are allocated from spans. A span is an array of small objects of the same size. It doesn't return to the pool until all objects in it are freed. In the worst case, all memory may be occupied by spans with one live object inside. This profile type helps detect such allocations.

Memory profiler works in all build types except those with sanitizers.

## Spinlock Profiler

ytprof supports profiling two types of spinlocks:
- `lock` — profile of absl spinlocks. These are used inside tcmalloc.
- `block` — profile of spinlocks from `library/cpp/yt/threading`.

### Quick examples for YT

```bash
# Current node memory usage
curl http://vla0-8040-co-node-arnold.vla.yp-c.yandex.net:10013/ytprof/heap > ../heap.pb.gz
# Node peak memory usage
curl 'http://vla2-8153-node-seneca-vla.vla.yp-c.yandex.net:10012/ytprof/peak' > ../peak.pb.gz
# Node allocation profile
curl 'http://vla2-8153-node-seneca-vla.vla.yp-c.yandex.net:10012/ytprof/allocations?d=60' > ../allocations_node.pb.gz
# Master CPU profile
curl 'http://m002-hahn.sas.yp-c.yandex.net:10010/ytprof/profile' > ../profile.pb.gz
# Scheduler CPU profile at high frequency
curl 'http://sas5-9718-scheduler-hahn.sas.yp-c.yandex.net:10011/ytprof/profile?freq=1000' > ../profile_1000.pb.gz

# View the profile from the arcadia root. You can edit trim_path if sources aren't found.
ya tool pprof -symbolize=none -trim_path='/-S/:/-B/:/home/teamcity/source/Yt_ArcRelease'  ../heap.pb.gz
File: ytserver-node
generated by ytprof 0.3
binary_version=22.1.9091475-stable-ya~b6081b45d6f7f85a
arc_revision=b6081b45d6f7f85ab6f9772f31c277fe01de886c
build_type=profile
Type: space
Entering interactive mode (type "help" for commands, "o" for options)
# Save SVG file. It's easier to find interesting functions and then examine them in more detail
(pprof) svg
# Show top functions. Useful in CPU profile, in memory profile it will probably show allocation functions
(pprof) top
# Sort not by consumption in function, but by consumption in it and its children
(pprof) sort=cum
# Switch sample weight to units instead of seconds or megabytes
(pprof) sample_index=0
# Show function code. Parameter is a regex
(pprof) list IOutputStream::Write
# Filter samples by thread
(pprof) tagfocus=thread=StorageHeavy
# Allocations by size
(pprof) tagfocus=allocated_size=2mb:
# Filter actions running longer than 10ms
(pprof) tagfocus=action_run_time_us=10000:
# Remove filter
(pprof) tagfocus=
# Show raw samples
(pprof) traces
```

